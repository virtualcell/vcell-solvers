/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.0
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON
#define SWIG_PYTHON_DIRECTOR_NO_VTABLE


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



/* Python.h has to appear first */
#include <Python.h>

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
  
  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The SWIG conversion methods, as ConvertPtr, return and integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/* 
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13



/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03000000
  char *cstr;
  char *newstr;
  Py_ssize_t len;
  str = PyUnicode_AsUTF8String(str);
  PyBytes_AsStringAndSize(str, &cstr, &len);
  newstr = (char *) malloc(len+1);
  memcpy(newstr, cstr, len+1);
  Py_XDECREF(str);
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#else
#  define SWIG_Python_str_DelForPy3(x) 
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

/* Add PyOS_snprintf for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
#  define PyOS_snprintf _snprintf
# else
#  define PyOS_snprintf snprintf
# endif
#endif

/* A crude PyString_FromFormat implementation for old Pythons */
#if PY_VERSION_HEX < 0x02020000

#ifndef SWIG_PYBUFFER_SIZE
# define SWIG_PYBUFFER_SIZE 1024
#endif

static PyObject *
PyString_FromFormat(const char *fmt, ...) {
  va_list ap;
  char buf[SWIG_PYBUFFER_SIZE * 2];
  int res;
  va_start(ap, fmt);
  res = vsnprintf(buf, sizeof(buf), fmt, ap);
  va_end(ap);
  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
}
#endif

/* Add PyObject_Del for old Pythons */
#if PY_VERSION_HEX < 0x01060000
# define PyObject_Del(op) PyMem_DEL((op))
#endif
#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

/* A crude PyExc_StopIteration exception for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# ifndef PyExc_StopIteration
#  define PyExc_StopIteration PyExc_RuntimeError
# endif
# ifndef PyObject_GenericGetAttr
#  define PyObject_GenericGetAttr 0
# endif
#endif

/* Py_NotImplemented is defined in 2.1 and up. */
#if PY_VERSION_HEX < 0x02010000
# ifndef Py_NotImplemented
#  define Py_NotImplemented PyExc_RuntimeError
# endif
#endif

/* A crude PyString_AsStringAndSize implementation for old Pythons */
#if PY_VERSION_HEX < 0x02010000
# ifndef PyString_AsStringAndSize
#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
# endif
#endif

/* PySequence_Size for old Pythons */
#if PY_VERSION_HEX < 0x02000000
# ifndef PySequence_Size
#  define PySequence_Size PySequence_Length
# endif
#endif

/* PyBool_FromLong for old Pythons */
#if PY_VERSION_HEX < 0x02030000
static
PyObject *PyBool_FromLong(long ok)
{
  PyObject *result = ok ? Py_True : Py_False;
  Py_INCREF(result);
  return result;
}
#endif

/* Py_ssize_t for old Pythons */
/* This code is as recommended by: */
/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    char *tmp;
    PyObject *old_str = PyObject_Str(value);
    PyErr_Clear();
    Py_XINCREF(type);

    PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
#      define SWIG_PYTHON_USE_GIL
#    endif
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* cc-mode */
#endif
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;


/* -----------------------------------------------------------------------------
 * Wrapper of PyInstanceMethod_New() used in Python 3
 * It is exported to the generated module, used for -fastproxy
 * ----------------------------------------------------------------------------- */
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *self, PyObject *func)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyInstanceMethod_New(func);
#else
  return NULL;
#endif
}

#ifdef __cplusplus
#if 0
{ /* cc-mode */
#endif
}
#endif


/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(ptr, type, flags)
#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule()
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, (char *) msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, (char*) name, obj);
  Py_DECREF(obj);                            
}

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
#else
  PyObject*   o2;
  PyObject*   o3;
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyTuple_Check(result)) {
      o2 = result;
      result = PyTuple_New(1);
      PyTuple_SET_ITEM(result, 0, o2);
    }
    o3 = PyTuple_New(1);
    PyTuple_SET_ITEM(o3, 0, obj);
    o2 = result;
    result = PySequence_Concat(o2, o3);
    Py_DECREF(o2);
    Py_DECREF(o3);
  }
  return result;
#endif
}

/* Unpack the argument tuple */

SWIGINTERN int
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    register Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      register int i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

/* A functor is a function object with one single object argument */
#if PY_VERSION_HEX >= 0x02020000
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
#else
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
#endif

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#ifdef __cplusplus
extern "C" {
#if 0
} /* cc-mode */
#endif
#endif

/*  How to access Py_None */
#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  ifndef SWIG_PYTHON_NO_BUILD_NONE
#    ifndef SWIG_PYTHON_BUILD_NONE
#      define SWIG_PYTHON_BUILD_NONE
#    endif
#  endif
#endif

#ifdef SWIG_PYTHON_BUILD_NONE
#  ifdef Py_None
#   undef Py_None
#   define Py_None SWIG_Py_None()
#  endif
SWIGRUNTIMEINLINE PyObject * 
_SWIG_Py_None(void)
{
  PyObject *none = Py_BuildValue((char*)"");
  Py_DECREF(none);
  return none;
}
SWIGRUNTIME PyObject * 
SWIG_Py_None(void)
{
  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
  return none;
}
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  return data ? data->implicitconv : 0;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
#if (PY_VERSION_HEX < 0x02020000)
      data->newraw = 0;
#else
      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
#endif
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
#ifdef METH_O
      data->delargs = !(flags & (METH_O));
#else
      data->delargs = 0;
#endif
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData* data)
{
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
} SwigPyObject;

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
#ifdef METH_NOARGS
SwigPyObject_repr(SwigPyObject *v)
#else
SwigPyObject_repr(SwigPyObject *v, PyObject *args)
#endif
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", name, v);
  if (v->next) {
#ifdef METH_NOARGS
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
#else
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
#endif
#if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
#else
    PyString_ConcatAndDel(&repr,nrep);
#endif
  }
  return repr;  
}

SWIGRUNTIME int
SwigPyObject_print(SwigPyObject *v, FILE *fp, int SWIGUNUSEDPARM(flags))
{
  char *str;
#ifdef METH_NOARGS
  PyObject *repr = SwigPyObject_repr(v);
#else
  PyObject *repr = SwigPyObject_repr(v, NULL);
#endif
  if (repr) {
    str = SWIG_Python_str_AsChar(repr); 
    fputs(str, fp);
    SWIG_Python_str_DelForPy3(str);
    Py_DECREF(repr);
    return 0; 
  } else {
    return 1; 
  }
}

SWIGRUNTIME PyObject *
SwigPyObject_str(SwigPyObject *v)
{
  char result[SWIG_BUFFER_SIZE];
  return SWIG_PackVoidPtr(result, v->ptr, v->ty->name, sizeof(result)) ?
    SWIG_Python_str_FromChar(result) : 0;
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  if( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) )
    res = Py_True;
  else
    res = Py_False;
  Py_INCREF(res);
  return res;  
}


SWIGRUNTIME PyTypeObject* _PySwigObject_type(void);

SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = _PySwigObject_type();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;
      if (data->delargs) {
	/* we need to create a temporary object to carry the destroy operation */
	PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
	res = SWIG_Python_CallFunctor(destroy, tmp);
	Py_DECREF(tmp);
      } else {
	PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
	PyObject *mself = PyCFunction_GET_SELF(destroy);
	res = ((*meth)(mself, v));
      }
      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
#ifndef METH_O
  PyObject *tmp = 0;
  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
  next = tmp;
#endif
  if (!SwigPyObject_Check(next)) {
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
#ifdef METH_NOARGS
SwigPyObject_next(PyObject* v)
#else
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_disown(PyObject *v)
#else
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_acquire(PyObject *v)
#else
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
#if (PY_VERSION_HEX < 0x02020000)
  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
#else
  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
#endif
    {
      return NULL;
    } 
  else
    {
      SwigPyObject *sobj = (SwigPyObject *)v;
      PyObject *obj = PyBool_FromLong(sobj->own);
      if (val) {
#ifdef METH_NOARGS
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v);
	} else {
	  SwigPyObject_disown(v);
	}
#else
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v,args);
	} else {
	  SwigPyObject_disown(v,args);
	}
#endif
      } 
      return obj;
    }
}

#ifdef METH_O
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_NOARGS,  (char *)"aquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#else
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"aquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#endif

#if PY_VERSION_HEX < 0x02020000
SWIGINTERN PyObject *
SwigPyObject_getattr(SwigPyObject *sobj,char *name)
{
  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
}
#endif

SWIGRUNTIME PyTypeObject*
_PySwigObject_type(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";
  
  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#elif PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
#endif
  };

  static PyTypeObject swigpyobject_type;  
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp
      = {
	/* PyObject header changed in Python 3 */
#if PY_VERSION_HEX >= 0x03000000
	PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else    
	PyObject_HEAD_INIT(NULL)
	0,				    /* ob_size */
#endif
	(char *)"SwigPyObject",		    /* tp_name */
	sizeof(SwigPyObject),		    /* tp_basicsize */
	0,			            /* tp_itemsize */
	(destructor)SwigPyObject_dealloc,   /* tp_dealloc */
	(printfunc)SwigPyObject_print,	    /* tp_print */
#if PY_VERSION_HEX < 0x02020000
	(getattrfunc)SwigPyObject_getattr,  /* tp_getattr */ 
#else
	(getattrfunc)0,			    /* tp_getattr */ 
#endif
	(setattrfunc)0,			    /* tp_setattr */ 
#if PY_VERSION_HEX >= 0x03000000
    0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
	(cmpfunc)SwigPyObject_compare,	    /* tp_compare */
#endif
	(reprfunc)SwigPyObject_repr,	    /* tp_repr */    
	&SwigPyObject_as_number,	    /* tp_as_number */
	0,				    /* tp_as_sequence */
	0,				    /* tp_as_mapping */
	(hashfunc)0,			    /* tp_hash */
	(ternaryfunc)0,			    /* tp_call */
	(reprfunc)SwigPyObject_str,	    /* tp_str */
	PyObject_GenericGetAttr,            /* tp_getattro */
	0,				    /* tp_setattro */
	0,		                    /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,	            /* tp_flags */
	swigobject_doc, 	            /* tp_doc */        
	0,                                  /* tp_traverse */
	0,                                  /* tp_clear */
	(richcmpfunc)SwigPyObject_richcompare,           /* tp_richcompare */
	0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
	0,                                  /* tp_iter */
	0,                                  /* tp_iternext */
	swigobject_methods,		    /* tp_methods */ 
	0,			            /* tp_members */
	0,				    /* tp_getset */	    	
	0,			            /* tp_base */	        
	0,				    /* tp_dict */	    	
	0,				    /* tp_descr_get */  	
	0,				    /* tp_descr_set */  	
	0,				    /* tp_dictoffset */ 	
	0,				    /* tp_init */	    	
	0,				    /* tp_alloc */	    	
	0,			            /* tp_new */	    	
	0,	                            /* tp_free */	   
	0,                                  /* tp_is_gc */  
	0,				    /* tp_bases */   
	0,				    /* tp_mro */
	0,				    /* tp_cache */   
	0,				    /* tp_subclasses */
	0,				    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
	0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
	0,0,0,0                             /* tp_alloc -> tp_next */
#endif
      };
    swigpyobject_type = tmp;
    /* for Python 3 we already assigned ob_type in PyVarObject_HEAD_INIT() */
#if PY_VERSION_HEX < 0x03000000
    swigpyobject_type.ob_type = &PyType_Type;
#endif
    type_init = 1;
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME int
SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
{
  char result[SWIG_BUFFER_SIZE];
  fputs("<Swig Packed ", fp); 
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    fputs("at ", fp); 
    fputs(result, fp); 
  }
  fputs(v->ty->name,fp); 
  fputs(">", fp);
  return 0; 
}
  
SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* _PySwigPacked_type(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = _PySwigPacked_type();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == _PySwigPacked_type()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
_PySwigPacked_type(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;  
  if (!type_init) {
    const PyTypeObject tmp
      = {
    /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX>=0x03000000
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else
	PyObject_HEAD_INIT(NULL)
    0,				    /* ob_size */	
#endif
	(char *)"SwigPyPacked",		    /* tp_name */	
	sizeof(SwigPyPacked),		    /* tp_basicsize */	
	0,				    /* tp_itemsize */	
	(destructor)SwigPyPacked_dealloc,   /* tp_dealloc */	
	(printfunc)SwigPyPacked_print,	    /* tp_print */   	
	(getattrfunc)0,			    /* tp_getattr */ 	
	(setattrfunc)0,			    /* tp_setattr */ 	
#if PY_VERSION_HEX>=0x03000000
    0, /* tp_reserved in 3.0.1 */
#else
    (cmpfunc)SwigPyPacked_compare,	    /* tp_compare */
#endif
	(reprfunc)SwigPyPacked_repr,	    /* tp_repr */
	0,	                            /* tp_as_number */
	0,				    /* tp_as_sequence */
	0,				    /* tp_as_mapping */
	(hashfunc)0,			    /* tp_hash */
	(ternaryfunc)0,			    /* tp_call */
	(reprfunc)SwigPyPacked_str,	    /* tp_str */
	PyObject_GenericGetAttr,            /* tp_getattro */
	0,				    /* tp_setattro */
	0,		                    /* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,	            /* tp_flags */
	swigpacked_doc, 	            /* tp_doc */
	0,                                  /* tp_traverse */
	0,                                  /* tp_clear */
	0,                                  /* tp_richcompare */
	0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
	0,                                  /* tp_iter */
	0,                                  /* tp_iternext */
	0,		                    /* tp_methods */ 
	0,			            /* tp_members */
	0,				    /* tp_getset */	    	
	0,			            /* tp_base */	        
	0,				    /* tp_dict */	    	
	0,				    /* tp_descr_get */  	
	0,				    /* tp_descr_set */  	
	0,				    /* tp_dictoffset */ 	
	0,				    /* tp_init */	    	
	0,				    /* tp_alloc */	    	
	0,			            /* tp_new */	    	
	0, 	                            /* tp_free */	   
        0,                                  /* tp_is_gc */  
	0,				    /* tp_bases */   
	0,				    /* tp_mro */
	0,				    /* tp_cache */   
 	0,				    /* tp_subclasses */
	0,				    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
	0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
	0,0,0,0                             /* tp_alloc -> tp_next */
#endif
      };
    swigpypacked_type = tmp;
    /* for Python 3 the ob_type already assigned in PyVarObject_HEAD_INIT() */
#if PY_VERSION_HEX < 0x03000000
    swigpypacked_type.ob_type = &PyType_Type;
#endif
    type_init = 1;
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIMEINLINE PyObject *
_SWIG_This(void)
{
    return SWIG_Python_str_FromChar("this");
}

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  static PyObject *SWIG_STATIC_POINTER(swig_this) = _SWIG_This();
  return swig_this;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  if (SwigPyObject_Check(pyobj)) {
    return (SwigPyObject *) pyobj;
  } else {
    PyObject *obj = 0;
#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
    if (PyInstance_Check(pyobj)) {
      obj = _PyInstance_Lookup(pyobj, SWIG_This());      
    } else {
      PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
      } else {
#ifdef PyWeakref_CheckProxy
	if (PyWeakref_CheckProxy(pyobj)) {
	  PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	  return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
	}
#endif
	obj = PyObject_GetAttr(pyobj,SWIG_This());
	if (obj) {
	  Py_DECREF(obj);
	} else {
	  if (PyErr_Occurred()) PyErr_Clear();
	  return 0;
	}
      }
    }
#else
    obj = PyObject_GetAttr(pyobj,SWIG_This());
    if (obj) {
      Py_DECREF(obj);
    } else {
      if (PyErr_Occurred()) PyErr_Clear();
      return 0;
    }
#endif
    if (obj && !SwigPyObject_Check(obj)) {
      /* a PyObject is called 'this', try to get the 'real this'
	 SwigPyObject from it */ 
      return SWIG_Python_GetSwigThis(obj);
    }
    return (SwigPyObject *)obj;
  }
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  if (!obj) return SWIG_ERROR;
  if (obj == Py_None) {
    if (ptr) *ptr = 0;
    return SWIG_OK;
  } else {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (own)
      *own = 0;
    while (sobj) {
      void *vptr = sobj->ptr;
      if (ty) {
	swig_type_info *to = sobj->ty;
	if (to == ty) {
	  /* no type cast needed */
	  if (ptr) *ptr = vptr;
	  break;
	} else {
	  swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
	  if (!tc) {
	    sobj = (SwigPyObject *)sobj->next;
	  } else {
	    if (ptr) {
              int newmemory = 0;
              *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
              if (newmemory == SWIG_CAST_NEW_MEMORY) {
                assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
                if (own)
                  *own = *own | SWIG_CAST_NEW_MEMORY;
              }
            }
	    break;
	  }
	}
      } else {
	if (ptr) *ptr = vptr;
	break;
      }
    }
    if (sobj) {
      if (own)
        *own = *own | sobj->own;
      if (flags & SWIG_POINTER_DISOWN) {
	sobj->own = 0;
      }
      return SWIG_OK;
    } else {
      int res = SWIG_ERROR;
      if (flags & SWIG_POINTER_IMPLICIT_CONV) {
	SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
	if (data && !data->implicitconv) {
	  PyObject *klass = data->klass;
	  if (klass) {
	    PyObject *impconv;
	    data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
	    impconv = SWIG_Python_CallFunctor(klass, obj);
	    data->implicitconv = 0;
	    if (PyErr_Occurred()) {
	      PyErr_Clear();
	      impconv = 0;
	    }
	    if (impconv) {
	      SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
	      if (iobj) {
		void *vptr;
		res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
		if (SWIG_IsOK(res)) {
		  if (ptr) {
		    *ptr = vptr;
		    /* transfer the ownership to 'ptr' */
		    iobj->own = 0;
		    res = SWIG_AddCast(res);
		    res = SWIG_AddNewMask(res);
		  } else {
		    res = SWIG_AddCast(res);		    
		  }
		}
	      }
	      Py_DECREF(impconv);
	    }
	  }
	}
      }
      return res;
    }
  }
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    
    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc) 
      return SWIG_ERROR;
    if (ty) {
      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
      if (tc) {
        int newmemory = 0;
        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
        assert(!newmemory); /* newmemory handling not yet implemented */
      } else {
        return SWIG_ERROR;
      }
    } else {
      *ptr = vptr;
    }
    return SWIG_OK;
  }
}

/* Convert a packed value value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
#if (PY_VERSION_HEX >= 0x02020000)
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      PyObject *key = SWIG_This();
      PyObject_SetAttr(inst, key, swig_this);
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    inst = PyBaseObject_Type.tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
    PyObject_SetAttr(inst, SWIG_This(), swig_this);
    Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
#else
    PyObject *dict = PyDict_New();
    PyDict_SetItem(dict, SWIG_This(), swig_this);
    inst = PyInstance_NewRaw(data->newargs, dict);
    Py_DECREF(dict);
#endif
  }
  return inst;
#else
#if (PY_VERSION_HEX >= 0x02010000)
  PyObject *inst;
  PyObject *dict = PyDict_New();
  PyDict_SetItem(dict, SWIG_This(), swig_this);
  inst = PyInstance_NewRaw(data->newargs, dict);
  Py_DECREF(dict);
  return (PyObject *) inst;
#else
  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
  if (inst == NULL) {
    return NULL;
  }
  inst->in_class = (PyClassObject *)data->newargs;
  Py_INCREF(inst->in_class);
  inst->in_dict = PyDict_New();
  if (inst->in_dict == NULL) {
    Py_DECREF(inst);
    return NULL;
  }
#ifdef Py_TPFLAGS_HAVE_WEAKREFS
  inst->in_weakreflist = NULL;
#endif
#ifdef Py_TPFLAGS_GC
  PyObject_GC_Init(inst);
#endif
  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
  return (PyObject *) inst;
#endif
#endif
}

SWIGRUNTIME void
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
 PyObject *dict;
#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
 PyObject **dictptr = _PyObject_GetDictPtr(inst);
 if (dictptr != NULL) {
   dict = *dictptr;
   if (dict == NULL) {
     dict = PyDict_New();
     *dictptr = dict;
   }
   PyDict_SetItem(dict, SWIG_This(), swig_this);
   return;
 }
#endif
 dict = PyObject_GetAttrString(inst, (char*)"__dict__");
 PyDict_SetItem(dict, SWIG_This(), swig_this);
 Py_DECREF(dict);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args,(char*)"swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      SWIG_Python_SetSwigThis(obj[0], obj[1]);
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
  if (!ptr) {
    return SWIG_Py_Void();
  } else {
    int own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
    PyObject *robj = SwigPyObject_New(ptr, type, own);
    SwigPyClientData *clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
    if (clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
      PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
      if (inst) {
	Py_DECREF(robj);
	robj = inst;
      }
    }
    return robj;
  }
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

#if PY_MAJOR_VERSION < 2
/* PyModule_AddObject function was introduced in Python 2.0.  The following function
   is copied out of Python/modsupport.c in python version 2.3.4 */
SWIGINTERN int
PyModule_AddObject(PyObject *m, char *name, PyObject *o)
{
  PyObject *dict;
  if (!PyModule_Check(m)) {
    PyErr_SetString(PyExc_TypeError,
		    "PyModule_AddObject() needs module as first arg");
    return SWIG_ERROR;
  }
  if (!o) {
    PyErr_SetString(PyExc_TypeError,
		    "PyModule_AddObject() needs non-NULL value");
    return SWIG_ERROR;
  }
  
  dict = PyModule_GetDict(m);
  if (dict == NULL) {
    /* Internal error -- modules must have a dict! */
    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
		 PyModule_GetName(m));
    return SWIG_ERROR;
  }
  if (PyDict_SetItemString(dict, name, o))
    return SWIG_ERROR;
  Py_DECREF(o);
  return SWIG_OK;
}
#endif

SWIGRUNTIME void
SWIG_Python_DestroyModule(void *vptr)
{
  swig_module_info *swig_module = (swig_module_info *) vptr;
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} };/* Sentinel */

#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
				   swig_empty_runtime_method_table);
#endif
  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
  } else {
    swig_module_info *swig_module = SWIG_Python_GetModule();
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
      obj = PyCObject_FromVoidPtr(descriptor, NULL);
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      char *tmp;
      PyObject *old_str = PyObject_Str(value);
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
      } else {
	PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : (char*)"";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int argnum, int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}


#ifdef __cplusplus
#if 0
{ /* cc-mode */
#endif
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_ASTNode swig_types[0]
#define SWIGTYPE_p_ASTNodeType_t swig_types[1]
#define SWIGTYPE_p_AlgebraicRule swig_types[2]
#define SWIGTYPE_p_AssignmentRule swig_types[3]
#define SWIGTYPE_p_BiolQualifierType_t swig_types[4]
#define SWIGTYPE_p_CVTerm swig_types[5]
#define SWIGTYPE_p_Compartment swig_types[6]
#define SWIGTYPE_p_CompartmentType swig_types[7]
#define SWIGTYPE_p_Constraint swig_types[8]
#define SWIGTYPE_p_Date swig_types[9]
#define SWIGTYPE_p_Delay swig_types[10]
#define SWIGTYPE_p_Event swig_types[11]
#define SWIGTYPE_p_EventAssignment swig_types[12]
#define SWIGTYPE_p_FunctionDefinition swig_types[13]
#define SWIGTYPE_p_InitialAssignment swig_types[14]
#define SWIGTYPE_p_KineticLaw swig_types[15]
#define SWIGTYPE_p_List swig_types[16]
#define SWIGTYPE_p_ListOf swig_types[17]
#define SWIGTYPE_p_ListOfCompartmentTypes swig_types[18]
#define SWIGTYPE_p_ListOfCompartments swig_types[19]
#define SWIGTYPE_p_ListOfConstraints swig_types[20]
#define SWIGTYPE_p_ListOfEventAssignments swig_types[21]
#define SWIGTYPE_p_ListOfEvents swig_types[22]
#define SWIGTYPE_p_ListOfFunctionDefinitions swig_types[23]
#define SWIGTYPE_p_ListOfInitialAssignments swig_types[24]
#define SWIGTYPE_p_ListOfLocalParameters swig_types[25]
#define SWIGTYPE_p_ListOfParameters swig_types[26]
#define SWIGTYPE_p_ListOfReactions swig_types[27]
#define SWIGTYPE_p_ListOfRules swig_types[28]
#define SWIGTYPE_p_ListOfSpecies swig_types[29]
#define SWIGTYPE_p_ListOfSpeciesReferences swig_types[30]
#define SWIGTYPE_p_ListOfSpeciesTypes swig_types[31]
#define SWIGTYPE_p_ListOfUnitDefinitions swig_types[32]
#define SWIGTYPE_p_ListOfUnits swig_types[33]
#define SWIGTYPE_p_ListWrapperT_ASTNode_t swig_types[34]
#define SWIGTYPE_p_ListWrapperT_CVTerm_t swig_types[35]
#define SWIGTYPE_p_ListWrapperT_Date_t swig_types[36]
#define SWIGTYPE_p_ListWrapperT_ModelCreator_t swig_types[37]
#define SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t swig_types[38]
#define SWIGTYPE_p_LocalParameter swig_types[39]
#define SWIGTYPE_p_Model swig_types[40]
#define SWIGTYPE_p_ModelCreator swig_types[41]
#define SWIGTYPE_p_ModelHistory swig_types[42]
#define SWIGTYPE_p_ModelQualifierType_t swig_types[43]
#define SWIGTYPE_p_ModifierSpeciesReference swig_types[44]
#define SWIGTYPE_p_OperationReturnValues_t swig_types[45]
#define SWIGTYPE_p_Parameter swig_types[46]
#define SWIGTYPE_p_ParentMap__iterator swig_types[47]
#define SWIGTYPE_p_Priority swig_types[48]
#define SWIGTYPE_p_QualifierType_t swig_types[49]
#define SWIGTYPE_p_RDFAnnotationParser swig_types[50]
#define SWIGTYPE_p_RateRule swig_types[51]
#define SWIGTYPE_p_Reaction swig_types[52]
#define SWIGTYPE_p_Rule swig_types[53]
#define SWIGTYPE_p_RuleType_t swig_types[54]
#define SWIGTYPE_p_SBMLConstructorException swig_types[55]
#define SWIGTYPE_p_SBMLDocument swig_types[56]
#define SWIGTYPE_p_SBMLError swig_types[57]
#define SWIGTYPE_p_SBMLErrorCategory_t swig_types[58]
#define SWIGTYPE_p_SBMLErrorCode_t swig_types[59]
#define SWIGTYPE_p_SBMLErrorLog swig_types[60]
#define SWIGTYPE_p_SBMLErrorSeverity_t swig_types[61]
#define SWIGTYPE_p_SBMLNamespaces swig_types[62]
#define SWIGTYPE_p_SBMLReader swig_types[63]
#define SWIGTYPE_p_SBMLTransforms swig_types[64]
#define SWIGTYPE_p_SBMLTypeCode_t swig_types[65]
#define SWIGTYPE_p_SBMLWriter swig_types[66]
#define SWIGTYPE_p_SBO swig_types[67]
#define SWIGTYPE_p_SBase swig_types[68]
#define SWIGTYPE_p_SimpleSpeciesReference swig_types[69]
#define SWIGTYPE_p_Species swig_types[70]
#define SWIGTYPE_p_SpeciesReference swig_types[71]
#define SWIGTYPE_p_SpeciesType swig_types[72]
#define SWIGTYPE_p_StoichiometryMath swig_types[73]
#define SWIGTYPE_p_SyntaxChecker swig_types[74]
#define SWIGTYPE_p_Trigger swig_types[75]
#define SWIGTYPE_p_Unit swig_types[76]
#define SWIGTYPE_p_UnitDefinition swig_types[77]
#define SWIGTYPE_p_UnitKind_t swig_types[78]
#define SWIGTYPE_p_XMLAttributes swig_types[79]
#define SWIGTYPE_p_XMLConstructorException swig_types[80]
#define SWIGTYPE_p_XMLError swig_types[81]
#define SWIGTYPE_p_XMLErrorCategory_t swig_types[82]
#define SWIGTYPE_p_XMLErrorCode_t swig_types[83]
#define SWIGTYPE_p_XMLErrorLog swig_types[84]
#define SWIGTYPE_p_XMLErrorSeverity_t swig_types[85]
#define SWIGTYPE_p_XMLInputStream swig_types[86]
#define SWIGTYPE_p_XMLNamespaces swig_types[87]
#define SWIGTYPE_p_XMLNode swig_types[88]
#define SWIGTYPE_p_XMLOutputFileStream swig_types[89]
#define SWIGTYPE_p_XMLOutputStream swig_types[90]
#define SWIGTYPE_p_XMLOutputStringStream swig_types[91]
#define SWIGTYPE_p_XMLToken swig_types[92]
#define SWIGTYPE_p_XMLTriple swig_types[93]
#define SWIGTYPE_p__CharT swig_types[94]
#define SWIGTYPE_p_allocator_type swig_types[95]
#define SWIGTYPE_p_char swig_types[96]
#define SWIGTYPE_p_char_type swig_types[97]
#define SWIGTYPE_p_const_reference swig_types[98]
#define SWIGTYPE_p_difference_type swig_types[99]
#define SWIGTYPE_p_int_type swig_types[100]
#define SWIGTYPE_p_off_type swig_types[101]
#define SWIGTYPE_p_p_PyObject swig_types[102]
#define SWIGTYPE_p_pos_type swig_types[103]
#define SWIGTYPE_p_reference swig_types[104]
#define SWIGTYPE_p_size_type swig_types[105]
#define SWIGTYPE_p_state_type swig_types[106]
#define SWIGTYPE_p_std__basic_iosT_char_std__char_traitsT_char_t_t swig_types[107]
#define SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t swig_types[108]
#define SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t swig_types[109]
#define SWIGTYPE_p_std__basic_streambufT_char_std__char_traitsT_char_t_t swig_types[110]
#define SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t swig_types[111]
#define SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator swig_types[112]
#define SWIGTYPE_p_std__invalid_argument swig_types[113]
#define SWIGTYPE_p_std__ios_base__openmode swig_types[114]
#define SWIGTYPE_p_std__multimapT_int_int_t swig_types[115]
#define SWIGTYPE_p_std__pairT_ParentMap__iterator_ParentMap__iterator_t swig_types[116]
#define SWIGTYPE_p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t swig_types[117]
#define SWIGTYPE_p_swig__SwigPyIterator swig_types[118]
#define SWIGTYPE_p_value_type swig_types[119]
static swig_type_info *swig_types[121];
static swig_module_info swig_module = {swig_types, 120, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#if (PY_VERSION_HEX <= 0x02000000)
# if !defined(SWIG_PYTHON_CLASSIC)
#  error "This python version requires swig to be run with the '-classic' option"
# endif
#endif

/*-----------------------------------------------
              @(target):= _libsbml.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit__libsbml

#else
#  define SWIG_init    init_libsbml

#endif
#define SWIG_name    "_libsbml"

#define SWIGVERSION 0x020000 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


namespace swig {
  class SwigPtr_PyObject {
  protected:
    PyObject *_obj;

  public:
    SwigPtr_PyObject() :_obj(0)
    {
    }

    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
    {
      Py_XINCREF(_obj);      
    }
    
    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
    {
      if (initial_ref) {
        Py_XINCREF(_obj);
      }
    }
    
    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
    {
      Py_XINCREF(item._obj);
      Py_XDECREF(_obj);
      _obj = item._obj;
      return *this;      
    }
    
    ~SwigPtr_PyObject() 
    {
      Py_XDECREF(_obj);
    }
    
    operator PyObject *() const
    {
      return _obj;
    }

    PyObject *operator->() const
    {
      return _obj;
    }
  };
}


namespace swig {
  struct SwigVar_PyObject : SwigPtr_PyObject {
    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
    
    SwigVar_PyObject & operator = (PyObject* obj)
    {
      Py_XDECREF(_obj);
      _obj = obj;
      return *this;      
    }
  };
}


#include "libsbml.h"

LIBSBML_CPP_NAMESPACE_USE

#ifdef USE_LAYOUT
#include "../swig/layout.h"
#endif /* USE_LAYOUT */
#include "local.cpp"


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
  } else if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}


  #define SWIG_From_long   PyInt_FromLong 


SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) : PyInt_FromLong(static_cast< long >(value)); 
}


SWIGINTERNINLINE PyObject *
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


#include <iostream>


#include <stdexcept>


#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif


#include <string>
#include <stdexcept>

  
namespace swig {
  struct stop_iteration {
  };

  struct SwigPyIterator {
  private:
    SwigPtr_PyObject _seq;

  protected:
    SwigPyIterator(PyObject *seq) : _seq(seq)
    {
    }
      
  public:
    virtual ~SwigPyIterator() {}

    // Access iterator method, required by Python
    virtual PyObject *value() const = 0;

    // Forward iterator method, required by Python
    virtual SwigPyIterator *incr(size_t n = 1) = 0;
    
    // Backward iterator method, very common in C++, but not required in Python
    virtual SwigPyIterator *decr(size_t /*n*/ = 1)
    {
      throw stop_iteration();
    }

    // Random access iterator methods, but not required in Python
    virtual ptrdiff_t distance(const SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }

    virtual bool equal (const SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }
    
    // C++ common/needed methods
    virtual SwigPyIterator *copy() const = 0;

    PyObject *next()     
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      PyObject *obj = value();
      incr();       
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads
      return obj;     
    }

    /* Make an alias for Python 3.x */
    PyObject *__next__()
    {
      return next();
    }

    PyObject *previous()
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      decr();
      PyObject *obj = value();
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads       
      return obj;
    }

    SwigPyIterator *advance(ptrdiff_t n)
    {
      return  (n > 0) ?  incr(n) : decr(-n);
    }
      
    bool operator == (const SwigPyIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const SwigPyIterator& x) const
    {
      return ! operator==(x);
    }
      
    SwigPyIterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    SwigPyIterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }
      
    SwigPyIterator* operator + (ptrdiff_t n) const
    {
      return copy()->advance(n);
    }

    SwigPyIterator* operator - (ptrdiff_t n) const
    {
      return copy()->advance(-n);
    }
      
    ptrdiff_t operator - (const SwigPyIterator& x) const
    {
      return x.distance(*this);
    }
      
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::SwigPyIterator *");
	init = 1;
      }	
      return desc;
    }    
  };
}


SWIGINTERNINLINE int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  return res;
}


SWIGINTERNINLINE PyObject *
SWIG_From_ptrdiff_t  (ptrdiff_t value)
{    
  return SWIG_From_long  (static_cast< long >(value));
}


SWIGINTERNINLINE PyObject*
  SWIG_From_bool  (bool value)
{
  return PyBool_FromLong(value ? 1 : 0);
}


SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERNINLINE int
SWIG_AsVal_ptrdiff_t (PyObject * obj, ptrdiff_t *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
  return res;
}


#include <stdexcept>


#include <algorithm>


#include <string>


SWIGINTERNINLINE PyObject *
SWIG_From_size_t  (size_t value)
{    
  return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
}


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(PyObject *obj, char** cptr, size_t* psize, int *alloc)
{
#if PY_VERSION_HEX>=0x03000000
  if (PyUnicode_Check(obj))
#else  
  if (PyString_Check(obj))
#endif
  {
    char *cstr; Py_ssize_t len;
#if PY_VERSION_HEX>=0x03000000
    if (!alloc && cptr) {
        /* We can't allow converting without allocation, since the internal
           representation of string in Python 3 is UCS-2/UCS-4 but we require
           a UTF-8 representation.
           TODO(bhy) More detailed explanation */
        return SWIG_RuntimeError;
    }
    obj = PyUnicode_AsUTF8String(obj);
    PyBytes_AsStringAndSize(obj, &cstr, &len);
    if(alloc) *alloc = SWIG_NEWOBJ;
#else
    PyString_AsStringAndSize(obj, &cstr, &len);
#endif
    if (cptr) {
      if (alloc) {
	/* 
	   In python the user should not be able to modify the inner
	   string representation. To warranty that, if you define
	   SWIG_PYTHON_SAFE_CSTRINGS, a new/copy of the python string
	   buffer is always returned.

	   The default behavior is just to return the pointer value,
	   so, be careful.
	*/ 
#if defined(SWIG_PYTHON_SAFE_CSTRINGS)
	if (*alloc != SWIG_OLDOBJ) 
#else
	if (*alloc == SWIG_NEWOBJ) 
#endif
	  {
	    *cptr = reinterpret_cast< char* >(memcpy((new char[len + 1]), cstr, sizeof(char)*(len + 1)));
	    *alloc = SWIG_NEWOBJ;
	  }
	else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      } else {
        #if PY_VERSION_HEX>=0x03000000
        assert(0); /* Should never reach here in Python 3 */
        #endif
	*cptr = SWIG_Python_str_AsChar(obj);
      }
    }
    if (psize) *psize = len + 1;
#if PY_VERSION_HEX>=0x03000000
    Py_XDECREF(obj);
#endif
    return SWIG_OK;
  } else {
    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *) vptr;
	if (psize) *psize = vptr ? (strlen((char *)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsCharArray(PyObject * obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    if ((csize == size + 1) && cptr && !(cptr[csize-1])) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char (PyObject * obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_NewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
      return PyUnicode_FromStringAndSize(carray, static_cast< int >(size));
#else
      return PyString_FromStringAndSize(carray, static_cast< int >(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}


SWIGINTERNINLINE PyObject *
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}


namespace swig {  
  template <class Type>
  struct noconst_traits {
    typedef Type noconst_type;
  };

  template <class Type>
  struct noconst_traits<const Type> {
    typedef Type noconst_type;
  };

  /*
    type categories
  */
  struct pointer_category { };  
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
  }

  template <class Type> 
  struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }    
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }    
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

  template <class Type, class Category> 
  struct traits_as { };
 
  template <class Type, class Category> 
  struct traits_check { };

}


namespace swig {  
  /*
    Traits that provides the from method
  */
  template <class Type> struct traits_from_ptr {
    static PyObject *from(Type *val, int owner = 0) {
      return SWIG_NewPointerObj(val, type_info<Type>(), owner);
    }
  };

  template <class Type> struct traits_from {
    static PyObject *from(const Type& val) {
      return traits_from_ptr<Type>::from(new Type(val), 1);
    }
  };

  template <class Type> struct traits_from<Type *> {
    static PyObject *from(Type* val) {
      return traits_from_ptr<Type>::from(val, 0);
    }
  };

  template <class Type> struct traits_from<const Type *> {
    static PyObject *from(const Type* val) {
      return traits_from_ptr<Type>::from(const_cast<Type*>(val), 0);
    }
  };


  template <class Type>
  inline PyObject *from(const Type& val) {
    return traits_from<Type>::from(val);
  }

  template <class Type>
  inline PyObject *from_ptr(Type* val, int owner) {
    return traits_from_ptr<Type>::from(val, owner);
  }

  /*
    Traits that provides the asval/as/check method
  */
  template <class Type>
  struct traits_asptr {   
    static int asptr(PyObject *obj, Type **val) {
      Type *p;
      int res = SWIG_ConvertPtr(obj, (void**)&p, type_info<Type>(), 0);
      if (SWIG_IsOK(res)) {
	if (val) *val = p;
      }
      return res;
    }
  }; 

  template <class Type>
  inline int asptr(PyObject *obj, Type **vptr) {
    return traits_asptr<Type>::asptr(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static int asval(PyObject *obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr(obj, &p);
	if (!SWIG_IsOK(res)) return res;	
	if (p) {
	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
	  *(const_cast<noconst_type*>(val)) = *p;
	  if (SWIG_IsNewObj(res)){
	    delete p;
	    res = SWIG_DelNewMask(res);
	  }
	  return res;
	} else {
	  return SWIG_ERROR;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };

  template <class Type> struct traits_asval<Type*> {
    static int asval(PyObject *obj, Type **val) {
      if (val) {
        typedef typename noconst_traits<Type>::noconst_type noconst_type;
        noconst_type *p = 0;
        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
        if (SWIG_IsOK(res)) {
          *(const_cast<noconst_type**>(val)) = p;
	}
	return res;
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline int asval(PyObject *obj, Type *val) {
    return traits_asval<Type>::asval(obj, val);
  }

  template <class Type> 
  struct traits_as<Type, value_category> {
    static Type as(PyObject *obj, bool throw_error) {
      Type v;
      int res = asval(obj, &v);
      if (!obj || !SWIG_IsOK(res)) {
	if (!PyErr_Occurred()) {
	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
      }
      return v;
    }
  };

  template <class Type> 
  struct traits_as<Type, pointer_category> {
    static Type as(PyObject *obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res) && v) {
	if (SWIG_IsNewObj(res)) {
	  Type r(*v);
	  delete v;
	  return r;
	} else {
	  return *v;
	}
      } else {
	// Uninitialized return value, no Type() constructor required.
	static Type *v_def = (Type*) malloc(sizeof(Type));
	if (!PyErr_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
	memset(v_def,0,sizeof(Type));
	return *v_def;
      }
    }
  };

  template <class Type> 
  struct traits_as<Type*, pointer_category> {
    static Type* as(PyObject *obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res)) {
	return v;
      } else {
	if (!PyErr_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	if (throw_error) throw std::invalid_argument("bad type");
	return 0;
      }
    }
  };
    
  template <class Type>
  inline Type as(PyObject *obj, bool te = false) {
    return traits_as<Type, typename traits<Type>::category>::as(obj, te);
  }

  template <class Type> 
  struct traits_check<Type, value_category> {
    static bool check(PyObject *obj) {
      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> {
    static bool check(PyObject *obj) {
      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type>
  inline bool check(PyObject *obj) {
    return traits_check<Type, typename traits<Type>::category>::check(obj);
  }
}


namespace swig {
  template <> struct traits<char > {
    typedef value_category category;
    static const char* type_name() { return"char"; }
  };  
  template <>  struct traits_asval<char > {   
    typedef char value_type;
    static int asval(PyObject *obj, value_type *val) { 
      return SWIG_AsVal_char (obj, val);
    }
  };
  template <>  struct traits_from<char > {
    typedef char value_type;
    static PyObject *from(const value_type& val) {
      return SWIG_From_char  (val);
    }
  };
}





SWIGINTERN int
SWIG_AsPtr_std_basic_string_Sl_char_Sg_ (PyObject* obj, std::string **val)
{
  static swig_type_info* string_info = 
    SWIG_TypeQuery("std::basic_string<char> *");
  std::string *vptr;    
  if (SWIG_ConvertPtr(obj, (void**)&vptr, string_info, 0) == SWIG_OK) {
    if (val) *val = vptr;
    return SWIG_OLDOBJ;
  } else {
    PyErr_Clear();
    char* buf = 0 ; size_t size = 0; int alloc = 0;
    if (SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc) == SWIG_OK) {
      if (buf) {
	if (val) *val = new std::string(buf, size - 1);
	if (alloc == SWIG_NEWOBJ) delete[] buf;
	return SWIG_NEWOBJ;
      }
    } else {
      PyErr_Clear();
    }  
    if (val) {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      PyErr_SetString(PyExc_TypeError,"a string is expected");
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    return 0;
  }
}  


SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


SWIGINTERNINLINE PyObject*
  SWIG_From_std_basic_string_Sl_char_Sg_  (const std::string& s)
  {
    return SWIG_FromCharPtrAndSize(s.data(), s.size());
  }


#include <functional>

namespace std {
  template <>
  struct less <PyObject *>: public binary_function<PyObject *, PyObject *, bool>
  {
    bool
    operator()(PyObject * v, PyObject *w) const
    { 
      bool res;
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      res = PyObject_RichCompareBool(v, w, Py_LT) ? true : false;
      /* This may fall into a case of inconsistent
               eg. ObjA > ObjX > ObjB
               but ObjA < ObjB
      */
      if( PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError) )
      {
        /* Objects can't be compared, this mostly occurred in Python 3.0 */
        /* Compare their ptr directly for a workaround */
        res = (v < w);
        PyErr_Clear();
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
      return res;
    }
  };

  template <>
  struct less <swig::SwigPtr_PyObject>: public binary_function<swig::SwigPtr_PyObject, swig::SwigPtr_PyObject, bool>
  {
    bool
    operator()(const swig::SwigPtr_PyObject& v, const swig::SwigPtr_PyObject& w) const
    {
      return std::less<PyObject *>()(v, w);
    }
  };

  template <>
  struct less <swig::SwigVar_PyObject>: public binary_function<swig::SwigVar_PyObject, swig::SwigVar_PyObject, bool>
  {
    bool
    operator()(const swig::SwigVar_PyObject& v, const swig::SwigVar_PyObject& w) const
    {
      return std::less<PyObject *>()(v, w);
    }
  };

}

namespace swig {
  template <> struct traits<PyObject *> {
    typedef value_category category;
    static const char* type_name() { return "PyObject *"; }
  };  

  template <>  struct traits_asval<PyObject * > {   
    typedef PyObject * value_type;
    static int asval(PyObject *obj, value_type *val) {
      if (val) *val = obj;
      return SWIG_OK;
    }
  };

  template <> 
  struct traits_check<PyObject *, value_category> {
    static bool check(PyObject *) {
      return true;
    }
  };

  template <>  struct traits_from<PyObject *> {
    typedef PyObject * value_type;
    static PyObject *from(const value_type& val) {
      Py_XINCREF(val);
      return val;
    }
  };
  
}

namespace swig {
  inline size_t
  check_index(ptrdiff_t i, size_t size, bool insert = false) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size)
	return (size_t) (i + size);
    } else if ( (size_t) i < size ) {
      return (size_t) i;
    } else if (insert && ((size_t) i == size)) {
      return size;
    }
    
    throw std::out_of_range("index out of range");
  }

  inline size_t
  slice_index(ptrdiff_t i, size_t size) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size) {
	return (size_t) (i + size);
      } else {
	throw std::out_of_range("index out of range");
      }
    } else {
      return ( (size_t) i < size ) ? ((size_t) i) : size;
    }
  }

  template <class Sequence, class Difference>
  inline typename Sequence::iterator
  getpos(Sequence* self, Difference i)  {
    typename Sequence::iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline typename Sequence::const_iterator
  cgetpos(const Sequence* self, Difference i)  {
    typename Sequence::const_iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline Sequence*
  getslice(const Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size);
    typename Sequence::size_type jj = swig::slice_index(j, size);

    if (jj > ii) {
      typename Sequence::const_iterator vb = self->begin();
      typename Sequence::const_iterator ve = self->begin();
      std::advance(vb,ii);
      std::advance(ve,jj);
      return new Sequence(vb, ve);
    } else {
      return new Sequence();
    }
  }

  template <class Sequence, class Difference, class InputSeq>
  inline void
  setslice(Sequence* self, Difference i, Difference j, const InputSeq& v) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj < ii) jj = ii;
    size_t ssize = jj - ii;
    if (ssize <= v.size()) {
      typename Sequence::iterator sb = self->begin();
      typename InputSeq::const_iterator vmid = v.begin();
      std::advance(sb,ii);
      std::advance(vmid, jj - ii);
      self->insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
    } else {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
      self->insert(sb, v.begin(), v.end());
    }
  }

  template <class Sequence, class Difference>
  inline void
  delslice(Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj > ii) {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
    }
  }
}


#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
#  if !defined(SWIG_NO_STD_NOITERATOR_TRAITS_STL)
#    define SWIG_STD_NOITERATOR_TRAITS_STL
#  endif
#endif

#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
#include <iterator>
#else
namespace std {
  template <class Iterator>
  struct iterator_traits {
    typedef ptrdiff_t difference_type;
    typedef typename Iterator::value_type value_type;
  };

  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
    typedef Distance difference_type;
    typedef T value_type;
  };

  template <class T>
  struct iterator_traits<T*> {
    typedef T value_type;
    typedef ptrdiff_t difference_type;
  };

  template<typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type
  distance(_InputIterator __first, _InputIterator __last)
  {
    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last) {
      ++__first; ++__n;
    }
    return __n;
  }
}
#endif


namespace swig {
  template<typename OutIterator>
  class SwigPyIterator_T :  public SwigPyIterator
  {
  public:
    typedef OutIterator out_iterator;
    typedef typename std::iterator_traits<out_iterator>::value_type value_type;    
    typedef SwigPyIterator_T<out_iterator> self_type;

    SwigPyIterator_T(out_iterator curr, PyObject *seq)
      : SwigPyIterator(seq), current(curr)
    {
    }

    const out_iterator& get_current() const
    {
      return current;
    }

    
    bool equal (const SwigPyIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    ptrdiff_t distance(const SwigPyIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }    
    
  protected:
    out_iterator current;
  };
  
  template <class ValueType>
  struct from_oper 
  {
    typedef const ValueType& argument_type;
    typedef PyObject *result_type;
    result_type operator()(argument_type v) const
    {
      return swig::from(v);
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyIteratorOpen_T :  public SwigPyIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;
    typedef SwigPyIteratorOpen_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyIteratorOpen_T(out_iterator curr, PyObject *seq)
      : SwigPyIterator_T<OutIterator>(curr, seq)
    {
    }
    
    PyObject *value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    SwigPyIterator *copy() const
    {
      return new self_type(*this);
    }

    SwigPyIterator *incr(size_t n = 1)
    {
      while (n--) {
	++base::current;
      }
      return this;
    }

    SwigPyIterator *decr(size_t n = 1)
    {
      while (n--) {
	--base::current;
      }
      return this;
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyIteratorClosed_T :  public SwigPyIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;    
    typedef SwigPyIteratorClosed_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyIteratorClosed_T(out_iterator curr, out_iterator first, out_iterator last, PyObject *seq)
      : SwigPyIterator_T<OutIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    PyObject *value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    SwigPyIterator *copy() const
    {
      return new self_type(*this);
    }

    SwigPyIterator *incr(size_t n = 1)
    {
      while (n--) {
	if (base::current == end) {
	  throw stop_iteration();
	} else {
	  ++base::current;
	}
      }
      return this;
    }

    SwigPyIterator *decr(size_t n = 1)
    {
      while (n--) {
	if (base::current == begin) {
	  throw stop_iteration();
	} else {
	  --base::current;
	}
      }
      return this;
    }

  private:
    out_iterator begin;
    out_iterator end;
  };

  template<typename OutIter>
  inline SwigPyIterator*
  make_output_iterator(const OutIter& current, const OutIter& begin,const OutIter& end, PyObject *seq = 0)
  {
    return new SwigPyIteratorClosed_T<OutIter>(current, begin, end, seq);
  }

  template<typename OutIter>
  inline SwigPyIterator*
  make_output_iterator(const OutIter& current, PyObject *seq = 0)
  {
    return new SwigPyIteratorOpen_T<OutIter>(current, seq);
  }
}


namespace swig
{
  template <class T>
  struct SwigPySequence_Ref
  {
    SwigPySequence_Ref(PyObject* seq, int index)
      : _seq(seq), _index(index)
    {
    }
    
    operator T () const
    {
      swig::SwigVar_PyObject item = PySequence_GetItem(_seq, _index);
      try {
	return swig::as<T>(item, true);
      } catch (std::exception& e) {
	char msg[1024];
	sprintf(msg, "in sequence element %d ", _index);
	if (!PyErr_Occurred()) {
	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<T>());
	}
	SWIG_Python_AddErrorMsg(msg);
	SWIG_Python_AddErrorMsg(e.what());
	throw;
      }
    }

    SwigPySequence_Ref& operator=(const T& v)
    {
      PySequence_SetItem(_seq, _index, swig::from<T>(v));
      return *this;
    }

  private:
    PyObject* _seq;
    int _index;
  };

  template <class T>
  struct SwigPySequence_ArrowProxy
  {
    SwigPySequence_ArrowProxy(const T& x): m_value(x) {}
    const T* operator->() const { return &m_value; }
    operator const T*() const { return &m_value; }
    T m_value;
  };

  template <class T, class Reference >
  struct SwigPySequence_InputIterator
  {
    typedef SwigPySequence_InputIterator<T, Reference > self;

    typedef std::random_access_iterator_tag iterator_category;
    typedef Reference reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;

    SwigPySequence_InputIterator()
    {
    }

    SwigPySequence_InputIterator(PyObject* seq, int index)
      : _seq(seq), _index(index)
    {
    }

    reference operator*() const
    {
      return reference(_seq, _index);
    }

    SwigPySequence_ArrowProxy<T>
    operator->() const {
      return SwigPySequence_ArrowProxy<T>(operator*());
    }

    bool operator==(const self& ri) const
    {
      return (_index == ri._index) && (_seq == ri._seq);
    }

    bool operator!=(const self& ri) const
    {
      return !(operator==(ri));
    }

    self& operator ++ ()
    {
      ++_index;
      return *this;
    }

    self& operator -- ()
    {
      --_index;
      return *this;
    }

    self& operator += (difference_type n)
    {
      _index += n;
      return *this;
    }

    self operator +(difference_type n) const
    {
      return self(_seq, _index + n);
    }

    self& operator -= (difference_type n)
    {
      _index -= n;
      return *this;
    }

    self operator -(difference_type n) const
    {
      return self(_seq, _index - n);
    }

    difference_type operator - (const self& ri) const
    {
      return _index - ri._index;
    }

    bool operator < (const self& ri) const
    {
      return _index < ri._index;
    }

    reference
    operator[](difference_type n) const
    {
      return reference(_seq, _index + n);
    }

  private:
    PyObject* _seq;
    difference_type _index;
  };

  template <class T>
  struct SwigPySequence_Cont
  {
    typedef SwigPySequence_Ref<T> reference;
    typedef const SwigPySequence_Ref<T> const_reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;
    typedef int size_type;
    typedef const pointer const_pointer;
    typedef SwigPySequence_InputIterator<T, reference> iterator;
    typedef SwigPySequence_InputIterator<T, const_reference> const_iterator;

    SwigPySequence_Cont(PyObject* seq) : _seq(0)
    {
      if (!PySequence_Check(seq)) {
	throw std::invalid_argument("a sequence is expected");
      }
      _seq = seq;
      Py_INCREF(_seq);
    }

    ~SwigPySequence_Cont()
    {
      Py_XDECREF(_seq);
    }

    size_type size() const
    {
      return static_cast<size_type>(PySequence_Size(_seq));
    }

    bool empty() const
    {
      return size() == 0;
    }

    iterator begin()
    {
      return iterator(_seq, 0);
    }

    const_iterator begin() const
    {
      return const_iterator(_seq, 0);
    }

    iterator end()
    {
      return iterator(_seq, size());
    }

    const_iterator end() const
    {
      return const_iterator(_seq, size());
    }

    reference operator[](difference_type n)
    {
      return reference(_seq, n);
    }

    const_reference operator[](difference_type n)  const
    {
      return const_reference(_seq, n);
    }

    bool check(bool set_err = true) const
    {
      int s = size();
      for (int i = 0; i < s; ++i) {
	swig::SwigVar_PyObject item = PySequence_GetItem(_seq, i);
	if (!swig::check<value_type>(item)) {
	  if (set_err) {
	    char msg[1024];
	    sprintf(msg, "in sequence element %d", i);
	    SWIG_Error(SWIG_RuntimeError, msg);
	  }
	  return false;
	}
      }
      return true;
    }

  private:
    PyObject* _seq;
  };

}

SWIGINTERN swig::SwigPyIterator *std_basic_string_Sl_char_Sg__iterator(std::basic_string< char > *self,PyObject **PYTHON_SELF){
      return swig::make_output_iterator(self->begin(), self->begin(), self->end(), *PYTHON_SELF);
    }
SWIGINTERN bool std_basic_string_Sl_char_Sg____nonzero__(std::basic_string< char > const *self){
      return !(self->empty());
    }
SWIGINTERN bool std_basic_string_Sl_char_Sg____bool__(std::basic_string< char > const *self){
      return !(self->empty());
    }
SWIGINTERN std::basic_string< char >::size_type std_basic_string_Sl_char_Sg____len__(std::basic_string< char > const *self){
      return self->size();
    }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg____getslice__(std::basic_string< char > *self,std::basic_string< char >::difference_type i,std::basic_string< char >::difference_type j){
      return swig::getslice(self, i, j);
    }
SWIGINTERN void std_basic_string_Sl_char_Sg____setslice__(std::basic_string< char > *self,std::basic_string< char >::difference_type i,std::basic_string< char >::difference_type j,std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &v){
      swig::setslice(self, i, j, v);
    }
SWIGINTERN void std_basic_string_Sl_char_Sg____delslice__(std::basic_string< char > *self,std::basic_string< char >::difference_type i,std::basic_string< char >::difference_type j){
      swig::delslice(self, i, j);
    }
SWIGINTERN void std_basic_string_Sl_char_Sg____delitem____SWIG_0(std::basic_string< char > *self,std::basic_string< char >::difference_type i){
      self->erase(swig::getpos(self,i));
    }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg____getitem____SWIG_0(std::basic_string< char > *self,PySliceObject *slice){
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return NULL;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      return swig::getslice(self, i, j);
    }
SWIGINTERN void std_basic_string_Sl_char_Sg____setitem____SWIG_0(std::basic_string< char > *self,PySliceObject *slice,std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &v){
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      swig::setslice(self, i, j, v);
    }
SWIGINTERN void std_basic_string_Sl_char_Sg____delitem____SWIG_1(std::basic_string< char > *self,PySliceObject *slice){
      Py_ssize_t i, j, step;
      if( !PySlice_Check(slice) ) {
        SWIG_Error(SWIG_TypeError, "Slice object expected.");
        return;
      }
      PySlice_GetIndices(slice, self->size(), &i, &j, &step);
      swig::delslice(self, i,j);
    }
SWIGINTERN std::basic_string< char >::value_type std_basic_string_Sl_char_Sg____getitem____SWIG_1(std::basic_string< char > *self,std::basic_string< char >::difference_type i){
      return *(swig::cgetpos(self, i));
    }
SWIGINTERN void std_basic_string_Sl_char_Sg____setitem____SWIG_1(std::basic_string< char > *self,std::basic_string< char >::difference_type i,std::basic_string< char >::value_type x){
      *(swig::getpos(self,i)) = x;
    }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg____add__(std::basic_string< char > *self,std::basic_string< char > const &v){
	std::basic_string<char,std::char_traits< char >,std::allocator< char > >* res = new std::basic_string<char,std::char_traits< char >,std::allocator< char > >(*self);
	*res += v;      
	return res;
      }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > *std_basic_string_Sl_char_Sg____radd__(std::basic_string< char > *self,std::basic_string< char > const &v){
	std::basic_string<char,std::char_traits< char >,std::allocator< char > >* res = new std::basic_string<char,std::char_traits< char >,std::allocator< char > >(v);
	*res += *self;      
	return res;
      }
SWIGINTERN std::basic_string< char,std::char_traits< char >,std::allocator< char > > std_basic_string_Sl_char_Sg____str__(std::basic_string< char > *self){
	return *self;
      }
SWIGINTERN std::basic_ostream< char,std::char_traits< char > > &std_basic_string_Sl_char_Sg____rlshift__(std::basic_string< char > *self,std::basic_ostream< char,std::char_traits< char > > &out){
	out << *self;
	return out;
      }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Se__Se_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self == v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_SN__Se_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self != v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Sg_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self > v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Sl_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self < v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Sg__Se_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self >= v;
  }
SWIGINTERN bool std_basic_string_Sl_char_Sg__operator_Sl__Se_(std::basic_string< char > *self,std::basic_string< char > const &v){
    return *self <= v;
  }

  /**
  * @deprecated libSBML internal
  */
  int ASTNode_true(const ASTNode *node)
  {
    return 1;
  }


SWIGINTERNINLINE PyObject *
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}


SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


SWIGINTERN int
SWIG_AsVal_bool (PyObject *obj, bool *val)
{
  int r = PyObject_IsTrue(obj);
  if (r == -1)
    return SWIG_ERROR;
  if (val) *val = r ? true : false;
  return SWIG_OK;
}

SWIGINTERN int ListOf___len__(ListOf *self){
    return self->size();
  }

  #define SWIG_From_double   PyFloat_FromDouble 

SWIGINTERN ListWrapper< ASTNode > *ASTNode_getListOfNodes(ASTNode *self){
    List *list = self->getListOfNodes(ASTNode_true);
    return new ListWrapper<ASTNode>(list);
  }
SWIGINTERN void XMLOutputStream_writeAttributeBool__SWIG_0(XMLOutputStream *self,std::string const &name,bool const &value){
    self->writeAttribute(name, value);
  }
SWIGINTERN void XMLOutputStream_writeAttributeBool__SWIG_1(XMLOutputStream *self,XMLTriple const &name,bool const &value){
    self->writeAttribute(name, value);
  }
SWIGINTERN void RDFAnnotationParser_parseRDFAnnotation__SWIG_1(XMLNode const *annotation,ListWrapper< CVTerm > *CVTerms){
    if (!CVTerms) return;

    List *list = CVTerms->getList();
    RDFAnnotationParser::parseRDFAnnotation(annotation,list);
  }
#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN PyObject *_wrap_new_ModelCreatorList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ModelCreatorList")) SWIG_fail;
  result = (ListWrapper< ModelCreator > *)new ListWrapper< ModelCreator >();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListWrapperT_ModelCreator_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ModelCreatorList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ModelCreatorList",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ModelCreatorList" "', argument " "1"" of type '" "ListWrapper< ModelCreator > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreatorList_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  ModelCreator *arg2 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreatorList_add",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreatorList_add" "', argument " "1"" of type '" "ListWrapper< ModelCreator > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelCreatorList_add" "', argument " "2"" of type '" "ModelCreator *""'"); 
  }
  arg2 = reinterpret_cast< ModelCreator * >(argp2);
  (arg1)->add(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreatorList_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreatorList_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreatorList_get" "', argument " "1"" of type '" "ListWrapper< ModelCreator > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ModelCreatorList_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModelCreator *)((ListWrapper< ModelCreator > const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreatorList_prepend(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  ModelCreator *arg2 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreatorList_prepend",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreatorList_prepend" "', argument " "1"" of type '" "ListWrapper< ModelCreator > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelCreatorList_prepend" "', argument " "2"" of type '" "ModelCreator *""'"); 
  }
  arg2 = reinterpret_cast< ModelCreator * >(argp2);
  (arg1)->prepend(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreatorList_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreatorList_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreatorList_remove" "', argument " "1"" of type '" "ListWrapper< ModelCreator > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ModelCreatorList_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModelCreator *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreatorList_getSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ModelCreator > *arg1 = (ListWrapper< ModelCreator > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreatorList_getSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ModelCreator_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreatorList_getSize" "', argument " "1"" of type '" "ListWrapper< ModelCreator > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ModelCreator > * >(argp1);
  result = (unsigned int)((ListWrapper< ModelCreator > const *)arg1)->getSize();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ModelCreatorList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListWrapperT_ModelCreator_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_DateList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_DateList")) SWIG_fail;
  result = (ListWrapper< Date > *)new ListWrapper< Date >();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListWrapperT_Date_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_DateList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_DateList",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DateList" "', argument " "1"" of type '" "ListWrapper< Date > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DateList_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:DateList_add",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DateList_add" "', argument " "1"" of type '" "ListWrapper< Date > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DateList_add" "', argument " "2"" of type '" "Date *""'"); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  (arg1)->add(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DateList_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:DateList_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DateList_get" "', argument " "1"" of type '" "ListWrapper< Date > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DateList_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Date *)((ListWrapper< Date > const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DateList_prepend(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:DateList_prepend",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DateList_prepend" "', argument " "1"" of type '" "ListWrapper< Date > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DateList_prepend" "', argument " "2"" of type '" "Date *""'"); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  (arg1)->prepend(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DateList_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:DateList_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DateList_remove" "', argument " "1"" of type '" "ListWrapper< Date > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "DateList_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Date *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DateList_getSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< Date > *arg1 = (ListWrapper< Date > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:DateList_getSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_Date_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DateList_getSize" "', argument " "1"" of type '" "ListWrapper< Date > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< Date > * >(argp1);
  result = (unsigned int)((ListWrapper< Date > const *)arg1)->getSize();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *DateList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListWrapperT_Date_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_CVTermList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_CVTermList")) SWIG_fail;
  result = (ListWrapper< CVTerm > *)new ListWrapper< CVTerm >();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListWrapperT_CVTerm_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CVTermList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_CVTermList",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CVTermList" "', argument " "1"" of type '" "ListWrapper< CVTerm > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTermList_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  CVTerm *arg2 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTermList_add",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTermList_add" "', argument " "1"" of type '" "ListWrapper< CVTerm > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CVTermList_add" "', argument " "2"" of type '" "CVTerm *""'"); 
  }
  arg2 = reinterpret_cast< CVTerm * >(argp2);
  (arg1)->add(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTermList_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTermList_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTermList_get" "', argument " "1"" of type '" "ListWrapper< CVTerm > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CVTermList_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CVTerm *)((ListWrapper< CVTerm > const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTermList_prepend(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  CVTerm *arg2 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTermList_prepend",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTermList_prepend" "', argument " "1"" of type '" "ListWrapper< CVTerm > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CVTermList_prepend" "', argument " "2"" of type '" "CVTerm *""'"); 
  }
  arg2 = reinterpret_cast< CVTerm * >(argp2);
  (arg1)->prepend(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTermList_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTermList_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTermList_remove" "', argument " "1"" of type '" "ListWrapper< CVTerm > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CVTermList_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CVTerm *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTermList_getSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< CVTerm > *arg1 = (ListWrapper< CVTerm > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTermList_getSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTermList_getSize" "', argument " "1"" of type '" "ListWrapper< CVTerm > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< CVTerm > * >(argp1);
  result = (unsigned int)((ListWrapper< CVTerm > const *)arg1)->getSize();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CVTermList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListWrapperT_CVTerm_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ASTNodeList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ASTNodeList")) SWIG_fail;
  result = (ListWrapper< ASTNode > *)new ListWrapper< ASTNode >();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListWrapperT_ASTNode_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ASTNodeList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ASTNodeList",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ASTNodeList" "', argument " "1"" of type '" "ListWrapper< ASTNode > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNodeList_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNodeList_add",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNodeList_add" "', argument " "1"" of type '" "ListWrapper< ASTNode > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNodeList_add" "', argument " "2"" of type '" "ASTNode *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  (arg1)->add(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNodeList_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNodeList_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNodeList_get" "', argument " "1"" of type '" "ListWrapper< ASTNode > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNodeList_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ASTNode *)((ListWrapper< ASTNode > const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNodeList_prepend(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNodeList_prepend",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNodeList_prepend" "', argument " "1"" of type '" "ListWrapper< ASTNode > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNodeList_prepend" "', argument " "2"" of type '" "ASTNode *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  (arg1)->prepend(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNodeList_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNodeList_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNodeList_remove" "', argument " "1"" of type '" "ListWrapper< ASTNode > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNodeList_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ASTNode *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNodeList_getSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< ASTNode > *arg1 = (ListWrapper< ASTNode > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNodeList_getSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_ASTNode_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNodeList_getSize" "', argument " "1"" of type '" "ListWrapper< ASTNode > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< ASTNode > * >(argp1);
  result = (unsigned int)((ListWrapper< ASTNode > const *)arg1)->getSize();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ASTNodeList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListWrapperT_ASTNode_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_SBMLNamespacesList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< SBMLNamespaces > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBMLNamespacesList")) SWIG_fail;
  result = (ListWrapper< SBMLNamespaces > *)new ListWrapper< SBMLNamespaces >();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLNamespacesList(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< SBMLNamespaces > *arg1 = (ListWrapper< SBMLNamespaces > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLNamespacesList",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLNamespacesList" "', argument " "1"" of type '" "ListWrapper< SBMLNamespaces > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< SBMLNamespaces > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespacesList_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< SBMLNamespaces > *arg1 = (ListWrapper< SBMLNamespaces > *) 0 ;
  SBMLNamespaces *arg2 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLNamespacesList_add",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespacesList_add" "', argument " "1"" of type '" "ListWrapper< SBMLNamespaces > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< SBMLNamespaces > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLNamespacesList_add" "', argument " "2"" of type '" "SBMLNamespaces *""'"); 
  }
  arg2 = reinterpret_cast< SBMLNamespaces * >(argp2);
  (arg1)->add(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespacesList_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< SBMLNamespaces > *arg1 = (ListWrapper< SBMLNamespaces > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLNamespacesList_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespacesList_get" "', argument " "1"" of type '" "ListWrapper< SBMLNamespaces > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< SBMLNamespaces > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLNamespacesList_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLNamespaces *)((ListWrapper< SBMLNamespaces > const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespacesList_prepend(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< SBMLNamespaces > *arg1 = (ListWrapper< SBMLNamespaces > *) 0 ;
  SBMLNamespaces *arg2 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLNamespacesList_prepend",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespacesList_prepend" "', argument " "1"" of type '" "ListWrapper< SBMLNamespaces > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< SBMLNamespaces > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLNamespacesList_prepend" "', argument " "2"" of type '" "SBMLNamespaces *""'"); 
  }
  arg2 = reinterpret_cast< SBMLNamespaces * >(argp2);
  (arg1)->prepend(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespacesList_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< SBMLNamespaces > *arg1 = (ListWrapper< SBMLNamespaces > *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLNamespacesList_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespacesList_remove" "', argument " "1"" of type '" "ListWrapper< SBMLNamespaces > *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< SBMLNamespaces > * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLNamespacesList_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLNamespaces *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespacesList_getSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListWrapper< SBMLNamespaces > *arg1 = (ListWrapper< SBMLNamespaces > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespacesList_getSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespacesList_getSize" "', argument " "1"" of type '" "ListWrapper< SBMLNamespaces > const *""'"); 
  }
  arg1 = reinterpret_cast< ListWrapper< SBMLNamespaces > * >(argp1);
  result = (unsigned int)((ListWrapper< SBMLNamespaces > const *)arg1)->getSize();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLNamespacesList_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_SwigPyIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SwigPyIterator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SwigPyIterator" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_value",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_value" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)((swig::SwigPyIterator const *)arg1)->value();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_incr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_incr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_incr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_incr" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  try {
    result = (swig::SwigPyIterator *)(arg1)->incr(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_incr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_incr",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_incr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (swig::SwigPyIterator *)(arg1)->incr();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_incr(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SwigPyIterator_incr__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SwigPyIterator_incr__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SwigPyIterator_incr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    incr(swig::SwigPyIterator *,size_t)\n"
    "    incr(swig::SwigPyIterator *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_decr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  size_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_decr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_decr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_decr" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  try {
    result = (swig::SwigPyIterator *)(arg1)->decr(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_decr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_decr",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_decr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (swig::SwigPyIterator *)(arg1)->decr();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_decr(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SwigPyIterator_decr__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SwigPyIterator_decr__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SwigPyIterator_decr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    decr(swig::SwigPyIterator *,size_t)\n"
    "    decr(swig::SwigPyIterator *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_distance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ptrdiff_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_distance",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_distance" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator_distance" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator_distance" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  try {
    result = ((swig::SwigPyIterator const *)arg1)->distance((swig::SwigPyIterator const &)*arg2);
  }
  catch(std::invalid_argument &_e) {
    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
  }
  
  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_equal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_equal",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_equal" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator_equal" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator_equal" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  try {
    result = (bool)((swig::SwigPyIterator const *)arg1)->equal((swig::SwigPyIterator const &)*arg2);
  }
  catch(std::invalid_argument &_e) {
    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
  }
  
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_copy",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_copy" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->copy();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_next",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_next" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->next();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___next__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator___next__",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___next__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->__next__();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_previous(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SwigPyIterator_previous",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_previous" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->previous();
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_advance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator_advance",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_advance" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_advance" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *)(arg1)->advance(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___eq__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___eq__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___eq__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___eq__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___eq__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  result = (bool)((swig::SwigPyIterator const *)arg1)->operator ==((swig::SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___ne__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___ne__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___ne__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___ne__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___ne__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  result = (bool)((swig::SwigPyIterator const *)arg1)->operator !=((swig::SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___iadd__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___iadd__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___iadd__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___iadd__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *) &(arg1)->operator +=(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___isub__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___isub__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___isub__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___isub__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *) &(arg1)->operator -=(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___add__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___add__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___add__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___add__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->operator +(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___sub____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___sub__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___sub__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->operator -(arg2);
  }
  catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___sub____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ptrdiff_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SwigPyIterator___sub__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___sub__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  result = ((swig::SwigPyIterator const *)arg1)->operator -((swig::SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___sub__(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_swig__SwigPyIterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SwigPyIterator___sub____SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SwigPyIterator___sub____SWIG_0(self, args);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *SwigPyIterator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_swig__SwigPyIterator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN int Swig_var_string_npos_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable string_npos is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_string_npos_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_From_size_t(static_cast< size_t >(std::basic_string< char >::npos));
  return pyobj;
}


SWIGINTERN PyObject *_wrap_new_string__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_string",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_string" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_string" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  result = (std::basic_string< char > *)new std::basic_string< char >((char const *)arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_NEW |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_length(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_length",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_length" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = ((std::basic_string< char > const *)arg1)->length();
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_max_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_max_size",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_max_size" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = ((std::basic_string< char > const *)arg1)->max_size();
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_assign__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_assign",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_assign" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_assign" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_assign" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->assign((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_assign__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_assign",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_assign" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_assign" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_assign" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_assign" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_assign" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = (std::basic_string< char > *) &(arg1)->assign((std::basic_string< char > const &)*arg2,arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_assign__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_assign",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_assign" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_assign" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_assign" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = (std::basic_string< char > *) &(arg1)->assign((char const *)arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_insert",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg3 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->insert(arg2,(std::basic_string< char > const &)*arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char > *arg3 = 0 ;
  std::basic_string< char >::size_type arg4 ;
  std::basic_string< char >::size_type arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  size_t val4 ;
  int ecode4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_insert",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg3 = ptr;
  }
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_insert" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "string_insert" "', argument " "5"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg5 = static_cast< std::basic_string< char >::size_type >(val5);
  result = (std::basic_string< char > *) &(arg1)->insert(arg2,(std::basic_string< char > const &)*arg3,arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  char *arg3 = (char *) 0 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  res3 = SWIG_AsCharPtrAndSize(obj2, &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "string_insert" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_insert" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = (std::basic_string< char > *) &(arg1)->insert(arg2,(char const *)arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return resultobj;
fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  char arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  char val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_char(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_insert" "', argument " "4"" of type '" "char""'");
  } 
  arg4 = static_cast< char >(val4);
  result = (std::basic_string< char > *) &(arg1)->insert(arg2,arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_erase__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_erase",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_erase" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_erase" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_erase" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = (std::basic_string< char > *) &(arg1)->erase(arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_erase__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_erase",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_erase" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_erase" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  result = (std::basic_string< char > *) &(arg1)->erase(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_erase__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_erase",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_erase" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (std::basic_string< char > *) &(arg1)->erase();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_replace",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg4 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(std::basic_string< char > const &)*arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char > *arg4 = 0 ;
  std::basic_string< char >::size_type arg5 ;
  std::basic_string< char >::size_type arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  size_t val5 ;
  int ecode5 = 0 ;
  size_t val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "string_replace" "', argument " "5"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg5 = static_cast< std::basic_string< char >::size_type >(val5);
  ecode6 = SWIG_AsVal_size_t(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "string_replace" "', argument " "6"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg6 = static_cast< std::basic_string< char >::size_type >(val6);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(std::basic_string< char > const &)*arg4,arg5,arg6);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  char *arg4 = (char *) 0 ;
  std::basic_string< char >::size_type arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string_replace" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "string_replace" "', argument " "5"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg5 = static_cast< std::basic_string< char >::size_type >(val5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(char const *)arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  char arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  ecode5 = SWIG_AsVal_char(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "string_replace" "', argument " "5"" of type '" "char""'");
  } 
  arg5 = static_cast< char >(val5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_copy__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_copy",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_copy" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_copy" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_copy" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_copy" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->copy(arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_copy__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_copy",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_copy" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_copy" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_copy" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->copy(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_copy(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_copy__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_copy__SWIG_0(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_copy'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    copy(std::basic_string< char > const *,char *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    copy(std::basic_string< char > const *,char *,std::basic_string< char >::size_type)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_c_str(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_c_str",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_c_str" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (char *)((std::basic_string< char > const *)arg1)->c_str();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_find",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_find" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find((char const *)arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find((std::basic_string< char > const &)*arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find(arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find__SWIG_4(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find__SWIG_0(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_find'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    find(std::basic_string< char > const *,char const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    find(std::basic_string< char > const *,std::basic_string< char > const &,std::basic_string< char >::size_type)\n"
    "    find(std::basic_string< char > const *,std::basic_string< char > const &)\n"
    "    find(std::basic_string< char > const *,char,std::basic_string< char >::size_type)\n"
    "    find(std::basic_string< char > const *,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_rfind__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_rfind",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_rfind" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_rfind" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_rfind" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_rfind" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->rfind((std::basic_string< char > const &)*arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_rfind__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_rfind",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_rfind" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_rfind" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_rfind" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->rfind((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_rfind__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_rfind",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_rfind" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_rfind" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_rfind" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_rfind" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->rfind((char const *)arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_rfind__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_rfind",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_rfind" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_rfind" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_rfind" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->rfind(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_rfind__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_rfind",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_rfind" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_rfind" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->rfind(arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_rfind(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_rfind__SWIG_4(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_rfind__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_rfind__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_rfind__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_rfind__SWIG_2(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_rfind'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    rfind(std::basic_string< char > const *,std::basic_string< char > const &,std::basic_string< char >::size_type)\n"
    "    rfind(std::basic_string< char > const *,std::basic_string< char > const &)\n"
    "    rfind(std::basic_string< char > const *,char const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    rfind(std::basic_string< char > const *,char,std::basic_string< char >::size_type)\n"
    "    rfind(std::basic_string< char > const *,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_of__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_first_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_first_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_first_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_first_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_first_of((std::basic_string< char > const &)*arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_of__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_first_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_first_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_first_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find_first_of((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_of__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_find_first_of",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_first_of" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_first_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_find_first_of" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find_first_of((char const *)arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_of__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_first_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_first_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_first_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_first_of(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_of__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_first_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_first_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find_first_of(arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_of(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find_first_of__SWIG_4(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find_first_of__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_first_of__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_first_of__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find_first_of__SWIG_2(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_find_first_of'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    find_first_of(std::basic_string< char > const *,std::basic_string< char > const &,std::basic_string< char >::size_type)\n"
    "    find_first_of(std::basic_string< char > const *,std::basic_string< char > const &)\n"
    "    find_first_of(std::basic_string< char > const *,char const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    find_first_of(std::basic_string< char > const *,char,std::basic_string< char >::size_type)\n"
    "    find_first_of(std::basic_string< char > const *,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_of__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_last_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_last_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_last_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_last_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_last_of((std::basic_string< char > const &)*arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_of__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_last_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_last_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_last_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find_last_of((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_of__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_find_last_of",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_last_of" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_last_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_find_last_of" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find_last_of((char const *)arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_of__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_last_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_last_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_last_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_last_of(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_of__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_last_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_last_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find_last_of(arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_of(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find_last_of__SWIG_4(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find_last_of__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_last_of__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_last_of__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find_last_of__SWIG_2(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_find_last_of'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    find_last_of(std::basic_string< char > const *,std::basic_string< char > const &,std::basic_string< char >::size_type)\n"
    "    find_last_of(std::basic_string< char > const *,std::basic_string< char > const &)\n"
    "    find_last_of(std::basic_string< char > const *,char const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    find_last_of(std::basic_string< char > const *,char,std::basic_string< char >::size_type)\n"
    "    find_last_of(std::basic_string< char > const *,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_not_of__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_first_not_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_first_not_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of((std::basic_string< char > const &)*arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_not_of__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_first_not_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_not_of__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_find_first_not_of",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_first_not_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_find_first_not_of" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of((char const *)arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_not_of__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_first_not_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_first_not_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_not_of__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_first_not_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_first_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_first_not_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find_first_not_of(arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_first_not_of(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find_first_not_of__SWIG_4(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find_first_not_of__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_first_not_of__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_first_not_of__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find_first_not_of__SWIG_2(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_find_first_not_of'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    find_first_not_of(std::basic_string< char > const *,std::basic_string< char > const &,std::basic_string< char >::size_type)\n"
    "    find_first_not_of(std::basic_string< char > const *,std::basic_string< char > const &)\n"
    "    find_first_not_of(std::basic_string< char > const *,char const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    find_first_not_of(std::basic_string< char > const *,char,std::basic_string< char >::size_type)\n"
    "    find_first_not_of(std::basic_string< char > const *,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_not_of__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_last_not_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_last_not_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of((std::basic_string< char > const &)*arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_not_of__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_last_not_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_not_of__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char *arg2 = (char *) 0 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::size_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  size_t val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_find_last_not_of",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_last_not_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_find_last_not_of" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of((char const *)arg2,arg3,arg4);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_not_of__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_find_last_not_of",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_find_last_not_of" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of(arg2,arg3);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_not_of__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_find_last_not_of",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_find_last_not_of" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_find_last_not_of" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = ((std::basic_string< char > const *)arg1)->find_last_not_of(arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_find_last_not_of(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_find_last_not_of__SWIG_4(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_find_last_not_of__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_last_not_of__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_find_last_not_of__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_find_last_not_of__SWIG_2(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_find_last_not_of'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    find_last_not_of(std::basic_string< char > const *,std::basic_string< char > const &,std::basic_string< char >::size_type)\n"
    "    find_last_not_of(std::basic_string< char > const *,std::basic_string< char > const &)\n"
    "    find_last_not_of(std::basic_string< char > const *,char const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    find_last_not_of(std::basic_string< char > const *,char,std::basic_string< char >::size_type)\n"
    "    find_last_not_of(std::basic_string< char > const *,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_substr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::size_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char > result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_substr",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_substr" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_substr" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_substr" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  result = ((std::basic_string< char > const *)arg1)->substr(arg2,arg3);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_substr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char > result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_substr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_substr" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_substr" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  result = ((std::basic_string< char > const *)arg1)->substr(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_substr__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_substr",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_substr" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = ((std::basic_string< char > const *)arg1)->substr();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_substr(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_string_substr__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_substr__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_substr__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_substr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    substr(std::basic_string< char > const *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    substr(std::basic_string< char > const *,std::basic_string< char >::size_type)\n"
    "    substr(std::basic_string< char > const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_string__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_string")) SWIG_fail;
  result = (std::basic_string< char > *)new std::basic_string< char >();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_string__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_string",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_string" "', argument " "1"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_string" "', argument " "1"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg1 = ptr;
  }
  result = (std::basic_string< char > *)new std::basic_string< char >((std::basic_string< char > const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_empty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_empty" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (bool)((std::basic_string< char > const *)arg1)->empty();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string_size",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_size" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = ((std::basic_string< char > const *)arg1)->size();
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_swap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_swap",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_swap" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_swap" "', argument " "2"" of type '" "std::basic_string< char > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_swap" "', argument " "2"" of type '" "std::basic_string< char > &""'"); 
  }
  arg2 = reinterpret_cast< std::basic_string< char > * >(argp2);
  (arg1)->swap(*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_resize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_resize",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_resize" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_resize" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  (arg1)->resize(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_erase__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string_erase",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_erase" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_erase" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_erase" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    } else {
      std::basic_string< char >::iterator * temp = reinterpret_cast< std::basic_string< char >::iterator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = (arg1)->erase(arg2);
  resultobj = SWIG_NewPointerObj((new std::basic_string< char >::iterator(static_cast< const std::basic_string< char >::iterator& >(result))), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_erase__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_erase",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_erase" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_erase" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_erase" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    } else {
      std::basic_string< char >::iterator * temp = reinterpret_cast< std::basic_string< char >::iterator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "string_erase" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_erase" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
    } else {
      std::basic_string< char >::iterator * temp = reinterpret_cast< std::basic_string< char >::iterator * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  result = (arg1)->erase(arg2,arg3);
  resultobj = SWIG_NewPointerObj((new std::basic_string< char >::iterator(static_cast< const std::basic_string< char >::iterator& >(result))), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_erase(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_string_erase__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_erase__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_erase__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_string_erase__SWIG_4(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_erase__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_erase'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    erase(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    erase(std::basic_string< char > *,std::basic_string< char >::size_type)\n"
    "    erase(std::basic_string< char > *)\n"
    "    erase(std::basic_string< char > *,std::basic_string< char >::iterator)\n"
    "    erase(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::iterator)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_string__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char >::size_type arg1 ;
  std::basic_string< char >::value_type arg2 ;
  size_t val1 ;
  int ecode1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_string",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_size_t(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_string" "', argument " "1"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg1 = static_cast< std::basic_string< char >::size_type >(val1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_string" "', argument " "2"" of type '" "std::basic_string< char >::value_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::value_type >(val2);
  result = (std::basic_string< char > *)new std::basic_string< char >(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_string(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_string__SWIG_1(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_string__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_size_t(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_string__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsCharPtrAndSize(argv[0], 0, NULL, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_string__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_string'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    std::basic_string< char >(char const *,std::basic_string< char >::size_type)\n"
    "    std::basic_string< char >()\n"
    "    std::basic_string< char >(std::basic_string< char > const &)\n"
    "    std::basic_string< char >(std::basic_string< char >::size_type,std::basic_string< char >::value_type)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_assign__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::value_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_assign",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_assign" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_assign" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_char(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_assign" "', argument " "3"" of type '" "std::basic_string< char >::value_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::value_type >(val3);
  (arg1)->assign(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_assign(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_string_assign__SWIG_0(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_assign__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsCharPtrAndSize(argv[1], 0, NULL, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_assign__SWIG_2(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_assign__SWIG_1(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_assign'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    assign(std::basic_string< char > *,std::basic_string< char > const &)\n"
    "    assign(std::basic_string< char > *,std::basic_string< char > const &,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    assign(std::basic_string< char > *,char const *,std::basic_string< char >::size_type)\n"
    "    assign(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::value_type)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_resize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::size_type arg2 ;
  std::basic_string< char >::value_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_resize",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_resize" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_size_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string_resize" "', argument " "2"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::size_type >(val2);
  ecode3 = SWIG_AsVal_char(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_resize" "', argument " "3"" of type '" "std::basic_string< char >::value_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::value_type >(val3);
  (arg1)->resize(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_resize(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string_resize__SWIG_0(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_resize__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_resize'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    resize(std::basic_string< char > *,std::basic_string< char >::size_type)\n"
    "    resize(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::value_type)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::value_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char >::iterator result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string_insert",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    } else {
      std::basic_string< char >::iterator * temp = reinterpret_cast< std::basic_string< char >::iterator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_char(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char >::value_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::value_type >(val3);
  result = (arg1)->insert(arg2,arg3);
  resultobj = SWIG_NewPointerObj((new std::basic_string< char >::iterator(static_cast< const std::basic_string< char >::iterator& >(result))), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::size_type arg3 ;
  std::basic_string< char >::value_type arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  char val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    } else {
      std::basic_string< char >::iterator * temp = reinterpret_cast< std::basic_string< char >::iterator * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_char(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_insert" "', argument " "4"" of type '" "std::basic_string< char >::value_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::value_type >(val4);
  (arg1)->insert(arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_iterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  PyObject **arg2 = (PyObject **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  arg2 = &obj0;
  if (!PyArg_ParseTuple(args,(char *)"O:string_iterator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_iterator" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (swig::SwigPyIterator *)std_basic_string_Sl_char_Sg__iterator(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___nonzero__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string___nonzero__",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___nonzero__" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (bool)std_basic_string_Sl_char_Sg____nonzero__((std::basic_string< char > const *)arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___bool__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string___bool__",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___bool__" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = (bool)std_basic_string_Sl_char_Sg____bool__((std::basic_string< char > const *)arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___len__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char >::size_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string___len__",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___len__" "', argument " "1"" of type '" "std::basic_string< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = std_basic_string_Sl_char_Sg____len__((std::basic_string< char > const *)arg1);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___getslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  std::basic_string< char >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string___getslice__",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___getslice__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string___getslice__" "', argument " "2"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string___getslice__" "', argument " "3"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::difference_type >(val3);
  try {
    result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg____getslice__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___setslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  std::basic_string< char >::difference_type arg3 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string___setslice__",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___setslice__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string___setslice__" "', argument " "2"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string___setslice__" "', argument " "3"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::difference_type >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string___setslice__" "', argument " "4"" of type '" "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___setslice__" "', argument " "4"" of type '" "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &""'"); 
    }
    arg4 = ptr;
  }
  try {
    std_basic_string_Sl_char_Sg____setslice__(arg1,arg2,arg3,(std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg4);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  catch(std::invalid_argument &_e) {
    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
  }
  
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___delslice__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  std::basic_string< char >::difference_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  ptrdiff_t val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string___delslice__",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___delslice__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string___delslice__" "', argument " "2"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string___delslice__" "', argument " "3"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::difference_type >(val3);
  try {
    std_basic_string_Sl_char_Sg____delslice__(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___delitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___delitem__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___delitem__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string___delitem__" "', argument " "2"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  try {
    std_basic_string_Sl_char_Sg____delitem____SWIG_0(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___getitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  PySliceObject *arg2 = (PySliceObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___getitem__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___getitem__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    arg2 = (PySliceObject *) obj1;
  }
  try {
    result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg____getitem____SWIG_0(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___setitem____SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  PySliceObject *arg2 = (PySliceObject *) 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___setitem__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    arg2 = (PySliceObject *) obj1;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "string___setitem__" "', argument " "3"" of type '" "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___setitem__" "', argument " "3"" of type '" "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &""'"); 
    }
    arg3 = ptr;
  }
  try {
    std_basic_string_Sl_char_Sg____setitem____SWIG_0(arg1,arg2,(std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  catch(std::invalid_argument &_e) {
    SWIG_exception_fail(SWIG_ValueError, (&_e)->what());
  }
  
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___delitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  PySliceObject *arg2 = (PySliceObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___delitem__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___delitem__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    arg2 = (PySliceObject *) obj1;
  }
  try {
    std_basic_string_Sl_char_Sg____delitem____SWIG_1(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___delitem__(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PySlice_Check(argv[1]);
      }
      if (_v) {
        return _wrap_string___delitem____SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string___delitem____SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string___delitem__'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    __delitem__(std::basic_string< char > *,std::basic_string< char >::difference_type)\n"
    "    __delitem__(std::basic_string< char > *,PySliceObject *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___getitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char >::value_type result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___getitem__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___getitem__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string___getitem__" "', argument " "2"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  try {
    result = (std::basic_string< char >::value_type)std_basic_string_Sl_char_Sg____getitem____SWIG_1(arg1,arg2);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_From_char(static_cast< char >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___getitem__(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PySlice_Check(argv[1]);
      }
      if (_v) {
        return _wrap_string___getitem____SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_string___getitem____SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string___getitem__'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    __getitem__(std::basic_string< char > *,PySliceObject *)\n"
    "    __getitem__(std::basic_string< char > *,std::basic_string< char >::difference_type)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___setitem____SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::difference_type arg2 ;
  std::basic_string< char >::value_type arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:string___setitem__",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___setitem__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "string___setitem__" "', argument " "2"" of type '" "std::basic_string< char >::difference_type""'");
  } 
  arg2 = static_cast< std::basic_string< char >::difference_type >(val2);
  ecode3 = SWIG_AsVal_char(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string___setitem__" "', argument " "3"" of type '" "std::basic_string< char >::value_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::value_type >(val3);
  try {
    std_basic_string_Sl_char_Sg____setitem____SWIG_1(arg1,arg2,arg3);
  }
  catch(std::out_of_range &_e) {
    SWIG_exception_fail(SWIG_IndexError, (&_e)->what());
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___setitem__(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        _v = PySlice_Check(argv[1]);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_string___setitem____SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string___setitem____SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string___setitem__'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    __setitem__(std::basic_string< char > *,PySliceObject *,std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)\n"
    "    __setitem__(std::basic_string< char > *,std::basic_string< char >::difference_type,std::basic_string< char >::value_type)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::size_type arg3 ;
  char arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::SwigPyIterator *iter2 = 0 ;
  int res2 ;
  size_t val3 ;
  int ecode3 = 0 ;
  char val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_insert",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_insert" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_insert" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  ecode3 = SWIG_AsVal_size_t(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "string_insert" "', argument " "3"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg3 = static_cast< std::basic_string< char >::size_type >(val3);
  ecode4 = SWIG_AsVal_char(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_insert" "', argument " "4"" of type '" "char""'");
  } 
  arg4 = static_cast< char >(val4);
  (arg1)->insert(arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_insert(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[6];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_char(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_string_insert__SWIG_4(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_string_insert__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_char(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_insert__SWIG_5(self, args);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::SwigPyIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_char(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_insert__SWIG_6(self, args);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_char(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_insert__SWIG_3(self, args);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsCharPtrAndSize(argv[2], 0, NULL, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_string_insert__SWIG_2(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_size_t(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_insert__SWIG_1(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_insert'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char > const &)\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char > const &,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::size_type,char const *,std::basic_string< char >::size_type)\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::size_type,char)\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::value_type)\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::size_type,std::basic_string< char >::value_type)\n"
    "    insert(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::size_type,char)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  std::basic_string< char > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::SwigPyIterator *iter2 = 0 ;
  int res2 ;
  swig::SwigPyIterator *iter3 = 0 ;
  int res3 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:string_replace",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg4 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(std::basic_string< char > const &)*arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  char *arg4 = (char *) 0 ;
  std::basic_string< char >::size_type arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::SwigPyIterator *iter2 = 0 ;
  int res2 ;
  swig::SwigPyIterator *iter3 = 0 ;
  int res3 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  size_t val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string_replace" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  ecode5 = SWIG_AsVal_size_t(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "string_replace" "', argument " "5"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg5 = static_cast< std::basic_string< char >::size_type >(val5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(char const *)arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  std::basic_string< char >::size_type arg4 ;
  char arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::SwigPyIterator *iter2 = 0 ;
  int res2 ;
  swig::SwigPyIterator *iter3 = 0 ;
  int res3 ;
  size_t val4 ;
  int ecode4 = 0 ;
  char val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  ecode4 = SWIG_AsVal_size_t(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char >::size_type""'");
  } 
  arg4 = static_cast< std::basic_string< char >::size_type >(val4);
  ecode5 = SWIG_AsVal_char(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "string_replace" "', argument " "5"" of type '" "char""'");
  } 
  arg5 = static_cast< char >(val5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::SwigPyIterator *iter2 = 0 ;
  int res2 ;
  swig::SwigPyIterator *iter3 = 0 ;
  int res3 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res4 = SWIG_AsCharPtrAndSize(obj3, &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "string_replace" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  res5 = SWIG_AsCharPtrAndSize(obj4, &buf5, NULL, &alloc5);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "string_replace" "', argument " "5"" of type '" "char const *""'");
  }
  arg5 = reinterpret_cast< char * >(buf5);
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,(char const *)arg4,(char const *)arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  return resultobj;
fail:
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace__SWIG_8(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char >::iterator arg2 ;
  std::basic_string< char >::iterator arg3 ;
  std::basic_string< char >::const_iterator arg4 ;
  std::basic_string< char >::const_iterator arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  swig::SwigPyIterator *iter2 = 0 ;
  int res2 ;
  swig::SwigPyIterator *iter3 = 0 ;
  int res3 ;
  swig::SwigPyIterator *iter4 = 0 ;
  int res4 ;
  swig::SwigPyIterator *iter5 = 0 ;
  int res5 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:string_replace",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string_replace" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, SWIG_as_voidptrptr(&iter2), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter2);
    if (iter_t) {
      arg2 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "2"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res3 = SWIG_ConvertPtr(obj2, SWIG_as_voidptrptr(&iter3), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter3);
    if (iter_t) {
      arg3 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "3"" of type '" "std::basic_string< char >::iterator""'");
    }
  }
  res4 = SWIG_ConvertPtr(obj3, SWIG_as_voidptrptr(&iter4), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res4) || !iter4) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char >::const_iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::const_iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::const_iterator > *>(iter4);
    if (iter_t) {
      arg4 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "4"" of type '" "std::basic_string< char >::const_iterator""'");
    }
  }
  res5 = SWIG_ConvertPtr(obj4, SWIG_as_voidptrptr(&iter5), swig::SwigPyIterator::descriptor(), 0);
  if (!SWIG_IsOK(res5) || !iter5) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "5"" of type '" "std::basic_string< char >::const_iterator""'");
  } else {
    swig::SwigPyIterator_T<std::basic_string< char >::const_iterator > *iter_t = dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::const_iterator > *>(iter5);
    if (iter_t) {
      arg5 = iter_t->get_current();
    } else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), "in method '" "string_replace" "', argument " "5"" of type '" "std::basic_string< char >::const_iterator""'");
    }
  }
  result = (std::basic_string< char > *) &(arg1)->replace(arg2,arg3,arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string_replace(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[7];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 6); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::SwigPyIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::SwigPyIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_string_replace__SWIG_4(self, args);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_string_replace__SWIG_0(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::SwigPyIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::SwigPyIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          swig::SwigPyIterator *iter = 0;
          int res = SWIG_ConvertPtr(argv[3], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
          _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::const_iterator > *>(iter) != 0));
          if (_v) {
            swig::SwigPyIterator *iter = 0;
            int res = SWIG_ConvertPtr(argv[4], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
            _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::const_iterator > *>(iter) != 0));
            if (_v) {
              return _wrap_string_replace__SWIG_8(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::SwigPyIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::SwigPyIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_replace__SWIG_6(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::SwigPyIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::SwigPyIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_size_t(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_replace__SWIG_5(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      swig::SwigPyIterator *iter = 0;
      int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
      if (_v) {
        swig::SwigPyIterator *iter = 0;
        int res = SWIG_ConvertPtr(argv[2], SWIG_as_voidptrptr(&iter), swig::SwigPyIterator::descriptor(), 0);
        _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::SwigPyIterator_T<std::basic_string< char >::iterator > *>(iter) != 0));
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsCharPtrAndSize(argv[4], 0, NULL, 0);
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_string_replace__SWIG_7(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_size_t(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_char(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_replace__SWIG_3(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsCharPtrAndSize(argv[3], 0, NULL, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_size_t(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_string_replace__SWIG_2(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_size_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_size_t(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_size_t(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_string_replace__SWIG_1(self, args);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'string_replace'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::size_type,std::basic_string< char > const &)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::size_type,std::basic_string< char > const &,std::basic_string< char >::size_type,std::basic_string< char >::size_type)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::size_type,char const *,std::basic_string< char >::size_type)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::size_type,std::basic_string< char >::size_type,std::basic_string< char >::size_type,char)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::iterator,std::basic_string< char > const &)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::iterator,char const *,std::basic_string< char >::size_type)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::iterator,std::basic_string< char >::size_type,char)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::iterator,char const *,char const *)\n"
    "    replace(std::basic_string< char > *,std::basic_string< char >::iterator,std::basic_string< char >::iterator,std::basic_string< char >::const_iterator,std::basic_string< char >::const_iterator)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___iadd__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___iadd__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___iadd__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___iadd__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___iadd__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (std::basic_string< char > *) &(arg1)->operator +=((std::basic_string< char > const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___add__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___add__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___add__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___add__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___add__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg____add__(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___radd__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___radd__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___radd__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___radd__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___radd__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (std::basic_string< char,std::char_traits< char >,std::allocator< char > > *)std_basic_string_Sl_char_Sg____radd__(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___str__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:string___str__",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___str__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  result = std_basic_string_Sl_char_Sg____str__(arg1);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___rlshift__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_ostream< char,std::char_traits< char > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::basic_ostream< char,std::char_traits< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___rlshift__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___rlshift__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___rlshift__" "', argument " "2"" of type '" "std::basic_ostream< char,std::char_traits< char > > &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___rlshift__" "', argument " "2"" of type '" "std::basic_ostream< char,std::char_traits< char > > &""'"); 
  }
  arg2 = reinterpret_cast< std::basic_ostream< char,std::char_traits< char > > * >(argp2);
  result = (std::basic_ostream< char,std::char_traits< char > > *) &std_basic_string_Sl_char_Sg____rlshift__(arg1,*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___eq__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___eq__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___eq__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___eq__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___eq__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Se__Se_(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___ne__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___ne__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___ne__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___ne__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___ne__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_SN__Se_(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___gt__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___gt__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___gt__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___gt__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___gt__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Sg_(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___lt__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___lt__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___lt__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___lt__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___lt__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Sl_(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___ge__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___ge__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___ge__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___ge__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___ge__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Sg__Se_(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_string___le__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  std::basic_string< char > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:string___le__",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "string___le__" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "string___le__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "string___le__" "', argument " "2"" of type '" "std::basic_string< char > const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)std_basic_string_Sl_char_Sg__operator_Sl__Se_(arg1,(std::basic_string< char > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_string< char > *arg1 = (std::basic_string< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_string",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_string" "', argument " "1"" of type '" "std::basic_string< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_string< char > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *string_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ostream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_streambuf< char,std::char_traits< char > > *arg1 = (std::basic_streambuf< char,std::char_traits< char > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_ostream< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ostream",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_streambufT_char_std__char_traitsT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ostream" "', argument " "1"" of type '" "std::basic_streambuf< char,std::char_traits< char > > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_streambuf< char,std::char_traits< char > > * >(argp1);
  result = (std::basic_ostream< char > *)new std::basic_ostream< char >(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ostream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostream< char > *arg1 = (std::basic_ostream< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ostream",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ostream" "', argument " "1"" of type '" "std::basic_ostream< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_ostream< char > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ostream_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ostringstream__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::ios_base::openmode arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_ostringstream< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ostringstream",&obj0)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__ios_base__openmode,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ostringstream" "', argument " "1"" of type '" "std::ios_base::openmode""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ostringstream" "', argument " "1"" of type '" "std::ios_base::openmode""'");
    } else {
      std::ios_base::openmode * temp = reinterpret_cast< std::ios_base::openmode * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  result = (std::basic_ostringstream< char > *)new std::basic_ostringstream< char >(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ostringstream__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostringstream< char > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ostringstream")) SWIG_fail;
  result = (std::basic_ostringstream< char > *)new std::basic_ostringstream< char >();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ostringstream(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_ostringstream__SWIG_1(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_std__ios_base__openmode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ostringstream__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_ostringstream'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    std::basic_ostringstream< char >(std::ios_base::openmode)\n"
    "    std::basic_ostringstream< char >()\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ostringstream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostringstream< char > *arg1 = (std::basic_ostringstream< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ostringstream",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ostringstream" "', argument " "1"" of type '" "std::basic_ostringstream< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_ostringstream< char > * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ostringstream_str__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostringstream< char > *arg1 = (std::basic_ostringstream< char > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ostringstream_str",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ostringstream_str" "', argument " "1"" of type '" "std::basic_ostringstream< char > const *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_ostringstream< char > * >(argp1);
  result = ((std::basic_ostringstream< char > const *)arg1)->str();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ostringstream_str__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostringstream< char > *arg1 = (std::basic_ostringstream< char > *) 0 ;
  std::basic_string< char,std::char_traits< char >,std::allocator< char > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ostringstream_str",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ostringstream_str" "', argument " "1"" of type '" "std::basic_ostringstream< char > *""'"); 
  }
  arg1 = reinterpret_cast< std::basic_ostringstream< char > * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ostringstream_str" "', argument " "2"" of type '" "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ostringstream_str" "', argument " "2"" of type '" "std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->str((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg2);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ostringstream_str(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ostringstream_str__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ostringstream_str__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ostringstream_str'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    str(std::basic_ostringstream< char > const *)\n"
    "    str(std::basic_ostringstream< char > *,std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)\n");
  return NULL;
}


SWIGINTERN PyObject *ostringstream_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_endl(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostream< char,std::char_traits< char > > *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_ostream< char,std::char_traits< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:endl",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "endl" "', argument " "1"" of type '" "std::basic_ostream< char,std::char_traits< char > > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "endl" "', argument " "1"" of type '" "std::basic_ostream< char,std::char_traits< char > > &""'"); 
  }
  arg1 = reinterpret_cast< std::basic_ostream< char,std::char_traits< char > > * >(argp1);
  result = (std::basic_ostream< char,std::char_traits< char > > *) &std::SWIGTEMPLATEDISAMBIGUATOR endl< char,std::char_traits< char > >(*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_flush(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::basic_ostream< char,std::char_traits< char > > *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::basic_ostream< char,std::char_traits< char > > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:flush",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "flush" "', argument " "1"" of type '" "std::basic_ostream< char,std::char_traits< char > > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "flush" "', argument " "1"" of type '" "std::basic_ostream< char,std::char_traits< char > > &""'"); 
  }
  arg1 = reinterpret_cast< std::basic_ostream< char,std::char_traits< char > > * >(argp1);
  result = (std::basic_ostream< char,std::char_traits< char > > *) &std::SWIGTEMPLATEDISAMBIGUATOR flush< char,std::char_traits< char > >(*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int Swig_var_cout_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable cout is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_cout_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(&std::cout), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  return pyobj;
}


SWIGINTERN int Swig_var_cerr_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable cerr is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_cerr_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(&std::cerr), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  return pyobj;
}


SWIGINTERN int Swig_var_clog_set(PyObject *) {
  SWIG_Error(SWIG_AttributeError,"Variable clog is read-only.");
  return 1;
}


SWIGINTERN PyObject *Swig_var_clog_get(void) {
  PyObject *pyobj = 0;
  
  pyobj = SWIG_NewPointerObj(SWIG_as_voidptr(&std::clog), SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  return pyobj;
}


SWIGINTERN PyObject *_wrap_ASTNode_true(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_true",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_true" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (int)ASTNode_true((ASTNode const *)arg1);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_getLibSBMLVersion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)":getLibSBMLVersion")) SWIG_fail;
  result = (int)getLibSBMLVersion();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_getLibSBMLDottedVersion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":getLibSBMLDottedVersion")) SWIG_fail;
  result = (char *)getLibSBMLDottedVersion();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_getLibSBMLVersionString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":getLibSBMLVersionString")) SWIG_fail;
  result = (char *)getLibSBMLVersionString();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLReader(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLReader *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBMLReader")) SWIG_fail;
  result = (SBMLReader *)new SBMLReader();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLReader, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLReader(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLReader *arg1 = (SBMLReader *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLReader",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLReader, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLReader" "', argument " "1"" of type '" "SBMLReader *""'"); 
  }
  arg1 = reinterpret_cast< SBMLReader * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLReader_readSBML(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLReader *arg1 = (SBMLReader *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLReader_readSBML",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLReader_readSBML" "', argument " "1"" of type '" "SBMLReader *""'"); 
  }
  arg1 = reinterpret_cast< SBMLReader * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLReader_readSBML" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLReader_readSBML" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SBMLDocument *)(arg1)->readSBML((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLReader_readSBMLFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLReader *arg1 = (SBMLReader *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLReader_readSBMLFromFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLReader_readSBMLFromFile" "', argument " "1"" of type '" "SBMLReader *""'"); 
  }
  arg1 = reinterpret_cast< SBMLReader * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLReader_readSBMLFromFile" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLReader_readSBMLFromFile" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SBMLDocument *)(arg1)->readSBMLFromFile((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLReader_readSBMLFromString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLReader *arg1 = (SBMLReader *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLReader_readSBMLFromString",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLReader, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLReader_readSBMLFromString" "', argument " "1"" of type '" "SBMLReader *""'"); 
  }
  arg1 = reinterpret_cast< SBMLReader * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLReader_readSBMLFromString" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLReader_readSBMLFromString" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SBMLDocument *)(arg1)->readSBMLFromString((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLReader_hasZlib(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)":SBMLReader_hasZlib")) SWIG_fail;
  result = (bool)SBMLReader::hasZlib();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLReader_hasBzip2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)":SBMLReader_hasBzip2")) SWIG_fail;
  result = (bool)SBMLReader::hasBzip2();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLReader_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLReader, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_readSBMLFromFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:readSBMLFromFile",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "readSBMLFromFile" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (SBMLDocument_t *)readSBMLFromFile((char const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_readSBMLFromString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:readSBMLFromString",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "readSBMLFromString" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (SBMLDocument_t *)readSBMLFromString((char const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLWriter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBMLWriter")) SWIG_fail;
  result = (SBMLWriter *)new SBMLWriter();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLWriter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLWriter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLWriter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLWriter" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_setProgramName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLWriter_setProgramName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_setProgramName" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_setProgramName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLWriter_setProgramName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setProgramName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_setProgramVersion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLWriter_setProgramVersion",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_setProgramVersion" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_setProgramVersion" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLWriter_setProgramVersion" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setProgramVersion((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_writeSBML__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBMLWriter_writeSBML",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_writeSBML" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_writeSBML" "', argument " "2"" of type '" "SBMLDocument const *""'"); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SBMLWriter_writeSBML" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLWriter_writeSBML" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (bool)(arg1)->writeSBML((SBMLDocument const *)arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_writeSBML__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  std::ostream *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBMLWriter_writeSBML",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_writeSBML" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_writeSBML" "', argument " "2"" of type '" "SBMLDocument const *""'"); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SBMLWriter_writeSBML" "', argument " "3"" of type '" "std::ostream &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLWriter_writeSBML" "', argument " "3"" of type '" "std::ostream &""'"); 
  }
  arg3 = reinterpret_cast< std::ostream * >(argp3);
  result = (bool)(arg1)->writeSBML((SBMLDocument const *)arg2,*arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_writeSBML(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLWriter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_SBMLDocument, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SBMLWriter_writeSBML__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLWriter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_SBMLDocument, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_SBMLWriter_writeSBML__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLWriter_writeSBML'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    writeSBML(SBMLWriter *,SBMLDocument const *,std::string const &)\n"
    "    writeSBML(SBMLWriter *,SBMLDocument const *,std::ostream &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_writeToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLWriter_writeToString",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_writeToString" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_writeToString" "', argument " "2"" of type '" "SBMLDocument const *""'"); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  result = (char *)(arg1)->writeToString((SBMLDocument const *)arg2);
  resultobj = SWIG_FromCharPtr((const char *)result);
  free(result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_writeSBMLToFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBMLWriter_writeSBMLToFile",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_writeSBMLToFile" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_writeSBMLToFile" "', argument " "2"" of type '" "SBMLDocument const *""'"); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "SBMLWriter_writeSBMLToFile" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLWriter_writeSBMLToFile" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (bool)(arg1)->writeSBMLToFile((SBMLDocument const *)arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_writeSBMLToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLWriter *arg1 = (SBMLWriter *) 0 ;
  SBMLDocument *arg2 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLWriter_writeSBMLToString",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLWriter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLWriter_writeSBMLToString" "', argument " "1"" of type '" "SBMLWriter *""'"); 
  }
  arg1 = reinterpret_cast< SBMLWriter * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLWriter_writeSBMLToString" "', argument " "2"" of type '" "SBMLDocument const *""'"); 
  }
  arg2 = reinterpret_cast< SBMLDocument * >(argp2);
  result = (char *)(arg1)->writeSBMLToString((SBMLDocument const *)arg2);
  resultobj = SWIG_FromCharPtr((const char *)result);
  free(result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_hasZlib(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)":SBMLWriter_hasZlib")) SWIG_fail;
  result = (bool)SBMLWriter::hasZlib();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLWriter_hasBzip2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)":SBMLWriter_hasBzip2")) SWIG_fail;
  result = (bool)SBMLWriter::hasBzip2();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLWriter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLWriter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_writeSBML(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument_t *arg1 = (SBMLDocument_t *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:writeSBML",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "writeSBML" "', argument " "1"" of type '" "SBMLDocument_t const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument_t * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "writeSBML" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)writeSBML((SBMLDocument const *)arg1,(char const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_writeSBMLToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument_t *arg1 = (SBMLDocument_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:writeSBMLToString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "writeSBMLToString" "', argument " "1"" of type '" "SBMLDocument_t const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument_t * >(argp1);
  result = (char *)writeSBMLToString((SBMLDocument const *)arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  free(result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_writeSBMLToFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument_t *arg1 = (SBMLDocument_t *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:writeSBMLToFile",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "writeSBMLToFile" "', argument " "1"" of type '" "SBMLDocument_t const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument_t * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "writeSBMLToFile" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)writeSBMLToFile((SBMLDocument const *)arg1,(char const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLTypeCode_toString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLTypeCode_t arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLTypeCode_toString",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBMLTypeCode_toString" "', argument " "1"" of type '" "SBMLTypeCode_t""'");
  } 
  arg1 = static_cast< SBMLTypeCode_t >(val1);
  result = (char *)SBMLTypeCode_toString(arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBase(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBase",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBase" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_clone" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBase *)((SBase const *)arg1)->clone();
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getMetaId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getMetaId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getMetaId" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (std::string *) &((SBase const *)arg1)->getMetaId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getId" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (std::string *) &((SBase const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getName" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (std::string *) &((SBase const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getNotes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getNotes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getNotes" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)(arg1)->getNotes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getNotesString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getNotesString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getNotesString" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (arg1)->getNotesString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getAnnotation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getAnnotation" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)(arg1)->getAnnotation();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getAnnotationString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getAnnotationString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getAnnotationString" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (arg1)->getAnnotationString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getNamespaces" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNamespaces *)((SBase const *)arg1)->getNamespaces();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getSBMLDocument__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getSBMLDocument",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getSBMLDocument" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBMLDocument *)((SBase const *)arg1)->getSBMLDocument();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getSBMLDocument__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getSBMLDocument",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getSBMLDocument" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBMLDocument *)(arg1)->getSBMLDocument();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getSBMLDocument(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getSBMLDocument__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getSBMLDocument__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_getSBMLDocument'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getSBMLDocument(SBase const *)\n"
    "    getSBMLDocument(SBase *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getParentSBMLObject(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getParentSBMLObject",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getParentSBMLObject" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBase *)(arg1)->getParentSBMLObject();
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getAncestorOfType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  SBMLTypeCode_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_getAncestorOfType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getAncestorOfType" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBase_getAncestorOfType" "', argument " "2"" of type '" "SBMLTypeCode_t""'");
  } 
  arg2 = static_cast< SBMLTypeCode_t >(val2);
  result = (SBase *)(arg1)->getAncestorOfType(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getSBOTerm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getSBOTerm",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getSBOTerm" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)((SBase const *)arg1)->getSBOTerm();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getSBOTermID(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getSBOTermID",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getSBOTermID" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = ((SBase const *)arg1)->getSBOTermID();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getLine(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getLine",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getLine" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)((SBase const *)arg1)->getLine();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getColumn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getColumn",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getColumn" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)((SBase const *)arg1)->getColumn();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getModelHistory__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelHistory *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getModelHistory" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (ModelHistory *)((SBase const *)arg1)->getModelHistory();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getModelHistory__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelHistory *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getModelHistory" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (ModelHistory *)(arg1)->getModelHistory();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getModelHistory(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getModelHistory__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getModelHistory__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_getModelHistory'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getModelHistory(SBase const *)\n"
    "    getModelHistory(SBase *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetMetaId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetMetaId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetMetaId" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetMetaId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetId" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetName" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetNotes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetNotes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetNotes" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetNotes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetAnnotation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetAnnotation" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetAnnotation();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetSBOTerm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetSBOTerm",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetSBOTerm" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->isSetSBOTerm();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setMetaId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setMetaId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setMetaId" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setMetaId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_setMetaId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setMetaId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_isSetModelHistory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_isSetModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_isSetModelHistory" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)(arg1)->isSetModelHistory();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setId" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setName" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setAnnotation" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setAnnotation" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setAnnotation((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setAnnotation" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_setAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setAnnotation((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setAnnotation__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_setAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setAnnotation(SBase *,XMLNode const *)\n"
    "    setAnnotation(SBase *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_appendAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_appendAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_appendAnnotation" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_appendAnnotation" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->appendAnnotation((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_appendAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_appendAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_appendAnnotation" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_appendAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_appendAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->appendAnnotation((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_appendAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_appendAnnotation__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_appendAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_appendAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    appendAnnotation(SBase *,XMLNode const *)\n"
    "    appendAnnotation(SBase *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setNotes__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setNotes",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setNotes" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setNotes" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setNotes((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setNotes__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setNotes",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setNotes" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setNotes" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_setNotes" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setNotes((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setNotes(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setNotes__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setNotes__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_setNotes'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setNotes(SBase *,XMLNode const *)\n"
    "    setNotes(SBase *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_appendNotes__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_appendNotes",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_appendNotes" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_appendNotes" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->appendNotes((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_appendNotes__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_appendNotes",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_appendNotes" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_appendNotes" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_appendNotes" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->appendNotes((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_appendNotes(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_appendNotes__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_appendNotes__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_appendNotes'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    appendNotes(SBase *,XMLNode const *)\n"
    "    appendNotes(SBase *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setModelHistory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  ModelHistory *arg2 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setModelHistory",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setModelHistory" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setModelHistory" "', argument " "2"" of type '" "ModelHistory *""'"); 
  }
  arg2 = reinterpret_cast< ModelHistory * >(argp2);
  result = (int)(arg1)->setModelHistory(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setSBOTerm__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setSBOTerm",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setSBOTerm" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBase_setSBOTerm" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setSBOTerm(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setSBOTerm__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setSBOTerm",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setSBOTerm" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setSBOTerm" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_setSBOTerm" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSBOTerm((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setSBOTerm(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SBase_setSBOTerm__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_setSBOTerm__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_setSBOTerm'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setSBOTerm(SBase *,int)\n"
    "    setSBOTerm(SBase *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_setNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  XMLNamespaces *arg2 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_setNamespaces",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_setNamespaces" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_setNamespaces" "', argument " "2"" of type '" "XMLNamespaces *""'"); 
  }
  arg2 = reinterpret_cast< XMLNamespaces * >(argp2);
  result = (int)(arg1)->setNamespaces(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_unsetMetaId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_unsetMetaId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_unsetMetaId" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetMetaId();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_unsetNotes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_unsetNotes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_unsetNotes" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetNotes();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_unsetAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_unsetAnnotation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_unsetAnnotation" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetAnnotation();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_unsetSBOTerm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_unsetSBOTerm",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_unsetSBOTerm" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetSBOTerm();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_addCVTerm__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  CVTerm *arg2 = (CVTerm *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBase_addCVTerm",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_addCVTerm" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_addCVTerm" "', argument " "2"" of type '" "CVTerm *""'"); 
  }
  arg2 = reinterpret_cast< CVTerm * >(argp2);
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBase_addCVTerm" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  result = (int)(arg1)->addCVTerm(arg2,arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_addCVTerm__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  CVTerm *arg2 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_addCVTerm",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_addCVTerm" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_addCVTerm" "', argument " "2"" of type '" "CVTerm *""'"); 
  }
  arg2 = reinterpret_cast< CVTerm * >(argp2);
  result = (int)(arg1)->addCVTerm(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_addCVTerm(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CVTerm, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBase_addCVTerm__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_CVTerm, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SBase_addCVTerm__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_addCVTerm'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    addCVTerm(SBase *,CVTerm *,bool)\n"
    "    addCVTerm(SBase *,CVTerm *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getCVTerms__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  List *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getCVTerms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getCVTerms" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (List *)(arg1)->getCVTerms();
  {
    ListWrapper<CVTerm> *listw = (result != 0) ? new ListWrapper<CVTerm>(result) : 0;
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_CVTerm_t, 
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getCVTerms__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  List *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getCVTerms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getCVTerms" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (List *)((SBase const *)arg1)->getCVTerms();
  {
    ListWrapper<CVTerm> *listw = (result != 0) ? new ListWrapper<CVTerm>(result) : 0;
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_CVTerm_t, 
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getCVTerms(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getCVTerms__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBase_getCVTerms__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBase_getCVTerms'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getCVTerms(SBase *)\n"
    "    getCVTerms(SBase const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getNumCVTerms(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getNumCVTerms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getNumCVTerms" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)(arg1)->getNumCVTerms();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getCVTerm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_getCVTerm",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getCVTerm" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBase_getCVTerm" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CVTerm *)(arg1)->getCVTerm(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_unsetCVTerms(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_unsetCVTerms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_unsetCVTerms" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetCVTerms();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_unsetModelHistory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_unsetModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_unsetModelHistory" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (int)(arg1)->unsetModelHistory();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getResourceBiologicalQualifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  BiolQualifierType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_getResourceBiologicalQualifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getResourceBiologicalQualifier" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SBase_getResourceBiologicalQualifier" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (BiolQualifierType_t)(arg1)->getResourceBiologicalQualifier(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getResourceModelQualifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModelQualifierType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_getResourceModelQualifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getResourceModelQualifier" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SBase_getResourceModelQualifier" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (ModelQualifierType_t)(arg1)->getResourceModelQualifier(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getModel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getModel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getModel" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (Model *)((SBase const *)arg1)->getModel();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getLevel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getLevel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getLevel" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)((SBase const *)arg1)->getLevel();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getVersion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getVersion",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getVersion" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (unsigned int)((SBase const *)arg1)->getVersion();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getTypeCode" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (SBMLTypeCode_t)((SBase const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_hasValidLevelVersionNamespaceCombination(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_hasValidLevelVersionNamespaceCombination",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_hasValidLevelVersionNamespaceCombination" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)(arg1)->hasValidLevelVersionNamespaceCombination();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_getElementName" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (std::string *) &((SBase const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_toSBML(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_toSBML",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_toSBML" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (char *)(arg1)->toSBML();
  resultobj = SWIG_FromCharPtr((const char *)result);
  free(result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_hasRequiredAttributes" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBase_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_hasRequiredElements" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (bool)((SBase const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBase_checkMathMLNamespace(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  XMLToken arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBase_checkMathMLNamespace",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBase_checkMathMLNamespace" "', argument " "1"" of type '" "SBase *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  {
    res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLToken,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBase_checkMathMLNamespace" "', argument " "2"" of type '" "XMLToken const""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBase_checkMathMLNamespace" "', argument " "2"" of type '" "XMLToken const""'");
    } else {
      XMLToken * temp = reinterpret_cast< XMLToken * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = (arg1)->checkMathMLNamespace(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBase_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBase, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ListOf__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOf")) SWIG_fail;
  result = (ListOf *)new ListOf();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOf, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOf",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOf" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOf__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOf *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ListOf",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_ListOf,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ListOf" "', argument " "1"" of type '" "ListOf const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ListOf" "', argument " "1"" of type '" "ListOf const &""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (ListOf *)new ListOf((ListOf const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOf, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOf(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_ListOf__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ListOf__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_ListOf'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ListOf()\n"
    "    ListOf(ListOf const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_clone" "', argument " "1"" of type '" "ListOf const *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (SBase *)((ListOf const *)arg1)->clone();
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_append(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  SBase *arg2 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOf_append",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_append" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOf_append" "', argument " "2"" of type '" "SBase const *""'"); 
  }
  arg2 = reinterpret_cast< SBase * >(argp2);
  result = (int)(arg1)->append((SBase const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_appendAndOwn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  SBase *arg2 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOf_appendAndOwn",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_appendAndOwn" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOf_appendAndOwn" "', argument " "2"" of type '" "SBase *""'"); 
  }
  arg2 = reinterpret_cast< SBase * >(argp2);
  result = (int)(arg1)->appendAndOwn(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOf_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_get" "', argument " "1"" of type '" "ListOf const *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOf_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBase *)((ListOf const *)arg1)->get(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOf_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_get" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOf_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBase *)(arg1)->get(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOf_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOf_get__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOf_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOf const *,unsigned int)\n"
    "    get(ListOf *,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_clear__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOf_clear",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_clear" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOf_clear" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->clear(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_clear__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf_clear",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_clear" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  (arg1)->clear();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_clear(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ListOf_clear__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOf, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOf_clear__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOf_clear'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    clear(ListOf *,bool)\n"
    "    clear(ListOf *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOf_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_remove" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOf_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBase *)(arg1)->remove(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf_size",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_size" "', argument " "1"" of type '" "ListOf const *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (unsigned int)((ListOf const *)arg1)->size();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_getTypeCode" "', argument " "1"" of type '" "ListOf const *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (SBMLTypeCode_t)((ListOf const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_getItemTypeCode" "', argument " "1"" of type '" "ListOf const *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (SBMLTypeCode_t)((ListOf const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf_getElementName" "', argument " "1"" of type '" "ListOf const *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (std::string *) &((ListOf const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOf___len__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOf *arg1 = (ListOf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOf___len__",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOf, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOf___len__" "', argument " "1"" of type '" "ListOf *""'"); 
  }
  arg1 = reinterpret_cast< ListOf * >(argp1);
  result = (int)ListOf___len__(arg1);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOf_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOf, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Model__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Model",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Model" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Model" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Model *)new Model(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Model__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Model",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Model" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Model *)new Model(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Model(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Model",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Model" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Model__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Model",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Model,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Model" "', argument " "1"" of type '" "Model const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Model" "', argument " "1"" of type '" "Model const &""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    try {
      result = (Model *)new Model((Model const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Model(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Model__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Model__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Model__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Model'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Model(unsigned int,unsigned int)\n"
    "    Model(SBMLNamespaces *)\n"
    "    Model(Model const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_clone" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Model *)((Model const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getId" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getName" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSubstanceUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getSubstanceUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getTimeUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getTimeUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getVolumeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getVolumeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getVolumeUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getVolumeUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getAreaUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getAreaUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getAreaUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getAreaUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getLengthUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getLengthUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getLengthUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getLengthUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getExtentUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getExtentUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getExtentUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getExtentUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getConversionFactor",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getConversionFactor" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getConversionFactor();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetId" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetName" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetSubstanceUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetSubstanceUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetTimeUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetTimeUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetVolumeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetVolumeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetVolumeUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetVolumeUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetAreaUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetAreaUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetAreaUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetAreaUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetLengthUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetLengthUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetLengthUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetLengthUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetExtentUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetExtentUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetExtentUnits" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetExtentUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isSetConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isSetConversionFactor",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isSetConversionFactor" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->isSetConversionFactor();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setId" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setName" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setSubstanceUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setSubstanceUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setSubstanceUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setSubstanceUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSubstanceUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setTimeUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setTimeUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setTimeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setTimeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setTimeUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setVolumeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setVolumeUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setVolumeUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setVolumeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setVolumeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setVolumeUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setAreaUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setAreaUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setAreaUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setAreaUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setAreaUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setAreaUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setLengthUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setLengthUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setLengthUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setLengthUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setLengthUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setLengthUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setExtentUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setExtentUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setExtentUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setExtentUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setExtentUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setExtentUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setConversionFactor",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setConversionFactor" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setConversionFactor" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setConversionFactor" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setConversionFactor((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetId" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetId();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetName" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetSubstanceUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetSubstanceUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetTimeUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetTimeUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetVolumeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetVolumeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetVolumeUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetVolumeUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetAreaUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetAreaUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetAreaUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetAreaUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetLengthUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetLengthUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetLengthUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetLengthUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetExtentUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetExtentUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetExtentUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetExtentUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_unsetConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_unsetConversionFactor",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_unsetConversionFactor" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (int)(arg1)->unsetConversionFactor();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addFunctionDefinition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  FunctionDefinition *arg2 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addFunctionDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addFunctionDefinition" "', argument " "2"" of type '" "FunctionDefinition const *""'"); 
  }
  arg2 = reinterpret_cast< FunctionDefinition * >(argp2);
  result = (int)(arg1)->addFunctionDefinition((FunctionDefinition const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addUnitDefinition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  UnitDefinition *arg2 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addUnitDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addUnitDefinition" "', argument " "2"" of type '" "UnitDefinition const *""'"); 
  }
  arg2 = reinterpret_cast< UnitDefinition * >(argp2);
  result = (int)(arg1)->addUnitDefinition((UnitDefinition const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addCompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  CompartmentType *arg2 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addCompartmentType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addCompartmentType" "', argument " "2"" of type '" "CompartmentType const *""'"); 
  }
  arg2 = reinterpret_cast< CompartmentType * >(argp2);
  result = (int)(arg1)->addCompartmentType((CompartmentType const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addSpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  SpeciesType *arg2 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addSpeciesType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addSpeciesType" "', argument " "2"" of type '" "SpeciesType const *""'"); 
  }
  arg2 = reinterpret_cast< SpeciesType * >(argp2);
  result = (int)(arg1)->addSpeciesType((SpeciesType const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Compartment *arg2 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addCompartment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addCompartment" "', argument " "2"" of type '" "Compartment const *""'"); 
  }
  arg2 = reinterpret_cast< Compartment * >(argp2);
  result = (int)(arg1)->addCompartment((Compartment const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Species *arg2 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addSpecies" "', argument " "2"" of type '" "Species const *""'"); 
  }
  arg2 = reinterpret_cast< Species * >(argp2);
  result = (int)(arg1)->addSpecies((Species const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Parameter *arg2 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addParameter" "', argument " "2"" of type '" "Parameter const *""'"); 
  }
  arg2 = reinterpret_cast< Parameter * >(argp2);
  result = (int)(arg1)->addParameter((Parameter const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addInitialAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  InitialAssignment *arg2 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addInitialAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addInitialAssignment" "', argument " "2"" of type '" "InitialAssignment const *""'"); 
  }
  arg2 = reinterpret_cast< InitialAssignment * >(argp2);
  result = (int)(arg1)->addInitialAssignment((InitialAssignment const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Rule *arg2 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addRule" "', argument " "2"" of type '" "Rule const *""'"); 
  }
  arg2 = reinterpret_cast< Rule * >(argp2);
  result = (int)(arg1)->addRule((Rule const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addConstraint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Constraint *arg2 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addConstraint",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addConstraint" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addConstraint" "', argument " "2"" of type '" "Constraint const *""'"); 
  }
  arg2 = reinterpret_cast< Constraint * >(argp2);
  result = (int)(arg1)->addConstraint((Constraint const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addReaction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Reaction *arg2 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addReaction" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addReaction" "', argument " "2"" of type '" "Reaction const *""'"); 
  }
  arg2 = reinterpret_cast< Reaction * >(argp2);
  result = (int)(arg1)->addReaction((Reaction const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addEvent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  Event *arg2 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_addEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addEvent" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_addEvent" "', argument " "2"" of type '" "Event const *""'"); 
  }
  arg2 = reinterpret_cast< Event * >(argp2);
  result = (int)(arg1)->addEvent((Event const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createFunctionDefinition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createFunctionDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createFunctionDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (FunctionDefinition *)(arg1)->createFunctionDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createUnitDefinition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createUnitDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (UnitDefinition *)(arg1)->createUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createUnit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createUnit",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createUnit" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Unit *)(arg1)->createUnit();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createCompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createCompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createCompartmentType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (CompartmentType *)(arg1)->createCompartmentType();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createSpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createSpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createSpeciesType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (SpeciesType *)(arg1)->createSpeciesType();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createCompartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createCompartment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Compartment *)(arg1)->createCompartment();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Species *)(arg1)->createSpecies();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Parameter *)(arg1)->createParameter();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createInitialAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createInitialAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createInitialAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (InitialAssignment *)(arg1)->createInitialAssignment();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createAlgebraicRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  AlgebraicRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createAlgebraicRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createAlgebraicRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (AlgebraicRule *)(arg1)->createAlgebraicRule();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AlgebraicRule, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createAssignmentRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  AssignmentRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createAssignmentRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createAssignmentRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (AssignmentRule *)(arg1)->createAssignmentRule();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AssignmentRule, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createRateRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  RateRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createRateRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createRateRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (RateRule *)(arg1)->createRateRule();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RateRule, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createConstraint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createConstraint",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createConstraint" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Constraint *)(arg1)->createConstraint();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createReaction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createReaction",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createReaction" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Reaction *)(arg1)->createReaction();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createReactant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createReactant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createReactant" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (SpeciesReference *)(arg1)->createReactant();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createProduct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createProduct",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createProduct" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (SpeciesReference *)(arg1)->createProduct();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createModifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createModifier",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createModifier" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ModifierSpeciesReference *)(arg1)->createModifier();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createKineticLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createKineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createKineticLaw" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (KineticLaw *)(arg1)->createKineticLaw();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createKineticLawParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createKineticLawParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createKineticLawParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Parameter *)(arg1)->createKineticLawParameter();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createKineticLawLocalParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createKineticLawLocalParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createKineticLawLocalParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (LocalParameter *)(arg1)->createKineticLawLocalParameter();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createEvent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createEvent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createEvent" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Event *)(arg1)->createEvent();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createEventAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createEventAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createEventAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (EventAssignment *)(arg1)->createEventAssignment();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createTrigger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createTrigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createTrigger" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Trigger *)(arg1)->createTrigger();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_createDelay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_createDelay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_createDelay" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (Delay *)(arg1)->createDelay();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setAnnotation" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setAnnotation" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setAnnotation((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setAnnotation" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_setAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_setAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setAnnotation((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_setAnnotation__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_setAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_setAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setAnnotation(Model *,XMLNode const *)\n"
    "    setAnnotation(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_appendAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_appendAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_appendAnnotation" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_appendAnnotation" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->appendAnnotation((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_appendAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_appendAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_appendAnnotation" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_appendAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_appendAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->appendAnnotation((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_appendAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_appendAnnotation__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_appendAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_appendAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    appendAnnotation(Model *,XMLNode const *)\n"
    "    appendAnnotation(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfFunctionDefinitions__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfFunctionDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfFunctionDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfFunctionDefinitions" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfFunctionDefinitions *)((Model const *)arg1)->getListOfFunctionDefinitions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfFunctionDefinitions__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfFunctionDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfFunctionDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfFunctionDefinitions" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfFunctionDefinitions *)(arg1)->getListOfFunctionDefinitions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfFunctionDefinitions(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfFunctionDefinitions__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfFunctionDefinitions__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfFunctionDefinitions'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfFunctionDefinitions(Model const *)\n"
    "    getListOfFunctionDefinitions(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfUnitDefinitions__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfUnitDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfUnitDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfUnitDefinitions" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfUnitDefinitions *)((Model const *)arg1)->getListOfUnitDefinitions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfUnitDefinitions__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfUnitDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfUnitDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfUnitDefinitions" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfUnitDefinitions *)(arg1)->getListOfUnitDefinitions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfUnitDefinitions(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfUnitDefinitions__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfUnitDefinitions__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfUnitDefinitions'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfUnitDefinitions(Model const *)\n"
    "    getListOfUnitDefinitions(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfCompartmentTypes__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfCompartmentTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfCompartmentTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfCompartmentTypes" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfCompartmentTypes *)((Model const *)arg1)->getListOfCompartmentTypes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfCompartmentTypes__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfCompartmentTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfCompartmentTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfCompartmentTypes" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfCompartmentTypes *)(arg1)->getListOfCompartmentTypes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfCompartmentTypes(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfCompartmentTypes__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfCompartmentTypes__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfCompartmentTypes'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfCompartmentTypes(Model const *)\n"
    "    getListOfCompartmentTypes(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfSpeciesTypes__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfSpeciesTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfSpeciesTypes" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfSpeciesTypes *)((Model const *)arg1)->getListOfSpeciesTypes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfSpeciesTypes__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfSpeciesTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfSpeciesTypes" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfSpeciesTypes *)(arg1)->getListOfSpeciesTypes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfSpeciesTypes(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfSpeciesTypes__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfSpeciesTypes__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfSpeciesTypes'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfSpeciesTypes(Model const *)\n"
    "    getListOfSpeciesTypes(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfCompartments__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfCompartments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfCompartments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfCompartments" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfCompartments *)((Model const *)arg1)->getListOfCompartments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfCompartments__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfCompartments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfCompartments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfCompartments" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfCompartments *)(arg1)->getListOfCompartments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfCompartments(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfCompartments__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfCompartments__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfCompartments'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfCompartments(Model const *)\n"
    "    getListOfCompartments(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfSpecies__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpecies *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfSpecies" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfSpecies *)((Model const *)arg1)->getListOfSpecies();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfSpecies__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpecies *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfSpecies *)(arg1)->getListOfSpecies();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfSpecies(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfSpecies__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfSpecies__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfSpecies'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfSpecies(Model const *)\n"
    "    getListOfSpecies(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfParameters__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfParameters" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfParameters *)((Model const *)arg1)->getListOfParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfParameters__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfParameters" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfParameters *)(arg1)->getListOfParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfParameters(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfParameters__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfParameters__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfParameters'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfParameters(Model const *)\n"
    "    getListOfParameters(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfInitialAssignments__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfInitialAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfInitialAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfInitialAssignments" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfInitialAssignments *)((Model const *)arg1)->getListOfInitialAssignments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfInitialAssignments__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfInitialAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfInitialAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfInitialAssignments" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfInitialAssignments *)(arg1)->getListOfInitialAssignments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfInitialAssignments(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfInitialAssignments__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfInitialAssignments__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfInitialAssignments'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfInitialAssignments(Model const *)\n"
    "    getListOfInitialAssignments(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfRules__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfRules *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfRules",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfRules" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfRules *)((Model const *)arg1)->getListOfRules();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfRules, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfRules__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfRules *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfRules",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfRules" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfRules *)(arg1)->getListOfRules();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfRules, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfRules(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfRules__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfRules__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfRules'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfRules(Model const *)\n"
    "    getListOfRules(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfConstraints__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfConstraints *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfConstraints",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfConstraints" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfConstraints *)((Model const *)arg1)->getListOfConstraints();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfConstraints__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfConstraints *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfConstraints",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfConstraints" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfConstraints *)(arg1)->getListOfConstraints();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfConstraints(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfConstraints__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfConstraints__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfConstraints'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfConstraints(Model const *)\n"
    "    getListOfConstraints(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfReactions__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfReactions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfReactions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfReactions" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfReactions *)((Model const *)arg1)->getListOfReactions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfReactions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfReactions__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfReactions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfReactions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfReactions" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfReactions *)(arg1)->getListOfReactions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfReactions, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfReactions(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfReactions__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfReactions__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfReactions'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfReactions(Model const *)\n"
    "    getListOfReactions(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfEvents__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfEvents *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfEvents",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfEvents" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfEvents *)((Model const *)arg1)->getListOfEvents();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEvents, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfEvents__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfEvents *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getListOfEvents",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getListOfEvents" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (ListOfEvents *)(arg1)->getListOfEvents();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEvents, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getListOfEvents(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfEvents__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_getListOfEvents__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getListOfEvents'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfEvents(Model const *)\n"
    "    getListOfEvents(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getFunctionDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getFunctionDefinition" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getFunctionDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)((Model const *)arg1)->getFunctionDefinition(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getFunctionDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getFunctionDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getFunctionDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)(arg1)->getFunctionDefinition(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getFunctionDefinition__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getFunctionDefinition" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getFunctionDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getFunctionDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)((Model const *)arg1)->getFunctionDefinition((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getFunctionDefinition__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getFunctionDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getFunctionDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getFunctionDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)(arg1)->getFunctionDefinition((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getFunctionDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getFunctionDefinition__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getFunctionDefinition__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getFunctionDefinition__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getFunctionDefinition__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getFunctionDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getFunctionDefinition(Model const *,unsigned int)\n"
    "    getFunctionDefinition(Model *,unsigned int)\n"
    "    getFunctionDefinition(Model const *,std::string const &)\n"
    "    getFunctionDefinition(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getUnitDefinition" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getUnitDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)((Model const *)arg1)->getUnitDefinition(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getUnitDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getUnitDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)(arg1)->getUnitDefinition(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getUnitDefinition__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getUnitDefinition" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getUnitDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getUnitDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)((Model const *)arg1)->getUnitDefinition((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getUnitDefinition__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getUnitDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getUnitDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getUnitDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)(arg1)->getUnitDefinition((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getUnitDefinition__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getUnitDefinition__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getUnitDefinition__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getUnitDefinition__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getUnitDefinition(Model const *,unsigned int)\n"
    "    getUnitDefinition(Model *,unsigned int)\n"
    "    getUnitDefinition(Model const *,std::string const &)\n"
    "    getUnitDefinition(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartmentType__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartmentType" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getCompartmentType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)((Model const *)arg1)->getCompartmentType(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartmentType__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartmentType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getCompartmentType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)(arg1)->getCompartmentType(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartmentType__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartmentType" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)((Model const *)arg1)->getCompartmentType((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartmentType__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartmentType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)(arg1)->getCompartmentType((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartmentType(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getCompartmentType__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getCompartmentType__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getCompartmentType__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getCompartmentType__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getCompartmentType'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getCompartmentType(Model const *,unsigned int)\n"
    "    getCompartmentType(Model *,unsigned int)\n"
    "    getCompartmentType(Model const *,std::string const &)\n"
    "    getCompartmentType(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesType__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpeciesType" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getSpeciesType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)((Model const *)arg1)->getSpeciesType(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesType__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpeciesType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getSpeciesType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)(arg1)->getSpeciesType(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesType__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpeciesType" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)((Model const *)arg1)->getSpeciesType((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesType__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpeciesType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)(arg1)->getSpeciesType((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesType(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getSpeciesType__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getSpeciesType__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpeciesType__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpeciesType__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getSpeciesType'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getSpeciesType(Model const *,unsigned int)\n"
    "    getSpeciesType(Model *,unsigned int)\n"
    "    getSpeciesType(Model const *,std::string const &)\n"
    "    getSpeciesType(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartment" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getCompartment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)((Model const *)arg1)->getCompartment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getCompartment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)(arg1)->getCompartment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartment__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartment" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)((Model const *)arg1)->getCompartment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartment__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getCompartment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)(arg1)->getCompartment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getCompartment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getCompartment__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getCompartment__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getCompartment__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getCompartment__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getCompartment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getCompartment(Model const *,unsigned int)\n"
    "    getCompartment(Model *,unsigned int)\n"
    "    getCompartment(Model const *,std::string const &)\n"
    "    getCompartment(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpecies__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpecies" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getSpecies" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)((Model const *)arg1)->getSpecies(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpecies__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getSpecies" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)(arg1)->getSpecies(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpecies__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpecies" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Species *)((Model const *)arg1)->getSpecies((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpecies__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Species *)(arg1)->getSpecies((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpecies(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getSpecies__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getSpecies__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpecies__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpecies__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getSpecies'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getSpecies(Model const *,unsigned int)\n"
    "    getSpecies(Model *,unsigned int)\n"
    "    getSpecies(Model const *,std::string const &)\n"
    "    getSpecies(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getParameter" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)((Model const *)arg1)->getParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->getParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getParameter__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getParameter" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)((Model const *)arg1)->getParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getParameter__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->getParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getParameter__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getParameter__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getParameter__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getParameter__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getParameter(Model const *,unsigned int)\n"
    "    getParameter(Model *,unsigned int)\n"
    "    getParameter(Model const *,std::string const &)\n"
    "    getParameter(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getInitialAssignment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getInitialAssignment" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getInitialAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)((Model const *)arg1)->getInitialAssignment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getInitialAssignment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getInitialAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getInitialAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)(arg1)->getInitialAssignment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getInitialAssignment__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getInitialAssignment" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getInitialAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getInitialAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)((Model const *)arg1)->getInitialAssignment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getInitialAssignment__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getInitialAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getInitialAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getInitialAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)(arg1)->getInitialAssignment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getInitialAssignment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getInitialAssignment__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getInitialAssignment__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getInitialAssignment__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getInitialAssignment__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getInitialAssignment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getInitialAssignment(Model const *,unsigned int)\n"
    "    getInitialAssignment(Model *,unsigned int)\n"
    "    getInitialAssignment(Model const *,std::string const &)\n"
    "    getInitialAssignment(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getRule__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getRule" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getRule" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)((Model const *)arg1)->getRule(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getRule__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getRule" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)(arg1)->getRule(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getRule__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getRule" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getRule" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getRule" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Rule *)((Model const *)arg1)->getRule((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getRule__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getRule" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getRule" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Rule *)(arg1)->getRule((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getRule(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getRule__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getRule__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getRule__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getRule__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getRule'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getRule(Model const *,unsigned int)\n"
    "    getRule(Model *,unsigned int)\n"
    "    getRule(Model const *,std::string const &)\n"
    "    getRule(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getConstraint__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getConstraint",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getConstraint" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getConstraint" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)((Model const *)arg1)->getConstraint(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getConstraint__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getConstraint",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getConstraint" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getConstraint" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)(arg1)->getConstraint(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getConstraint(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getConstraint__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getConstraint__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getConstraint'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getConstraint(Model const *,unsigned int)\n"
    "    getConstraint(Model *,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getReaction__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getReaction" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getReaction" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)((Model const *)arg1)->getReaction(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getReaction__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getReaction" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getReaction" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)(arg1)->getReaction(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getReaction__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getReaction" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getReaction" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getReaction" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)((Model const *)arg1)->getReaction((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getReaction__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getReaction" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getReaction" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getReaction" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)(arg1)->getReaction((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getReaction(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getReaction__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getReaction__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getReaction__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getReaction__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getReaction'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getReaction(Model const *,unsigned int)\n"
    "    getReaction(Model *,unsigned int)\n"
    "    getReaction(Model const *,std::string const &)\n"
    "    getReaction(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesReference__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpeciesReference",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpeciesReference" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getSpeciesReference" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getSpeciesReference" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->getSpeciesReference((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesReference__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getSpeciesReference",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getSpeciesReference" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getSpeciesReference" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getSpeciesReference" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)((Model const *)arg1)->getSpeciesReference((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getSpeciesReference(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpeciesReference__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getSpeciesReference__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getSpeciesReference'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getSpeciesReference(Model *,std::string const &)\n"
    "    getSpeciesReference(Model const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getEvent__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getEvent" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getEvent" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)((Model const *)arg1)->getEvent(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getEvent__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getEvent" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_getEvent" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)(arg1)->getEvent(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getEvent__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getEvent" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getEvent" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getEvent" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Event *)((Model const *)arg1)->getEvent((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getEvent__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_getEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getEvent" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_getEvent" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_getEvent" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Event *)(arg1)->getEvent((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getEvent(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getEvent__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_getEvent__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getEvent__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_getEvent__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_getEvent'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getEvent(Model const *,unsigned int)\n"
    "    getEvent(Model *,unsigned int)\n"
    "    getEvent(Model const *,std::string const &)\n"
    "    getEvent(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumFunctionDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumFunctionDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumFunctionDefinitions" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumFunctionDefinitions();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumUnitDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumUnitDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumUnitDefinitions" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumUnitDefinitions();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumCompartmentTypes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumCompartmentTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumCompartmentTypes" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumCompartmentTypes();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumSpeciesTypes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumSpeciesTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumSpeciesTypes" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumSpeciesTypes();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumCompartments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumCompartments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumCompartments" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumCompartments();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumSpecies" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumSpecies();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumSpeciesWithBoundaryCondition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumSpeciesWithBoundaryCondition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumSpeciesWithBoundaryCondition" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumSpeciesWithBoundaryCondition();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumParameters" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumParameters();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumInitialAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumInitialAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumInitialAssignments" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumInitialAssignments();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumRules(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumRules",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumRules" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumRules();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumConstraints(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumConstraints",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumConstraints" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumConstraints();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumReactions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumReactions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumReactions" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumReactions();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getNumEvents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getNumEvents",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getNumEvents" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (unsigned int)((Model const *)arg1)->getNumEvents();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL1ToL2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_convertL1ToL2",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertL1ToL2" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL1ToL2();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL1ToL3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_convertL1ToL3",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertL1ToL3" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL1ToL3();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL2ToL3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_convertL2ToL3",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertL2ToL3" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL2ToL3();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL2ToL1__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_convertL2ToL1",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertL2ToL1" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_convertL2ToL1" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->convertL2ToL1(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL2ToL1__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_convertL2ToL1",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertL2ToL1" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL2ToL1();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL2ToL1(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_convertL2ToL1__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_convertL2ToL1__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_convertL2ToL1'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    convertL2ToL1(Model *,bool)\n"
    "    convertL2ToL1(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL3ToL1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_convertL3ToL1",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertL3ToL1" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL3ToL1();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertL3ToL2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_convertL3ToL2",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertL3ToL2" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertL3ToL2();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addModifiers(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_addModifiers",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addModifiers" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->addModifiers();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addConstantAttribute(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_addConstantAttribute",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addConstantAttribute" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->addConstantAttribute();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setSpatialDimensions__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_setSpatialDimensions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setSpatialDimensions" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_setSpatialDimensions" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  (arg1)->setSpatialDimensions(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setSpatialDimensions__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_setSpatialDimensions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setSpatialDimensions" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->setSpatialDimensions();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setSpatialDimensions(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Model_setSpatialDimensions__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_setSpatialDimensions__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_setSpatialDimensions'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setSpatialDimensions(Model *,double)\n"
    "    setSpatialDimensions(Model *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_addDefinitionsForDefaultUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_addDefinitionsForDefaultUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_addDefinitionsForDefaultUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->addDefinitionsForDefaultUnits();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertParametersToLocals(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Model_convertParametersToLocals",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertParametersToLocals" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_convertParametersToLocals" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Model_convertParametersToLocals" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  (arg1)->convertParametersToLocals(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_setSpeciesReferenceConstantValueAndStoichiometry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_setSpeciesReferenceConstantValueAndStoichiometry",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_setSpeciesReferenceConstantValueAndStoichiometry" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->setSpeciesReferenceConstantValueAndStoichiometry();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeParameterRuleUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_removeParameterRuleUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeParameterRuleUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->removeParameterRuleUnits();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_convertStoichiometryMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_convertStoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_convertStoichiometryMath" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->convertStoichiometryMath();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_assignRequiredValues(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_assignRequiredValues",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_assignRequiredValues" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->assignRequiredValues();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_dealWithModelUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_dealWithModelUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_dealWithModelUnits" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->dealWithModelUnits();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_dealWithStoichiometry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_dealWithStoichiometry",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_dealWithStoichiometry" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->dealWithStoichiometry();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getTypeCode" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (SBMLTypeCode_t)((Model const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_getElementName" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (std::string *) &((Model const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_populateListFormulaUnitsData(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_populateListFormulaUnitsData",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_populateListFormulaUnitsData" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  (arg1)->populateListFormulaUnitsData();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_isPopulatedListFormulaUnitsData(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_isPopulatedListFormulaUnitsData",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_isPopulatedListFormulaUnitsData" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)(arg1)->isPopulatedListFormulaUnitsData();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Model_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_hasRequiredElements" "', argument " "1"" of type '" "Model const *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  result = (bool)((Model const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeFunctionDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeFunctionDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeFunctionDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)(arg1)->removeFunctionDefinition(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeFunctionDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeFunctionDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeFunctionDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeFunctionDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeFunctionDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)(arg1)->removeFunctionDefinition((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeFunctionDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeFunctionDefinition__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeFunctionDefinition__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeFunctionDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeFunctionDefinition(Model *,unsigned int)\n"
    "    removeFunctionDefinition(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeUnitDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeUnitDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)(arg1)->removeUnitDefinition(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeUnitDefinition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeUnitDefinition" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeUnitDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeUnitDefinition" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)(arg1)->removeUnitDefinition((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeUnitDefinition__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeUnitDefinition__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeUnitDefinition(Model *,unsigned int)\n"
    "    removeUnitDefinition(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeCompartmentType__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeCompartmentType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeCompartmentType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)(arg1)->removeCompartmentType(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeCompartmentType__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeCompartmentType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)(arg1)->removeCompartmentType((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeCompartmentType(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeCompartmentType__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeCompartmentType__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeCompartmentType'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeCompartmentType(Model *,unsigned int)\n"
    "    removeCompartmentType(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeSpeciesType__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeSpeciesType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeSpeciesType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)(arg1)->removeSpeciesType(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeSpeciesType__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeSpeciesType" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)(arg1)->removeSpeciesType((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeSpeciesType(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeSpeciesType__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeSpeciesType__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeSpeciesType'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeSpeciesType(Model *,unsigned int)\n"
    "    removeSpeciesType(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeCompartment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeCompartment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeCompartment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)(arg1)->removeCompartment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeCompartment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeCompartment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)(arg1)->removeCompartment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeCompartment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeCompartment__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeCompartment__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeCompartment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeCompartment(Model *,unsigned int)\n"
    "    removeCompartment(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeSpecies__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeSpecies" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)(arg1)->removeSpecies(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeSpecies__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeSpecies" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Species *)(arg1)->removeSpecies((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeSpecies(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeSpecies__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeSpecies__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeSpecies'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeSpecies(Model *,unsigned int)\n"
    "    removeSpecies(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->removeParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeParameter" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->removeParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeParameter__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeParameter__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeParameter(Model *,unsigned int)\n"
    "    removeParameter(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeInitialAssignment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeInitialAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeInitialAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)(arg1)->removeInitialAssignment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeInitialAssignment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeInitialAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeInitialAssignment" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeInitialAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeInitialAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)(arg1)->removeInitialAssignment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeInitialAssignment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeInitialAssignment__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeInitialAssignment__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeInitialAssignment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeInitialAssignment(Model *,unsigned int)\n"
    "    removeInitialAssignment(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeRule__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeRule" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)(arg1)->removeRule(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeRule__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeRule",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeRule" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeRule" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeRule" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Rule *)(arg1)->removeRule((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeRule(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeRule__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeRule__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeRule'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeRule(Model *,unsigned int)\n"
    "    removeRule(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeConstraint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeConstraint",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeConstraint" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeConstraint" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)(arg1)->removeConstraint(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeReaction__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeReaction" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeReaction" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)(arg1)->removeReaction(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeReaction__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeReaction",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeReaction" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeReaction" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeReaction" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)(arg1)->removeReaction((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeReaction(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeReaction__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeReaction__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeReaction'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeReaction(Model *,unsigned int)\n"
    "    removeReaction(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeEvent__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeEvent" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Model_removeEvent" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)(arg1)->removeEvent(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeEvent__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Model *arg1 = (Model *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Model_removeEvent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Model_removeEvent" "', argument " "1"" of type '" "Model *""'"); 
  }
  arg1 = reinterpret_cast< Model * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Model_removeEvent" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Model_removeEvent" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Event *)(arg1)->removeEvent((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Model_removeEvent(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Model_removeEvent__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Model, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Model_removeEvent__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Model_removeEvent'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeEvent(Model *,unsigned int)\n"
    "    removeEvent(Model *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *Model_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Model, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SBMLDocument_getDefaultLevel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)":SBMLDocument_getDefaultLevel")) SWIG_fail;
  result = (unsigned int)SBMLDocument::getDefaultLevel();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getDefaultVersion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)":SBMLDocument_getDefaultVersion")) SWIG_fail;
  result = (unsigned int)SBMLDocument::getDefaultVersion();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLDocument__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SBMLDocument",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLDocument" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLDocument" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (SBMLDocument *)new SBMLDocument(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLDocument__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SBMLDocument",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLDocument" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  {
    try {
      result = (SBMLDocument *)new SBMLDocument(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLDocument__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBMLDocument")) SWIG_fail;
  {
    try {
      result = (SBMLDocument *)new SBMLDocument();
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLDocument__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SBMLDocument",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SBMLDocument" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (SBMLDocument *)new SBMLDocument(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLDocument(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLDocument",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLDocument" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLDocument__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SBMLDocument",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_SBMLDocument,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SBMLDocument" "', argument " "1"" of type '" "SBMLDocument const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLDocument" "', argument " "1"" of type '" "SBMLDocument const &""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  {
    try {
      result = (SBMLDocument *)new SBMLDocument((SBMLDocument const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLDocument(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_SBMLDocument__SWIG_2(self, args);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBMLDocument__SWIG_3(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBMLDocument__SWIG_4(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_SBMLDocument__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SBMLDocument__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_SBMLDocument'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    SBMLDocument(unsigned int,unsigned int)\n"
    "    SBMLDocument(unsigned int)\n"
    "    SBMLDocument()\n"
    "    SBMLDocument(SBMLNamespaces *)\n"
    "    SBMLDocument(SBMLDocument const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLDocument *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_clone" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (SBMLDocument *)((SBMLDocument const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLDocument, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getModel__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getModel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getModel" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (Model *)((SBMLDocument const *)arg1)->getModel();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getModel__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getModel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getModel" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (Model *)(arg1)->getModel();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getModel(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLDocument_getModel__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLDocument_getModel__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLDocument_getModel'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getModel(SBMLDocument const *)\n"
    "    getModel(SBMLDocument *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_expandFunctionDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_expandFunctionDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_expandFunctionDefinitions" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (bool)(arg1)->expandFunctionDefinitions();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_expandInitialAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_expandInitialAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_expandInitialAssignments" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (bool)(arg1)->expandInitialAssignments();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_setLevelAndVersion__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:SBMLDocument_setLevelAndVersion",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_bool(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  result = (bool)(arg1)->setLevelAndVersion(arg2,arg3,arg4);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_setLevelAndVersion__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBMLDocument_setLevelAndVersion",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBMLDocument_setLevelAndVersion" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (bool)(arg1)->setLevelAndVersion(arg2,arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_setLevelAndVersion(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[5];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 4); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_SBMLDocument_setLevelAndVersion__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_bool(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_SBMLDocument_setLevelAndVersion__SWIG_0(self, args);
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLDocument_setLevelAndVersion'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setLevelAndVersion(SBMLDocument *,unsigned int,unsigned int,bool)\n"
    "    setLevelAndVersion(SBMLDocument *,unsigned int,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_setModel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  Model *arg2 = (Model *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLDocument_setModel",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_setModel" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Model, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLDocument_setModel" "', argument " "2"" of type '" "Model const *""'"); 
  }
  arg2 = reinterpret_cast< Model * >(argp2);
  result = (int)(arg1)->setModel((Model const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_createModel__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLDocument_createModel",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_createModel" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLDocument_createModel" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLDocument_createModel" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Model *)(arg1)->createModel((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_createModel__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Model *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_createModel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_createModel" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (Model *)(arg1)->createModel();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Model, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_createModel(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLDocument_createModel__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBMLDocument_createModel__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLDocument_createModel'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    createModel(SBMLDocument *,std::string const &)\n"
    "    createModel(SBMLDocument *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_setConsistencyChecks(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  SBMLErrorCategory_t arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBMLDocument_setConsistencyChecks",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_setConsistencyChecks" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLDocument_setConsistencyChecks" "', argument " "2"" of type '" "SBMLErrorCategory_t""'");
  } 
  arg2 = static_cast< SBMLErrorCategory_t >(val2);
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBMLDocument_setConsistencyChecks" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->setConsistencyChecks(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_setConsistencyChecksForConversion(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  SBMLErrorCategory_t arg2 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:SBMLDocument_setConsistencyChecksForConversion",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_setConsistencyChecksForConversion" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLDocument_setConsistencyChecksForConversion" "', argument " "2"" of type '" "SBMLErrorCategory_t""'");
  } 
  arg2 = static_cast< SBMLErrorCategory_t >(val2);
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "SBMLDocument_setConsistencyChecksForConversion" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->setConsistencyChecksForConversion(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkConsistency(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkConsistency",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkConsistency" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkConsistency();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkInternalConsistency(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkInternalConsistency",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkInternalConsistency" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkInternalConsistency();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkL1Compatibility(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkL1Compatibility",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkL1Compatibility" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL1Compatibility();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkL2v1Compatibility(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkL2v1Compatibility",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkL2v1Compatibility" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL2v1Compatibility();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkL2v2Compatibility(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkL2v2Compatibility",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkL2v2Compatibility" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL2v2Compatibility();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkL2v3Compatibility(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkL2v3Compatibility",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkL2v3Compatibility" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL2v3Compatibility();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkL2v4Compatibility(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkL2v4Compatibility",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkL2v4Compatibility" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL2v4Compatibility();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_checkL3v1Compatibility(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_checkL3v1Compatibility",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_checkL3v1Compatibility" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)(arg1)->checkL3v1Compatibility();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLDocument_getError",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getError" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLDocument_getError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLError *)((SBMLDocument const *)arg1)->getError(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getNumErrors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getNumErrors",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getNumErrors" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (unsigned int)((SBMLDocument const *)arg1)->getNumErrors();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_printErrors__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLDocument_printErrors",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_printErrors" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLDocument_printErrors" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBMLDocument_printErrors" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  ((SBMLDocument const *)arg1)->printErrors(*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_printErrors__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_printErrors",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_printErrors" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  ((SBMLDocument const *)arg1)->printErrors();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_printErrors(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLDocument_printErrors__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLDocument, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SBMLDocument_printErrors__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLDocument_printErrors'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    printErrors(SBMLDocument const *,std::ostream &)\n"
    "    printErrors(SBMLDocument const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getTypeCode" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (SBMLTypeCode_t)((SBMLDocument const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getElementName" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (std::string *) &((SBMLDocument const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getErrorLog(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLErrorLog *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getErrorLog",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getErrorLog" "', argument " "1"" of type '" "SBMLDocument *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (SBMLErrorLog *)(arg1)->getErrorLog();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLErrorLog, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLDocument_getNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLDocument *arg1 = (SBMLDocument *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLDocument_getNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLDocument, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLDocument_getNamespaces" "', argument " "1"" of type '" "SBMLDocument const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLDocument * >(argp1);
  result = (XMLNamespaces *)((SBMLDocument const *)arg1)->getNamespaces();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLDocument_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLDocument, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_FunctionDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_FunctionDefinition",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_FunctionDefinition" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_FunctionDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (FunctionDefinition *)new FunctionDefinition(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_FunctionDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_FunctionDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_FunctionDefinition" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (FunctionDefinition *)new FunctionDefinition(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_FunctionDefinition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_FunctionDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FunctionDefinition" "', argument " "1"" of type '" "FunctionDefinition *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_FunctionDefinition__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_FunctionDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_FunctionDefinition,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_FunctionDefinition" "', argument " "1"" of type '" "FunctionDefinition const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_FunctionDefinition" "', argument " "1"" of type '" "FunctionDefinition const &""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  {
    try {
      result = (FunctionDefinition *)new FunctionDefinition((FunctionDefinition const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_FunctionDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FunctionDefinition__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FunctionDefinition__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_FunctionDefinition__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_FunctionDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    FunctionDefinition(unsigned int,unsigned int)\n"
    "    FunctionDefinition(SBMLNamespaces *)\n"
    "    FunctionDefinition(FunctionDefinition const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_clone" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (FunctionDefinition *)((FunctionDefinition const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getId" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (std::string *) &((FunctionDefinition const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getName" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (std::string *) &((FunctionDefinition const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getMath" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (ASTNode *)((FunctionDefinition const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_isSetId" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_isSetName" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_isSetMath" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FunctionDefinition_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_setId" "', argument " "1"" of type '" "FunctionDefinition *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FunctionDefinition_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FunctionDefinition_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FunctionDefinition_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_setName" "', argument " "1"" of type '" "FunctionDefinition *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FunctionDefinition_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FunctionDefinition_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FunctionDefinition_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_setMath" "', argument " "1"" of type '" "FunctionDefinition *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FunctionDefinition_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_unsetName" "', argument " "1"" of type '" "FunctionDefinition *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getArgument__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FunctionDefinition_getArgument",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getArgument" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "FunctionDefinition_getArgument" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ASTNode *)((FunctionDefinition const *)arg1)->getArgument(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getArgument__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:FunctionDefinition_getArgument",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getArgument" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "FunctionDefinition_getArgument" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "FunctionDefinition_getArgument" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (ASTNode *)((FunctionDefinition const *)arg1)->getArgument((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getArgument(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_FunctionDefinition_getArgument__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_FunctionDefinition_getArgument__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'FunctionDefinition_getArgument'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getArgument(FunctionDefinition const *,unsigned int)\n"
    "    getArgument(FunctionDefinition const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getBody__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getBody",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getBody" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (ASTNode *)((FunctionDefinition const *)arg1)->getBody();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getBody__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getBody",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getBody" "', argument " "1"" of type '" "FunctionDefinition *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (ASTNode *)(arg1)->getBody();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getBody(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FunctionDefinition_getBody__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_FunctionDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_FunctionDefinition_getBody__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'FunctionDefinition_getBody'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getBody(FunctionDefinition const *)\n"
    "    getBody(FunctionDefinition *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getNumArguments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getNumArguments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getNumArguments" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (unsigned int)((FunctionDefinition const *)arg1)->getNumArguments();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getTypeCode" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (SBMLTypeCode_t)((FunctionDefinition const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_getElementName" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (std::string *) &((FunctionDefinition const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_hasRequiredAttributes" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionDefinition_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  FunctionDefinition *arg1 = (FunctionDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:FunctionDefinition_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionDefinition_hasRequiredElements" "', argument " "1"" of type '" "FunctionDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< FunctionDefinition * >(argp1);
  result = (bool)((FunctionDefinition const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *FunctionDefinition_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_FunctionDefinition, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfFunctionDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfFunctionDefinitions_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_clone" "', argument " "1"" of type '" "ListOfFunctionDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  result = (ListOfFunctionDefinitions *)((ListOfFunctionDefinitions const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfFunctionDefinitions, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfFunctionDefinitions_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_getTypeCode" "', argument " "1"" of type '" "ListOfFunctionDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  result = (SBMLTypeCode_t)((ListOfFunctionDefinitions const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfFunctionDefinitions_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_getItemTypeCode" "', argument " "1"" of type '" "ListOfFunctionDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  result = (SBMLTypeCode_t)((ListOfFunctionDefinitions const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfFunctionDefinitions_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_getElementName" "', argument " "1"" of type '" "ListOfFunctionDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  result = (std::string *) &((ListOfFunctionDefinitions const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfFunctionDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_get" "', argument " "1"" of type '" "ListOfFunctionDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfFunctionDefinitions_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfFunctionDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_get" "', argument " "1"" of type '" "ListOfFunctionDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfFunctionDefinitions_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)((ListOfFunctionDefinitions const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfFunctionDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_get" "', argument " "1"" of type '" "ListOfFunctionDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfFunctionDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfFunctionDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfFunctionDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_get" "', argument " "1"" of type '" "ListOfFunctionDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfFunctionDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfFunctionDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)((ListOfFunctionDefinitions const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfFunctionDefinitions_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfFunctionDefinitions *,unsigned int)\n"
    "    get(ListOfFunctionDefinitions const *,unsigned int)\n"
    "    get(ListOfFunctionDefinitions *,std::string const &)\n"
    "    get(ListOfFunctionDefinitions const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfFunctionDefinitions_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_remove" "', argument " "1"" of type '" "ListOfFunctionDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfFunctionDefinitions_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (FunctionDefinition *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  FunctionDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfFunctionDefinitions_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfFunctionDefinitions_remove" "', argument " "1"" of type '" "ListOfFunctionDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfFunctionDefinitions_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfFunctionDefinitions_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (FunctionDefinition *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FunctionDefinition, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfFunctionDefinitions_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfFunctionDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfFunctionDefinitions_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfFunctionDefinitions_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfFunctionDefinitions *,unsigned int)\n"
    "    remove(ListOfFunctionDefinitions *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfFunctionDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfFunctionDefinitions")) SWIG_fail;
  result = (ListOfFunctionDefinitions *)new ListOfFunctionDefinitions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfFunctionDefinitions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfFunctionDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfFunctionDefinitions *arg1 = (ListOfFunctionDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfFunctionDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfFunctionDefinitions, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfFunctionDefinitions" "', argument " "1"" of type '" "ListOfFunctionDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfFunctionDefinitions * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfFunctionDefinitions_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfFunctionDefinitions, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_UnitKind_equals(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitKind_t arg1 ;
  UnitKind_t arg2 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitKind_equals",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "UnitKind_equals" "', argument " "1"" of type '" "UnitKind_t""'");
  } 
  arg1 = static_cast< UnitKind_t >(val1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnitKind_equals" "', argument " "2"" of type '" "UnitKind_t""'");
  } 
  arg2 = static_cast< UnitKind_t >(val2);
  result = (int)UnitKind_equals(arg1,arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitKind_forName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitKind_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitKind_forName",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitKind_forName" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (UnitKind_t)UnitKind_forName((char const *)arg1);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitKind_toString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitKind_t arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitKind_toString",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "UnitKind_toString" "', argument " "1"" of type '" "UnitKind_t""'");
  } 
  arg1 = static_cast< UnitKind_t >(val1);
  result = (char *)UnitKind_toString(arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitKind_isValidUnitKindString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:UnitKind_isValidUnitKindString",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitKind_isValidUnitKindString" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnitKind_isValidUnitKindString" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "UnitKind_isValidUnitKindString" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (int)UnitKind_isValidUnitKindString((char const *)arg1,arg2,arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Unit__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Unit",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Unit" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Unit" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Unit *)new Unit(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Unit__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Unit",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Unit" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Unit *)new Unit(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Unit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Unit",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Unit" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Unit__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Unit",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Unit,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Unit" "', argument " "1"" of type '" "Unit const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Unit" "', argument " "1"" of type '" "Unit const &""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  {
    try {
      result = (Unit *)new Unit((Unit const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Unit(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Unit__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Unit, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Unit__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Unit__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Unit'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Unit(unsigned int,unsigned int)\n"
    "    Unit(SBMLNamespaces *)\n"
    "    Unit(Unit const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_clone" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (Unit *)((Unit const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_initDefaults(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_initDefaults",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_initDefaults" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  (arg1)->initDefaults();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getKind(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitKind_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getKind",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getKind" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (UnitKind_t)((Unit const *)arg1)->getKind();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getExponent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getExponent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getExponent" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (int)((Unit const *)arg1)->getExponent();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getExponentAsDouble(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getExponentAsDouble",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getExponentAsDouble" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (double)((Unit const *)arg1)->getExponentAsDouble();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getScale(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getScale",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getScale" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (int)((Unit const *)arg1)->getScale();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getMultiplier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getMultiplier",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getMultiplier" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (double)((Unit const *)arg1)->getMultiplier();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getOffset",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getOffset" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (double)((Unit const *)arg1)->getOffset();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isAmpere(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isAmpere",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isAmpere" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isAmpere();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isAvogadro(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isAvogadro",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isAvogadro" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isAvogadro();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isBecquerel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isBecquerel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isBecquerel" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isBecquerel();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isCandela(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isCandela",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isCandela" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isCandela();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isCelsius(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isCelsius",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isCelsius" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isCelsius();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isCoulomb(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isCoulomb",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isCoulomb" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isCoulomb();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isDimensionless(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isDimensionless",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isDimensionless" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isDimensionless();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isFarad(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isFarad",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isFarad" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isFarad();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isGram(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isGram",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isGram" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isGram();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isGray(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isGray",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isGray" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isGray();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isHenry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isHenry",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isHenry" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isHenry();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isHertz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isHertz",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isHertz" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isHertz();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isItem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isItem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isItem" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isItem();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isJoule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isJoule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isJoule" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isJoule();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isKatal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isKatal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isKatal" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isKatal();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isKelvin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isKelvin",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isKelvin" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isKelvin();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isKilogram(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isKilogram",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isKilogram" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isKilogram();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isLitre(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isLitre",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isLitre" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isLitre();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isLumen(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isLumen",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isLumen" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isLumen();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isLux(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isLux",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isLux" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isLux();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isMetre(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isMetre",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isMetre" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isMetre();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isMole(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isMole",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isMole" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isMole();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isNewton(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isNewton",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isNewton" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isNewton();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isOhm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isOhm",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isOhm" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isOhm();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isPascal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isPascal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isPascal" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isPascal();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isRadian(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isRadian",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isRadian" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isRadian();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSecond(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSecond",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSecond" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSecond();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSiemens(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSiemens",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSiemens" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSiemens();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSievert(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSievert",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSievert" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSievert();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSteradian(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSteradian",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSteradian" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSteradian();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isTesla(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isTesla",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isTesla" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isTesla();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isVolt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isVolt",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isVolt" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isVolt();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isWatt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isWatt",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isWatt" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isWatt();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isWeber(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isWeber",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isWeber" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isWeber();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSetKind(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSetKind",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSetKind" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSetKind();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSetExponent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSetExponent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSetExponent" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSetExponent();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSetScale(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSetScale",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSetScale" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSetScale();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isSetMultiplier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_isSetMultiplier",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isSetMultiplier" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->isSetMultiplier();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setKind(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  UnitKind_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_setKind",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_setKind" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_setKind" "', argument " "2"" of type '" "UnitKind_t""'");
  } 
  arg2 = static_cast< UnitKind_t >(val2);
  result = (int)(arg1)->setKind(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setExponent__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_setExponent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_setExponent" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_setExponent" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setExponent(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setExponent__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_setExponent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_setExponent" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_setExponent" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setExponent(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setExponent(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Unit, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Unit_setExponent__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Unit, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Unit_setExponent__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Unit_setExponent'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setExponent(Unit *,int)\n"
    "    setExponent(Unit *,double)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setScale(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_setScale",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_setScale" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_setScale" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setScale(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setMultiplier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_setMultiplier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_setMultiplier" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_setMultiplier" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setMultiplier(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_setOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_setOffset",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_setOffset" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_setOffset" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setOffset(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getTypeCode" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (SBMLTypeCode_t)((Unit const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_getElementName" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (std::string *) &((Unit const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isBuiltIn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_isBuiltIn",&obj0,&obj1)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isBuiltIn" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Unit_isBuiltIn" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_isBuiltIn" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (bool)Unit::isBuiltIn((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1,arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_isUnitKind(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:Unit_isUnitKind",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_isUnitKind" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Unit_isUnitKind" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Unit_isUnitKind" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Unit_isUnitKind" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (bool)Unit::isUnitKind((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1,arg2,arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_areIdentical(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  Unit *arg2 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_areIdentical",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_areIdentical" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Unit_areIdentical" "', argument " "2"" of type '" "Unit *""'"); 
  }
  arg2 = reinterpret_cast< Unit * >(argp2);
  result = (bool)Unit::areIdentical(arg1,arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_areEquivalent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  Unit *arg2 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_areEquivalent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_areEquivalent" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Unit_areEquivalent" "', argument " "2"" of type '" "Unit *""'"); 
  }
  arg2 = reinterpret_cast< Unit * >(argp2);
  result = (bool)Unit::areEquivalent(arg1,arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_removeScale(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_removeScale",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_removeScale" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (int)Unit::removeScale(arg1);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_merge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  Unit *arg2 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Unit_merge",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_merge" "', argument " "1"" of type '" "Unit *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Unit_merge" "', argument " "2"" of type '" "Unit *""'"); 
  }
  arg2 = reinterpret_cast< Unit * >(argp2);
  Unit::merge(arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_convertToSI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_convertToSI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_convertToSI" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (UnitDefinition *)Unit::convertToSI((Unit const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Unit_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Unit *arg1 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Unit_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Unit_hasRequiredAttributes" "', argument " "1"" of type '" "Unit const *""'"); 
  }
  arg1 = reinterpret_cast< Unit * >(argp1);
  result = (bool)((Unit const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Unit_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Unit, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfUnits_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfUnits *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnits_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_clone" "', argument " "1"" of type '" "ListOfUnits const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  result = (ListOfUnits *)((ListOfUnits const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnits, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnits_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_getTypeCode" "', argument " "1"" of type '" "ListOfUnits const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  result = (SBMLTypeCode_t)((ListOfUnits const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnits_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_getItemTypeCode" "', argument " "1"" of type '" "ListOfUnits const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  result = (SBMLTypeCode_t)((ListOfUnits const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnits_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_getElementName" "', argument " "1"" of type '" "ListOfUnits const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  result = (std::string *) &((ListOfUnits const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnits_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_get" "', argument " "1"" of type '" "ListOfUnits *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfUnits_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnits_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_get" "', argument " "1"" of type '" "ListOfUnits const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfUnits_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)((ListOfUnits const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnits, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnits_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnits, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnits_get__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfUnits_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfUnits *,unsigned int)\n"
    "    get(ListOfUnits const *,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnits_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnits_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnits_remove" "', argument " "1"" of type '" "ListOfUnits *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfUnits_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfUnits")) SWIG_fail;
  result = (ListOfUnits *)new ListOfUnits();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnits, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnits *arg1 = (ListOfUnits *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnits, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfUnits" "', argument " "1"" of type '" "ListOfUnits *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnits * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfUnits_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfUnits, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_UnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_UnitDefinition",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_UnitDefinition" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_UnitDefinition" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (UnitDefinition *)new UnitDefinition(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_UnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_UnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_UnitDefinition" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (UnitDefinition *)new UnitDefinition(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_UnitDefinition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_UnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_UnitDefinition" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_UnitDefinition__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_UnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_UnitDefinition,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_UnitDefinition" "', argument " "1"" of type '" "UnitDefinition const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_UnitDefinition" "', argument " "1"" of type '" "UnitDefinition const &""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  {
    try {
      result = (UnitDefinition *)new UnitDefinition((UnitDefinition const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_UnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UnitDefinition__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_UnitDefinition__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_UnitDefinition__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_UnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    UnitDefinition(unsigned int,unsigned int)\n"
    "    UnitDefinition(SBMLNamespaces *)\n"
    "    UnitDefinition(UnitDefinition const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_clone" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (UnitDefinition *)((UnitDefinition const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getId" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (std::string *) &((UnitDefinition const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getName" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (std::string *) &((UnitDefinition const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isSetId" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isSetName" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_setId" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UnitDefinition_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "UnitDefinition_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_setName" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UnitDefinition_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "UnitDefinition_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_unsetName" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfArea(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfArea",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfArea" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfArea();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfLength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfLength",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfLength" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfLength();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfSubstance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfSubstance",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfSubstance" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfSubstance();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfTime(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfTime",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfTime" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfTime();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfVolume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfVolume",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfVolume" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfVolume();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfDimensionless(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfDimensionless",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfDimensionless" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfDimensionless();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfMass(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfMass",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfMass" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfMass();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_isVariantOfSubstancePerTime(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_isVariantOfSubstancePerTime",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_isVariantOfSubstancePerTime" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->isVariantOfSubstancePerTime();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_addUnit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  Unit *arg2 = (Unit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_addUnit",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_addUnit" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Unit, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UnitDefinition_addUnit" "', argument " "2"" of type '" "Unit const *""'"); 
  }
  arg2 = reinterpret_cast< Unit * >(argp2);
  result = (int)(arg1)->addUnit((Unit const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_createUnit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_createUnit",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_createUnit" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (Unit *)(arg1)->createUnit();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getListOfUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfUnits *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getListOfUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getListOfUnits" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (ListOfUnits *)((UnitDefinition const *)arg1)->getListOfUnits();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnits, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getListOfUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfUnits *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getListOfUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getListOfUnits" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (ListOfUnits *)(arg1)->getListOfUnits();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnits, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getListOfUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_UnitDefinition_getListOfUnits__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_UnitDefinition_getListOfUnits__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'UnitDefinition_getListOfUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfUnits(UnitDefinition const *)\n"
    "    getListOfUnits(UnitDefinition *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getUnit__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_getUnit",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getUnit" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnitDefinition_getUnit" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)(arg1)->getUnit(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getUnit__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_getUnit",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getUnit" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnitDefinition_getUnit" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)((UnitDefinition const *)arg1)->getUnit(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getUnit(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_UnitDefinition_getUnit__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_UnitDefinition_getUnit__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'UnitDefinition_getUnit'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getUnit(UnitDefinition *,unsigned int)\n"
    "    getUnit(UnitDefinition const *,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getNumUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getNumUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getNumUnits" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (unsigned int)((UnitDefinition const *)arg1)->getNumUnits();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_removeUnit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Unit *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_removeUnit",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_removeUnit" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnitDefinition_removeUnit" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Unit *)(arg1)->removeUnit(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Unit, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getTypeCode" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (SBMLTypeCode_t)((UnitDefinition const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_getElementName" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (std::string *) &((UnitDefinition const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_simplify(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_simplify",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_simplify" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  UnitDefinition::simplify(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_reorder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_reorder",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_reorder" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  UnitDefinition::reorder(arg1);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_convertToSI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_convertToSI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_convertToSI" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (UnitDefinition *)UnitDefinition::convertToSI((UnitDefinition const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_areIdentical(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  UnitDefinition *arg2 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_areIdentical",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_areIdentical" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UnitDefinition_areIdentical" "', argument " "2"" of type '" "UnitDefinition const *""'"); 
  }
  arg2 = reinterpret_cast< UnitDefinition * >(argp2);
  result = (bool)UnitDefinition::areIdentical((UnitDefinition const *)arg1,(UnitDefinition const *)arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_areEquivalent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  UnitDefinition *arg2 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_areEquivalent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_areEquivalent" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UnitDefinition_areEquivalent" "', argument " "2"" of type '" "UnitDefinition const *""'"); 
  }
  arg2 = reinterpret_cast< UnitDefinition * >(argp2);
  result = (bool)UnitDefinition::areEquivalent((UnitDefinition const *)arg1,(UnitDefinition const *)arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_combine(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  UnitDefinition *arg2 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_combine",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_combine" "', argument " "1"" of type '" "UnitDefinition *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "UnitDefinition_combine" "', argument " "2"" of type '" "UnitDefinition *""'"); 
  }
  arg2 = reinterpret_cast< UnitDefinition * >(argp2);
  result = (UnitDefinition *)UnitDefinition::combine(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_printUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:UnitDefinition_printUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_printUnits" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "UnitDefinition_printUnits" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = UnitDefinition::printUnits((UnitDefinition const *)arg1,arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_printUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_printUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_printUnits" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = UnitDefinition::printUnits((UnitDefinition const *)arg1);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_printUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_UnitDefinition_printUnits__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_UnitDefinition, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_bool(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_UnitDefinition_printUnits__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'UnitDefinition_printUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    printUnits(UnitDefinition const *,bool)\n"
    "    UnitDefinition::printUnits(UnitDefinition const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_hasRequiredAttributes" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_UnitDefinition_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  UnitDefinition *arg1 = (UnitDefinition *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:UnitDefinition_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "UnitDefinition_hasRequiredElements" "', argument " "1"" of type '" "UnitDefinition const *""'"); 
  }
  arg1 = reinterpret_cast< UnitDefinition * >(argp1);
  result = (bool)((UnitDefinition const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *UnitDefinition_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_UnitDefinition, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfUnitDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnitDefinitions_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_clone" "', argument " "1"" of type '" "ListOfUnitDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  result = (ListOfUnitDefinitions *)((ListOfUnitDefinitions const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnitDefinitions, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnitDefinitions_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_getTypeCode" "', argument " "1"" of type '" "ListOfUnitDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  result = (SBMLTypeCode_t)((ListOfUnitDefinitions const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnitDefinitions_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_getItemTypeCode" "', argument " "1"" of type '" "ListOfUnitDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  result = (SBMLTypeCode_t)((ListOfUnitDefinitions const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfUnitDefinitions_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_getElementName" "', argument " "1"" of type '" "ListOfUnitDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  result = (std::string *) &((ListOfUnitDefinitions const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnitDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_get" "', argument " "1"" of type '" "ListOfUnitDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfUnitDefinitions_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnitDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_get" "', argument " "1"" of type '" "ListOfUnitDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfUnitDefinitions_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)((ListOfUnitDefinitions const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnitDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_get" "', argument " "1"" of type '" "ListOfUnitDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfUnitDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfUnitDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnitDefinitions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_get" "', argument " "1"" of type '" "ListOfUnitDefinitions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfUnitDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfUnitDefinitions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)((ListOfUnitDefinitions const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnitDefinitions_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnitDefinitions_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfUnitDefinitions_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfUnitDefinitions_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfUnitDefinitions_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfUnitDefinitions *,unsigned int)\n"
    "    get(ListOfUnitDefinitions const *,unsigned int)\n"
    "    get(ListOfUnitDefinitions *,std::string const &)\n"
    "    get(ListOfUnitDefinitions const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnitDefinitions_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_remove" "', argument " "1"" of type '" "ListOfUnitDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfUnitDefinitions_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (UnitDefinition *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfUnitDefinitions_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfUnitDefinitions_remove" "', argument " "1"" of type '" "ListOfUnitDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfUnitDefinitions_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfUnitDefinitions_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (UnitDefinition *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfUnitDefinitions_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfUnitDefinitions_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfUnitDefinitions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfUnitDefinitions_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfUnitDefinitions_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfUnitDefinitions *,unsigned int)\n"
    "    remove(ListOfUnitDefinitions *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfUnitDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfUnitDefinitions")) SWIG_fail;
  result = (ListOfUnitDefinitions *)new ListOfUnitDefinitions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfUnitDefinitions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfUnitDefinitions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfUnitDefinitions *arg1 = (ListOfUnitDefinitions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfUnitDefinitions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfUnitDefinitions, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfUnitDefinitions" "', argument " "1"" of type '" "ListOfUnitDefinitions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfUnitDefinitions * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfUnitDefinitions_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfUnitDefinitions, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_CompartmentType__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_CompartmentType",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CompartmentType" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_CompartmentType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (CompartmentType *)new CompartmentType(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CompartmentType__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_CompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CompartmentType" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (CompartmentType *)new CompartmentType(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_CompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CompartmentType" "', argument " "1"" of type '" "CompartmentType *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CompartmentType__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_CompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_CompartmentType,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CompartmentType" "', argument " "1"" of type '" "CompartmentType const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CompartmentType" "', argument " "1"" of type '" "CompartmentType const &""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  {
    try {
      result = (CompartmentType *)new CompartmentType((CompartmentType const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CompartmentType(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CompartmentType__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_CompartmentType, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CompartmentType__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_CompartmentType__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_CompartmentType'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    CompartmentType(unsigned int,unsigned int)\n"
    "    CompartmentType(SBMLNamespaces *)\n"
    "    CompartmentType(CompartmentType const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_clone" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (CompartmentType *)((CompartmentType const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_getId" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (std::string *) &((CompartmentType const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_getName" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (std::string *) &((CompartmentType const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_isSetId" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (bool)((CompartmentType const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_isSetName" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (bool)((CompartmentType const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CompartmentType_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_setId" "', argument " "1"" of type '" "CompartmentType *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CompartmentType_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompartmentType_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CompartmentType_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_setName" "', argument " "1"" of type '" "CompartmentType *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CompartmentType_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CompartmentType_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_unsetName" "', argument " "1"" of type '" "CompartmentType *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_getTypeCode" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (SBMLTypeCode_t)((CompartmentType const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_getElementName" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (std::string *) &((CompartmentType const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CompartmentType_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CompartmentType *arg1 = (CompartmentType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CompartmentType_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CompartmentType_hasRequiredAttributes" "', argument " "1"" of type '" "CompartmentType const *""'"); 
  }
  arg1 = reinterpret_cast< CompartmentType * >(argp1);
  result = (bool)((CompartmentType const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CompartmentType_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_CompartmentType, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfCompartmentTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartmentTypes_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_clone" "', argument " "1"" of type '" "ListOfCompartmentTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  result = (ListOfCompartmentTypes *)((ListOfCompartmentTypes const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartmentTypes, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartmentTypes_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_getTypeCode" "', argument " "1"" of type '" "ListOfCompartmentTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  result = (SBMLTypeCode_t)((ListOfCompartmentTypes const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartmentTypes_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_getItemTypeCode" "', argument " "1"" of type '" "ListOfCompartmentTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  result = (SBMLTypeCode_t)((ListOfCompartmentTypes const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartmentTypes_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_getElementName" "', argument " "1"" of type '" "ListOfCompartmentTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  result = (std::string *) &((ListOfCompartmentTypes const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartmentTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_get" "', argument " "1"" of type '" "ListOfCompartmentTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfCompartmentTypes_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartmentTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_get" "', argument " "1"" of type '" "ListOfCompartmentTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfCompartmentTypes_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)((ListOfCompartmentTypes const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartmentTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_get" "', argument " "1"" of type '" "ListOfCompartmentTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfCompartmentTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfCompartmentTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartmentTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_get" "', argument " "1"" of type '" "ListOfCompartmentTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfCompartmentTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfCompartmentTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)((ListOfCompartmentTypes const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartmentTypes_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartmentTypes_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartmentTypes_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartmentTypes_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfCompartmentTypes_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfCompartmentTypes *,unsigned int)\n"
    "    get(ListOfCompartmentTypes const *,unsigned int)\n"
    "    get(ListOfCompartmentTypes *,std::string const &)\n"
    "    get(ListOfCompartmentTypes const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartmentTypes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_remove" "', argument " "1"" of type '" "ListOfCompartmentTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfCompartmentTypes_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (CompartmentType *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  CompartmentType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartmentTypes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartmentTypes_remove" "', argument " "1"" of type '" "ListOfCompartmentTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfCompartmentTypes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfCompartmentTypes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (CompartmentType *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CompartmentType, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartmentTypes_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartmentTypes_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartmentTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartmentTypes_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfCompartmentTypes_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfCompartmentTypes *,unsigned int)\n"
    "    remove(ListOfCompartmentTypes *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfCompartmentTypes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfCompartmentTypes")) SWIG_fail;
  result = (ListOfCompartmentTypes *)new ListOfCompartmentTypes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartmentTypes, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfCompartmentTypes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartmentTypes *arg1 = (ListOfCompartmentTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfCompartmentTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartmentTypes, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfCompartmentTypes" "', argument " "1"" of type '" "ListOfCompartmentTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartmentTypes * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfCompartmentTypes_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfCompartmentTypes, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_SpeciesType__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SpeciesType",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SpeciesType" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SpeciesType" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (SpeciesType *)new SpeciesType(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SpeciesType__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SpeciesType" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (SpeciesType *)new SpeciesType(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SpeciesType" "', argument " "1"" of type '" "SpeciesType *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SpeciesType__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_SpeciesType,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SpeciesType" "', argument " "1"" of type '" "SpeciesType const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpeciesType" "', argument " "1"" of type '" "SpeciesType const &""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  {
    try {
      result = (SpeciesType *)new SpeciesType((SpeciesType const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SpeciesType(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SpeciesType__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_SpeciesType, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SpeciesType__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SpeciesType__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_SpeciesType'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    SpeciesType(unsigned int,unsigned int)\n"
    "    SpeciesType(SBMLNamespaces *)\n"
    "    SpeciesType(SpeciesType const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_clone" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (SpeciesType *)((SpeciesType const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_getId" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (std::string *) &((SpeciesType const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_getName" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (std::string *) &((SpeciesType const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_isSetId" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (bool)((SpeciesType const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_isSetName" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (bool)((SpeciesType const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesType_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_setId" "', argument " "1"" of type '" "SpeciesType *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesType_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpeciesType_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesType_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_setName" "', argument " "1"" of type '" "SpeciesType *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesType_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpeciesType_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_unsetName" "', argument " "1"" of type '" "SpeciesType *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_getTypeCode" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (SBMLTypeCode_t)((SpeciesType const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_getElementName" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (std::string *) &((SpeciesType const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesType_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesType *arg1 = (SpeciesType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesType_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesType_hasRequiredAttributes" "', argument " "1"" of type '" "SpeciesType const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesType * >(argp1);
  result = (bool)((SpeciesType const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SpeciesType_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SpeciesType, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesTypes_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_clone" "', argument " "1"" of type '" "ListOfSpeciesTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  result = (ListOfSpeciesTypes *)((ListOfSpeciesTypes const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesTypes, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesTypes_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_getTypeCode" "', argument " "1"" of type '" "ListOfSpeciesTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  result = (SBMLTypeCode_t)((ListOfSpeciesTypes const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesTypes_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_getItemTypeCode" "', argument " "1"" of type '" "ListOfSpeciesTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  result = (SBMLTypeCode_t)((ListOfSpeciesTypes const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesTypes_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_getElementName" "', argument " "1"" of type '" "ListOfSpeciesTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  result = (std::string *) &((ListOfSpeciesTypes const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_get" "', argument " "1"" of type '" "ListOfSpeciesTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpeciesTypes_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_get" "', argument " "1"" of type '" "ListOfSpeciesTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpeciesTypes_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)((ListOfSpeciesTypes const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_get" "', argument " "1"" of type '" "ListOfSpeciesTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpeciesTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpeciesTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesTypes_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_get" "', argument " "1"" of type '" "ListOfSpeciesTypes const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpeciesTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpeciesTypes_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)((ListOfSpeciesTypes const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesTypes_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesTypes_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesTypes_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesTypes_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfSpeciesTypes_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfSpeciesTypes *,unsigned int)\n"
    "    get(ListOfSpeciesTypes const *,unsigned int)\n"
    "    get(ListOfSpeciesTypes *,std::string const &)\n"
    "    get(ListOfSpeciesTypes const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesTypes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_remove" "', argument " "1"" of type '" "ListOfSpeciesTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpeciesTypes_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesType *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesType *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesTypes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesTypes_remove" "', argument " "1"" of type '" "ListOfSpeciesTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpeciesTypes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpeciesTypes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesType *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesType, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesTypes_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesTypes_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesTypes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesTypes_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfSpeciesTypes_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfSpeciesTypes *,unsigned int)\n"
    "    remove(ListOfSpeciesTypes *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfSpeciesTypes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfSpeciesTypes")) SWIG_fail;
  result = (ListOfSpeciesTypes *)new ListOfSpeciesTypes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesTypes, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfSpeciesTypes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesTypes *arg1 = (ListOfSpeciesTypes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfSpeciesTypes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesTypes, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfSpeciesTypes" "', argument " "1"" of type '" "ListOfSpeciesTypes *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesTypes * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfSpeciesTypes_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfSpeciesTypes, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Compartment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Compartment",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Compartment" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Compartment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Compartment *)new Compartment(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Compartment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Compartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Compartment" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Compartment *)new Compartment(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Compartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Compartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Compartment" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Compartment__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Compartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Compartment,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Compartment" "', argument " "1"" of type '" "Compartment const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Compartment" "', argument " "1"" of type '" "Compartment const &""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    try {
      result = (Compartment *)new Compartment((Compartment const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Compartment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Compartment__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Compartment__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Compartment__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Compartment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Compartment(unsigned int,unsigned int)\n"
    "    Compartment(SBMLNamespaces *)\n"
    "    Compartment(Compartment const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_clone" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (Compartment *)((Compartment const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_initDefaults(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_initDefaults",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_initDefaults" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  (arg1)->initDefaults();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getId" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getName" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getCompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getCompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getCompartmentType" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getCompartmentType();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getSpatialDimensions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getSpatialDimensions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getSpatialDimensions" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (unsigned int)((Compartment const *)arg1)->getSpatialDimensions();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getSpatialDimensionsAsDouble(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getSpatialDimensionsAsDouble",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getSpatialDimensionsAsDouble" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (double)((Compartment const *)arg1)->getSpatialDimensionsAsDouble();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getSize" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (double)((Compartment const *)arg1)->getSize();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getVolume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getVolume",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getVolume" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (double)((Compartment const *)arg1)->getVolume();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getUnits" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getOutside(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getOutside",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getOutside" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getOutside();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getConstant" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->getConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetId" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetName" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetCompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetCompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetCompartmentType" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetCompartmentType();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetSize" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetSize();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetVolume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetVolume",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetVolume" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetVolume();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetUnits" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetOutside(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetOutside",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetOutside" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetOutside();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetSpatialDimensions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetSpatialDimensions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetSpatialDimensions" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetSpatialDimensions();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_isSetConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_isSetConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_isSetConstant" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->isSetConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setId" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Compartment_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Compartment_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setName" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Compartment_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Compartment_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setCompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setCompartmentType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setCompartmentType" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Compartment_setCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Compartment_setCompartmentType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setCompartmentType((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setSpatialDimensions__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setSpatialDimensions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setSpatialDimensions" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Compartment_setSpatialDimensions" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setSpatialDimensions(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setSpatialDimensions__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setSpatialDimensions",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setSpatialDimensions" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Compartment_setSpatialDimensions" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setSpatialDimensions(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setSpatialDimensions(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Compartment_setSpatialDimensions__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Compartment_setSpatialDimensions__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Compartment_setSpatialDimensions'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setSpatialDimensions(Compartment *,unsigned int)\n"
    "    setSpatialDimensions(Compartment *,double)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setSize",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setSize" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Compartment_setSize" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setSize(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setVolume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setVolume",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setVolume" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Compartment_setVolume" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setVolume(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setUnits" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Compartment_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Compartment_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setOutside(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setOutside",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setOutside" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Compartment_setOutside" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Compartment_setOutside" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setOutside((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_setConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Compartment_setConstant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_setConstant" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Compartment_setConstant" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setConstant(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetName" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetCompartmentType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetCompartmentType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetCompartmentType" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetCompartmentType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetSize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetSize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetSize" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetSize();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetVolume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetVolume",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetVolume" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetVolume();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetUnits" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetOutside(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetOutside",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetOutside" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetOutside();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_unsetSpatialDimensions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_unsetSpatialDimensions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_unsetSpatialDimensions" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (int)(arg1)->unsetSpatialDimensions();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getDerivedUnitDefinition" "', argument " "1"" of type '" "Compartment *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getDerivedUnitDefinition" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (UnitDefinition *)((Compartment const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Compartment_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Compartment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Compartment_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Compartment_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(Compartment *)\n"
    "    getDerivedUnitDefinition(Compartment const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getTypeCode" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (SBMLTypeCode_t)((Compartment const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_getElementName" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (std::string *) &((Compartment const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Compartment_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Compartment *arg1 = (Compartment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Compartment_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Compartment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Compartment_hasRequiredAttributes" "', argument " "1"" of type '" "Compartment const *""'"); 
  }
  arg1 = reinterpret_cast< Compartment * >(argp1);
  result = (bool)((Compartment const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Compartment_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Compartment, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfCompartments_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfCompartments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartments_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_clone" "', argument " "1"" of type '" "ListOfCompartments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  result = (ListOfCompartments *)((ListOfCompartments const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartments, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartments_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_getTypeCode" "', argument " "1"" of type '" "ListOfCompartments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  result = (SBMLTypeCode_t)((ListOfCompartments const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartments_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_getItemTypeCode" "', argument " "1"" of type '" "ListOfCompartments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  result = (SBMLTypeCode_t)((ListOfCompartments const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfCompartments_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_getElementName" "', argument " "1"" of type '" "ListOfCompartments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  result = (std::string *) &((ListOfCompartments const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_get" "', argument " "1"" of type '" "ListOfCompartments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfCompartments_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_get" "', argument " "1"" of type '" "ListOfCompartments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfCompartments_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)((ListOfCompartments const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_get" "', argument " "1"" of type '" "ListOfCompartments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfCompartments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfCompartments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_get" "', argument " "1"" of type '" "ListOfCompartments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfCompartments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfCompartments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)((ListOfCompartments const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartments_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartments_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartments_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartments_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfCompartments_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfCompartments *,unsigned int)\n"
    "    get(ListOfCompartments const *,unsigned int)\n"
    "    get(ListOfCompartments *,std::string const &)\n"
    "    get(ListOfCompartments const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartments_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_remove" "', argument " "1"" of type '" "ListOfCompartments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfCompartments_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Compartment *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Compartment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfCompartments_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfCompartments_remove" "', argument " "1"" of type '" "ListOfCompartments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfCompartments_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfCompartments_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Compartment *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Compartment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfCompartments_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfCompartments_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfCompartments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfCompartments_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfCompartments_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfCompartments *,unsigned int)\n"
    "    remove(ListOfCompartments *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfCompartments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfCompartments")) SWIG_fail;
  result = (ListOfCompartments *)new ListOfCompartments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfCompartments, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfCompartments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfCompartments *arg1 = (ListOfCompartments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfCompartments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfCompartments, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfCompartments" "', argument " "1"" of type '" "ListOfCompartments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfCompartments * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfCompartments_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfCompartments, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Species__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Species",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Species" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Species" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Species *)new Species(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Species__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Species",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Species" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Species *)new Species(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Species(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Species",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Species" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Species__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Species",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Species,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Species" "', argument " "1"" of type '" "Species const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Species" "', argument " "1"" of type '" "Species const &""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    try {
      result = (Species *)new Species((Species const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Species(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Species__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Species, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Species__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Species__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Species'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Species(unsigned int,unsigned int)\n"
    "    Species(SBMLNamespaces *)\n"
    "    Species(Species const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_clone" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (Species *)((Species const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_initDefaults(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_initDefaults",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_initDefaults" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  (arg1)->initDefaults();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getId" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getName" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getSpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getSpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getSpeciesType" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getSpeciesType();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getCompartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getCompartment" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getCompartment();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getInitialAmount(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getInitialAmount",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getInitialAmount" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (double)((Species const *)arg1)->getInitialAmount();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getInitialConcentration(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getInitialConcentration",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getInitialConcentration" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (double)((Species const *)arg1)->getInitialConcentration();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getSubstanceUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getSubstanceUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getSpatialSizeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getSpatialSizeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getSpatialSizeUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getSpatialSizeUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getHasOnlySubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getHasOnlySubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getHasOnlySubstanceUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->getHasOnlySubstanceUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getBoundaryCondition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getBoundaryCondition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getBoundaryCondition" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->getBoundaryCondition();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getCharge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getCharge",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getCharge" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)((Species const *)arg1)->getCharge();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getConstant" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->getConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getConversionFactor",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getConversionFactor" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getConversionFactor();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetId" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetName" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetSpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetSpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetSpeciesType" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetSpeciesType();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetCompartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetCompartment" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetCompartment();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetInitialAmount(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetInitialAmount",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetInitialAmount" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetInitialAmount();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetInitialConcentration(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetInitialConcentration",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetInitialConcentration" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetInitialConcentration();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetSubstanceUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetSubstanceUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetSpatialSizeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetSpatialSizeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetSpatialSizeUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetSpatialSizeUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetCharge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetCharge",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetCharge" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetCharge();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetConversionFactor",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetConversionFactor" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetConversionFactor();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetBoundaryCondition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetBoundaryCondition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetBoundaryCondition" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetBoundaryCondition();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetHasOnlySubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetHasOnlySubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetHasOnlySubstanceUnits" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetHasOnlySubstanceUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_isSetConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_isSetConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_isSetConstant" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->isSetConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setId" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setName" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setSpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setSpeciesType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setSpeciesType" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setSpeciesType" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSpeciesType((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setCompartment" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setCompartment((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setInitialAmount(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setInitialAmount",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setInitialAmount" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Species_setInitialAmount" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setInitialAmount(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setInitialConcentration(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setInitialConcentration",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setInitialConcentration" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Species_setInitialConcentration" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setInitialConcentration(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setSubstanceUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setSubstanceUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setSubstanceUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setSubstanceUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSubstanceUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setSpatialSizeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setSpatialSizeUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setSpatialSizeUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setSpatialSizeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setSpatialSizeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSpatialSizeUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setHasOnlySubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setHasOnlySubstanceUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setHasOnlySubstanceUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Species_setHasOnlySubstanceUnits" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setHasOnlySubstanceUnits(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setBoundaryCondition(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setBoundaryCondition",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setBoundaryCondition" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Species_setBoundaryCondition" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setBoundaryCondition(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setCharge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setCharge",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setCharge" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Species_setCharge" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setCharge(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setConstant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setConstant" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Species_setConstant" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setConstant(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_setConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Species_setConversionFactor",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_setConversionFactor" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Species_setConversionFactor" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Species_setConversionFactor" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setConversionFactor((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetName" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetSpeciesType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetSpeciesType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetSpeciesType" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetSpeciesType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetInitialAmount(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetInitialAmount",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetInitialAmount" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetInitialAmount();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetInitialConcentration(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetInitialConcentration",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetInitialConcentration" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetInitialConcentration();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetSubstanceUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetSubstanceUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetSpatialSizeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetSpatialSizeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetSpatialSizeUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetSpatialSizeUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetUnits" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetCharge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetCharge",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetCharge" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetCharge();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_unsetConversionFactor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_unsetConversionFactor",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_unsetConversionFactor" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (int)(arg1)->unsetConversionFactor();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getDerivedUnitDefinition" "', argument " "1"" of type '" "Species *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getDerivedUnitDefinition" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (UnitDefinition *)((Species const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Species, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Species_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Species, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Species_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Species_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(Species *)\n"
    "    getDerivedUnitDefinition(Species const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getTypeCode" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (SBMLTypeCode_t)((Species const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_getElementName" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (std::string *) &((Species const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Species_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Species *arg1 = (Species *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Species_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Species, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Species_hasRequiredAttributes" "', argument " "1"" of type '" "Species const *""'"); 
  }
  arg1 = reinterpret_cast< Species * >(argp1);
  result = (bool)((Species const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Species_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Species, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfSpecies_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpecies *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpecies_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_clone" "', argument " "1"" of type '" "ListOfSpecies const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  result = (ListOfSpecies *)((ListOfSpecies const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpecies, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpecies_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_getTypeCode" "', argument " "1"" of type '" "ListOfSpecies const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  result = (SBMLTypeCode_t)((ListOfSpecies const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpecies_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_getItemTypeCode" "', argument " "1"" of type '" "ListOfSpecies const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  result = (SBMLTypeCode_t)((ListOfSpecies const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpecies_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_getElementName" "', argument " "1"" of type '" "ListOfSpecies const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  result = (std::string *) &((ListOfSpecies const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpecies_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_get" "', argument " "1"" of type '" "ListOfSpecies *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpecies_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpecies_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_get" "', argument " "1"" of type '" "ListOfSpecies const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpecies_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)((ListOfSpecies const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpecies_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_get" "', argument " "1"" of type '" "ListOfSpecies *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpecies_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpecies_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Species *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpecies_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_get" "', argument " "1"" of type '" "ListOfSpecies const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpecies_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpecies_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Species *)((ListOfSpecies const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpecies_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpecies_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpecies_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpecies_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfSpecies_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfSpecies *,unsigned int)\n"
    "    get(ListOfSpecies const *,unsigned int)\n"
    "    get(ListOfSpecies *,std::string const &)\n"
    "    get(ListOfSpecies const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpecies_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_remove" "', argument " "1"" of type '" "ListOfSpecies *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpecies_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Species *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Species *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpecies_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpecies_remove" "', argument " "1"" of type '" "ListOfSpecies *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpecies_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpecies_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Species *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Species, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpecies_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpecies_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpecies, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpecies_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfSpecies_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfSpecies *,unsigned int)\n"
    "    remove(ListOfSpecies *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfSpecies")) SWIG_fail;
  result = (ListOfSpecies *)new ListOfSpecies();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpecies, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpecies *arg1 = (ListOfSpecies *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpecies, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfSpecies" "', argument " "1"" of type '" "ListOfSpecies *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpecies * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfSpecies_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfSpecies, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Parameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Parameter",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Parameter" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Parameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Parameter *)new Parameter(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Parameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Parameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Parameter" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Parameter *)new Parameter(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Parameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Parameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Parameter" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Parameter__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Parameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Parameter,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Parameter" "', argument " "1"" of type '" "Parameter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Parameter" "', argument " "1"" of type '" "Parameter const &""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    try {
      result = (Parameter *)new Parameter((Parameter const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Parameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Parameter__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Parameter__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Parameter__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Parameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Parameter(unsigned int,unsigned int)\n"
    "    Parameter(SBMLNamespaces *)\n"
    "    Parameter(Parameter const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_clone" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (Parameter *)((Parameter const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_initDefaults(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_initDefaults",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_initDefaults" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  (arg1)->initDefaults();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getId" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (std::string *) &((Parameter const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getName" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (std::string *) &((Parameter const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getValue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getValue",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getValue" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (double)((Parameter const *)arg1)->getValue();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getUnits" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (std::string *) &((Parameter const *)arg1)->getUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getConstant" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->getConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_isSetId" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_isSetName" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_isSetValue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_isSetValue",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_isSetValue" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetValue();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_isSetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_isSetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_isSetUnits" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_isSetConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_isSetConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_isSetConstant" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->isSetConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setId" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setName" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setValue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setValue" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Parameter_setValue" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setValue(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setUnits" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Parameter_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Parameter_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_setConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Parameter_setConstant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_setConstant" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Parameter_setConstant" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setConstant(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_unsetName" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_unsetValue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_unsetValue",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_unsetValue" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (int)(arg1)->unsetValue();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_unsetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_unsetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_unsetUnits" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (int)(arg1)->unsetUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getDerivedUnitDefinition" "', argument " "1"" of type '" "Parameter *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getDerivedUnitDefinition" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (UnitDefinition *)((Parameter const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Parameter_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Parameter_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Parameter_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(Parameter *)\n"
    "    getDerivedUnitDefinition(Parameter const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getTypeCode" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (SBMLTypeCode_t)((Parameter const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_getElementName" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (std::string *) &((Parameter const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Parameter_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Parameter_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Parameter_hasRequiredAttributes" "', argument " "1"" of type '" "Parameter const *""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  result = (bool)((Parameter const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Parameter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Parameter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfParameters_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfParameters_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_clone" "', argument " "1"" of type '" "ListOfParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  result = (ListOfParameters *)((ListOfParameters const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfParameters_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_getTypeCode" "', argument " "1"" of type '" "ListOfParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  result = (SBMLTypeCode_t)((ListOfParameters const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfParameters_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_getItemTypeCode" "', argument " "1"" of type '" "ListOfParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  result = (SBMLTypeCode_t)((ListOfParameters const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfParameters_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_getElementName" "', argument " "1"" of type '" "ListOfParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  result = (std::string *) &((ListOfParameters const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_get" "', argument " "1"" of type '" "ListOfParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfParameters_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_get" "', argument " "1"" of type '" "ListOfParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfParameters_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)((ListOfParameters const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_get" "', argument " "1"" of type '" "ListOfParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_get" "', argument " "1"" of type '" "ListOfParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)((ListOfParameters const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfParameters_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfParameters_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfParameters_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfParameters_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfParameters_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfParameters *,unsigned int)\n"
    "    get(ListOfParameters const *,unsigned int)\n"
    "    get(ListOfParameters *,std::string const &)\n"
    "    get(ListOfParameters const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfParameters_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_remove" "', argument " "1"" of type '" "ListOfParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfParameters_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfParameters_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfParameters_remove" "', argument " "1"" of type '" "ListOfParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfParameters_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfParameters_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfParameters_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfParameters_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfParameters_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfParameters_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfParameters *,unsigned int)\n"
    "    remove(ListOfParameters *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfParameters")) SWIG_fail;
  result = (ListOfParameters *)new ListOfParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfParameters *arg1 = (ListOfParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfParameters, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfParameters" "', argument " "1"" of type '" "ListOfParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfParameters * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfParameters_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfParameters, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_LocalParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_LocalParameter",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_LocalParameter" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_LocalParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (LocalParameter *)new LocalParameter(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_LocalParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_LocalParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_LocalParameter" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (LocalParameter *)new LocalParameter(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_LocalParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_LocalParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_LocalParameter" "', argument " "1"" of type '" "LocalParameter *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_LocalParameter__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_LocalParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_LocalParameter,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_LocalParameter" "', argument " "1"" of type '" "LocalParameter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_LocalParameter" "', argument " "1"" of type '" "LocalParameter const &""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  {
    try {
      result = (LocalParameter *)new LocalParameter((LocalParameter const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_LocalParameter__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Parameter *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_LocalParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Parameter,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_LocalParameter" "', argument " "1"" of type '" "Parameter const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_LocalParameter" "', argument " "1"" of type '" "Parameter const &""'"); 
  }
  arg1 = reinterpret_cast< Parameter * >(argp1);
  {
    try {
      result = (LocalParameter *)new LocalParameter((Parameter const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_LocalParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalParameter__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_LocalParameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalParameter__SWIG_2(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Parameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_LocalParameter__SWIG_3(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_LocalParameter__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_LocalParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    LocalParameter(unsigned int,unsigned int)\n"
    "    LocalParameter(SBMLNamespaces *)\n"
    "    LocalParameter(LocalParameter const &)\n"
    "    LocalParameter(Parameter const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LocalParameter_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LocalParameter_clone" "', argument " "1"" of type '" "LocalParameter const *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (LocalParameter *)((LocalParameter const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LocalParameter_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LocalParameter_getDerivedUnitDefinition" "', argument " "1"" of type '" "LocalParameter *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LocalParameter_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LocalParameter_getDerivedUnitDefinition" "', argument " "1"" of type '" "LocalParameter const *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (UnitDefinition *)((LocalParameter const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_LocalParameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_LocalParameter_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_LocalParameter, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_LocalParameter_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'LocalParameter_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(LocalParameter *)\n"
    "    getDerivedUnitDefinition(LocalParameter const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LocalParameter_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LocalParameter_getTypeCode" "', argument " "1"" of type '" "LocalParameter const *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (SBMLTypeCode_t)((LocalParameter const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LocalParameter_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LocalParameter_getElementName" "', argument " "1"" of type '" "LocalParameter const *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (std::string *) &((LocalParameter const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_LocalParameter_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  LocalParameter *arg1 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:LocalParameter_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LocalParameter_hasRequiredAttributes" "', argument " "1"" of type '" "LocalParameter const *""'"); 
  }
  arg1 = reinterpret_cast< LocalParameter * >(argp1);
  result = (bool)((LocalParameter const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *LocalParameter_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_LocalParameter, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfLocalParameters_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfLocalParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfLocalParameters_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_clone" "', argument " "1"" of type '" "ListOfLocalParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  result = (ListOfLocalParameters *)((ListOfLocalParameters const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfLocalParameters, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfLocalParameters_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_getTypeCode" "', argument " "1"" of type '" "ListOfLocalParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  result = (SBMLTypeCode_t)((ListOfLocalParameters const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfLocalParameters_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_getItemTypeCode" "', argument " "1"" of type '" "ListOfLocalParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  result = (SBMLTypeCode_t)((ListOfLocalParameters const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfLocalParameters_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_getElementName" "', argument " "1"" of type '" "ListOfLocalParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  result = (std::string *) &((ListOfLocalParameters const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfLocalParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_get" "', argument " "1"" of type '" "ListOfLocalParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfLocalParameters_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfLocalParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_get" "', argument " "1"" of type '" "ListOfLocalParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfLocalParameters_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)((ListOfLocalParameters const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfLocalParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_get" "', argument " "1"" of type '" "ListOfLocalParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfLocalParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfLocalParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfLocalParameters_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_get" "', argument " "1"" of type '" "ListOfLocalParameters const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfLocalParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfLocalParameters_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)((ListOfLocalParameters const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfLocalParameters_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfLocalParameters_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfLocalParameters_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfLocalParameters_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfLocalParameters_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfLocalParameters *,unsigned int)\n"
    "    get(ListOfLocalParameters const *,unsigned int)\n"
    "    get(ListOfLocalParameters *,std::string const &)\n"
    "    get(ListOfLocalParameters const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfLocalParameters_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_remove" "', argument " "1"" of type '" "ListOfLocalParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfLocalParameters_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfLocalParameters_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfLocalParameters_remove" "', argument " "1"" of type '" "ListOfLocalParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfLocalParameters_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfLocalParameters_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfLocalParameters_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfLocalParameters_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfLocalParameters, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfLocalParameters_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfLocalParameters_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfLocalParameters *,unsigned int)\n"
    "    remove(ListOfLocalParameters *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfLocalParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfLocalParameters")) SWIG_fail;
  result = (ListOfLocalParameters *)new ListOfLocalParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfLocalParameters, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfLocalParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfLocalParameters *arg1 = (ListOfLocalParameters *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfLocalParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfLocalParameters, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfLocalParameters" "', argument " "1"" of type '" "ListOfLocalParameters *""'"); 
  }
  arg1 = reinterpret_cast< ListOfLocalParameters * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfLocalParameters_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfLocalParameters, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_InitialAssignment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_InitialAssignment",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_InitialAssignment" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_InitialAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (InitialAssignment *)new InitialAssignment(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_InitialAssignment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_InitialAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InitialAssignment" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (InitialAssignment *)new InitialAssignment(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_InitialAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_InitialAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_InitialAssignment" "', argument " "1"" of type '" "InitialAssignment *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_InitialAssignment__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_InitialAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_InitialAssignment,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_InitialAssignment" "', argument " "1"" of type '" "InitialAssignment const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_InitialAssignment" "', argument " "1"" of type '" "InitialAssignment const &""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  {
    try {
      result = (InitialAssignment *)new InitialAssignment((InitialAssignment const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_InitialAssignment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InitialAssignment__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_InitialAssignment__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_InitialAssignment__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_InitialAssignment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    InitialAssignment(unsigned int,unsigned int)\n"
    "    InitialAssignment(SBMLNamespaces *)\n"
    "    InitialAssignment(InitialAssignment const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_clone" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (InitialAssignment *)((InitialAssignment const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getSymbol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getSymbol",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getSymbol" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (std::string *) &((InitialAssignment const *)arg1)->getSymbol();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getMath" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (ASTNode *)((InitialAssignment const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_isSetSymbol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_isSetSymbol",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_isSetSymbol" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->isSetSymbol();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_isSetMath" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_setSymbol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:InitialAssignment_setSymbol",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_setSymbol" "', argument " "1"" of type '" "InitialAssignment *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InitialAssignment_setSymbol" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "InitialAssignment_setSymbol" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSymbol((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:InitialAssignment_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_setMath" "', argument " "1"" of type '" "InitialAssignment *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "InitialAssignment_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getDerivedUnitDefinition" "', argument " "1"" of type '" "InitialAssignment *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getDerivedUnitDefinition" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (UnitDefinition *)((InitialAssignment const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_InitialAssignment_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_InitialAssignment_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'InitialAssignment_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(InitialAssignment *)\n"
    "    getDerivedUnitDefinition(InitialAssignment const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_containsUndeclaredUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_containsUndeclaredUnits" "', argument " "1"" of type '" "InitialAssignment *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_containsUndeclaredUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_containsUndeclaredUnits" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_containsUndeclaredUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_InitialAssignment_containsUndeclaredUnits__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_InitialAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_InitialAssignment_containsUndeclaredUnits__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'InitialAssignment_containsUndeclaredUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    containsUndeclaredUnits(InitialAssignment *)\n"
    "    containsUndeclaredUnits(InitialAssignment const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getTypeCode" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (SBMLTypeCode_t)((InitialAssignment const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getElementName" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (std::string *) &((InitialAssignment const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_hasRequiredAttributes" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_hasRequiredElements" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = (bool)((InitialAssignment const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_InitialAssignment_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  InitialAssignment *arg1 = (InitialAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:InitialAssignment_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InitialAssignment_getId" "', argument " "1"" of type '" "InitialAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< InitialAssignment * >(argp1);
  result = ((InitialAssignment const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *InitialAssignment_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_InitialAssignment, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfInitialAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfInitialAssignments_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_clone" "', argument " "1"" of type '" "ListOfInitialAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  result = (ListOfInitialAssignments *)((ListOfInitialAssignments const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfInitialAssignments, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfInitialAssignments_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_getTypeCode" "', argument " "1"" of type '" "ListOfInitialAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  result = (SBMLTypeCode_t)((ListOfInitialAssignments const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfInitialAssignments_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_getItemTypeCode" "', argument " "1"" of type '" "ListOfInitialAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  result = (SBMLTypeCode_t)((ListOfInitialAssignments const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfInitialAssignments_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_getElementName" "', argument " "1"" of type '" "ListOfInitialAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  result = (std::string *) &((ListOfInitialAssignments const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfInitialAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_get" "', argument " "1"" of type '" "ListOfInitialAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfInitialAssignments_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfInitialAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_get" "', argument " "1"" of type '" "ListOfInitialAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfInitialAssignments_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)((ListOfInitialAssignments const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfInitialAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_get" "', argument " "1"" of type '" "ListOfInitialAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfInitialAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfInitialAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfInitialAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_get" "', argument " "1"" of type '" "ListOfInitialAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfInitialAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfInitialAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)((ListOfInitialAssignments const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfInitialAssignments_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfInitialAssignments_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfInitialAssignments_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfInitialAssignments_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfInitialAssignments_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfInitialAssignments *,unsigned int)\n"
    "    get(ListOfInitialAssignments const *,unsigned int)\n"
    "    get(ListOfInitialAssignments *,std::string const &)\n"
    "    get(ListOfInitialAssignments const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfInitialAssignments_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_remove" "', argument " "1"" of type '" "ListOfInitialAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfInitialAssignments_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (InitialAssignment *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  InitialAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfInitialAssignments_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfInitialAssignments_remove" "', argument " "1"" of type '" "ListOfInitialAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfInitialAssignments_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfInitialAssignments_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (InitialAssignment *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_InitialAssignment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfInitialAssignments_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfInitialAssignments_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfInitialAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfInitialAssignments_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfInitialAssignments_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfInitialAssignments *,unsigned int)\n"
    "    remove(ListOfInitialAssignments *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfInitialAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfInitialAssignments")) SWIG_fail;
  result = (ListOfInitialAssignments *)new ListOfInitialAssignments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfInitialAssignments, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfInitialAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfInitialAssignments *arg1 = (ListOfInitialAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfInitialAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfInitialAssignments, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfInitialAssignments" "', argument " "1"" of type '" "ListOfInitialAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfInitialAssignments * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfInitialAssignments_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfInitialAssignments, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_Rule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Rule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Rule" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Rule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Rule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Rule,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Rule" "', argument " "1"" of type '" "Rule const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Rule" "', argument " "1"" of type '" "Rule const &""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (Rule *)new Rule((Rule const &)*arg1);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_NEW |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_clone" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (Rule *)((Rule const *)arg1)->clone();
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getFormula",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getFormula" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (std::string *) &((Rule const *)arg1)->getFormula();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getMath" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (ASTNode *)((Rule const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getVariable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getVariable",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getVariable" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (std::string *) &((Rule const *)arg1)->getVariable();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getUnits" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (std::string *) &((Rule const *)arg1)->getUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isSetFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isSetFormula",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isSetFormula" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSetFormula();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isSetMath" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isSetVariable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isSetVariable",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isSetVariable" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSetVariable();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isSetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isSetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isSetUnits" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSetUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_setFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Rule_setFormula",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_setFormula" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rule_setFormula" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Rule_setFormula" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setFormula((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Rule_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_setMath" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rule_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_setVariable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Rule_setVariable",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_setVariable" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rule_setVariable" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Rule_setVariable" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setVariable((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_setUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Rule_setUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_setUnits" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Rule_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Rule_setUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_unsetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_unsetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_unsetUnits" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (int)(arg1)->unsetUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getDerivedUnitDefinition" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getDerivedUnitDefinition" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (UnitDefinition *)((Rule const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Rule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Rule_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Rule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Rule_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Rule_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(Rule *)\n"
    "    getDerivedUnitDefinition(Rule const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_containsUndeclaredUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_containsUndeclaredUnits" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_containsUndeclaredUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_containsUndeclaredUnits" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_containsUndeclaredUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Rule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Rule_containsUndeclaredUnits__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Rule, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Rule_containsUndeclaredUnits__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Rule_containsUndeclaredUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    containsUndeclaredUnits(Rule *)\n"
    "    containsUndeclaredUnits(Rule const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  RuleType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getType" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (RuleType_t)((Rule const *)arg1)->getType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isAlgebraic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isAlgebraic",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isAlgebraic" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isAlgebraic();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isAssignment" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isAssignment();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isCompartmentVolume(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isCompartmentVolume",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isCompartmentVolume" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isCompartmentVolume();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isParameter" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isParameter();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isRate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isRate",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isRate" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isRate();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isScalar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isScalar",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isScalar" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isScalar();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_isSpeciesConcentration(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_isSpeciesConcentration",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_isSpeciesConcentration" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->isSpeciesConcentration();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getTypeCode" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (SBMLTypeCode_t)((Rule const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getL1TypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getL1TypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getL1TypeCode" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (SBMLTypeCode_t)((Rule const *)arg1)->getL1TypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getElementName" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (std::string *) &((Rule const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_setL1TypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  SBMLTypeCode_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Rule_setL1TypeCode",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_setL1TypeCode" "', argument " "1"" of type '" "Rule *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Rule_setL1TypeCode" "', argument " "2"" of type '" "SBMLTypeCode_t""'");
  } 
  arg2 = static_cast< SBMLTypeCode_t >(val2);
  result = (int)(arg1)->setL1TypeCode(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_hasRequiredElements" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_hasRequiredAttributes" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = (bool)((Rule const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Rule_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Rule *arg1 = (Rule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Rule_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Rule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Rule_getId" "', argument " "1"" of type '" "Rule const *""'"); 
  }
  arg1 = reinterpret_cast< Rule * >(argp1);
  result = ((Rule const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Rule_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Rule, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_AlgebraicRule__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  AlgebraicRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_AlgebraicRule",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_AlgebraicRule" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_AlgebraicRule" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (AlgebraicRule *)new AlgebraicRule(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AlgebraicRule, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_AlgebraicRule__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  AlgebraicRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_AlgebraicRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_AlgebraicRule" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (AlgebraicRule *)new AlgebraicRule(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AlgebraicRule, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_AlgebraicRule(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AlgebraicRule__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_AlgebraicRule__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_AlgebraicRule'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    AlgebraicRule(unsigned int,unsigned int)\n"
    "    AlgebraicRule(SBMLNamespaces *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_AlgebraicRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AlgebraicRule *arg1 = (AlgebraicRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_AlgebraicRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AlgebraicRule, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AlgebraicRule" "', argument " "1"" of type '" "AlgebraicRule *""'"); 
  }
  arg1 = reinterpret_cast< AlgebraicRule * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AlgebraicRule_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AlgebraicRule *arg1 = (AlgebraicRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  AlgebraicRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AlgebraicRule_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AlgebraicRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AlgebraicRule_clone" "', argument " "1"" of type '" "AlgebraicRule const *""'"); 
  }
  arg1 = reinterpret_cast< AlgebraicRule * >(argp1);
  result = (AlgebraicRule *)((AlgebraicRule const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AlgebraicRule, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AlgebraicRule_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AlgebraicRule *arg1 = (AlgebraicRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AlgebraicRule_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AlgebraicRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AlgebraicRule_hasRequiredAttributes" "', argument " "1"" of type '" "AlgebraicRule const *""'"); 
  }
  arg1 = reinterpret_cast< AlgebraicRule * >(argp1);
  result = (bool)((AlgebraicRule const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *AlgebraicRule_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_AlgebraicRule, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_AssignmentRule__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  AssignmentRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_AssignmentRule",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_AssignmentRule" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_AssignmentRule" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (AssignmentRule *)new AssignmentRule(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AssignmentRule, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_AssignmentRule__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  AssignmentRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_AssignmentRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_AssignmentRule" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (AssignmentRule *)new AssignmentRule(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AssignmentRule, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_AssignmentRule(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_AssignmentRule__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_AssignmentRule__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_AssignmentRule'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    AssignmentRule(unsigned int,unsigned int)\n"
    "    AssignmentRule(SBMLNamespaces *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_AssignmentRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AssignmentRule *arg1 = (AssignmentRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_AssignmentRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AssignmentRule, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_AssignmentRule" "', argument " "1"" of type '" "AssignmentRule *""'"); 
  }
  arg1 = reinterpret_cast< AssignmentRule * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AssignmentRule_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AssignmentRule *arg1 = (AssignmentRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  AssignmentRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AssignmentRule_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AssignmentRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AssignmentRule_clone" "', argument " "1"" of type '" "AssignmentRule const *""'"); 
  }
  arg1 = reinterpret_cast< AssignmentRule * >(argp1);
  result = (AssignmentRule *)((AssignmentRule const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_AssignmentRule, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AssignmentRule_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  AssignmentRule *arg1 = (AssignmentRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:AssignmentRule_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_AssignmentRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AssignmentRule_hasRequiredAttributes" "', argument " "1"" of type '" "AssignmentRule const *""'"); 
  }
  arg1 = reinterpret_cast< AssignmentRule * >(argp1);
  result = (bool)((AssignmentRule const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *AssignmentRule_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_AssignmentRule, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_RateRule__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  RateRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_RateRule",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_RateRule" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_RateRule" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (RateRule *)new RateRule(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RateRule, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_RateRule__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  RateRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_RateRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RateRule" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (RateRule *)new RateRule(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RateRule, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_RateRule(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_RateRule__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_RateRule__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_RateRule'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    RateRule(unsigned int,unsigned int)\n"
    "    RateRule(SBMLNamespaces *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RateRule(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  RateRule *arg1 = (RateRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_RateRule",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_RateRule, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RateRule" "', argument " "1"" of type '" "RateRule *""'"); 
  }
  arg1 = reinterpret_cast< RateRule * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RateRule_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  RateRule *arg1 = (RateRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  RateRule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RateRule_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_RateRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RateRule_clone" "', argument " "1"" of type '" "RateRule const *""'"); 
  }
  arg1 = reinterpret_cast< RateRule * >(argp1);
  result = (RateRule *)((RateRule const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RateRule, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RateRule_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  RateRule *arg1 = (RateRule *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RateRule_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_RateRule, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RateRule_hasRequiredAttributes" "', argument " "1"" of type '" "RateRule const *""'"); 
  }
  arg1 = reinterpret_cast< RateRule * >(argp1);
  result = (bool)((RateRule const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *RateRule_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_RateRule, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfRules_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfRules *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfRules_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_clone" "', argument " "1"" of type '" "ListOfRules const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  result = (ListOfRules *)((ListOfRules const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfRules, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfRules_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_getTypeCode" "', argument " "1"" of type '" "ListOfRules const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  result = (SBMLTypeCode_t)((ListOfRules const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfRules_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_getItemTypeCode" "', argument " "1"" of type '" "ListOfRules const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  result = (SBMLTypeCode_t)((ListOfRules const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfRules_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_getElementName" "', argument " "1"" of type '" "ListOfRules const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  result = (std::string *) &((ListOfRules const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfRules_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_get" "', argument " "1"" of type '" "ListOfRules *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfRules_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)(arg1)->get(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfRules_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_get" "', argument " "1"" of type '" "ListOfRules const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfRules_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)((ListOfRules const *)arg1)->get(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfRules_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_get" "', argument " "1"" of type '" "ListOfRules *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfRules_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfRules_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Rule *)(arg1)->get((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfRules_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_get" "', argument " "1"" of type '" "ListOfRules const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfRules_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfRules_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Rule *)((ListOfRules const *)arg1)->get((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfRules_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfRules_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfRules_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfRules_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfRules_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfRules *,unsigned int)\n"
    "    get(ListOfRules const *,unsigned int)\n"
    "    get(ListOfRules *,std::string const &)\n"
    "    get(ListOfRules const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfRules_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_remove" "', argument " "1"" of type '" "ListOfRules *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfRules_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Rule *)(arg1)->remove(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Rule *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfRules_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfRules_remove" "', argument " "1"" of type '" "ListOfRules *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfRules_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfRules_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Rule *)(arg1)->remove((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfRules_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfRules_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfRules, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfRules_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfRules_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfRules *,unsigned int)\n"
    "    remove(ListOfRules *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfRules(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfRules")) SWIG_fail;
  result = (ListOfRules *)new ListOfRules();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfRules, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfRules(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfRules *arg1 = (ListOfRules *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfRules",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfRules, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfRules" "', argument " "1"" of type '" "ListOfRules *""'"); 
  }
  arg1 = reinterpret_cast< ListOfRules * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfRules_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfRules, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Constraint__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Constraint",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Constraint" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Constraint" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Constraint *)new Constraint(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Constraint__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Constraint",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Constraint" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Constraint *)new Constraint(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Constraint(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Constraint",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Constraint" "', argument " "1"" of type '" "Constraint *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Constraint__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Constraint",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Constraint,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Constraint" "', argument " "1"" of type '" "Constraint const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Constraint" "', argument " "1"" of type '" "Constraint const &""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  {
    try {
      result = (Constraint *)new Constraint((Constraint const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Constraint(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Constraint__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Constraint, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Constraint__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Constraint__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Constraint'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Constraint(unsigned int,unsigned int)\n"
    "    Constraint(SBMLNamespaces *)\n"
    "    Constraint(Constraint const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_clone" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (Constraint *)((Constraint const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_getMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_getMessage",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_getMessage" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (XMLNode *)((Constraint const *)arg1)->getMessage();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_getMessageString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_getMessageString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_getMessageString" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = ((Constraint const *)arg1)->getMessageString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_getMath" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (ASTNode *)((Constraint const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_isSetMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_isSetMessage",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_isSetMessage" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (bool)((Constraint const *)arg1)->isSetMessage();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_isSetMath" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (bool)((Constraint const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_setMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Constraint_setMessage",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_setMessage" "', argument " "1"" of type '" "Constraint *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Constraint_setMessage" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setMessage((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Constraint_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_setMath" "', argument " "1"" of type '" "Constraint *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Constraint_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_unsetMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_unsetMessage",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_unsetMessage" "', argument " "1"" of type '" "Constraint *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (int)(arg1)->unsetMessage();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_getTypeCode" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (SBMLTypeCode_t)((Constraint const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_getElementName" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (std::string *) &((Constraint const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Constraint_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Constraint *arg1 = (Constraint *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Constraint_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Constraint, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Constraint_hasRequiredElements" "', argument " "1"" of type '" "Constraint const *""'"); 
  }
  arg1 = reinterpret_cast< Constraint * >(argp1);
  result = (bool)((Constraint const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Constraint_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Constraint, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfConstraints_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfConstraints *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfConstraints_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_clone" "', argument " "1"" of type '" "ListOfConstraints const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  result = (ListOfConstraints *)((ListOfConstraints const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfConstraints, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfConstraints_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_getTypeCode" "', argument " "1"" of type '" "ListOfConstraints const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  result = (SBMLTypeCode_t)((ListOfConstraints const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfConstraints_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_getItemTypeCode" "', argument " "1"" of type '" "ListOfConstraints const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  result = (SBMLTypeCode_t)((ListOfConstraints const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfConstraints_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_getElementName" "', argument " "1"" of type '" "ListOfConstraints const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  result = (std::string *) &((ListOfConstraints const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfConstraints_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_get" "', argument " "1"" of type '" "ListOfConstraints *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfConstraints_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfConstraints_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_get" "', argument " "1"" of type '" "ListOfConstraints const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfConstraints_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)((ListOfConstraints const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfConstraints, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfConstraints_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfConstraints, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfConstraints_get__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfConstraints_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfConstraints *,unsigned int)\n"
    "    get(ListOfConstraints const *,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfConstraints_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Constraint *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfConstraints_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfConstraints_remove" "', argument " "1"" of type '" "ListOfConstraints *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfConstraints_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Constraint *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Constraint, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfConstraints(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfConstraints")) SWIG_fail;
  result = (ListOfConstraints *)new ListOfConstraints();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfConstraints, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfConstraints(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfConstraints *arg1 = (ListOfConstraints *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfConstraints",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfConstraints, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfConstraints" "', argument " "1"" of type '" "ListOfConstraints *""'"); 
  }
  arg1 = reinterpret_cast< ListOfConstraints * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfConstraints_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfConstraints, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Reaction__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Reaction",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Reaction" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Reaction" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Reaction *)new Reaction(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Reaction__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Reaction",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Reaction" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Reaction *)new Reaction(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Reaction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Reaction",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Reaction" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Reaction__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Reaction",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Reaction,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Reaction" "', argument " "1"" of type '" "Reaction const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Reaction" "', argument " "1"" of type '" "Reaction const &""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    try {
      result = (Reaction *)new Reaction((Reaction const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Reaction(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Reaction__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Reaction__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Reaction__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Reaction'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Reaction(unsigned int,unsigned int)\n"
    "    Reaction(SBMLNamespaces *)\n"
    "    Reaction(Reaction const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_clone" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (Reaction *)((Reaction const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_initDefaults(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_initDefaults",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_initDefaults" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  (arg1)->initDefaults();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getId" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (std::string *) &((Reaction const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getName" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (std::string *) &((Reaction const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getKineticLaw__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getKineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getKineticLaw" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (KineticLaw *)((Reaction const *)arg1)->getKineticLaw();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getKineticLaw__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getKineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getKineticLaw" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (KineticLaw *)(arg1)->getKineticLaw();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getKineticLaw(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getKineticLaw__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getKineticLaw__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getKineticLaw'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getKineticLaw(Reaction const *)\n"
    "    getKineticLaw(Reaction *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getReversible(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getReversible",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getReversible" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->getReversible();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getFast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getFast",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getFast" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->getFast();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getCompartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getCompartment" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (std::string *) &((Reaction const *)arg1)->getCompartment();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_isSetId" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_isSetName" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_isSetKineticLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_isSetKineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_isSetKineticLaw" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetKineticLaw();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_isSetFast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_isSetFast",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_isSetFast" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetFast();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_isSetCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_isSetCompartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_isSetCompartment" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetCompartment();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_isSetReversible(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_isSetReversible",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_isSetReversible" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->isSetReversible();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_setId" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_setName" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_setKineticLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  KineticLaw *arg2 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_setKineticLaw",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_setKineticLaw" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_setKineticLaw" "', argument " "2"" of type '" "KineticLaw const *""'"); 
  }
  arg2 = reinterpret_cast< KineticLaw * >(argp2);
  result = (int)(arg1)->setKineticLaw((KineticLaw const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_setReversible(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_setReversible",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_setReversible" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_setReversible" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setReversible(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_setFast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_setFast",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_setFast" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_setFast" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setFast(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_setCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_setCompartment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_setCompartment" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_setCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_setCompartment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setCompartment((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_unsetName" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_unsetKineticLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_unsetKineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_unsetKineticLaw" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (int)(arg1)->unsetKineticLaw();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_unsetFast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_unsetFast",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_unsetFast" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (int)(arg1)->unsetFast();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_unsetCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_unsetCompartment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_unsetCompartment" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (int)(arg1)->unsetCompartment();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_addReactant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  SpeciesReference *arg2 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_addReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_addReactant" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_addReactant" "', argument " "2"" of type '" "SpeciesReference const *""'"); 
  }
  arg2 = reinterpret_cast< SpeciesReference * >(argp2);
  result = (int)(arg1)->addReactant((SpeciesReference const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_addProduct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  SpeciesReference *arg2 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_addProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_addProduct" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_addProduct" "', argument " "2"" of type '" "SpeciesReference const *""'"); 
  }
  arg2 = reinterpret_cast< SpeciesReference * >(argp2);
  result = (int)(arg1)->addProduct((SpeciesReference const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_addModifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  ModifierSpeciesReference *arg2 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_addModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_addModifier" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_addModifier" "', argument " "2"" of type '" "ModifierSpeciesReference const *""'"); 
  }
  arg2 = reinterpret_cast< ModifierSpeciesReference * >(argp2);
  result = (int)(arg1)->addModifier((ModifierSpeciesReference const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_createReactant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_createReactant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_createReactant" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (SpeciesReference *)(arg1)->createReactant();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_createProduct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_createProduct",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_createProduct" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (SpeciesReference *)(arg1)->createProduct();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_createModifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_createModifier",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_createModifier" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ModifierSpeciesReference *)(arg1)->createModifier();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_createKineticLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_createKineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_createKineticLaw" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (KineticLaw *)(arg1)->createKineticLaw();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfReactants__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getListOfReactants",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getListOfReactants" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)((Reaction const *)arg1)->getListOfReactants();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfReactants__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getListOfReactants",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getListOfReactants" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)(arg1)->getListOfReactants();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfReactants(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfReactants__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfReactants__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getListOfReactants'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfReactants(Reaction const *)\n"
    "    getListOfReactants(Reaction *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfProducts__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getListOfProducts",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getListOfProducts" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)((Reaction const *)arg1)->getListOfProducts();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfProducts__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getListOfProducts",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getListOfProducts" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)(arg1)->getListOfProducts();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfProducts(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfProducts__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfProducts__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getListOfProducts'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfProducts(Reaction const *)\n"
    "    getListOfProducts(Reaction *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfModifiers__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getListOfModifiers",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getListOfModifiers" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)((Reaction const *)arg1)->getListOfModifiers();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfModifiers__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getListOfModifiers",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getListOfModifiers" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (ListOfSpeciesReferences *)(arg1)->getListOfModifiers();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getListOfModifiers(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfModifiers__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Reaction_getListOfModifiers__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getListOfModifiers'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfModifiers(Reaction const *)\n"
    "    getListOfModifiers(Reaction *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getReactant__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getReactant" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_getReactant" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)((Reaction const *)arg1)->getReactant(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getReactant__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getReactant" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_getReactant" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)(arg1)->getReactant(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getReactant__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getReactant" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_getReactant" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_getReactant" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)((Reaction const *)arg1)->getReactant((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getReactant__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getReactant" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_getReactant" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_getReactant" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->getReactant((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getReactant(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getReactant__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getReactant__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getReactant__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getReactant__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getReactant'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getReactant(Reaction const *,unsigned int)\n"
    "    getReactant(Reaction *,unsigned int)\n"
    "    getReactant(Reaction const *,std::string const &)\n"
    "    getReactant(Reaction *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getProduct__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getProduct" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_getProduct" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)((Reaction const *)arg1)->getProduct(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getProduct__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getProduct" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_getProduct" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)(arg1)->getProduct(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getProduct__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getProduct" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_getProduct" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_getProduct" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)((Reaction const *)arg1)->getProduct((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getProduct__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getProduct" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_getProduct" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_getProduct" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->getProduct((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getProduct(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getProduct__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getProduct__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getProduct__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getProduct__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getProduct'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getProduct(Reaction const *,unsigned int)\n"
    "    getProduct(Reaction *,unsigned int)\n"
    "    getProduct(Reaction const *,std::string const &)\n"
    "    getProduct(Reaction *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getModifier__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getModifier" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_getModifier" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModifierSpeciesReference *)((Reaction const *)arg1)->getModifier(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getModifier__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getModifier" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_getModifier" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModifierSpeciesReference *)(arg1)->getModifier(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getModifier__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getModifier" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_getModifier" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_getModifier" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (ModifierSpeciesReference *)((Reaction const *)arg1)->getModifier((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getModifier__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_getModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getModifier" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_getModifier" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_getModifier" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (ModifierSpeciesReference *)(arg1)->getModifier((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getModifier(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getModifier__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_getModifier__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getModifier__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_getModifier__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_getModifier'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getModifier(Reaction const *,unsigned int)\n"
    "    getModifier(Reaction *,unsigned int)\n"
    "    getModifier(Reaction const *,std::string const &)\n"
    "    getModifier(Reaction *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getNumReactants(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getNumReactants",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getNumReactants" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (unsigned int)((Reaction const *)arg1)->getNumReactants();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getNumProducts(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getNumProducts",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getNumProducts" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (unsigned int)((Reaction const *)arg1)->getNumProducts();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getNumModifiers(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getNumModifiers",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getNumModifiers" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (unsigned int)((Reaction const *)arg1)->getNumModifiers();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeReactant__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_removeReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_removeReactant" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_removeReactant" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)(arg1)->removeReactant(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeReactant__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_removeReactant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_removeReactant" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_removeReactant" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_removeReactant" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->removeReactant((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeReactant(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_removeReactant__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_removeReactant__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_removeReactant'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeReactant(Reaction *,unsigned int)\n"
    "    removeReactant(Reaction *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeProduct__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_removeProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_removeProduct" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_removeProduct" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SpeciesReference *)(arg1)->removeProduct(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeProduct__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_removeProduct",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_removeProduct" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_removeProduct" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_removeProduct" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SpeciesReference *)(arg1)->removeProduct((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeProduct(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_removeProduct__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_removeProduct__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_removeProduct'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeProduct(Reaction *,unsigned int)\n"
    "    removeProduct(Reaction *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeModifier__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_removeModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_removeModifier" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Reaction_removeModifier" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModifierSpeciesReference *)(arg1)->removeModifier(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeModifier__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Reaction_removeModifier",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_removeModifier" "', argument " "1"" of type '" "Reaction *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Reaction_removeModifier" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Reaction_removeModifier" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (ModifierSpeciesReference *)(arg1)->removeModifier((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_removeModifier(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Reaction_removeModifier__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Reaction, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Reaction_removeModifier__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Reaction_removeModifier'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeModifier(Reaction *,unsigned int)\n"
    "    removeModifier(Reaction *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getTypeCode" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (SBMLTypeCode_t)((Reaction const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_getElementName" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (std::string *) &((Reaction const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Reaction_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Reaction *arg1 = (Reaction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Reaction_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Reaction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Reaction_hasRequiredAttributes" "', argument " "1"" of type '" "Reaction const *""'"); 
  }
  arg1 = reinterpret_cast< Reaction * >(argp1);
  result = (bool)((Reaction const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Reaction_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Reaction, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfReactions_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfReactions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfReactions_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_clone" "', argument " "1"" of type '" "ListOfReactions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  result = (ListOfReactions *)((ListOfReactions const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfReactions, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfReactions_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_getTypeCode" "', argument " "1"" of type '" "ListOfReactions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  result = (SBMLTypeCode_t)((ListOfReactions const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfReactions_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_getItemTypeCode" "', argument " "1"" of type '" "ListOfReactions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  result = (SBMLTypeCode_t)((ListOfReactions const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfReactions_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_getElementName" "', argument " "1"" of type '" "ListOfReactions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  result = (std::string *) &((ListOfReactions const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfReactions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_get" "', argument " "1"" of type '" "ListOfReactions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfReactions_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfReactions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_get" "', argument " "1"" of type '" "ListOfReactions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfReactions_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)((ListOfReactions const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfReactions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_get" "', argument " "1"" of type '" "ListOfReactions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfReactions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfReactions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfReactions_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_get" "', argument " "1"" of type '" "ListOfReactions const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfReactions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfReactions_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)((ListOfReactions const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfReactions_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfReactions_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfReactions_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfReactions_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfReactions_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfReactions *,unsigned int)\n"
    "    get(ListOfReactions const *,unsigned int)\n"
    "    get(ListOfReactions *,std::string const &)\n"
    "    get(ListOfReactions const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfReactions_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_remove" "', argument " "1"" of type '" "ListOfReactions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfReactions_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Reaction *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Reaction *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfReactions_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfReactions_remove" "', argument " "1"" of type '" "ListOfReactions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfReactions_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfReactions_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Reaction *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Reaction, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfReactions_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfReactions_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfReactions, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfReactions_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfReactions_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfReactions *,unsigned int)\n"
    "    remove(ListOfReactions *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfReactions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfReactions")) SWIG_fail;
  result = (ListOfReactions *)new ListOfReactions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfReactions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfReactions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfReactions *arg1 = (ListOfReactions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfReactions",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfReactions, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfReactions" "', argument " "1"" of type '" "ListOfReactions *""'"); 
  }
  arg1 = reinterpret_cast< ListOfReactions * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfReactions_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfReactions, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_KineticLaw__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_KineticLaw",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_KineticLaw" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_KineticLaw" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (KineticLaw *)new KineticLaw(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_KineticLaw__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_KineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_KineticLaw" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (KineticLaw *)new KineticLaw(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_KineticLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_KineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_KineticLaw" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_KineticLaw__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_KineticLaw",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_KineticLaw,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_KineticLaw" "', argument " "1"" of type '" "KineticLaw const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_KineticLaw" "', argument " "1"" of type '" "KineticLaw const &""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    try {
      result = (KineticLaw *)new KineticLaw((KineticLaw const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_KineticLaw(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_KineticLaw__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_KineticLaw__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_KineticLaw__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_KineticLaw'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    KineticLaw(unsigned int,unsigned int)\n"
    "    KineticLaw(SBMLNamespaces *)\n"
    "    KineticLaw(KineticLaw const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  KineticLaw *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_clone" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (KineticLaw *)((KineticLaw const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_KineticLaw, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getFormula",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getFormula" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (std::string *) &((KineticLaw const *)arg1)->getFormula();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getMath" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ASTNode *)((KineticLaw const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getTimeUnits" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (std::string *) &((KineticLaw const *)arg1)->getTimeUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getSubstanceUnits" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (std::string *) &((KineticLaw const *)arg1)->getSubstanceUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_isSetFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_isSetFormula",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_isSetFormula" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->isSetFormula();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_isSetMath" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_isSetTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_isSetTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_isSetTimeUnits" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->isSetTimeUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_isSetSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_isSetSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_isSetSubstanceUnits" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->isSetSubstanceUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_setFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_setFormula",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_setFormula" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_setFormula" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_setFormula" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setFormula((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_setMath" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_setTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_setTimeUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_setTimeUnits" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_setTimeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_setTimeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setTimeUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_setSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_setSubstanceUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_setSubstanceUnits" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_setSubstanceUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_setSubstanceUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSubstanceUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_unsetTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_unsetTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_unsetTimeUnits" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (int)(arg1)->unsetTimeUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_unsetSubstanceUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_unsetSubstanceUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_unsetSubstanceUnits" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (int)(arg1)->unsetSubstanceUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_addParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  Parameter *arg2 = (Parameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_addParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_addParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Parameter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_addParameter" "', argument " "2"" of type '" "Parameter const *""'"); 
  }
  arg2 = reinterpret_cast< Parameter * >(argp2);
  result = (int)(arg1)->addParameter((Parameter const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_addLocalParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  LocalParameter *arg2 = (LocalParameter *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_addLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_addLocalParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_addLocalParameter" "', argument " "2"" of type '" "LocalParameter const *""'"); 
  }
  arg2 = reinterpret_cast< LocalParameter * >(argp2);
  result = (int)(arg1)->addLocalParameter((LocalParameter const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_createParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_createParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_createParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (Parameter *)(arg1)->createParameter();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_createLocalParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_createLocalParameter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_createLocalParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (LocalParameter *)(arg1)->createLocalParameter();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getListOfParameters__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getListOfParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getListOfParameters" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ListOfParameters *)((KineticLaw const *)arg1)->getListOfParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getListOfParameters__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getListOfParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getListOfParameters" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ListOfParameters *)(arg1)->getListOfParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfParameters, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getListOfParameters(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getListOfParameters__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getListOfParameters__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_getListOfParameters'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfParameters(KineticLaw const *)\n"
    "    getListOfParameters(KineticLaw *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getListOfLocalParameters__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfLocalParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getListOfLocalParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getListOfLocalParameters" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ListOfLocalParameters *)((KineticLaw const *)arg1)->getListOfLocalParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getListOfLocalParameters__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfLocalParameters *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getListOfLocalParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getListOfLocalParameters" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (ListOfLocalParameters *)(arg1)->getListOfLocalParameters();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfLocalParameters, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getListOfLocalParameters(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getListOfLocalParameters__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getListOfLocalParameters__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_getListOfLocalParameters'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfLocalParameters(KineticLaw const *)\n"
    "    getListOfLocalParameters(KineticLaw *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getParameter" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "KineticLaw_getParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)((KineticLaw const *)arg1)->getParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "KineticLaw_getParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->getParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getLocalParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getLocalParameter" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "KineticLaw_getLocalParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)((KineticLaw const *)arg1)->getLocalParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getLocalParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getLocalParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "KineticLaw_getLocalParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)(arg1)->getLocalParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getParameter__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getParameter" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)((KineticLaw const *)arg1)->getParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getParameter__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_getParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->getParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_getParameter__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_getParameter__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_getParameter__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_getParameter__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_getParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getParameter(KineticLaw const *,unsigned int)\n"
    "    getParameter(KineticLaw *,unsigned int)\n"
    "    getParameter(KineticLaw const *,std::string const &)\n"
    "    getParameter(KineticLaw *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getLocalParameter__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getLocalParameter" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_getLocalParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_getLocalParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)((KineticLaw const *)arg1)->getLocalParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getLocalParameter__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_getLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getLocalParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_getLocalParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_getLocalParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)(arg1)->getLocalParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getLocalParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_getLocalParameter__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_getLocalParameter__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_getLocalParameter__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_getLocalParameter__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_getLocalParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getLocalParameter(KineticLaw const *,unsigned int)\n"
    "    getLocalParameter(KineticLaw *,unsigned int)\n"
    "    getLocalParameter(KineticLaw const *,std::string const &)\n"
    "    getLocalParameter(KineticLaw *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getNumParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getNumParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getNumParameters" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (unsigned int)((KineticLaw const *)arg1)->getNumParameters();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getNumLocalParameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getNumLocalParameters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getNumLocalParameters" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (unsigned int)((KineticLaw const *)arg1)->getNumLocalParameters();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getDerivedUnitDefinition" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getDerivedUnitDefinition" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (UnitDefinition *)((KineticLaw const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(KineticLaw *)\n"
    "    getDerivedUnitDefinition(KineticLaw const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_containsUndeclaredUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_containsUndeclaredUnits" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_containsUndeclaredUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_containsUndeclaredUnits" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_containsUndeclaredUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_containsUndeclaredUnits__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_KineticLaw_containsUndeclaredUnits__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_containsUndeclaredUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    containsUndeclaredUnits(KineticLaw *)\n"
    "    containsUndeclaredUnits(KineticLaw const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_removeParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_removeParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_removeParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "KineticLaw_removeParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Parameter *)(arg1)->removeParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_removeLocalParameter__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_removeLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_removeLocalParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "KineticLaw_removeLocalParameter" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (LocalParameter *)(arg1)->removeLocalParameter(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_removeParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Parameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_removeParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_removeParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_removeParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_removeParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Parameter *)(arg1)->removeParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Parameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_removeParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_removeParameter__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_removeParameter__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_removeParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeParameter(KineticLaw *,unsigned int)\n"
    "    removeParameter(KineticLaw *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_removeLocalParameter__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  LocalParameter *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:KineticLaw_removeLocalParameter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_removeLocalParameter" "', argument " "1"" of type '" "KineticLaw *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "KineticLaw_removeLocalParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "KineticLaw_removeLocalParameter" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (LocalParameter *)(arg1)->removeLocalParameter((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_LocalParameter, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_removeLocalParameter(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_KineticLaw_removeLocalParameter__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_KineticLaw, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_KineticLaw_removeLocalParameter__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'KineticLaw_removeLocalParameter'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeLocalParameter(KineticLaw *,unsigned int)\n"
    "    removeLocalParameter(KineticLaw *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getTypeCode" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (SBMLTypeCode_t)((KineticLaw const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_getElementName" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (std::string *) &((KineticLaw const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_hasRequiredAttributes" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_KineticLaw_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  KineticLaw *arg1 = (KineticLaw *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:KineticLaw_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_KineticLaw, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "KineticLaw_hasRequiredElements" "', argument " "1"" of type '" "KineticLaw const *""'"); 
  }
  arg1 = reinterpret_cast< KineticLaw * >(argp1);
  result = (bool)((KineticLaw const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *KineticLaw_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_KineticLaw, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_SimpleSpeciesReference(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SimpleSpeciesReference",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SimpleSpeciesReference" "', argument " "1"" of type '" "SimpleSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_getId" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (std::string *) &((SimpleSpeciesReference const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_getName" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (std::string *) &((SimpleSpeciesReference const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_getSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_getSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_getSpecies" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (std::string *) &((SimpleSpeciesReference const *)arg1)->getSpecies();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_isSetId" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (bool)((SimpleSpeciesReference const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_isSetName" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (bool)((SimpleSpeciesReference const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_isSetSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_isSetSpecies",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_isSetSpecies" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (bool)((SimpleSpeciesReference const *)arg1)->isSetSpecies();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_setSpecies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SimpleSpeciesReference_setSpecies",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_setSpecies" "', argument " "1"" of type '" "SimpleSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SimpleSpeciesReference_setSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SimpleSpeciesReference_setSpecies" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setSpecies((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SimpleSpeciesReference_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_setId" "', argument " "1"" of type '" "SimpleSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SimpleSpeciesReference_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SimpleSpeciesReference_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SimpleSpeciesReference_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_setName" "', argument " "1"" of type '" "SimpleSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SimpleSpeciesReference_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SimpleSpeciesReference_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_unsetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_unsetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_unsetId" "', argument " "1"" of type '" "SimpleSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (int)(arg1)->unsetId();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_unsetName" "', argument " "1"" of type '" "SimpleSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SimpleSpeciesReference_isModifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SimpleSpeciesReference *arg1 = (SimpleSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SimpleSpeciesReference_isModifier",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SimpleSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SimpleSpeciesReference_isModifier" "', argument " "1"" of type '" "SimpleSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SimpleSpeciesReference * >(argp1);
  result = (bool)((SimpleSpeciesReference const *)arg1)->isModifier();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SimpleSpeciesReference_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SimpleSpeciesReference, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_SpeciesReference__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SpeciesReference",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SpeciesReference" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SpeciesReference" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (SpeciesReference *)new SpeciesReference(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SpeciesReference__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SpeciesReference",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SpeciesReference" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (SpeciesReference *)new SpeciesReference(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SpeciesReference(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SpeciesReference",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SpeciesReference" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SpeciesReference__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SpeciesReference",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_SpeciesReference,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SpeciesReference" "', argument " "1"" of type '" "SpeciesReference const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SpeciesReference" "', argument " "1"" of type '" "SpeciesReference const &""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  {
    try {
      result = (SpeciesReference *)new SpeciesReference((SpeciesReference const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SpeciesReference(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SpeciesReference__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SpeciesReference__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SpeciesReference__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_SpeciesReference'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    SpeciesReference(unsigned int,unsigned int)\n"
    "    SpeciesReference(SBMLNamespaces *)\n"
    "    SpeciesReference(SpeciesReference const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_clone" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (SpeciesReference *)((SpeciesReference const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SpeciesReference, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_initDefaults(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_initDefaults",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_initDefaults" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  (arg1)->initDefaults();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getStoichiometry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getStoichiometry",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getStoichiometry" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (double)((SpeciesReference const *)arg1)->getStoichiometry();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getStoichiometryMath__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getStoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getStoichiometryMath" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (StoichiometryMath *)((SpeciesReference const *)arg1)->getStoichiometryMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getStoichiometryMath__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getStoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getStoichiometryMath" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (StoichiometryMath *)(arg1)->getStoichiometryMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getStoichiometryMath(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SpeciesReference_getStoichiometryMath__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SpeciesReference_getStoichiometryMath__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SpeciesReference_getStoichiometryMath'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getStoichiometryMath(SpeciesReference const *)\n"
    "    getStoichiometryMath(SpeciesReference *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getDenominator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getDenominator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getDenominator" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (int)((SpeciesReference const *)arg1)->getDenominator();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getConstant" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->getConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_isSetStoichiometryMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_isSetStoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_isSetStoichiometryMath" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->isSetStoichiometryMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_isSetConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_isSetConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_isSetConstant" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->isSetConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_isSetStoichiometry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_isSetStoichiometry",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_isSetStoichiometry" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->isSetStoichiometry();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setStoichiometry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_setStoichiometry",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_setStoichiometry" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpeciesReference_setStoichiometry" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setStoichiometry(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setStoichiometryMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  StoichiometryMath *arg2 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_setStoichiometryMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_setStoichiometryMath" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesReference_setStoichiometryMath" "', argument " "2"" of type '" "StoichiometryMath const *""'"); 
  }
  arg2 = reinterpret_cast< StoichiometryMath * >(argp2);
  result = (int)(arg1)->setStoichiometryMath((StoichiometryMath const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setDenominator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_setDenominator",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_setDenominator" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpeciesReference_setDenominator" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->setDenominator(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_setConstant",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_setConstant" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SpeciesReference_setConstant" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setConstant(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_unsetStoichiometryMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_unsetStoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_unsetStoichiometryMath" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (int)(arg1)->unsetStoichiometryMath();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_unsetStoichiometry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_unsetStoichiometry",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_unsetStoichiometry" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (int)(arg1)->unsetStoichiometry();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_createStoichiometryMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_createStoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_createStoichiometryMath" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (StoichiometryMath *)(arg1)->createStoichiometryMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_setAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_setAnnotation" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesReference_setAnnotation" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->setAnnotation((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_setAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_setAnnotation" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesReference_setAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpeciesReference_setAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setAnnotation((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_setAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SpeciesReference_setAnnotation__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SpeciesReference_setAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SpeciesReference_setAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setAnnotation(SpeciesReference *,XMLNode const *)\n"
    "    setAnnotation(SpeciesReference *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_appendAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_appendAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_appendAnnotation" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesReference_appendAnnotation" "', argument " "2"" of type '" "XMLNode const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->appendAnnotation((XMLNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_appendAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SpeciesReference_appendAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_appendAnnotation" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SpeciesReference_appendAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SpeciesReference_appendAnnotation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->appendAnnotation((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_appendAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNode, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SpeciesReference_appendAnnotation__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SpeciesReference, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SpeciesReference_appendAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SpeciesReference_appendAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    appendAnnotation(SpeciesReference *,XMLNode const *)\n"
    "    appendAnnotation(SpeciesReference *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getTypeCode" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (SBMLTypeCode_t)((SpeciesReference const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_getElementName" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (std::string *) &((SpeciesReference const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_initL2Stoichiometry(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_initL2Stoichiometry",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_initL2Stoichiometry" "', argument " "1"" of type '" "SpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  (arg1)->initL2Stoichiometry();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SpeciesReference_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SpeciesReference *arg1 = (SpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SpeciesReference_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SpeciesReference_hasRequiredAttributes" "', argument " "1"" of type '" "SpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< SpeciesReference * >(argp1);
  result = (bool)((SpeciesReference const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SpeciesReference_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SpeciesReference, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ModifierSpeciesReference__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_ModifierSpeciesReference",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ModifierSpeciesReference" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_ModifierSpeciesReference" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (ModifierSpeciesReference *)new ModifierSpeciesReference(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModifierSpeciesReference__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ModifierSpeciesReference",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ModifierSpeciesReference" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (ModifierSpeciesReference *)new ModifierSpeciesReference(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModifierSpeciesReference(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModifierSpeciesReference__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_ModifierSpeciesReference__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_ModifierSpeciesReference'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ModifierSpeciesReference(unsigned int,unsigned int)\n"
    "    ModifierSpeciesReference(SBMLNamespaces *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ModifierSpeciesReference(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ModifierSpeciesReference",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ModifierSpeciesReference" "', argument " "1"" of type '" "ModifierSpeciesReference *""'"); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModifierSpeciesReference_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModifierSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModifierSpeciesReference_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModifierSpeciesReference_clone" "', argument " "1"" of type '" "ModifierSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  result = (ModifierSpeciesReference *)((ModifierSpeciesReference const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModifierSpeciesReference, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModifierSpeciesReference_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModifierSpeciesReference_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModifierSpeciesReference_getTypeCode" "', argument " "1"" of type '" "ModifierSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  result = (SBMLTypeCode_t)((ModifierSpeciesReference const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModifierSpeciesReference_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModifierSpeciesReference_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModifierSpeciesReference_getElementName" "', argument " "1"" of type '" "ModifierSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  result = (std::string *) &((ModifierSpeciesReference const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModifierSpeciesReference_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModifierSpeciesReference *arg1 = (ModifierSpeciesReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModifierSpeciesReference_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModifierSpeciesReference, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModifierSpeciesReference_hasRequiredAttributes" "', argument " "1"" of type '" "ModifierSpeciesReference const *""'"); 
  }
  arg1 = reinterpret_cast< ModifierSpeciesReference * >(argp1);
  result = (bool)((ModifierSpeciesReference const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ModifierSpeciesReference_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ModifierSpeciesReference, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ListOfSpeciesReferences(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfSpeciesReferences")) SWIG_fail;
  result = (ListOfSpeciesReferences *)new ListOfSpeciesReferences();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfSpeciesReferences *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesReferences_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_clone" "', argument " "1"" of type '" "ListOfSpeciesReferences const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  result = (ListOfSpeciesReferences *)((ListOfSpeciesReferences const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfSpeciesReferences, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesReferences_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_getTypeCode" "', argument " "1"" of type '" "ListOfSpeciesReferences const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  result = (SBMLTypeCode_t)((ListOfSpeciesReferences const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesReferences_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_getItemTypeCode" "', argument " "1"" of type '" "ListOfSpeciesReferences const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  result = (SBMLTypeCode_t)((ListOfSpeciesReferences const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfSpeciesReferences_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_getElementName" "', argument " "1"" of type '" "ListOfSpeciesReferences const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  result = (std::string *) &((ListOfSpeciesReferences const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesReferences_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_get" "', argument " "1"" of type '" "ListOfSpeciesReferences *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpeciesReferences_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SimpleSpeciesReference *)(arg1)->get(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesReferences_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_get" "', argument " "1"" of type '" "ListOfSpeciesReferences const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpeciesReferences_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SimpleSpeciesReference *)((ListOfSpeciesReferences const *)arg1)->get(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesReferences_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_get" "', argument " "1"" of type '" "ListOfSpeciesReferences *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpeciesReferences_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpeciesReferences_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SimpleSpeciesReference *)(arg1)->get((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesReferences_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_get" "', argument " "1"" of type '" "ListOfSpeciesReferences const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpeciesReferences_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpeciesReferences_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SimpleSpeciesReference *)((ListOfSpeciesReferences const *)arg1)->get((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesReferences_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesReferences_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesReferences_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesReferences_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfSpeciesReferences_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfSpeciesReferences *,unsigned int)\n"
    "    get(ListOfSpeciesReferences const *,unsigned int)\n"
    "    get(ListOfSpeciesReferences *,std::string const &)\n"
    "    get(ListOfSpeciesReferences const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesReferences_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_remove" "', argument " "1"" of type '" "ListOfSpeciesReferences *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfSpeciesReferences_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SimpleSpeciesReference *)(arg1)->remove(arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SimpleSpeciesReference *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfSpeciesReferences_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfSpeciesReferences_remove" "', argument " "1"" of type '" "ListOfSpeciesReferences *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfSpeciesReferences_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfSpeciesReferences_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (SimpleSpeciesReference *)(arg1)->remove((std::string const &)*arg2);
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      SWIG_POINTER_OWN |  0 );
  }
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfSpeciesReferences_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfSpeciesReferences_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfSpeciesReferences, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfSpeciesReferences_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfSpeciesReferences_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfSpeciesReferences *,unsigned int)\n"
    "    remove(ListOfSpeciesReferences *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfSpeciesReferences(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfSpeciesReferences *arg1 = (ListOfSpeciesReferences *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfSpeciesReferences",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfSpeciesReferences, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfSpeciesReferences" "', argument " "1"" of type '" "ListOfSpeciesReferences *""'"); 
  }
  arg1 = reinterpret_cast< ListOfSpeciesReferences * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfSpeciesReferences_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfSpeciesReferences, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Event__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Event",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Event" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Event" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Event *)new Event(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Event__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Event",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Event" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Event *)new Event(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Event(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Event",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Event" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Event__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Event",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Event,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Event" "', argument " "1"" of type '" "Event const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Event" "', argument " "1"" of type '" "Event const &""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    try {
      result = (Event *)new Event((Event const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Event(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Event__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Event__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Event__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Event'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Event(unsigned int,unsigned int)\n"
    "    Event(SBMLNamespaces *)\n"
    "    Event(Event const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_clone" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Event *)((Event const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getId" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (std::string *) &((Event const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getName" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (std::string *) &((Event const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getTrigger__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getTrigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getTrigger" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Trigger *)((Event const *)arg1)->getTrigger();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getTrigger__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getTrigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getTrigger" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Trigger *)(arg1)->getTrigger();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getTrigger(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getTrigger__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getTrigger__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Event_getTrigger'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getTrigger(Event const *)\n"
    "    getTrigger(Event *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getDelay__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getDelay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getDelay" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Delay *)((Event const *)arg1)->getDelay();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getDelay__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getDelay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getDelay" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Delay *)(arg1)->getDelay();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getDelay(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getDelay__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getDelay__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Event_getDelay'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDelay(Event const *)\n"
    "    getDelay(Event *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getPriority__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Priority *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getPriority",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getPriority" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Priority *)((Event const *)arg1)->getPriority();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Priority, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getPriority__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Priority *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getPriority",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getPriority" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Priority *)(arg1)->getPriority();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Priority, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getPriority(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getPriority__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getPriority__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Event_getPriority'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getPriority(Event const *)\n"
    "    getPriority(Event *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getTimeUnits" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (std::string *) &((Event const *)arg1)->getTimeUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getUseValuesFromTriggerTime(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getUseValuesFromTriggerTime",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getUseValuesFromTriggerTime" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->getUseValuesFromTriggerTime();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_isSetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_isSetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_isSetId" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetId();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_isSetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_isSetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_isSetName" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_isSetTrigger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_isSetTrigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_isSetTrigger" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetTrigger();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_isSetDelay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_isSetDelay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_isSetDelay" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetDelay();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_isSetPriority(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_isSetPriority",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_isSetPriority" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetPriority();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_isSetTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_isSetTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_isSetTimeUnits" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetTimeUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_isSetUseValuesFromTriggerTime(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_isSetUseValuesFromTriggerTime",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_isSetUseValuesFromTriggerTime" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->isSetUseValuesFromTriggerTime();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_setId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_setId",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_setId" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Event_setId" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setId((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_setName" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Event_setName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_setTrigger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  Trigger *arg2 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_setTrigger",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_setTrigger" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_setTrigger" "', argument " "2"" of type '" "Trigger const *""'"); 
  }
  arg2 = reinterpret_cast< Trigger * >(argp2);
  result = (int)(arg1)->setTrigger((Trigger const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_setDelay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  Delay *arg2 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_setDelay",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_setDelay" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_setDelay" "', argument " "2"" of type '" "Delay const *""'"); 
  }
  arg2 = reinterpret_cast< Delay * >(argp2);
  result = (int)(arg1)->setDelay((Delay const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_setPriority(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  Priority *arg2 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_setPriority",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_setPriority" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_setPriority" "', argument " "2"" of type '" "Priority const *""'"); 
  }
  arg2 = reinterpret_cast< Priority * >(argp2);
  result = (int)(arg1)->setPriority((Priority const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_setTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_setTimeUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_setTimeUnits" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_setTimeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Event_setTimeUnits" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setTimeUnits((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_setUseValuesFromTriggerTime(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_setUseValuesFromTriggerTime",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_setUseValuesFromTriggerTime" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Event_setUseValuesFromTriggerTime" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setUseValuesFromTriggerTime(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_unsetId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_unsetId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_unsetId" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetId();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_unsetName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_unsetName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_unsetName" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_unsetDelay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_unsetDelay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_unsetDelay" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetDelay();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_unsetPriority(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_unsetPriority",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_unsetPriority" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetPriority();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_unsetTimeUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_unsetTimeUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_unsetTimeUnits" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (int)(arg1)->unsetTimeUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_addEventAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  EventAssignment *arg2 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_addEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_addEventAssignment" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_addEventAssignment" "', argument " "2"" of type '" "EventAssignment const *""'"); 
  }
  arg2 = reinterpret_cast< EventAssignment * >(argp2);
  result = (int)(arg1)->addEventAssignment((EventAssignment const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_createEventAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_createEventAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_createEventAssignment" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (EventAssignment *)(arg1)->createEventAssignment();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_createTrigger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_createTrigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_createTrigger" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Trigger *)(arg1)->createTrigger();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_createDelay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_createDelay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_createDelay" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Delay *)(arg1)->createDelay();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_createPriority(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Priority *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_createPriority",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_createPriority" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (Priority *)(arg1)->createPriority();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Priority, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getListOfEventAssignments__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfEventAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getListOfEventAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getListOfEventAssignments" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (ListOfEventAssignments *)((Event const *)arg1)->getListOfEventAssignments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getListOfEventAssignments__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfEventAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getListOfEventAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getListOfEventAssignments" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (ListOfEventAssignments *)(arg1)->getListOfEventAssignments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getListOfEventAssignments(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getListOfEventAssignments__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Event_getListOfEventAssignments__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Event_getListOfEventAssignments'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getListOfEventAssignments(Event const *)\n"
    "    getListOfEventAssignments(Event *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getEventAssignment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_getEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getEventAssignment" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Event_getEventAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)((Event const *)arg1)->getEventAssignment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getEventAssignment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_getEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getEventAssignment" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Event_getEventAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)(arg1)->getEventAssignment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getEventAssignment__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_getEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getEventAssignment" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_getEventAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Event_getEventAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)((Event const *)arg1)->getEventAssignment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getEventAssignment__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_getEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getEventAssignment" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_getEventAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Event_getEventAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)(arg1)->getEventAssignment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getEventAssignment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Event_getEventAssignment__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Event_getEventAssignment__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Event_getEventAssignment__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Event_getEventAssignment__SWIG_2(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Event_getEventAssignment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getEventAssignment(Event const *,unsigned int)\n"
    "    getEventAssignment(Event *,unsigned int)\n"
    "    getEventAssignment(Event const *,std::string const &)\n"
    "    getEventAssignment(Event *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getNumEventAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getNumEventAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getNumEventAssignments" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (unsigned int)((Event const *)arg1)->getNumEventAssignments();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_removeEventAssignment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_removeEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_removeEventAssignment" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Event_removeEventAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)(arg1)->removeEventAssignment(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_removeEventAssignment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Event_removeEventAssignment",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_removeEventAssignment" "', argument " "1"" of type '" "Event *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Event_removeEventAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Event_removeEventAssignment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)(arg1)->removeEventAssignment((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_removeEventAssignment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_Event_removeEventAssignment__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Event, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Event_removeEventAssignment__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Event_removeEventAssignment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeEventAssignment(Event *,unsigned int)\n"
    "    removeEventAssignment(Event *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getTypeCode" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (SBMLTypeCode_t)((Event const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_getElementName" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (std::string *) &((Event const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_hasRequiredAttributes" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Event_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Event *arg1 = (Event *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Event_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Event, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Event_hasRequiredElements" "', argument " "1"" of type '" "Event const *""'"); 
  }
  arg1 = reinterpret_cast< Event * >(argp1);
  result = (bool)((Event const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Event_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Event, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfEvents_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfEvents *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEvents_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_clone" "', argument " "1"" of type '" "ListOfEvents const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  result = (ListOfEvents *)((ListOfEvents const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEvents, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEvents_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_getTypeCode" "', argument " "1"" of type '" "ListOfEvents const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  result = (SBMLTypeCode_t)((ListOfEvents const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEvents_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_getItemTypeCode" "', argument " "1"" of type '" "ListOfEvents const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  result = (SBMLTypeCode_t)((ListOfEvents const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEvents_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_getElementName" "', argument " "1"" of type '" "ListOfEvents const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  result = (std::string *) &((ListOfEvents const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEvents_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_get" "', argument " "1"" of type '" "ListOfEvents *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfEvents_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEvents_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_get" "', argument " "1"" of type '" "ListOfEvents const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfEvents_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)((ListOfEvents const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEvents_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_get" "', argument " "1"" of type '" "ListOfEvents *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfEvents_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfEvents_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Event *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEvents_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_get" "', argument " "1"" of type '" "ListOfEvents const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfEvents_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfEvents_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Event *)((ListOfEvents const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEvents_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEvents_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEvents_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEvents_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfEvents_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfEvents *,unsigned int)\n"
    "    get(ListOfEvents const *,unsigned int)\n"
    "    get(ListOfEvents *,std::string const &)\n"
    "    get(ListOfEvents const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEvents_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_remove" "', argument " "1"" of type '" "ListOfEvents *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfEvents_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Event *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Event *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEvents_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEvents_remove" "', argument " "1"" of type '" "ListOfEvents *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfEvents_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfEvents_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (Event *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Event, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEvents_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEvents_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEvents, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEvents_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfEvents_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfEvents *,unsigned int)\n"
    "    remove(ListOfEvents *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfEvents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfEvents")) SWIG_fail;
  result = (ListOfEvents *)new ListOfEvents();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEvents, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfEvents(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEvents *arg1 = (ListOfEvents *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfEvents",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEvents, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfEvents" "', argument " "1"" of type '" "ListOfEvents *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEvents * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfEvents_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfEvents, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_EventAssignment__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_EventAssignment",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_EventAssignment" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_EventAssignment" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (EventAssignment *)new EventAssignment(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_EventAssignment__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_EventAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_EventAssignment" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (EventAssignment *)new EventAssignment(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EventAssignment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_EventAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EventAssignment" "', argument " "1"" of type '" "EventAssignment *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_EventAssignment__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_EventAssignment",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_EventAssignment,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_EventAssignment" "', argument " "1"" of type '" "EventAssignment const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_EventAssignment" "', argument " "1"" of type '" "EventAssignment const &""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  {
    try {
      result = (EventAssignment *)new EventAssignment((EventAssignment const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_EventAssignment(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_EventAssignment__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_EventAssignment__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_EventAssignment__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_EventAssignment'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    EventAssignment(unsigned int,unsigned int)\n"
    "    EventAssignment(SBMLNamespaces *)\n"
    "    EventAssignment(EventAssignment const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_clone" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (EventAssignment *)((EventAssignment const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getVariable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getVariable",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getVariable" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (std::string *) &((EventAssignment const *)arg1)->getVariable();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getMath" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (ASTNode *)((EventAssignment const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_isSetVariable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_isSetVariable",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_isSetVariable" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->isSetVariable();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_isSetMath" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_setVariable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:EventAssignment_setVariable",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_setVariable" "', argument " "1"" of type '" "EventAssignment *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EventAssignment_setVariable" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventAssignment_setVariable" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setVariable((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:EventAssignment_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_setMath" "', argument " "1"" of type '" "EventAssignment *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EventAssignment_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getDerivedUnitDefinition" "', argument " "1"" of type '" "EventAssignment *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getDerivedUnitDefinition" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (UnitDefinition *)((EventAssignment const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_EventAssignment_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_EventAssignment_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'EventAssignment_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(EventAssignment *)\n"
    "    getDerivedUnitDefinition(EventAssignment const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_containsUndeclaredUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_containsUndeclaredUnits" "', argument " "1"" of type '" "EventAssignment *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_containsUndeclaredUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_containsUndeclaredUnits" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_containsUndeclaredUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_EventAssignment_containsUndeclaredUnits__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_EventAssignment, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_EventAssignment_containsUndeclaredUnits__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'EventAssignment_containsUndeclaredUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    containsUndeclaredUnits(EventAssignment *)\n"
    "    containsUndeclaredUnits(EventAssignment const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getTypeCode" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (SBMLTypeCode_t)((EventAssignment const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getElementName" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (std::string *) &((EventAssignment const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_hasRequiredAttributes" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_hasRequiredElements" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = (bool)((EventAssignment const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventAssignment_getId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  EventAssignment *arg1 = (EventAssignment *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:EventAssignment_getId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventAssignment_getId" "', argument " "1"" of type '" "EventAssignment const *""'"); 
  }
  arg1 = reinterpret_cast< EventAssignment * >(argp1);
  result = ((EventAssignment const *)arg1)->getId();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *EventAssignment_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_EventAssignment, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_ListOfEventAssignments_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListOfEventAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEventAssignments_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_clone" "', argument " "1"" of type '" "ListOfEventAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  result = (ListOfEventAssignments *)((ListOfEventAssignments const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEventAssignments, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEventAssignments_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_getTypeCode" "', argument " "1"" of type '" "ListOfEventAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  result = (SBMLTypeCode_t)((ListOfEventAssignments const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_getItemTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEventAssignments_getItemTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_getItemTypeCode" "', argument " "1"" of type '" "ListOfEventAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  result = (SBMLTypeCode_t)((ListOfEventAssignments const *)arg1)->getItemTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ListOfEventAssignments_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_getElementName" "', argument " "1"" of type '" "ListOfEventAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  result = (std::string *) &((ListOfEventAssignments const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEventAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_get" "', argument " "1"" of type '" "ListOfEventAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfEventAssignments_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)(arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEventAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_get" "', argument " "1"" of type '" "ListOfEventAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfEventAssignments_get" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)((ListOfEventAssignments const *)arg1)->get(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEventAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_get" "', argument " "1"" of type '" "ListOfEventAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfEventAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfEventAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)(arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEventAssignments_get",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_get" "', argument " "1"" of type '" "ListOfEventAssignments const *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfEventAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfEventAssignments_get" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)((ListOfEventAssignments const *)arg1)->get((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_get(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEventAssignments_get__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEventAssignments_get__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEventAssignments_get__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEventAssignments_get__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfEventAssignments_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    get(ListOfEventAssignments *,unsigned int)\n"
    "    get(ListOfEventAssignments const *,unsigned int)\n"
    "    get(ListOfEventAssignments *,std::string const &)\n"
    "    get(ListOfEventAssignments const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEventAssignments_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_remove" "', argument " "1"" of type '" "ListOfEventAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ListOfEventAssignments_remove" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (EventAssignment *)(arg1)->remove(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  EventAssignment *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ListOfEventAssignments_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ListOfEventAssignments_remove" "', argument " "1"" of type '" "ListOfEventAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ListOfEventAssignments_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ListOfEventAssignments_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (EventAssignment *)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventAssignment, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ListOfEventAssignments_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ListOfEventAssignments_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ListOfEventAssignments, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_ListOfEventAssignments_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ListOfEventAssignments_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(ListOfEventAssignments *,unsigned int)\n"
    "    remove(ListOfEventAssignments *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ListOfEventAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ListOfEventAssignments")) SWIG_fail;
  result = (ListOfEventAssignments *)new ListOfEventAssignments();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListOfEventAssignments, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ListOfEventAssignments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ListOfEventAssignments *arg1 = (ListOfEventAssignments *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ListOfEventAssignments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ListOfEventAssignments, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ListOfEventAssignments" "', argument " "1"" of type '" "ListOfEventAssignments *""'"); 
  }
  arg1 = reinterpret_cast< ListOfEventAssignments * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ListOfEventAssignments_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ListOfEventAssignments, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Trigger__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Trigger",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Trigger" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Trigger" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Trigger *)new Trigger(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Trigger__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Trigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Trigger" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Trigger *)new Trigger(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Trigger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Trigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Trigger" "', argument " "1"" of type '" "Trigger *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Trigger__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Trigger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Trigger,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Trigger" "', argument " "1"" of type '" "Trigger const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Trigger" "', argument " "1"" of type '" "Trigger const &""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  {
    try {
      result = (Trigger *)new Trigger((Trigger const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Trigger(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Trigger__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Trigger, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Trigger__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Trigger__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Trigger'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Trigger(unsigned int,unsigned int)\n"
    "    Trigger(SBMLNamespaces *)\n"
    "    Trigger(Trigger const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Trigger *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_clone" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (Trigger *)((Trigger const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Trigger, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_getMath" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (ASTNode *)((Trigger const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_getInitialValue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_getInitialValue",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_getInitialValue" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->getInitialValue();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_getPersistent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_getPersistent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_getPersistent" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->getPersistent();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_isSetMath" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_isSetInitialValue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_isSetInitialValue",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_isSetInitialValue" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->isSetInitialValue();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_isSetPersistent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_isSetPersistent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_isSetPersistent" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->isSetPersistent();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Trigger_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_setMath" "', argument " "1"" of type '" "Trigger *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Trigger_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_setInitialValue(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Trigger_setInitialValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_setInitialValue" "', argument " "1"" of type '" "Trigger *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Trigger_setInitialValue" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setInitialValue(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_setPersistent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Trigger_setPersistent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_setPersistent" "', argument " "1"" of type '" "Trigger *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Trigger_setPersistent" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (int)(arg1)->setPersistent(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_getTypeCode" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (SBMLTypeCode_t)((Trigger const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_getElementName" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (std::string *) &((Trigger const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_hasRequiredElements" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Trigger_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Trigger *arg1 = (Trigger *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Trigger_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Trigger, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Trigger_hasRequiredAttributes" "', argument " "1"" of type '" "Trigger const *""'"); 
  }
  arg1 = reinterpret_cast< Trigger * >(argp1);
  result = (bool)((Trigger const *)arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Trigger_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Trigger, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Delay__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Delay",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Delay" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Delay" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Delay *)new Delay(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Delay__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Delay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Delay" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Delay *)new Delay(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Delay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Delay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Delay" "', argument " "1"" of type '" "Delay *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Delay__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Delay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Delay,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Delay" "', argument " "1"" of type '" "Delay const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Delay" "', argument " "1"" of type '" "Delay const &""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  {
    try {
      result = (Delay *)new Delay((Delay const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Delay(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Delay__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Delay__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Delay__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Delay'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Delay(unsigned int,unsigned int)\n"
    "    Delay(SBMLNamespaces *)\n"
    "    Delay(Delay const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Delay *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_clone" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (Delay *)((Delay const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Delay, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_getMath" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (ASTNode *)((Delay const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_isSetMath" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (bool)((Delay const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Delay_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_setMath" "', argument " "1"" of type '" "Delay *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Delay_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_getDerivedUnitDefinition" "', argument " "1"" of type '" "Delay *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_getDerivedUnitDefinition" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (UnitDefinition *)((Delay const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Delay_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Delay_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Delay_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(Delay *)\n"
    "    getDerivedUnitDefinition(Delay const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_containsUndeclaredUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_containsUndeclaredUnits" "', argument " "1"" of type '" "Delay *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_containsUndeclaredUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_containsUndeclaredUnits" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (bool)((Delay const *)arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_containsUndeclaredUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Delay_containsUndeclaredUnits__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_Delay, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Delay_containsUndeclaredUnits__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'Delay_containsUndeclaredUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    containsUndeclaredUnits(Delay *)\n"
    "    containsUndeclaredUnits(Delay const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_getTypeCode" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (SBMLTypeCode_t)((Delay const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_getElementName" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (std::string *) &((Delay const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Delay_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Delay *arg1 = (Delay *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Delay_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Delay, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Delay_hasRequiredElements" "', argument " "1"" of type '" "Delay const *""'"); 
  }
  arg1 = reinterpret_cast< Delay * >(argp1);
  result = (bool)((Delay const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Delay_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Delay, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Priority__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Priority *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Priority",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Priority" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Priority" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (Priority *)new Priority(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Priority, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Priority__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Priority *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Priority",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Priority" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (Priority *)new Priority(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Priority, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Priority(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Priority *arg1 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Priority",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Priority, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Priority" "', argument " "1"" of type '" "Priority *""'"); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Priority__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Priority *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Priority *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Priority",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Priority,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Priority" "', argument " "1"" of type '" "Priority const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Priority" "', argument " "1"" of type '" "Priority const &""'"); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  {
    try {
      result = (Priority *)new Priority((Priority const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Priority, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Priority(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Priority__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Priority, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Priority__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Priority__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Priority'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Priority(unsigned int,unsigned int)\n"
    "    Priority(SBMLNamespaces *)\n"
    "    Priority(Priority const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Priority_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Priority *arg1 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Priority *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Priority_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Priority_clone" "', argument " "1"" of type '" "Priority const *""'"); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  result = (Priority *)((Priority const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Priority, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Priority_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Priority *arg1 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Priority_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Priority_getMath" "', argument " "1"" of type '" "Priority const *""'"); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  result = (ASTNode *)((Priority const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Priority_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Priority *arg1 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Priority_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Priority_isSetMath" "', argument " "1"" of type '" "Priority const *""'"); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  result = (bool)((Priority const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Priority_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Priority *arg1 = (Priority *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Priority_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Priority_setMath" "', argument " "1"" of type '" "Priority *""'"); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Priority_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Priority_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Priority *arg1 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Priority_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Priority_getTypeCode" "', argument " "1"" of type '" "Priority const *""'"); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  result = (SBMLTypeCode_t)((Priority const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Priority_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Priority *arg1 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Priority_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Priority_getElementName" "', argument " "1"" of type '" "Priority const *""'"); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  result = (std::string *) &((Priority const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Priority_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Priority *arg1 = (Priority *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Priority_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Priority, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Priority_hasRequiredElements" "', argument " "1"" of type '" "Priority const *""'"); 
  }
  arg1 = reinterpret_cast< Priority * >(argp1);
  result = (bool)((Priority const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Priority_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Priority, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SBO_isQuantitativeParameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isQuantitativeParameter",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isQuantitativeParameter" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isQuantitativeParameter(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isParticipantRole(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isParticipantRole",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isParticipantRole" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isParticipantRole(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isModellingFramework(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isModellingFramework",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isModellingFramework" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isModellingFramework(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isMathematicalExpression(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isMathematicalExpression",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isMathematicalExpression" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isMathematicalExpression(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isKineticConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isKineticConstant",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isKineticConstant" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isKineticConstant(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isReactant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isReactant",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isReactant" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isReactant(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isProduct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isProduct",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isProduct" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isProduct(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isModifier(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isModifier",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isModifier" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isModifier(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isRateLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isRateLaw",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isRateLaw" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isRateLaw(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isEvent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isEvent",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isEvent" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isEvent(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isPhysicalParticipant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isPhysicalParticipant",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isPhysicalParticipant" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isPhysicalParticipant(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isParticipant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isParticipant",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isParticipant" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isParticipant(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isInteraction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isInteraction",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isInteraction" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isInteraction(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isEntity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isEntity",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isEntity" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isEntity(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isFunctionalEntity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isFunctionalEntity",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isFunctionalEntity" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isFunctionalEntity(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isMaterialEntity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isMaterialEntity",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isMaterialEntity" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isMaterialEntity(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isConservationLaw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isConservationLaw",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isConservationLaw" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isConservationLaw(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isSteadyStateExpression(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isSteadyStateExpression",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isSteadyStateExpression" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isSteadyStateExpression(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isFunctionalCompartment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isFunctionalCompartment",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isFunctionalCompartment" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isFunctionalCompartment(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isContinuousFramework(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isContinuousFramework",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isContinuousFramework" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isContinuousFramework(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isDiscreteFramework(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isDiscreteFramework",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isDiscreteFramework" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isDiscreteFramework(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isLogicalFramework(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isLogicalFramework",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isLogicalFramework" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isLogicalFramework(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_isObselete(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_isObselete",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_isObselete" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (bool)SBO::isObselete(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_intToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_intToString",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_intToString" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  result = SBO::intToString(arg1);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_stringToInt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_stringToInt",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBO_stringToInt" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBO_stringToInt" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (int)SBO::stringToInt((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_checkTerm__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_checkTerm",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBO_checkTerm" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SBO_checkTerm" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (bool)SBO::checkTerm((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_checkTerm__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBO_checkTerm",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBO_checkTerm" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  result = (bool)SBO::checkTerm(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBO_checkTerm(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_SBO_checkTerm__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBO_checkTerm__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBO_checkTerm'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    checkTerm(std::string const &)\n"
    "    SBO::checkTerm(int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBO(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBO *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBO")) SWIG_fail;
  result = (SBO *)new SBO();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBO, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBO(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBO *arg1 = (SBO *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBO",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBO, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBO" "', argument " "1"" of type '" "SBO *""'"); 
  }
  arg1 = reinterpret_cast< SBO * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBO_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBO, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SyntaxChecker_isValidSBMLSId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SyntaxChecker_isValidSBMLSId",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SyntaxChecker_isValidSBMLSId" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)SyntaxChecker::isValidSBMLSId(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SyntaxChecker_isValidXMLID(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SyntaxChecker_isValidXMLID",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SyntaxChecker_isValidXMLID" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)SyntaxChecker::isValidXMLID(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SyntaxChecker_isValidUnitSId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SyntaxChecker_isValidUnitSId",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SyntaxChecker_isValidUnitSId" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)SyntaxChecker::isValidUnitSId(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SyntaxChecker_hasExpectedXHTMLSyntax__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  SBMLNamespaces *arg2 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SyntaxChecker_hasExpectedXHTMLSyntax",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SyntaxChecker_hasExpectedXHTMLSyntax" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SyntaxChecker_hasExpectedXHTMLSyntax" "', argument " "2"" of type '" "SBMLNamespaces *""'"); 
  }
  arg2 = reinterpret_cast< SBMLNamespaces * >(argp2);
  result = (bool)SyntaxChecker::hasExpectedXHTMLSyntax((XMLNode const *)arg1,arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SyntaxChecker_hasExpectedXHTMLSyntax__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SyntaxChecker_hasExpectedXHTMLSyntax",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SyntaxChecker_hasExpectedXHTMLSyntax" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (bool)SyntaxChecker::hasExpectedXHTMLSyntax((XMLNode const *)arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SyntaxChecker_hasExpectedXHTMLSyntax(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SyntaxChecker_hasExpectedXHTMLSyntax__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SyntaxChecker_hasExpectedXHTMLSyntax__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SyntaxChecker_hasExpectedXHTMLSyntax'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    hasExpectedXHTMLSyntax(XMLNode const *,SBMLNamespaces *)\n"
    "    SyntaxChecker::hasExpectedXHTMLSyntax(XMLNode const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SyntaxChecker_isValidInternalSId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SyntaxChecker_isValidInternalSId",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SyntaxChecker_isValidInternalSId" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)SyntaxChecker::isValidInternalSId(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SyntaxChecker_isValidInternalUnitSId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string arg1 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SyntaxChecker_isValidInternalUnitSId",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SyntaxChecker_isValidInternalUnitSId" "', argument " "1"" of type '" "std::string""'"); 
    }
    arg1 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)SyntaxChecker::isValidInternalUnitSId(arg1);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SyntaxChecker(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SyntaxChecker *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SyntaxChecker")) SWIG_fail;
  result = (SyntaxChecker *)new SyntaxChecker();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SyntaxChecker, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SyntaxChecker(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SyntaxChecker *arg1 = (SyntaxChecker *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SyntaxChecker",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SyntaxChecker, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SyntaxChecker" "', argument " "1"" of type '" "SyntaxChecker *""'"); 
  }
  arg1 = reinterpret_cast< SyntaxChecker * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SyntaxChecker_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SyntaxChecker, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_StoichiometryMath__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_StoichiometryMath",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_StoichiometryMath" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_StoichiometryMath" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (StoichiometryMath *)new StoichiometryMath(arg1,arg2);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_StoichiometryMath__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_StoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_StoichiometryMath" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    try {
      result = (StoichiometryMath *)new StoichiometryMath(arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_StoichiometryMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_StoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_StoichiometryMath" "', argument " "1"" of type '" "StoichiometryMath *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_StoichiometryMath__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_StoichiometryMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_StoichiometryMath,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_StoichiometryMath" "', argument " "1"" of type '" "StoichiometryMath const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_StoichiometryMath" "', argument " "1"" of type '" "StoichiometryMath const &""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  {
    try {
      result = (StoichiometryMath *)new StoichiometryMath((StoichiometryMath const &)*arg1);
    }
    catch (SBMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_StoichiometryMath(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_StoichiometryMath__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_StoichiometryMath__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_StoichiometryMath__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_StoichiometryMath'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    StoichiometryMath(unsigned int,unsigned int)\n"
    "    StoichiometryMath(SBMLNamespaces *)\n"
    "    StoichiometryMath(StoichiometryMath const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  StoichiometryMath *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_clone" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (StoichiometryMath *)((StoichiometryMath const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_StoichiometryMath, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_getMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_getMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_getMath" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (ASTNode *)((StoichiometryMath const *)arg1)->getMath();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_isSetMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_isSetMath",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_isSetMath" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (bool)((StoichiometryMath const *)arg1)->isSetMath();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_setMath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:StoichiometryMath_setMath",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_setMath" "', argument " "1"" of type '" "StoichiometryMath *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "StoichiometryMath_setMath" "', argument " "2"" of type '" "ASTNode const *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->setMath((ASTNode const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_getDerivedUnitDefinition__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_getDerivedUnitDefinition" "', argument " "1"" of type '" "StoichiometryMath *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (UnitDefinition *)(arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_getDerivedUnitDefinition__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  UnitDefinition *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_getDerivedUnitDefinition",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_getDerivedUnitDefinition" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (UnitDefinition *)((StoichiometryMath const *)arg1)->getDerivedUnitDefinition();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_UnitDefinition, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_getDerivedUnitDefinition(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_StoichiometryMath_getDerivedUnitDefinition__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_StoichiometryMath_getDerivedUnitDefinition__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'StoichiometryMath_getDerivedUnitDefinition'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getDerivedUnitDefinition(StoichiometryMath *)\n"
    "    getDerivedUnitDefinition(StoichiometryMath const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_containsUndeclaredUnits__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_containsUndeclaredUnits" "', argument " "1"" of type '" "StoichiometryMath *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (bool)(arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_containsUndeclaredUnits__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_containsUndeclaredUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_containsUndeclaredUnits" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (bool)((StoichiometryMath const *)arg1)->containsUndeclaredUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_containsUndeclaredUnits(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_StoichiometryMath_containsUndeclaredUnits__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_StoichiometryMath, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_StoichiometryMath_containsUndeclaredUnits__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'StoichiometryMath_containsUndeclaredUnits'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    containsUndeclaredUnits(StoichiometryMath *)\n"
    "    containsUndeclaredUnits(StoichiometryMath const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_getTypeCode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLTypeCode_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_getTypeCode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_getTypeCode" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (SBMLTypeCode_t)((StoichiometryMath const *)arg1)->getTypeCode();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_getElementName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_getElementName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_getElementName" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (std::string *) &((StoichiometryMath const *)arg1)->getElementName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StoichiometryMath_hasRequiredElements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  StoichiometryMath *arg1 = (StoichiometryMath *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:StoichiometryMath_hasRequiredElements",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_StoichiometryMath, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StoichiometryMath_hasRequiredElements" "', argument " "1"" of type '" "StoichiometryMath const *""'"); 
  }
  arg1 = reinterpret_cast< StoichiometryMath * >(argp1);
  result = (bool)((StoichiometryMath const *)arg1)->hasRequiredElements();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *StoichiometryMath_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_StoichiometryMath, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_SBMLNamespaces__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SBMLNamespaces",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLNamespaces" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLNamespaces" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLNamespaces *)new SBMLNamespaces(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLNamespaces__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SBMLNamespaces",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLNamespaces" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (SBMLNamespaces *)new SBMLNamespaces(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLNamespaces__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBMLNamespaces")) SWIG_fail;
  result = (SBMLNamespaces *)new SBMLNamespaces();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLNamespaces" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLNamespaces__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SBMLNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_SBMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SBMLNamespaces" "', argument " "1"" of type '" "SBMLNamespaces const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLNamespaces" "', argument " "1"" of type '" "SBMLNamespaces const &""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (SBMLNamespaces *)new SBMLNamespaces((SBMLNamespaces const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLNamespaces(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_SBMLNamespaces__SWIG_2(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBMLNamespaces__SWIG_3(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_SBMLNamespaces__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SBMLNamespaces__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_SBMLNamespaces'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    SBMLNamespaces(unsigned int,unsigned int)\n"
    "    SBMLNamespaces(unsigned int)\n"
    "    SBMLNamespaces()\n"
    "    SBMLNamespaces(SBMLNamespaces const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_clone" "', argument " "1"" of type '" "SBMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (SBMLNamespaces *)((SBMLNamespaces const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLNamespaces, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getSBMLNamespaceURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLNamespaces_getSBMLNamespaceURI",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SBMLNamespaces_getSBMLNamespaceURI" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLNamespaces_getSBMLNamespaceURI" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = SBMLNamespaces::getSBMLNamespaceURI(arg1,arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getSupportedNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  List *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":SBMLNamespaces_getSupportedNamespaces")) SWIG_fail;
  result = (List *)SBMLNamespaces::getSupportedNamespaces();
  {
    ListWrapper<SBMLNamespaces> *listw = (result != 0) ? new ListWrapper<SBMLNamespaces>(result) : 0;
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_SBMLNamespaces_t, 
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getLevel__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_getLevel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_getLevel" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (unsigned int)(arg1)->getLevel();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getLevel__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_getLevel",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_getLevel" "', argument " "1"" of type '" "SBMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (unsigned int)((SBMLNamespaces const *)arg1)->getLevel();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getLevel(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getLevel__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getLevel__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLNamespaces_getLevel'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getLevel(SBMLNamespaces *)\n"
    "    getLevel(SBMLNamespaces const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getVersion__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_getVersion",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_getVersion" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (unsigned int)(arg1)->getVersion();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getVersion__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_getVersion",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_getVersion" "', argument " "1"" of type '" "SBMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (unsigned int)((SBMLNamespaces const *)arg1)->getVersion();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getVersion(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getVersion__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getVersion__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLNamespaces_getVersion'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getVersion(SBMLNamespaces *)\n"
    "    getVersion(SBMLNamespaces const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getNamespaces__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_getNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_getNamespaces" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (XMLNamespaces *)(arg1)->getNamespaces();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getNamespaces__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:SBMLNamespaces_getNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_getNamespaces" "', argument " "1"" of type '" "SBMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  result = (XMLNamespaces *)((SBMLNamespaces const *)arg1)->getNamespaces();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getNamespaces(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getNamespaces__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_SBMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SBMLNamespaces_getNamespaces__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'SBMLNamespaces_getNamespaces'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getNamespaces(SBMLNamespaces *)\n"
    "    getNamespaces(SBMLNamespaces const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_addNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  XMLNamespaces *arg2 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLNamespaces_addNamespaces",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_addNamespaces" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SBMLNamespaces_addNamespaces" "', argument " "2"" of type '" "XMLNamespaces *""'"); 
  }
  arg2 = reinterpret_cast< XMLNamespaces * >(argp2);
  (arg1)->addNamespaces(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_addPackagePrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLNamespaces_addPackagePrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_addPackagePrefix" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SBMLNamespaces_addPackagePrefix" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  (arg1)->addPackagePrefix(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_getPackagePrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLNamespaces_getPackagePrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_getPackagePrefix" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLNamespaces_getPackagePrefix" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (arg1)->getPackagePrefix(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLNamespaces_containsPackagePrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLNamespaces *arg1 = (SBMLNamespaces *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLNamespaces_containsPackagePrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLNamespaces_containsPackagePrefix" "', argument " "1"" of type '" "SBMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< SBMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "SBMLNamespaces_containsPackagePrefix" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)(arg1)->containsPackagePrefix(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLNamespaces_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLNamespaces, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_SBMLTransforms(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLTransforms *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBMLTransforms")) SWIG_fail;
  result = (SBMLTransforms *)new SBMLTransforms();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLTransforms, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLTransforms(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLTransforms *arg1 = (SBMLTransforms *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLTransforms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLTransforms, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLTransforms" "', argument " "1"" of type '" "SBMLTransforms *""'"); 
  }
  arg1 = reinterpret_cast< SBMLTransforms * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLTransforms_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLTransforms, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_readMathMLFromString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:readMathMLFromString",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "readMathMLFromString" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (ASTNode_t *)readMathMLFromString((char const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_writeMathMLToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode_t *arg1 = (ASTNode_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:writeMathMLToString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "writeMathMLToString" "', argument " "1"" of type '" "ASTNode_t const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode_t * >(argp1);
  result = (char *)writeMathMLToString((ASTNode const *)arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  free(result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ASTNode__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNodeType_t arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ASTNode",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_ASTNode" "', argument " "1"" of type '" "ASTNodeType_t""'");
  } 
  arg1 = static_cast< ASTNodeType_t >(val1);
  result = (ASTNode *)new ASTNode(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ASTNode__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ASTNode")) SWIG_fail;
  result = (ASTNode *)new ASTNode();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ASTNode__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ASTNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_ASTNode,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ASTNode" "', argument " "1"" of type '" "ASTNode const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ASTNode" "', argument " "1"" of type '" "ASTNode const &""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNode *)new ASTNode((ASTNode const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ASTNode(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_ASTNode__SWIG_1(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ASTNode__SWIG_2(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_ASTNode__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_ASTNode'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ASTNode(ASTNodeType_t)\n"
    "    ASTNode()\n"
    "    ASTNode(ASTNode const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ASTNode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ASTNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ASTNode" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_freeName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_freeName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_freeName" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (int)(arg1)->freeName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_canonicalize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_canonicalize",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_canonicalize" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)(arg1)->canonicalize();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_addChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_addChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_addChild" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNode_addChild" "', argument " "2"" of type '" "ASTNode *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->addChild(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_prependChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_prependChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_prependChild" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNode_prependChild" "', argument " "2"" of type '" "ASTNode *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->prependChild(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_removeChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_removeChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_removeChild" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_removeChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->removeChild(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_replaceChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  ASTNode *arg3 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:ASTNode_replaceChild",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_replaceChild" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_replaceChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ASTNode_replaceChild" "', argument " "3"" of type '" "ASTNode *""'"); 
  }
  arg3 = reinterpret_cast< ASTNode * >(argp3);
  result = (int)(arg1)->replaceChild(arg2,arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_insertChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  ASTNode *arg3 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:ASTNode_insertChild",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_insertChild" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_insertChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ASTNode_insertChild" "', argument " "3"" of type '" "ASTNode *""'"); 
  }
  arg3 = reinterpret_cast< ASTNode * >(argp3);
  result = (int)(arg1)->insertChild(arg2,arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_deepCopy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_deepCopy",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_deepCopy" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNode *)((ASTNode const *)arg1)->deepCopy();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_getChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getChild" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_getChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ASTNode *)((ASTNode const *)arg1)->getChild(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getLeftChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getLeftChild",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getLeftChild" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNode *)((ASTNode const *)arg1)->getLeftChild();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getRightChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getRightChild",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getRightChild" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNode *)((ASTNode const *)arg1)->getRightChild();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getNumChildren(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getNumChildren",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getNumChildren" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (unsigned int)((ASTNode const *)arg1)->getNumChildren();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_addSemanticsAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  XMLNode *arg2 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_addSemanticsAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_addSemanticsAnnotation" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNode_addSemanticsAnnotation" "', argument " "2"" of type '" "XMLNode *""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->addSemanticsAnnotation(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getNumSemanticsAnnotations(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getNumSemanticsAnnotations",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getNumSemanticsAnnotations" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (unsigned int)((ASTNode const *)arg1)->getNumSemanticsAnnotations();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getSemanticsAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_getSemanticsAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getSemanticsAnnotation" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_getSemanticsAnnotation" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *)((ASTNode const *)arg1)->getSemanticsAnnotation(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getCharacter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getCharacter",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getCharacter" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (char)((ASTNode const *)arg1)->getCharacter();
  resultobj = SWIG_From_char(static_cast< char >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getInteger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  long result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getInteger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getInteger" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (long)((ASTNode const *)arg1)->getInteger();
  resultobj = SWIG_From_long(static_cast< long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getName" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (char *)((ASTNode const *)arg1)->getName();
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getNumerator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  long result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getNumerator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getNumerator" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (long)((ASTNode const *)arg1)->getNumerator();
  resultobj = SWIG_From_long(static_cast< long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getDenominator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  long result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getDenominator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getDenominator" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (long)((ASTNode const *)arg1)->getDenominator();
  resultobj = SWIG_From_long(static_cast< long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getReal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getReal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getReal" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (double)((ASTNode const *)arg1)->getReal();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getMantissa(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  double result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getMantissa",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getMantissa" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (double)((ASTNode const *)arg1)->getMantissa();
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getExponent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  long result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getExponent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getExponent" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (long)((ASTNode const *)arg1)->getExponent();
  resultobj = SWIG_From_long(static_cast< long >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getPrecedence(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getPrecedence",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getPrecedence" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (int)((ASTNode const *)arg1)->getPrecedence();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNodeType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getType" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ASTNodeType_t)((ASTNode const *)arg1)->getType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getUnits" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = ((ASTNode const *)arg1)->getUnits();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isBoolean(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isBoolean",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isBoolean" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isBoolean();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isConstant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isConstant",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isConstant" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isConstant();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isFunction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isFunction",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isFunction" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isFunction();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isInfinity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isInfinity",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isInfinity" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isInfinity();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isInteger(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isInteger",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isInteger" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isInteger();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isLambda(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isLambda",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isLambda" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isLambda();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isLog10(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isLog10",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isLog10" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isLog10();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isLogical(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isLogical",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isLogical" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isLogical();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isName" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isNaN(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isNaN",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isNaN" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isNaN();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isNegInfinity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isNegInfinity",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isNegInfinity" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isNegInfinity();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isNumber(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isNumber",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isNumber" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isNumber();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isOperator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isOperator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isOperator" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isOperator();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isPiecewise(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isPiecewise",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isPiecewise" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isPiecewise();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isRational(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isRational",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isRational" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isRational();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isReal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isReal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isReal" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isReal();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isRelational(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isRelational",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isRelational" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isRelational();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isSqrt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isSqrt",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isSqrt" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isSqrt();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isUMinus(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isUMinus",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isUMinus" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isUMinus();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isUnknown(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isUnknown",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isUnknown" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isUnknown();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isSetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isSetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isSetUnits" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isSetUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_hasUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_hasUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_hasUnits" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->hasUnits();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setCharacter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  char arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_setCharacter",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setCharacter" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_setCharacter" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = (int)(arg1)->setCharacter(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_setName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setName" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(obj1, &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNode_setName" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  result = (int)(arg1)->setName((char const *)arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return resultobj;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setValue__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  long arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_setValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setValue" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_setValue" "', argument " "2"" of type '" "long""'");
  } 
  arg2 = static_cast< long >(val2);
  result = (int)(arg1)->setValue(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setValue__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  long arg2 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  long val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:ASTNode_setValue",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setValue" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_long(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_setValue" "', argument " "2"" of type '" "long""'");
  } 
  arg2 = static_cast< long >(val2);
  ecode3 = SWIG_AsVal_long(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ASTNode_setValue" "', argument " "3"" of type '" "long""'");
  } 
  arg3 = static_cast< long >(val3);
  result = (int)(arg1)->setValue(arg2,arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setValue__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  double arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_setValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setValue" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_setValue" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  result = (int)(arg1)->setValue(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setValue__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  double arg2 ;
  long arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val2 ;
  int ecode2 = 0 ;
  long val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:ASTNode_setValue",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setValue" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_double(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_setValue" "', argument " "2"" of type '" "double""'");
  } 
  arg2 = static_cast< double >(val2);
  ecode3 = SWIG_AsVal_long(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ASTNode_setValue" "', argument " "3"" of type '" "long""'");
  } 
  arg3 = static_cast< long >(val3);
  result = (int)(arg1)->setValue(arg2,arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setValue(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ASTNode_setValue__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ASTNode_setValue__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_long(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_ASTNode_setValue__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ASTNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_double(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_ASTNode_setValue__SWIG_3(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ASTNode_setValue'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    setValue(ASTNode *,long)\n"
    "    setValue(ASTNode *,long,long)\n"
    "    setValue(ASTNode *,double)\n"
    "    setValue(ASTNode *,double,long)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  ASTNodeType_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_setType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setType" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ASTNode_setType" "', argument " "2"" of type '" "ASTNodeType_t""'");
  } 
  arg2 = static_cast< ASTNodeType_t >(val2);
  result = (int)(arg1)->setType(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_setUnits",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setUnits" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ASTNode_setUnits" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->setUnits(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_swapChildren(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  ASTNode *arg2 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ASTNode_swapChildren",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_swapChildren" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ASTNode_swapChildren" "', argument " "2"" of type '" "ASTNode *""'"); 
  }
  arg2 = reinterpret_cast< ASTNode * >(argp2);
  result = (int)(arg1)->swapChildren(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_unsetUnits(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_unsetUnits",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_unsetUnits" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (int)(arg1)->unsetUnits();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getDefinitionURL(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getDefinitionURL",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getDefinitionURL" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (XMLAttributes *)((ASTNode const *)arg1)->getDefinitionURL();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_replaceArgument(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  std::string arg2 ;
  ASTNode *arg3 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:ASTNode_replaceArgument",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_replaceArgument" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "ASTNode_replaceArgument" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  res3 = SWIG_ConvertPtr(obj2, &argp3,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ASTNode_replaceArgument" "', argument " "3"" of type '" "ASTNode *""'"); 
  }
  arg3 = reinterpret_cast< ASTNode * >(argp3);
  (arg1)->replaceArgument(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getParentSBMLObject(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBase *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getParentSBMLObject",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getParentSBMLObject" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (SBase *)((ASTNode const *)arg1)->getParentSBMLObject();
  {
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), GetDowncastSwigType(result),
      0 |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_reduceToBinary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_reduceToBinary",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_reduceToBinary" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  (arg1)->reduceToBinary();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isWellFormedASTNode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isWellFormedASTNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isWellFormedASTNode" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isWellFormedASTNode();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_hasCorrectNumberArguments(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_hasCorrectNumberArguments",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_hasCorrectNumberArguments" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->hasCorrectNumberArguments();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_isBvar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_isBvar",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_isBvar" "', argument " "1"" of type '" "ASTNode const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (bool)((ASTNode const *)arg1)->isBvar();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_setBvar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_setBvar",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_setBvar" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  (arg1)->setBvar();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ASTNode_getListOfNodes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode *arg1 = (ASTNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ListWrapper< ASTNode > *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ASTNode_getListOfNodes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ASTNode_getListOfNodes" "', argument " "1"" of type '" "ASTNode *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode * >(argp1);
  result = (ListWrapper< ASTNode > *)ASTNode_getListOfNodes(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ListWrapperT_ASTNode_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ASTNode_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ASTNode, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_parseFormula(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  PyObject * obj0 = 0 ;
  ASTNode_t *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:parseFormula",&obj0)) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(obj0, &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "parseFormula" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  result = (ASTNode_t *)SBML_parseFormula((char const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ASTNode, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return resultobj;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_formulaToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ASTNode_t *arg1 = (ASTNode_t *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  char *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:formulaToString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ASTNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "formulaToString" "', argument " "1"" of type '" "ASTNode_t const *""'"); 
  }
  arg1 = reinterpret_cast< ASTNode_t * >(argp1);
  result = (char *)SBML_formulaToString((ASTNode const *)arg1);
  resultobj = SWIG_FromCharPtr((const char *)result);
  free(result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLAttributes__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_XMLAttributes")) SWIG_fail;
  {
    try {
      result = (XMLAttributes *)new XMLAttributes();
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLAttributes" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLAttributes__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLAttributes" "', argument " "1"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLAttributes" "', argument " "1"" of type '" "XMLAttributes const &""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    try {
      result = (XMLAttributes *)new XMLAttributes((XMLAttributes const &)*arg1);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLAttributes(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_XMLAttributes__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLAttributes__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLAttributes'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLAttributes()\n"
    "    XMLAttributes(XMLAttributes const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLAttributes_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_clone" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (XMLAttributes *)((XMLAttributes const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_add__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:XMLAttributes_add",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_add" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "XMLAttributes_add" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res5 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj4, &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "XMLAttributes_add" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    arg5 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_add__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:XMLAttributes_add",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_add" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "XMLAttributes_add" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_add__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLAttributes_add",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_add" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_add__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLAttributes_add",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_add" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->add((XMLTriple const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_add(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[6];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_add__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_add__SWIG_2(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_XMLAttributes_add__SWIG_1(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[4], (std::basic_string<char>**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_XMLAttributes_add__SWIG_0(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLAttributes_add'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    add(XMLAttributes *,std::string const &,std::string const &,std::string const &,std::string const &)\n"
    "    add(XMLAttributes *,std::string const &,std::string const &,std::string const &)\n"
    "    add(XMLAttributes *,std::string const &,std::string const &)\n"
    "    add(XMLAttributes *,XMLTriple const &,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_removeResource(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_removeResource",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_removeResource" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_removeResource" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->removeResource(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_remove" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->remove(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLAttributes_remove",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_remove" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLAttributes_remove" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_remove" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->remove((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_remove__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_remove" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_remove__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_remove" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_remove" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)(arg1)->remove((XMLTriple const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_remove__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLAttributes_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_remove__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_remove__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLAttributes_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(XMLAttributes *,int)\n"
    "    remove(XMLAttributes *,std::string const &,std::string const &)\n"
    "    remove(XMLAttributes *,std::string const &)\n"
    "    remove(XMLAttributes *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLAttributes_clear",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_clear" "', argument " "1"" of type '" "XMLAttributes *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (int)(arg1)->clear();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getIndex__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getIndex",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getIndex" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_getIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_getIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLAttributes const *)arg1)->getIndex((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getIndex__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLAttributes_getIndex",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getIndex" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_getIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_getIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLAttributes_getIndex" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_getIndex" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)((XMLAttributes const *)arg1)->getIndex((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getIndex__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getIndex",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getIndex" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_getIndex" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_getIndex" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)((XMLAttributes const *)arg1)->getIndex((XMLTriple const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getIndex(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_getIndex__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_getIndex__SWIG_0(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_getIndex__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLAttributes_getIndex'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getIndex(XMLAttributes const *,std::string const &)\n"
    "    getIndex(XMLAttributes const *,std::string const &,std::string const &)\n"
    "    getIndex(XMLAttributes const *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getLength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLAttributes_getLength",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getLength" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (int)((XMLAttributes const *)arg1)->getLength();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getName" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_getName" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getName(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getPrefix" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_getPrefix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getPrefix(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getPrefixedName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getPrefixedName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getPrefixedName" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_getPrefixedName" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getPrefixedName(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getURI" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_getURI" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getURI(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getValue__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getValue" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_getValue" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLAttributes const *)arg1)->getValue(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getValue__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getValue" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLAttributes_getValue" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = ((XMLAttributes const *)arg1)->getValue(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getValue__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLAttributes_getValue",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getValue" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLAttributes_getValue" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLAttributes_getValue" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = ((XMLAttributes const *)arg1)->getValue(arg2,arg3);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getValue__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_getValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_getValue" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_getValue" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_getValue" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = ((XMLAttributes const *)arg1)->getValue((XMLTriple const &)*arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_getValue(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_getValue__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLAttributes_getValue__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_getValue__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_getValue__SWIG_2(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLAttributes_getValue'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getValue(XMLAttributes const *,int)\n"
    "    getValue(XMLAttributes const *,std::string const)\n"
    "    getValue(XMLAttributes const *,std::string const,std::string const)\n"
    "    getValue(XMLAttributes const *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_hasAttribute__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_hasAttribute",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_hasAttribute" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLAttributes_hasAttribute" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((XMLAttributes const *)arg1)->hasAttribute(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_hasAttribute__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLAttributes_hasAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_hasAttribute" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLAttributes_hasAttribute" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLAttributes_hasAttribute" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)((XMLAttributes const *)arg1)->hasAttribute(arg2,arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_hasAttribute__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_hasAttribute",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_hasAttribute" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLAttributes_hasAttribute" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)((XMLAttributes const *)arg1)->hasAttribute(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_hasAttribute__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLAttributes_hasAttribute",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_hasAttribute" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLAttributes_hasAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLAttributes_hasAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (bool)((XMLAttributes const *)arg1)->hasAttribute((XMLTriple const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_hasAttribute(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_hasAttribute__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLAttributes_hasAttribute__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLAttributes_hasAttribute__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLAttributes, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLAttributes_hasAttribute__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLAttributes_hasAttribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    hasAttribute(XMLAttributes const *,int)\n"
    "    hasAttribute(XMLAttributes const *,std::string const,std::string const)\n"
    "    hasAttribute(XMLAttributes const *,std::string const)\n"
    "    hasAttribute(XMLAttributes const *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLAttributes_isEmpty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLAttributes *arg1 = (XMLAttributes *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLAttributes_isEmpty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLAttributes, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLAttributes_isEmpty" "', argument " "1"" of type '" "XMLAttributes const *""'"); 
  }
  arg1 = reinterpret_cast< XMLAttributes * >(argp1);
  result = (bool)((XMLAttributes const *)arg1)->isEmpty();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *XMLAttributes_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLAttributes, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_XMLNamespaces__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_XMLNamespaces")) SWIG_fail;
  {
    try {
      result = (XMLNamespaces *)new XMLNamespaces();
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLNamespaces" "', argument " "1"" of type '" "XMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNamespaces__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNamespaces" "', argument " "1"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNamespaces" "', argument " "1"" of type '" "XMLNamespaces const &""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    try {
      result = (XMLNamespaces *)new XMLNamespaces((XMLNamespaces const &)*arg1);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNamespaces(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_XMLNamespaces__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNamespaces__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLNamespaces'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLNamespaces()\n"
    "    XMLNamespaces(XMLNamespaces const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNamespaces_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_clone" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (XMLNamespaces *)((XMLNamespaces const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_add__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLNamespaces_add",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_add" "', argument " "1"" of type '" "XMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLNamespaces_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_add" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_add__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_add",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_add" "', argument " "1"" of type '" "XMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_add" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->add((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_add(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNamespaces_add__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLNamespaces_add__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLNamespaces_add'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    add(XMLNamespaces *,std::string const &,std::string const &)\n"
    "    add(XMLNamespaces *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_remove__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_remove" "', argument " "1"" of type '" "XMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNamespaces_remove" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->remove(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_remove__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_remove",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_remove" "', argument " "1"" of type '" "XMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_remove" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->remove((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_remove(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNamespaces_remove__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNamespaces_remove__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLNamespaces_remove'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    remove(XMLNamespaces *,int)\n"
    "    remove(XMLNamespaces *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNamespaces_clear",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_clear" "', argument " "1"" of type '" "XMLNamespaces *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (int)(arg1)->clear();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getIndex(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_getIndex",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getIndex" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLNamespaces_getIndex" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)((XMLNamespaces const *)arg1)->getIndex(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getIndexByPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_getIndexByPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getIndexByPrefix" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLNamespaces_getIndexByPrefix" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)((XMLNamespaces const *)arg1)->getIndexByPrefix(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getLength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNamespaces_getLength",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getLength" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (int)((XMLNamespaces const *)arg1)->getLength();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getPrefix__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_getPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getPrefix" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNamespaces_getPrefix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLNamespaces const *)arg1)->getPrefix(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getPrefix__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_getPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getPrefix" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_getPrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_getPrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((XMLNamespaces const *)arg1)->getPrefix((std::string const &)*arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getPrefix(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNamespaces_getPrefix__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNamespaces_getPrefix__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLNamespaces_getPrefix'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getPrefix(XMLNamespaces const *,int)\n"
    "    getPrefix(XMLNamespaces const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getURI__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_getURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getURI" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNamespaces_getURI" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLNamespaces const *)arg1)->getURI(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getURI__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_getURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getURI" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_getURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_getURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((XMLNamespaces const *)arg1)->getURI((std::string const &)*arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getURI__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNamespaces_getURI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_getURI" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = ((XMLNamespaces const *)arg1)->getURI();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_getURI(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_XMLNamespaces_getURI__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNamespaces_getURI__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNamespaces_getURI__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLNamespaces_getURI'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getURI(XMLNamespaces const *,int)\n"
    "    getURI(XMLNamespaces const *,std::string const &)\n"
    "    getURI(XMLNamespaces const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_isEmpty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNamespaces_isEmpty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_isEmpty" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  result = (bool)((XMLNamespaces const *)arg1)->isEmpty();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_hasURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_hasURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_hasURI" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_hasURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_hasURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLNamespaces const *)arg1)->hasURI((std::string const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_hasPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNamespaces_hasPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_hasPrefix" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_hasPrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_hasPrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLNamespaces const *)arg1)->hasPrefix((std::string const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNamespaces_hasNS(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNamespaces *arg1 = (XMLNamespaces *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLNamespaces_hasNS",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNamespaces_hasNS" "', argument " "1"" of type '" "XMLNamespaces const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNamespaces * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNamespaces_hasNS" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_hasNS" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLNamespaces_hasNS" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNamespaces_hasNS" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (bool)((XMLNamespaces const *)arg1)->hasNS((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *XMLNamespaces_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLNamespaces, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_XMLToken")) SWIG_fail;
  {
    try {
      result = (XMLToken *)new XMLToken();
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_XMLToken",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLToken" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_XMLToken" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3,arg4,arg5);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  unsigned int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_XMLToken",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLToken" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3,arg4);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLToken",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_XMLToken",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLToken" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,arg3,arg4);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLToken",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,arg3);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLToken",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLToken",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,arg2,arg3);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_8(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLToken",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1,arg2);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_9(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLToken",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLTriple const &)*arg1);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_10(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLToken",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLToken" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLToken *)new XMLToken((std::string const &)*arg1,arg2,arg3);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_11(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLToken",&obj0,&obj1)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLToken" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (XMLToken *)new XMLToken((std::string const &)*arg1,arg2);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_12(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLToken",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (XMLToken *)new XMLToken((std::string const &)*arg1);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLToken(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLToken",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLToken" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken__SWIG_13(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLToken",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLToken,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLToken const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLToken" "', argument " "1"" of type '" "XMLToken const &""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    try {
      result = (XMLToken *)new XMLToken((XMLToken const &)*arg1);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLToken(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[6];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_XMLToken__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLToken__SWIG_9(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLToken__SWIG_13(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLToken__SWIG_12(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_XMLToken__SWIG_6(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLToken__SWIG_8(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLToken__SWIG_11(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_XMLToken__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLToken__SWIG_5(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLToken__SWIG_7(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLToken__SWIG_10(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLToken__SWIG_2(self, args);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLToken__SWIG_4(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_XMLToken__SWIG_1(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLToken'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLToken()\n"
    "    XMLToken(XMLTriple const &,XMLAttributes const &,XMLNamespaces const &,unsigned int const,unsigned int const)\n"
    "    XMLToken(XMLTriple const &,XMLAttributes const &,XMLNamespaces const &,unsigned int const)\n"
    "    XMLToken(XMLTriple const &,XMLAttributes const &,XMLNamespaces const &)\n"
    "    XMLToken(XMLTriple const &,XMLAttributes const &,unsigned int const,unsigned int const)\n"
    "    XMLToken(XMLTriple const &,XMLAttributes const &,unsigned int const)\n"
    "    XMLToken(XMLTriple const &,XMLAttributes const &)\n"
    "    XMLToken(XMLTriple const &,unsigned int const,unsigned int const)\n"
    "    XMLToken(XMLTriple const &,unsigned int const)\n"
    "    XMLToken(XMLTriple const &)\n"
    "    XMLToken(std::string const &,unsigned int const,unsigned int const)\n"
    "    XMLToken(std::string const &,unsigned int const)\n"
    "    XMLToken(std::string const &)\n"
    "    XMLToken(XMLToken const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLToken *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_clone" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (XMLToken *)((XMLToken const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLToken, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttributes" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (XMLAttributes *) &((XMLToken const *)arg1)->getAttributes();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_setAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLAttributes *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_setAttributes",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_setAttributes" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_setAttributes" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_setAttributes" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  result = (int)(arg1)->setAttributes((XMLAttributes const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addAttr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:XMLToken_addAttr",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_addAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "XMLToken_addAttr" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res5 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj4, &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "XMLToken_addAttr" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    arg5 = ptr;
  }
  result = (int)(arg1)->addAttr((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addAttr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:XMLToken_addAttr",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_addAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "XMLToken_addAttr" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  result = (int)(arg1)->addAttr((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addAttr__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_addAttr",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_addAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->addAttr((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addAttr__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_addAttr",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_addAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->addAttr((XMLTriple const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addAttr(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[6];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_addAttr__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_addAttr__SWIG_2(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_XMLToken_addAttr__SWIG_1(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[4], (std::basic_string<char>**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_XMLToken_addAttr__SWIG_0(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_addAttr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    addAttr(XMLToken *,std::string const &,std::string const &,std::string const &,std::string const &)\n"
    "    addAttr(XMLToken *,std::string const &,std::string const &,std::string const &)\n"
    "    addAttr(XMLToken *,std::string const &,std::string const &)\n"
    "    addAttr(XMLToken *,XMLTriple const &,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeAttr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_removeAttr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_removeAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->removeAttr(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeAttr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_removeAttr",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_removeAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_removeAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_removeAttr" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->removeAttr((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeAttr__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_removeAttr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_removeAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->removeAttr((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeAttr__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_removeAttr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_removeAttr" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_removeAttr" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)(arg1)->removeAttr((XMLTriple const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeAttr(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_removeAttr__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_removeAttr__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_removeAttr__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_removeAttr__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_removeAttr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeAttr(XMLToken *,int)\n"
    "    removeAttr(XMLToken *,std::string const &,std::string const &)\n"
    "    removeAttr(XMLToken *,std::string const &)\n"
    "    removeAttr(XMLToken *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_clearAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_clearAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_clearAttributes" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->clearAttributes();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrIndex__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_getAttrIndex",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrIndex" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getAttrIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getAttrIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_getAttrIndex" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getAttrIndex" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)((XMLToken const *)arg1)->getAttrIndex((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrIndex__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrIndex",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrIndex" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getAttrIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getAttrIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLToken const *)arg1)->getAttrIndex((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrIndex__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrIndex",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrIndex" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getAttrIndex" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getAttrIndex" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)((XMLToken const *)arg1)->getAttrIndex((XMLTriple const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrIndex(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getAttrIndex__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getAttrIndex__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_getAttrIndex__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_getAttrIndex'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getAttrIndex(XMLToken const *,std::string const &,std::string const &)\n"
    "    getAttrIndex(XMLToken const *,std::string const &)\n"
    "    getAttrIndex(XMLToken const *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttributesLength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getAttributesLength",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttributesLength" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)((XMLToken const *)arg1)->getAttributesLength();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrName" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getAttrName" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrName(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrPrefix" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getAttrPrefix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrPrefix(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrPrefixedName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrPrefixedName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrPrefixedName" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getAttrPrefixedName" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrPrefixedName(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrURI" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getAttrURI" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrURI(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrValue__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrValue" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getAttrValue" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getAttrValue(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrValue__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_getAttrValue",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrValue" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLToken_getAttrValue" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLToken_getAttrValue" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = ((XMLToken const *)arg1)->getAttrValue(arg2,arg3);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrValue__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrValue" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLToken_getAttrValue" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = ((XMLToken const *)arg1)->getAttrValue(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrValue__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getAttrValue",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getAttrValue" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getAttrValue" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getAttrValue" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = ((XMLToken const *)arg1)->getAttrValue((XMLTriple const &)*arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getAttrValue(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getAttrValue__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_getAttrValue__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getAttrValue__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_getAttrValue__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_getAttrValue'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getAttrValue(XMLToken const *,int)\n"
    "    getAttrValue(XMLToken const *,std::string const,std::string const)\n"
    "    getAttrValue(XMLToken const *,std::string const)\n"
    "    getAttrValue(XMLToken const *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasAttr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_hasAttr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasAttr" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_hasAttr" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (bool)((XMLToken const *)arg1)->hasAttr(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasAttr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string arg2 ;
  std::string arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_hasAttr",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasAttr" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLToken_hasAttr" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLToken_hasAttr" "', argument " "3"" of type '" "std::string const""'"); 
    }
    arg3 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasAttr(arg2,arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasAttr__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_hasAttr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasAttr" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "XMLToken_hasAttr" "', argument " "2"" of type '" "std::string const""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasAttr(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasAttr__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_hasAttr",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasAttr" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_hasAttr" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_hasAttr" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (bool)((XMLToken const *)arg1)->hasAttr((XMLTriple const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasAttr(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_hasAttr__SWIG_3(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_hasAttr__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_hasAttr__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_hasAttr__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_hasAttr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    hasAttr(XMLToken const *,int)\n"
    "    hasAttr(XMLToken const *,std::string const,std::string const)\n"
    "    hasAttr(XMLToken const *,std::string const)\n"
    "    hasAttr(XMLToken const *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isAttributesEmpty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isAttributesEmpty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isAttributesEmpty" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isAttributesEmpty();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNamespaces *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespaces" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (XMLNamespaces *) &((XMLToken const *)arg1)->getNamespaces();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_setNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLNamespaces *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_setNamespaces",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_setNamespaces" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_setNamespaces" "', argument " "2"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_setNamespaces" "', argument " "2"" of type '" "XMLNamespaces const &""'"); 
  }
  arg2 = reinterpret_cast< XMLNamespaces * >(argp2);
  result = (int)(arg1)->setNamespaces((XMLNamespaces const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addNamespace__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_addNamespace",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_addNamespace" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_addNamespace" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addNamespace" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_addNamespace" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addNamespace" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (int)(arg1)->addNamespace((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addNamespace__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_addNamespace",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_addNamespace" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_addNamespace" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_addNamespace" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->addNamespace((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_addNamespace(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_addNamespace__SWIG_1(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLToken_addNamespace__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_addNamespace'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    addNamespace(XMLToken *,std::string const &,std::string const &)\n"
    "    addNamespace(XMLToken *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeNamespace__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_removeNamespace",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_removeNamespace" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_removeNamespace" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = (int)(arg1)->removeNamespace(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeNamespace__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_removeNamespace",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_removeNamespace" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_removeNamespace" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_removeNamespace" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->removeNamespace((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_removeNamespace(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_removeNamespace__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_removeNamespace__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_removeNamespace'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    removeNamespace(XMLToken *,int)\n"
    "    removeNamespace(XMLToken *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_clearNamespaces(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_clearNamespaces",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_clearNamespaces" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->clearNamespaces();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaceIndex(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getNamespaceIndex",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespaceIndex" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getNamespaceIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getNamespaceIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLToken const *)arg1)->getNamespaceIndex((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaceIndexByPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getNamespaceIndexByPrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespaceIndexByPrefix" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getNamespaceIndexByPrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getNamespaceIndexByPrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLToken const *)arg1)->getNamespaceIndexByPrefix((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespacesLength(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getNamespacesLength",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespacesLength" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)((XMLToken const *)arg1)->getNamespacesLength();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespacePrefix__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getNamespacePrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespacePrefix" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getNamespacePrefix" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getNamespacePrefix(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespacePrefix__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getNamespacePrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespacePrefix" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getNamespacePrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getNamespacePrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((XMLToken const *)arg1)->getNamespacePrefix((std::string const &)*arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespacePrefix(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_getNamespacePrefix__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getNamespacePrefix__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_getNamespacePrefix'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getNamespacePrefix(XMLToken const *,int)\n"
    "    getNamespacePrefix(XMLToken const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaceURI__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getNamespaceURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespaceURI" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLToken_getNamespaceURI" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  result = ((XMLToken const *)arg1)->getNamespaceURI(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaceURI__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_getNamespaceURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespaceURI" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_getNamespaceURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_getNamespaceURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = ((XMLToken const *)arg1)->getNamespaceURI((std::string const &)*arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaceURI__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getNamespaceURI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getNamespaceURI" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = ((XMLToken const *)arg1)->getNamespaceURI();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getNamespaceURI(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_XMLToken_getNamespaceURI__SWIG_2(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLToken_getNamespaceURI__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLToken_getNamespaceURI__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLToken_getNamespaceURI'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getNamespaceURI(XMLToken const *,int)\n"
    "    getNamespaceURI(XMLToken const *,std::string const &)\n"
    "    getNamespaceURI(XMLToken const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isNamespacesEmpty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isNamespacesEmpty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isNamespacesEmpty" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isNamespacesEmpty();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasNamespaceURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_hasNamespaceURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasNamespaceURI" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_hasNamespaceURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_hasNamespaceURI" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasNamespaceURI((std::string const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasNamespacePrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_hasNamespacePrefix",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasNamespacePrefix" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_hasNamespacePrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_hasNamespacePrefix" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasNamespacePrefix((std::string const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_hasNamespaceNS(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLToken_hasNamespaceNS",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_hasNamespaceNS" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_hasNamespaceNS" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_hasNamespaceNS" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLToken_hasNamespaceNS" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_hasNamespaceNS" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (bool)((XMLToken const *)arg1)->hasNamespaceNS((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_setTriple(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_setTriple",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_setTriple" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_setTriple" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_setTriple" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  result = (int)(arg1)->setTriple((XMLTriple const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getName" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (std::string *) &((XMLToken const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getPrefix",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getPrefix" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (std::string *) &((XMLToken const *)arg1)->getPrefix();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getURI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getURI" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (std::string *) &((XMLToken const *)arg1)->getURI();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getCharacters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getCharacters",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getCharacters" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (std::string *) &((XMLToken const *)arg1)->getCharacters();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_append(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_append",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_append" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_append" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_append" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->append((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getColumn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getColumn",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getColumn" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (unsigned int)((XMLToken const *)arg1)->getColumn();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_getLine(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_getLine",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_getLine" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (unsigned int)((XMLToken const *)arg1)->getLine();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isElement(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isElement",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isElement" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isElement();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isEnd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isEnd",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isEnd" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isEnd();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isEndFor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  XMLToken *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLToken_isEndFor",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isEndFor" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLToken,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLToken_isEndFor" "', argument " "2"" of type '" "XMLToken const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLToken_isEndFor" "', argument " "2"" of type '" "XMLToken const &""'"); 
  }
  arg2 = reinterpret_cast< XMLToken * >(argp2);
  result = (bool)((XMLToken const *)arg1)->isEndFor((XMLToken const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isEOF(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isEOF",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isEOF" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isEOF();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isStart(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isStart",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isStart" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isStart();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_isText(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_isText",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_isText" "', argument " "1"" of type '" "XMLToken const *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (bool)((XMLToken const *)arg1)->isText();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_setEnd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_setEnd",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_setEnd" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->setEnd();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_setEOF(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_setEOF",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_setEOF" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->setEOF();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_unsetEnd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_unsetEnd",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_unsetEnd" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (int)(arg1)->unsetEnd();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLToken_toString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = (XMLToken *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLToken_toString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLToken, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLToken_toString" "', argument " "1"" of type '" "XMLToken *""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  result = (arg1)->toString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *XMLToken_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLToken, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_XMLNode")) SWIG_fail;
  {
    try {
      result = (XMLNode *)new XMLNode();
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLToken *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLToken,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLToken const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLToken const &""'"); 
  }
  arg1 = reinterpret_cast< XMLToken * >(argp1);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLToken const &)*arg1);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_XMLNode",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLNode" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_XMLNode" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3,arg4,arg5);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  unsigned int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_XMLNode",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLNode" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3,arg4);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  XMLNamespaces *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLNode",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNamespaces,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "3"" of type '" "XMLNamespaces const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNamespaces * >(argp3);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,(XMLNamespaces const &)*arg3);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_XMLNode",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLNode" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,arg3,arg4);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLNode",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2,arg3);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  XMLAttributes *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLNode",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLAttributes,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "2"" of type '" "XMLAttributes const &""'"); 
  }
  arg2 = reinterpret_cast< XMLAttributes * >(argp2);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,(XMLAttributes const &)*arg2);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_8(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLNode",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,arg2,arg3);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_9(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLNode",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1,arg2);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_10(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLTriple const &)*arg1);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_11(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLNode",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLNode" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLNode *)new XMLNode((std::string const &)*arg1,arg2,arg3);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_12(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  unsigned int arg2 ;
  int res1 = SWIG_OLDOBJ ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLNode",&obj0,&obj1)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLNode" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  {
    try {
      result = (XMLNode *)new XMLNode((std::string const &)*arg1,arg2);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_13(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLNode",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    try {
      result = (XMLNode *)new XMLNode((std::string const &)*arg1);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLNode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLNode" "', argument " "1"" of type '" "XMLNode *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode__SWIG_14(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLNode",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLNode,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLNode const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLNode" "', argument " "1"" of type '" "XMLNode const &""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  {
    try {
      result = (XMLNode *)new XMLNode((XMLNode const &)*arg1);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLNode(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[6];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_XMLNode__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNode__SWIG_14(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNode__SWIG_10(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLToken, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNode__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLNode__SWIG_13(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_XMLNode__SWIG_7(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLNode__SWIG_9(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLNode__SWIG_12(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_XMLNode__SWIG_4(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLNode__SWIG_6(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLNode__SWIG_8(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLNode__SWIG_11(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLNode__SWIG_3(self, args);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLNode__SWIG_5(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLAttributes, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_XMLNamespaces, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_XMLNode__SWIG_2(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLNode'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLNode()\n"
    "    XMLNode(XMLToken const &)\n"
    "    XMLNode(XMLTriple const &,XMLAttributes const &,XMLNamespaces const &,unsigned int const,unsigned int const)\n"
    "    XMLNode(XMLTriple const &,XMLAttributes const &,XMLNamespaces const &,unsigned int const)\n"
    "    XMLNode(XMLTriple const &,XMLAttributes const &,XMLNamespaces const &)\n"
    "    XMLNode(XMLTriple const &,XMLAttributes const &,unsigned int const,unsigned int const)\n"
    "    XMLNode(XMLTriple const &,XMLAttributes const &,unsigned int const)\n"
    "    XMLNode(XMLTriple const &,XMLAttributes const &)\n"
    "    XMLNode(XMLTriple const &,unsigned int const,unsigned int const)\n"
    "    XMLNode(XMLTriple const &,unsigned int const)\n"
    "    XMLNode(XMLTriple const &)\n"
    "    XMLNode(std::string const &,unsigned int const,unsigned int const)\n"
    "    XMLNode(std::string const &,unsigned int const)\n"
    "    XMLNode(std::string const &)\n"
    "    XMLNode(XMLNode const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNode_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_clone" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (XMLNode *)((XMLNode const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_addChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  XMLNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_addChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_addChild" "', argument " "1"" of type '" "XMLNode *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLNode,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNode_addChild" "', argument " "2"" of type '" "XMLNode const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNode_addChild" "', argument " "2"" of type '" "XMLNode const &""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (int)(arg1)->addChild((XMLNode const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_insertChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  unsigned int arg2 ;
  XMLNode *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLNode_insertChild",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_insertChild" "', argument " "1"" of type '" "XMLNode *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNode_insertChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  res3 = SWIG_ConvertPtr(obj2, &argp3, SWIGTYPE_p_XMLNode,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLNode_insertChild" "', argument " "3"" of type '" "XMLNode const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNode_insertChild" "', argument " "3"" of type '" "XMLNode const &""'"); 
  }
  arg3 = reinterpret_cast< XMLNode * >(argp3);
  result = (XMLNode *) &(arg1)->insertChild(arg2,(XMLNode const &)*arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_removeChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_removeChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_removeChild" "', argument " "1"" of type '" "XMLNode *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNode_removeChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *)(arg1)->removeChild(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_removeChildren(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNode_removeChildren",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_removeChildren" "', argument " "1"" of type '" "XMLNode *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (int)(arg1)->removeChildren();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_getChild__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_getChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_getChild" "', argument " "1"" of type '" "XMLNode *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNode_getChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *) &(arg1)->getChild(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_getChild__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_getChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_getChild" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLNode_getChild" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLNode *) &((XMLNode const *)arg1)->getChild(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_getChild__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_getChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_getChild" "', argument " "1"" of type '" "XMLNode *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNode_getChild" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNode_getChild" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (XMLNode *) &(arg1)->getChild((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_getChild__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_getChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_getChild" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNode_getChild" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNode_getChild" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (XMLNode *) &((XMLNode const *)arg1)->getChild((std::string const &)*arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_getChild(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNode_getChild__SWIG_0(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_XMLNode_getChild__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNode_getChild__SWIG_2(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNode_getChild__SWIG_3(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLNode_getChild'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getChild(XMLNode *,unsigned int)\n"
    "    getChild(XMLNode const *,unsigned int)\n"
    "    getChild(XMLNode *,std::string const &)\n"
    "    getChild(XMLNode const *,std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_getIndex(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_getIndex",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_getIndex" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNode_getIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNode_getIndex" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)((XMLNode const *)arg1)->getIndex((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_hasChild(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_hasChild",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_hasChild" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNode_hasChild" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNode_hasChild" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (bool)((XMLNode const *)arg1)->hasChild((std::string const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_equals(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  XMLNode *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_equals",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_equals" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLNode,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNode_equals" "', argument " "2"" of type '" "XMLNode const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNode_equals" "', argument " "2"" of type '" "XMLNode const &""'"); 
  }
  arg2 = reinterpret_cast< XMLNode * >(argp2);
  result = (bool)((XMLNode const *)arg1)->equals((XMLNode const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_getNumChildren(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNode_getNumChildren",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_getNumChildren" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (unsigned int)((XMLNode const *)arg1)->getNumChildren();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_toXMLString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNode_toXMLString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_toXMLString" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = ((XMLNode const *)arg1)->toXMLString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_convertXMLNodeToString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNode_convertXMLNodeToString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_convertXMLNodeToString" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = XMLNode::convertXMLNodeToString((XMLNode const *)arg1);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_convertStringToXMLNode__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  XMLNamespaces *arg2 = (XMLNamespaces *) 0 ;
  int res1 = SWIG_OLDOBJ ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLNode_convertStringToXMLNode",&obj0,&obj1)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_convertStringToXMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNode_convertStringToXMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_XMLNamespaces, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLNode_convertStringToXMLNode" "', argument " "2"" of type '" "XMLNamespaces const *""'"); 
  }
  arg2 = reinterpret_cast< XMLNamespaces * >(argp2);
  result = (XMLNode *)XMLNode::convertStringToXMLNode((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1,(XMLNamespaces const *)arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_convertStringToXMLNode__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLNode_convertStringToXMLNode",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLNode_convertStringToXMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLNode_convertStringToXMLNode" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (XMLNode *)XMLNode::convertStringToXMLNode((std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLNode_convertStringToXMLNode(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_XMLNode_convertStringToXMLNode__SWIG_1(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_XMLNamespaces, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLNode_convertStringToXMLNode__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLNode_convertStringToXMLNode'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    convertStringToXMLNode(std::string const &,XMLNamespaces const *)\n"
    "    XMLNode::convertStringToXMLNode(std::string const &)\n");
  return NULL;
}


SWIGINTERN PyObject *XMLNode_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLNode, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_XMLTriple__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_XMLTriple")) SWIG_fail;
  result = (XMLTriple *)new XMLTriple();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLTriple, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLTriple__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLTriple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLTriple",&obj0,&obj1,&obj2)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLTriple" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLTriple" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLTriple" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLTriple" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "new_XMLTriple" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLTriple" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  result = (XMLTriple *)new XMLTriple((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLTriple, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLTriple__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  char arg2 ;
  int res1 = SWIG_OLDOBJ ;
  char val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLTriple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLTriple",&obj0,&obj1)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLTriple" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLTriple" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  ecode2 = SWIG_AsVal_char(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_XMLTriple" "', argument " "2"" of type '" "char""'");
  } 
  arg2 = static_cast< char >(val2);
  result = (XMLTriple *)new XMLTriple((std::string const &)*arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLTriple, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLTriple__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  XMLTriple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLTriple",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLTriple" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLTriple" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (XMLTriple *)new XMLTriple((std::string const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLTriple, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLTriple__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLTriple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLTriple",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLTriple" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLTriple" "', argument " "1"" of type '" "XMLTriple const &""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (XMLTriple *)new XMLTriple((XMLTriple const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLTriple, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLTriple(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_XMLTriple__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLTriple, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLTriple__SWIG_4(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLTriple__SWIG_3(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_char(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_XMLTriple__SWIG_2(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_new_XMLTriple__SWIG_1(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLTriple'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLTriple()\n"
    "    XMLTriple(std::string const &,std::string const &,std::string const &)\n"
    "    XMLTriple(std::string const &,char const)\n"
    "    XMLTriple(std::string const &)\n"
    "    XMLTriple(XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLTriple_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLTriple *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLTriple_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLTriple_clone" "', argument " "1"" of type '" "XMLTriple const *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (XMLTriple *)((XMLTriple const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLTriple, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLTriple_getName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLTriple_getName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLTriple_getName" "', argument " "1"" of type '" "XMLTriple const *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (std::string *) &((XMLTriple const *)arg1)->getName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLTriple_getPrefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLTriple_getPrefix",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLTriple_getPrefix" "', argument " "1"" of type '" "XMLTriple const *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (std::string *) &((XMLTriple const *)arg1)->getPrefix();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLTriple_getURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLTriple_getURI",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLTriple_getURI" "', argument " "1"" of type '" "XMLTriple const *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (std::string *) &((XMLTriple const *)arg1)->getURI();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLTriple_getPrefixedName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLTriple_getPrefixedName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLTriple_getPrefixedName" "', argument " "1"" of type '" "XMLTriple const *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = ((XMLTriple const *)arg1)->getPrefixedName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLTriple_isEmpty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLTriple_isEmpty",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLTriple_isEmpty" "', argument " "1"" of type '" "XMLTriple const *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  result = (bool)((XMLTriple const *)arg1)->isEmpty();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLTriple(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLTriple *arg1 = (XMLTriple *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLTriple",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLTriple, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLTriple" "', argument " "1"" of type '" "XMLTriple *""'"); 
  }
  arg1 = reinterpret_cast< XMLTriple * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *XMLTriple_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLTriple, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_XMLOutputStream__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::ostream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  int res5 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  XMLOutputStream *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_XMLOutputStream",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLOutputStream" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_XMLOutputStream" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res5 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj4, &ptr);
    if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "new_XMLOutputStream" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "5"" of type '" "std::string const &""'"); 
    }
    arg5 = ptr;
  }
  {
    try {
      result = (XMLOutputStream *)new XMLOutputStream(*arg1,(std::string const &)*arg2,arg3,(std::string const &)*arg4,(std::string const &)*arg5);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLOutputStream, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  if (SWIG_IsNewObj(res5)) delete arg5;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLOutputStream__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::ostream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  std::string *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  XMLOutputStream *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_XMLOutputStream",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLOutputStream" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_XMLOutputStream" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  {
    try {
      result = (XMLOutputStream *)new XMLOutputStream(*arg1,(std::string const &)*arg2,arg3,(std::string const &)*arg4);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLOutputStream, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLOutputStream__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::ostream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLOutputStream *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLOutputStream",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLOutputStream" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = (XMLOutputStream *)new XMLOutputStream(*arg1,(std::string const &)*arg2,arg3);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLOutputStream, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLOutputStream__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::ostream *arg1 = 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLOutputStream *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLOutputStream",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      result = (XMLOutputStream *)new XMLOutputStream(*arg1,(std::string const &)*arg2);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLOutputStream, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLOutputStream__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::ostream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLOutputStream *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLOutputStream",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLOutputStream" "', argument " "1"" of type '" "std::ostream &""'"); 
  }
  arg1 = reinterpret_cast< std::ostream * >(argp1);
  {
    try {
      result = (XMLOutputStream *)new XMLOutputStream(*arg1);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLOutputStream, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLOutputStream(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[6];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 5); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLOutputStream__SWIG_4(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_XMLOutputStream__SWIG_3(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLOutputStream__SWIG_2(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_XMLOutputStream__SWIG_1(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[4], (std::basic_string<char>**)(0));
            _v = SWIG_CheckState(res);
            if (_v) {
              return _wrap_new_XMLOutputStream__SWIG_0(self, args);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLOutputStream'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLOutputStream(std::ostream &,std::string const &,bool,std::string const &,std::string const &)\n"
    "    XMLOutputStream(std::ostream &,std::string const &,bool,std::string const &)\n"
    "    XMLOutputStream(std::ostream &,std::string const &,bool)\n"
    "    XMLOutputStream(std::ostream &,std::string const &)\n"
    "    XMLOutputStream(std::ostream &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_endElement__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_endElement",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_endElement" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_endElement" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_endElement" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->endElement((std::string const &)*arg2);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_endElement__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_endElement",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_endElement" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_endElement" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_endElement" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  (arg1)->endElement((XMLTriple const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_endElement(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_endElement__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_endElement__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLOutputStream_endElement'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    endElement(XMLOutputStream *,std::string const &)\n"
    "    endElement(XMLOutputStream *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_setAutoIndent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_setAutoIndent",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_setAutoIndent" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  ecode2 = SWIG_AsVal_bool(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLOutputStream_setAutoIndent" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->setAutoIndent(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_startElement__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_startElement",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_startElement" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_startElement" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_startElement" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->startElement((std::string const &)*arg2);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_startElement__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_startElement",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_startElement" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_startElement" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_startElement" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  (arg1)->startElement((XMLTriple const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_startElement(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_startElement__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_startElement__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLOutputStream_startElement'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    startElement(XMLOutputStream *,std::string const &)\n"
    "    startElement(XMLOutputStream *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_startEndElement__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_startEndElement",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_startEndElement" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_startEndElement" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_startEndElement" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  (arg1)->startEndElement((std::string const &)*arg2);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_startEndElement__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLOutputStream_startEndElement",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_startEndElement" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_startEndElement" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_startEndElement" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  (arg1)->startEndElement((XMLTriple const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_startEndElement(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_startEndElement__SWIG_1(self, args);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_XMLOutputStream_startEndElement__SWIG_0(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLOutputStream_startEndElement'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    startEndElement(XMLOutputStream *,std::string const &)\n"
    "    startEndElement(XMLOutputStream *,XMLTriple const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  (arg1)->writeAttribute((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  bool *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool temp3 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "bool""'");
  } 
  temp3 = static_cast< bool >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((std::string const &)*arg2,(bool const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  bool *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool temp3 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "bool""'");
  } 
  temp3 = static_cast< bool >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(bool const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  double *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  double temp3 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "double""'");
  } 
  temp3 = static_cast< double >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((std::string const &)*arg2,(double const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  double *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  double temp3 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_double(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "double""'");
  } 
  temp3 = static_cast< double >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(double const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  long *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  long temp3 ;
  long val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_long(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "long""'");
  } 
  temp3 = static_cast< long >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((std::string const &)*arg2,(long const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  long *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  long temp3 ;
  long val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_long(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "long""'");
  } 
  temp3 = static_cast< long >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(long const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_8(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  int *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int temp3 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "int""'");
  } 
  temp3 = static_cast< int >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((std::string const &)*arg2,(int const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute__SWIG_9(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  int *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int temp3 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttribute",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttribute" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttribute" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttribute" "', argument " "3"" of type '" "int""'");
  } 
  temp3 = static_cast< int >(val3);
  arg3 = &temp3;
  (arg1)->writeAttribute((XMLTriple const &)*arg2,(int const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttribute(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_9(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_7(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_5(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_8(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_long(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_6(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_double(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_4(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[2], (std::basic_string<char>**)(0));
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_0(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttribute__SWIG_2(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLOutputStream_writeAttribute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    writeAttribute(XMLOutputStream *,std::string const &,std::string const &)\n"
    "    writeAttribute(XMLOutputStream *,XMLTriple const &,std::string const &)\n"
    "    writeAttribute(XMLOutputStream *,std::string const &,bool const &)\n"
    "    writeAttribute(XMLOutputStream *,XMLTriple const &,bool const &)\n"
    "    writeAttribute(XMLOutputStream *,std::string const &,double const &)\n"
    "    writeAttribute(XMLOutputStream *,XMLTriple const &,double const &)\n"
    "    writeAttribute(XMLOutputStream *,std::string const &,long const &)\n"
    "    writeAttribute(XMLOutputStream *,XMLTriple const &,long const &)\n"
    "    writeAttribute(XMLOutputStream *,std::string const &,int const &)\n"
    "    writeAttribute(XMLOutputStream *,XMLTriple const &,int const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeXMLDecl(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLOutputStream_writeXMLDecl",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeXMLDecl" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  (arg1)->writeXMLDecl();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeComment(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeComment",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeComment" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeComment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeComment" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res3 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj2, &ptr);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "XMLOutputStream_writeComment" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeComment" "', argument " "3"" of type '" "std::string const &""'"); 
    }
    arg3 = ptr;
  }
  (arg1)->writeComment((std::string const &)*arg2,(std::string const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_downIndent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLOutputStream_downIndent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_downIndent" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  (arg1)->downIndent();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_upIndent(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLOutputStream_upIndent",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_upIndent" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  (arg1)->upIndent();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttributeBool__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  std::string *arg2 = 0 ;
  bool *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  bool temp3 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttributeBool",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "3"" of type '" "bool""'");
  } 
  temp3 = static_cast< bool >(val3);
  arg3 = &temp3;
  XMLOutputStream_writeAttributeBool__SWIG_0(arg1,(std::basic_string< char,std::char_traits< char >,std::allocator< char > > const &)*arg2,(bool const &)*arg3);
  resultobj = SWIG_Py_Void();
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttributeBool__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  XMLTriple *arg2 = 0 ;
  bool *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool temp3 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:XMLOutputStream_writeAttributeBool",&obj0,&obj1,&obj2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2, SWIGTYPE_p_XMLTriple,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "2"" of type '" "XMLTriple const &""'"); 
  }
  arg2 = reinterpret_cast< XMLTriple * >(argp2);
  ecode3 = SWIG_AsVal_bool(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "XMLOutputStream_writeAttributeBool" "', argument " "3"" of type '" "bool""'");
  } 
  temp3 = static_cast< bool >(val3);
  arg3 = &temp3;
  XMLOutputStream_writeAttributeBool__SWIG_1(arg1,(XMLTriple const &)*arg2,(bool const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLOutputStream_writeAttributeBool(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[4];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 3); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_XMLTriple, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttributeBool__SWIG_1(self, args);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLOutputStream, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_bool(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_XMLOutputStream_writeAttributeBool__SWIG_0(self, args);
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'XMLOutputStream_writeAttributeBool'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    writeAttributeBool(XMLOutputStream *,std::string const &,bool const &)\n"
    "    writeAttributeBool(XMLOutputStream *,XMLTriple const &,bool const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLOutputStream(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLOutputStream *arg1 = (XMLOutputStream *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLOutputStream",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLOutputStream, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLOutputStream" "', argument " "1"" of type '" "XMLOutputStream *""'"); 
  }
  arg1 = reinterpret_cast< XMLOutputStream * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *XMLOutputStream_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLOutputStream, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:new_XMLError",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_XMLError" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLError" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_XMLError" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_XMLError" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  {
    try {
      result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2,arg3,arg4,arg5,arg6);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_XMLError",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_XMLError" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLError" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_XMLError" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  {
    try {
      result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2,arg3,arg4,arg5);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_XMLError",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_XMLError" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_XMLError" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  {
    try {
      result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2,arg3,arg4);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  std::string *arg2 = 0 ;
  unsigned int arg3 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_XMLError",&obj0,&obj1,&obj2)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_XMLError" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_XMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    try {
      result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2,arg3);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  std::string *arg2 = 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_XMLError",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_XMLError" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLError" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  {
    try {
      result = (XMLError *)new XMLError(arg1,(std::string const &)*arg2);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLError",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_XMLError" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    try {
      result = (XMLError *)new XMLError(arg1);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_XMLError")) SWIG_fail;
  {
    try {
      result = (XMLError *)new XMLError();
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_XMLError",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLError,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XMLError" "', argument " "1"" of type '" "XMLError const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XMLError" "', argument " "1"" of type '" "XMLError const &""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  {
    try {
      result = (XMLError *)new XMLError((XMLError const &)*arg1);
    }
    catch (XMLConstructorException &e) {
      PyErr_SetString(PyExc_ValueError, const_cast<char*>(e.what()));
      return NULL;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XMLError(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[7];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 6); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_XMLError__SWIG_6(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLError, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XMLError__SWIG_7(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_XMLError__SWIG_5(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_XMLError__SWIG_4(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_XMLError__SWIG_3(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_XMLError__SWIG_2(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_XMLError__SWIG_1(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[1], (std::basic_string<char>**)(0));
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_XMLError__SWIG_0(self, args);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_XMLError'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    XMLError(int const,std::string const &,unsigned int const,unsigned int const,unsigned int const,unsigned int const)\n"
    "    XMLError(int const,std::string const &,unsigned int const,unsigned int const,unsigned int const)\n"
    "    XMLError(int const,std::string const &,unsigned int const,unsigned int const)\n"
    "    XMLError(int const,std::string const &,unsigned int const)\n"
    "    XMLError(int const,std::string const &)\n"
    "    XMLError(int const)\n"
    "    XMLError()\n"
    "    XMLError(XMLError const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLError",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLError" "', argument " "1"" of type '" "XMLError *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getErrorId(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getErrorId",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getErrorId" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getErrorId();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getMessage",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getMessage" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (std::string *) &((XMLError const *)arg1)->getMessage();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getShortMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getShortMessage",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getShortMessage" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (std::string *) &((XMLError const *)arg1)->getShortMessage();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getLine(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getLine",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getLine" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getLine();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getColumn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getColumn",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getColumn" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getColumn();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getSeverity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getSeverity",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getSeverity" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getSeverity();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getSeverityAsString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getSeverityAsString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getSeverityAsString" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (std::string *) &((XMLError const *)arg1)->getSeverityAsString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getCategory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getCategory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getCategory" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (unsigned int)((XMLError const *)arg1)->getCategory();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getCategoryAsString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getCategoryAsString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_getCategoryAsString" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (std::string *) &((XMLError const *)arg1)->getCategoryAsString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isInfo(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isInfo",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isInfo" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isInfo();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isWarning(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isWarning",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isWarning" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isWarning();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isError",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isError" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isError();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isFatal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isFatal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isFatal" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isFatal();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isInternal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isInternal",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isInternal" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isInternal();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isSystem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isSystem",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isSystem" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isSystem();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_isXML(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_isXML",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_isXML" "', argument " "1"" of type '" "XMLError const *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  result = (bool)((XMLError const *)arg1)->isXML();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_setLine(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLError_setLine",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_setLine" "', argument " "1"" of type '" "XMLError *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLError_setLine" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setLine(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_setColumn(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLError *arg1 = (XMLError *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLError_setColumn",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLError, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLError_setColumn" "', argument " "1"" of type '" "XMLError *""'"); 
  }
  arg1 = reinterpret_cast< XMLError * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLError_setColumn" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setColumn(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLError_getStandardMessage(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLError_getStandardMessage",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "XMLError_getStandardMessage" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  result = XMLError::getStandardMessage(arg1);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *XMLError_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLError, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_XMLErrorLog_getNumErrors(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLErrorLog *arg1 = (XMLErrorLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLErrorLog_getNumErrors",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLErrorLog_getNumErrors" "', argument " "1"" of type '" "XMLErrorLog const *""'"); 
  }
  arg1 = reinterpret_cast< XMLErrorLog * >(argp1);
  result = (unsigned int)((XMLErrorLog const *)arg1)->getNumErrors();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLErrorLog_getError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLErrorLog *arg1 = (XMLErrorLog *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  XMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:XMLErrorLog_getError",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLErrorLog_getError" "', argument " "1"" of type '" "XMLErrorLog const *""'"); 
  }
  arg1 = reinterpret_cast< XMLErrorLog * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "XMLErrorLog_getError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (XMLError *)((XMLErrorLog const *)arg1)->getError(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLError, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XMLErrorLog_clearLog(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLErrorLog *arg1 = (XMLErrorLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:XMLErrorLog_clearLog",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "XMLErrorLog_clearLog" "', argument " "1"" of type '" "XMLErrorLog *""'"); 
  }
  arg1 = reinterpret_cast< XMLErrorLog * >(argp1);
  (arg1)->clearLog();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XMLErrorLog(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLErrorLog *arg1 = (XMLErrorLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_XMLErrorLog",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLErrorLog, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XMLErrorLog" "', argument " "1"" of type '" "XMLErrorLog *""'"); 
  }
  arg1 = reinterpret_cast< XMLErrorLog * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *XMLErrorLog_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_XMLErrorLog, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_SBMLErrorLog_getError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLErrorLog *arg1 = (SBMLErrorLog *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLErrorLog_getError",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLErrorLog_getError" "', argument " "1"" of type '" "SBMLErrorLog const *""'"); 
  }
  arg1 = reinterpret_cast< SBMLErrorLog * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLErrorLog_getError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLError *)((SBMLErrorLog const *)arg1)->getError(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SBMLErrorLog_getNumFailsWithSeverity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLErrorLog *arg1 = (SBMLErrorLog *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:SBMLErrorLog_getNumFailsWithSeverity",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLErrorLog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SBMLErrorLog_getNumFailsWithSeverity" "', argument " "1"" of type '" "SBMLErrorLog *""'"); 
  }
  arg1 = reinterpret_cast< SBMLErrorLog * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SBMLErrorLog_getNumFailsWithSeverity" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (unsigned int)(arg1)->getNumFailsWithSeverity(arg2);
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLErrorLog(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLErrorLog *arg1 = (SBMLErrorLog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLErrorLog",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLErrorLog, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLErrorLog" "', argument " "1"" of type '" "SBMLErrorLog *""'"); 
  }
  arg1 = reinterpret_cast< SBMLErrorLog * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLErrorLog_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLErrorLog, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  unsigned int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:new_SBMLError",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SBMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_SBMLError" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_SBMLError" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_SBMLError" "', argument " "7"" of type '" "unsigned int""'");
  } 
  arg7 = static_cast< unsigned int >(val7);
  ecode8 = SWIG_AsVal_unsigned_SS_int(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_SBMLError" "', argument " "8"" of type '" "unsigned int""'");
  } 
  arg8 = static_cast< unsigned int >(val8);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4,arg5,arg6,arg7,arg8);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:new_SBMLError",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SBMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_SBMLError" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_SBMLError" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_SBMLError" "', argument " "7"" of type '" "unsigned int""'");
  } 
  arg7 = static_cast< unsigned int >(val7);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4,arg5,arg6,arg7);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:new_SBMLError",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SBMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_SBMLError" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_SBMLError" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4,arg5,arg6);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int arg5 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_SBMLError",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SBMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_SBMLError" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  std::string *arg4 = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  int res4 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_SBMLError",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SBMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res4 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj3, &ptr);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLError" "', argument " "4"" of type '" "std::string const &""'"); 
    }
    arg4 = ptr;
  }
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3,(std::string const &)*arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res4)) delete arg4;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res4)) delete arg4;
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_SBMLError",&obj0,&obj1,&obj2)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_SBMLError" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (SBMLError *)new SBMLError(arg1,arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_SBMLError",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_SBMLError" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (SBMLError *)new SBMLError(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SBMLError",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (SBMLError *)new SBMLError(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_8(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_SBMLError")) SWIG_fail;
  result = (SBMLError *)new SBMLError();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError__SWIG_9(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLError *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  SBMLError *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_SBMLError",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_SBMLError,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SBMLError" "', argument " "1"" of type '" "SBMLError const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SBMLError" "', argument " "1"" of type '" "SBMLError const &""'"); 
  }
  arg1 = reinterpret_cast< SBMLError * >(argp1);
  result = (SBMLError *)new SBMLError((SBMLError const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SBMLError, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SBMLError(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[9];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 8); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_SBMLError__SWIG_8(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_SBMLError, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SBMLError__SWIG_9(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_SBMLError__SWIG_7(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_SBMLError__SWIG_6(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_SBMLError__SWIG_5(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_new_SBMLError__SWIG_4(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_SBMLError__SWIG_3(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_SBMLError__SWIG_2(self, args);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_SBMLError__SWIG_1(self, args);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[3], (std::basic_string<char>**)(0));
          _v = SWIG_CheckState(res);
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_unsigned_SS_int(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    return _wrap_new_SBMLError__SWIG_0(self, args);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_SBMLError'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    SBMLError(unsigned int const,unsigned int const,unsigned int const,std::string const &,unsigned int const,unsigned int const,unsigned int const,unsigned int const)\n"
    "    SBMLError(unsigned int const,unsigned int const,unsigned int const,std::string const &,unsigned int const,unsigned int const,unsigned int const)\n"
    "    SBMLError(unsigned int const,unsigned int const,unsigned int const,std::string const &,unsigned int const,unsigned int const)\n"
    "    SBMLError(unsigned int const,unsigned int const,unsigned int const,std::string const &,unsigned int const)\n"
    "    SBMLError(unsigned int const,unsigned int const,unsigned int const,std::string const &)\n"
    "    SBMLError(unsigned int const,unsigned int const,unsigned int const)\n"
    "    SBMLError(unsigned int const,unsigned int const)\n"
    "    SBMLError(unsigned int const)\n"
    "    SBMLError()\n"
    "    SBMLError(SBMLError const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_SBMLError(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBMLError *arg1 = (SBMLError *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_SBMLError",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBMLError, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SBMLError" "', argument " "1"" of type '" "SBMLError *""'"); 
  }
  arg1 = reinterpret_cast< SBMLError * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SBMLError_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_SBMLError, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_CVTerm__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  QualifierType_t arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_CVTerm",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_CVTerm" "', argument " "1"" of type '" "QualifierType_t""'");
  } 
  arg1 = static_cast< QualifierType_t >(val1);
  result = (CVTerm *)new CVTerm(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CVTerm__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_CVTerm")) SWIG_fail;
  result = (CVTerm *)new CVTerm();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CVTerm__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_CVTerm",&obj0)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLNode,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CVTerm" "', argument " "1"" of type '" "XMLNode const""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CVTerm" "', argument " "1"" of type '" "XMLNode const""'");
    } else {
      XMLNode * temp = reinterpret_cast< XMLNode * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  result = (CVTerm *)new CVTerm(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CVTerm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_CVTerm",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CVTerm" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CVTerm__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_CVTerm",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_CVTerm,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CVTerm" "', argument " "1"" of type '" "CVTerm const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CVTerm" "', argument " "1"" of type '" "CVTerm const &""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (CVTerm *)new CVTerm((CVTerm const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CVTerm(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_CVTerm__SWIG_1(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CVTerm__SWIG_2(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_CVTerm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_CVTerm__SWIG_3(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_CVTerm__SWIG_0(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_CVTerm'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    CVTerm(QualifierType_t)\n"
    "    CVTerm()\n"
    "    CVTerm(XMLNode const)\n"
    "    CVTerm(CVTerm const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  CVTerm *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_clone" "', argument " "1"" of type '" "CVTerm const *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (CVTerm *)((CVTerm const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CVTerm, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getQualifierType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  QualifierType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_getQualifierType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getQualifierType" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (QualifierType_t)(arg1)->getQualifierType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getModelQualifierType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelQualifierType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_getModelQualifierType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getModelQualifierType" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (ModelQualifierType_t)(arg1)->getModelQualifierType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getBiologicalQualifierType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  BiolQualifierType_t result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_getBiologicalQualifierType",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getBiologicalQualifierType" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (BiolQualifierType_t)(arg1)->getBiologicalQualifierType();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getResources__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_getResources",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getResources" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (XMLAttributes *)(arg1)->getResources();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getResources__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLAttributes *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_getResources",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getResources" "', argument " "1"" of type '" "CVTerm const *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (XMLAttributes *)((CVTerm const *)arg1)->getResources();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLAttributes, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getResources(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CVTerm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_CVTerm_getResources__SWIG_0(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_CVTerm, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_CVTerm_getResources__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'CVTerm_getResources'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getResources(CVTerm *)\n"
    "    getResources(CVTerm const *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getNumResources(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_getNumResources",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getNumResources" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (unsigned int)(arg1)->getNumResources();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_getResourceURI(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  std::string result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTerm_getResourceURI",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_getResourceURI" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CVTerm_getResourceURI" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (arg1)->getResourceURI(arg2);
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_setQualifierType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  QualifierType_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTerm_setQualifierType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_setQualifierType" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CVTerm_setQualifierType" "', argument " "2"" of type '" "QualifierType_t""'");
  } 
  arg2 = static_cast< QualifierType_t >(val2);
  result = (int)(arg1)->setQualifierType(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_setModelQualifierType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  ModelQualifierType_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTerm_setModelQualifierType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_setModelQualifierType" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CVTerm_setModelQualifierType" "', argument " "2"" of type '" "ModelQualifierType_t""'");
  } 
  arg2 = static_cast< ModelQualifierType_t >(val2);
  result = (int)(arg1)->setModelQualifierType(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_setBiologicalQualifierType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  BiolQualifierType_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTerm_setBiologicalQualifierType",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_setBiologicalQualifierType" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  ecode2 = SWIG_AsVal_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CVTerm_setBiologicalQualifierType" "', argument " "2"" of type '" "BiolQualifierType_t""'");
  } 
  arg2 = static_cast< BiolQualifierType_t >(val2);
  result = (int)(arg1)->setBiologicalQualifierType(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_addResource(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTerm_addResource",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_addResource" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CVTerm_addResource" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CVTerm_addResource" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->addResource((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_removeResource(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  std::string arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:CVTerm_removeResource",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_removeResource" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), "in method '" "CVTerm_removeResource" "', argument " "2"" of type '" "std::string""'"); 
    }
    arg2 = *ptr;
    if (SWIG_IsNewObj(res)) delete ptr;
  }
  result = (int)(arg1)->removeResource(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CVTerm_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  CVTerm *arg1 = (CVTerm *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:CVTerm_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_CVTerm, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CVTerm_hasRequiredAttributes" "', argument " "1"" of type '" "CVTerm *""'"); 
  }
  arg1 = reinterpret_cast< CVTerm * >(argp1);
  result = (bool)(arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CVTerm_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_CVTerm, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_Date__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  unsigned int arg9 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  unsigned int val8 ;
  int ecode8 = 0 ;
  unsigned int val9 ;
  int ecode9 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  PyObject * obj8 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOOO:new_Date",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7,&obj8)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Date" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Date" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Date" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_Date" "', argument " "7"" of type '" "unsigned int""'");
  } 
  arg7 = static_cast< unsigned int >(val7);
  ecode8 = SWIG_AsVal_unsigned_SS_int(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_Date" "', argument " "8"" of type '" "unsigned int""'");
  } 
  arg8 = static_cast< unsigned int >(val8);
  ecode9 = SWIG_AsVal_unsigned_SS_int(obj8, &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "new_Date" "', argument " "9"" of type '" "unsigned int""'");
  } 
  arg9 = static_cast< unsigned int >(val9);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int arg8 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  unsigned int val8 ;
  int ecode8 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOOO:new_Date",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Date" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Date" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Date" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_Date" "', argument " "7"" of type '" "unsigned int""'");
  } 
  arg7 = static_cast< unsigned int >(val7);
  ecode8 = SWIG_AsVal_unsigned_SS_int(obj7, &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "new_Date" "', argument " "8"" of type '" "unsigned int""'");
  } 
  arg8 = static_cast< unsigned int >(val8);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int arg7 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  unsigned int val7 ;
  int ecode7 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO:new_Date",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Date" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Date" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Date" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  ecode7 = SWIG_AsVal_unsigned_SS_int(obj6, &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "new_Date" "', argument " "7"" of type '" "unsigned int""'");
  } 
  arg7 = static_cast< unsigned int >(val7);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_3(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int arg6 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  unsigned int val6 ;
  int ecode6 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOOO:new_Date",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Date" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Date" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_unsigned_SS_int(obj5, &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "new_Date" "', argument " "6"" of type '" "unsigned int""'");
  } 
  arg6 = static_cast< unsigned int >(val6);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5,arg6);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_4(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int arg5 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOOO:new_Date",&obj0,&obj1,&obj2,&obj3,&obj4)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Date" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(obj4, &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "new_Date" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  result = (Date *)new Date(arg1,arg2,arg3,arg4,arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_5(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int arg4 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOOO:new_Date",&obj0,&obj1,&obj2,&obj3)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(obj3, &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "new_Date" "', argument " "4"" of type '" "unsigned int""'");
  } 
  arg4 = static_cast< unsigned int >(val4);
  result = (Date *)new Date(arg1,arg2,arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_6(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int arg3 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OOO:new_Date",&obj0,&obj1,&obj2)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(obj2, &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Date" "', argument " "3"" of type '" "unsigned int""'");
  } 
  arg3 = static_cast< unsigned int >(val3);
  result = (Date *)new Date(arg1,arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_7(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int arg2 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:new_Date",&obj0,&obj1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Date" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Date *)new Date(arg1,arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_8(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  PyObject * obj0 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Date",&obj0)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(obj0, &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Date" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  result = (Date *)new Date(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_9(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_Date")) SWIG_fail;
  result = (Date *)new Date();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_10(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Date",&obj0)) SWIG_fail;
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res1 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj0, &ptr);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Date" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Date" "', argument " "1"" of type '" "std::string const &""'"); 
    }
    arg1 = ptr;
  }
  result = (Date *)new Date((std::string const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res1)) delete arg1;
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_Date(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_Date",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Date" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date__SWIG_11(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_Date",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_Date,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Date" "', argument " "1"" of type '" "Date const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Date" "', argument " "1"" of type '" "Date const &""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (Date *)new Date((Date const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Date(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[10];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 9); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_Date__SWIG_9(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_Date, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Date__SWIG_11(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_Date__SWIG_8(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(argv[0], (std::basic_string<char>**)(0));
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Date__SWIG_10(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_new_Date__SWIG_7(self, args);
      }
    }
  }
  if (argc == 3) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_Date__SWIG_6(self, args);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            return _wrap_new_Date__SWIG_5(self, args);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              return _wrap_new_Date__SWIG_4(self, args);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                return _wrap_new_Date__SWIG_3(self, args);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 7) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  return _wrap_new_Date__SWIG_2(self, args);
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_unsigned_SS_int(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    return _wrap_new_Date__SWIG_1(self, args);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        {
          int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          {
            int res = SWIG_AsVal_unsigned_SS_int(argv[3], NULL);
            _v = SWIG_CheckState(res);
          }
          if (_v) {
            {
              int res = SWIG_AsVal_unsigned_SS_int(argv[4], NULL);
              _v = SWIG_CheckState(res);
            }
            if (_v) {
              {
                int res = SWIG_AsVal_unsigned_SS_int(argv[5], NULL);
                _v = SWIG_CheckState(res);
              }
              if (_v) {
                {
                  int res = SWIG_AsVal_unsigned_SS_int(argv[6], NULL);
                  _v = SWIG_CheckState(res);
                }
                if (_v) {
                  {
                    int res = SWIG_AsVal_unsigned_SS_int(argv[7], NULL);
                    _v = SWIG_CheckState(res);
                  }
                  if (_v) {
                    {
                      int res = SWIG_AsVal_unsigned_SS_int(argv[8], NULL);
                      _v = SWIG_CheckState(res);
                    }
                    if (_v) {
                      return _wrap_new_Date__SWIG_0(self, args);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_Date'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    Date(unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int,unsigned int,unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int,unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int,unsigned int)\n"
    "    Date(unsigned int,unsigned int)\n"
    "    Date(unsigned int)\n"
    "    Date()\n"
    "    Date(std::string const &)\n"
    "    Date(Date const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_clone" "', argument " "1"" of type '" "Date const *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (Date *)((Date const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getYear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getYear",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getYear" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getYear();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getMonth(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getMonth",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getMonth" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getMonth();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getDay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getDay",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getDay" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getDay();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getHour(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getHour",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getHour" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getHour();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getMinute(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getMinute",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getMinute" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getMinute();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getSecond(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getSecond",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getSecond" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getSecond();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getSignOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getSignOffset",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getSignOffset" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getSignOffset();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getHoursOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getHoursOffset",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getHoursOffset" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getHoursOffset();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getMinutesOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getMinutesOffset",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getMinutesOffset" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (unsigned int)(arg1)->getMinutesOffset();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_getDateAsString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_getDateAsString",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_getDateAsString" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (std::string *) &(arg1)->getDateAsString();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setYear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setYear",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setYear" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setYear" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setYear(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setMonth(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setMonth",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setMonth" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setMonth" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setMonth(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setDay(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setDay",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setDay" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setDay" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setDay(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setHour(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setHour",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setHour" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setHour" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setHour(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setMinute(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setMinute",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setMinute" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setMinute" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setMinute(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setSecond(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setSecond",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setSecond" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setSecond" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setSecond(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setSignOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setSignOffset",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setSignOffset" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setSignOffset" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setSignOffset(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setHoursOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setHoursOffset",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setHoursOffset" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setHoursOffset" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setHoursOffset(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setMinutesOffset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setMinutesOffset",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setMinutesOffset" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Date_setMinutesOffset" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (int)(arg1)->setMinutesOffset(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_setDateAsString(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:Date_setDateAsString",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_setDateAsString" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Date_setDateAsString" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Date_setDateAsString" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setDateAsString((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_Date_representsValidDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  Date *arg1 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:Date_representsValidDate",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Date_representsValidDate" "', argument " "1"" of type '" "Date *""'"); 
  }
  arg1 = reinterpret_cast< Date * >(argp1);
  result = (bool)(arg1)->representsValidDate();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Date_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_Date, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ModelCreator__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ModelCreator")) SWIG_fail;
  result = (ModelCreator *)new ModelCreator();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModelCreator__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ModelCreator",&obj0)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_XMLNode,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ModelCreator" "', argument " "1"" of type '" "XMLNode const""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ModelCreator" "', argument " "1"" of type '" "XMLNode const""'");
    } else {
      XMLNode * temp = reinterpret_cast< XMLNode * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  result = (ModelCreator *)new ModelCreator(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ModelCreator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ModelCreator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ModelCreator" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModelCreator__SWIG_2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ModelCreator",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_ModelCreator,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ModelCreator" "', argument " "1"" of type '" "ModelCreator const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ModelCreator" "', argument " "1"" of type '" "ModelCreator const &""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (ModelCreator *)new ModelCreator((ModelCreator const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModelCreator(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_ModelCreator__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModelCreator__SWIG_1(self, args);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ModelCreator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModelCreator__SWIG_2(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_ModelCreator'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ModelCreator()\n"
    "    ModelCreator(XMLNode const)\n"
    "    ModelCreator(ModelCreator const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_clone" "', argument " "1"" of type '" "ModelCreator const *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (ModelCreator *)((ModelCreator const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_getFamilyName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_getFamilyName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_getFamilyName" "', argument " "1"" of type '" "ModelCreator const *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (std::string *) &((ModelCreator const *)arg1)->getFamilyName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_getGivenName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_getGivenName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_getGivenName" "', argument " "1"" of type '" "ModelCreator const *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (std::string *) &((ModelCreator const *)arg1)->getGivenName();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_getEmail(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_getEmail",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_getEmail" "', argument " "1"" of type '" "ModelCreator const *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (std::string *) &((ModelCreator const *)arg1)->getEmail();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_getOrganization(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_getOrganization",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_getOrganization" "', argument " "1"" of type '" "ModelCreator const *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (std::string *) &((ModelCreator const *)arg1)->getOrganization();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_getOrganisation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  std::string *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_getOrganisation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_getOrganisation" "', argument " "1"" of type '" "ModelCreator const *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (std::string *) &((ModelCreator const *)arg1)->getOrganisation();
  resultobj = SWIG_From_std_basic_string_Sl_char_Sg_(static_cast< std::basic_string<char> >(*result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_isSetFamilyName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_isSetFamilyName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_isSetFamilyName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetFamilyName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_isSetGivenName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_isSetGivenName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_isSetGivenName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetGivenName();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_isSetEmail(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_isSetEmail",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_isSetEmail" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetEmail();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_isSetOrganization(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_isSetOrganization",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_isSetOrganization" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetOrganization();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_isSetOrganisation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_isSetOrganisation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_isSetOrganisation" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->isSetOrganisation();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_setFamilyName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreator_setFamilyName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_setFamilyName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelCreator_setFamilyName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelCreator_setFamilyName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setFamilyName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_setGivenName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreator_setGivenName",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_setGivenName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelCreator_setGivenName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelCreator_setGivenName" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setGivenName((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_setEmail(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreator_setEmail",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_setEmail" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelCreator_setEmail" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelCreator_setEmail" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setEmail((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_setOrganization(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreator_setOrganization",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_setOrganization" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelCreator_setOrganization" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelCreator_setOrganization" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setOrganization((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_setOrganisation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelCreator_setOrganisation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_setOrganisation" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  {
    std::basic_string<char> *ptr = (std::basic_string<char> *)0;
    res2 = SWIG_AsPtr_std_basic_string_Sl_char_Sg_(obj1, &ptr);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelCreator_setOrganisation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ModelCreator_setOrganisation" "', argument " "2"" of type '" "std::string const &""'"); 
    }
    arg2 = ptr;
  }
  result = (int)(arg1)->setOrganisation((std::string const &)*arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SWIG_IsNewObj(res2)) delete arg2;
  return resultobj;
fail:
  if (SWIG_IsNewObj(res2)) delete arg2;
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_unsetFamilyName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_unsetFamilyName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_unsetFamilyName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetFamilyName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_unsetGivenName(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_unsetGivenName",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_unsetGivenName" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetGivenName();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_unsetEmail(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_unsetEmail",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_unsetEmail" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetEmail();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_unsetOrganization(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_unsetOrganization",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_unsetOrganization" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetOrganization();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_unsetOrganisation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_unsetOrganisation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_unsetOrganisation" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (int)(arg1)->unsetOrganisation();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelCreator_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelCreator *arg1 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelCreator_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelCreator_hasRequiredAttributes" "', argument " "1"" of type '" "ModelCreator *""'"); 
  }
  arg1 = reinterpret_cast< ModelCreator * >(argp1);
  result = (bool)(arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ModelCreator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ModelCreator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_ModelHistory__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_ModelHistory")) SWIG_fail;
  result = (ModelHistory *)new ModelHistory();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ModelHistory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_ModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ModelHistory" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModelHistory__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelHistory *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:new_ModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1, SWIGTYPE_p_ModelHistory,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_ModelHistory" "', argument " "1"" of type '" "ModelHistory const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_ModelHistory" "', argument " "1"" of type '" "ModelHistory const &""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (ModelHistory *)new ModelHistory((ModelHistory const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_ModelHistory(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[2];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 1); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 0) {
    return _wrap_new_ModelHistory__SWIG_0(self, args);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_ModelHistory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_ModelHistory__SWIG_1(self, args);
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'new_ModelHistory'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ModelHistory()\n"
    "    ModelHistory(ModelHistory const &)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_clone(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelHistory *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_clone",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_clone" "', argument " "1"" of type '" "ModelHistory const *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (ModelHistory *)((ModelHistory const *)arg1)->clone();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getCreatedDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_getCreatedDate",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getCreatedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (Date *)(arg1)->getCreatedDate();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getModifiedDate__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_getModifiedDate",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getModifiedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (Date *)(arg1)->getModifiedDate();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_isSetCreatedDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_isSetCreatedDate",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_isSetCreatedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (bool)(arg1)->isSetCreatedDate();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_isSetModifiedDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_isSetModifiedDate",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_isSetModifiedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (bool)(arg1)->isSetModifiedDate();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_setCreatedDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelHistory_setCreatedDate",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_setCreatedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelHistory_setCreatedDate" "', argument " "2"" of type '" "Date *""'"); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  result = (int)(arg1)->setCreatedDate(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_setModifiedDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelHistory_setModifiedDate",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_setModifiedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelHistory_setModifiedDate" "', argument " "2"" of type '" "Date *""'"); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  result = (int)(arg1)->setModifiedDate(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_addModifiedDate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  Date *arg2 = (Date *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelHistory_addModifiedDate",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_addModifiedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_Date, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelHistory_addModifiedDate" "', argument " "2"" of type '" "Date *""'"); 
  }
  arg2 = reinterpret_cast< Date * >(argp2);
  result = (int)(arg1)->addModifiedDate(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getListModifiedDates(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  List *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_getListModifiedDates",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getListModifiedDates" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (List *)(arg1)->getListModifiedDates();
  {
    ListWrapper<Date> *listw = (result != 0) ? new ListWrapper<Date>(result) : 0;
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_Date_t, 
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getModifiedDate__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  Date *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelHistory_getModifiedDate",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getModifiedDate" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ModelHistory_getModifiedDate" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (Date *)(arg1)->getModifiedDate(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_Date, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getModifiedDate(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ModelHistory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_ModelHistory_getModifiedDate__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_ModelHistory, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_ModelHistory_getModifiedDate__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'ModelHistory_getModifiedDate'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    getModifiedDate(ModelHistory *)\n"
    "    getModifiedDate(ModelHistory *,unsigned int)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getNumModifiedDates(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_getNumModifiedDates",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getNumModifiedDates" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (unsigned int)(arg1)->getNumModifiedDates();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_addCreator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  ModelCreator *arg2 = (ModelCreator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  int result;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelHistory_addCreator",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_addCreator" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ModelCreator, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ModelHistory_addCreator" "', argument " "2"" of type '" "ModelCreator *""'"); 
  }
  arg2 = reinterpret_cast< ModelCreator * >(argp2);
  result = (int)(arg1)->addCreator(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getListCreators(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  List *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_getListCreators",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getListCreators" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (List *)(arg1)->getListCreators();
  {
    ListWrapper<ModelCreator> *listw = (result != 0) ? new ListWrapper<ModelCreator>(result) : 0;
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(listw), 
      
      SWIGTYPE_p_ListWrapperT_ModelCreator_t, 
      
      
      
      SWIG_POINTER_OWN |  0 );
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getCreator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  unsigned int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  ModelCreator *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:ModelHistory_getCreator",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getCreator" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(obj1, &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ModelHistory_getCreator" "', argument " "2"" of type '" "unsigned int""'");
  } 
  arg2 = static_cast< unsigned int >(val2);
  result = (ModelCreator *)(arg1)->getCreator(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelCreator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_getNumCreators(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  unsigned int result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_getNumCreators",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_getNumCreators" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (unsigned int)(arg1)->getNumCreators();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ModelHistory_hasRequiredAttributes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  ModelHistory *arg1 = (ModelHistory *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  bool result;
  
  if (!PyArg_ParseTuple(args,(char *)"O:ModelHistory_hasRequiredAttributes",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_ModelHistory, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ModelHistory_hasRequiredAttributes" "', argument " "1"" of type '" "ModelHistory *""'"); 
  }
  arg1 = reinterpret_cast< ModelHistory * >(argp1);
  result = (bool)(arg1)->hasRequiredAttributes();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *ModelHistory_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_ModelHistory, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_RDFAnnotationParser_parseRDFAnnotation__SWIG_0(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  ModelHistory *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RDFAnnotationParser_parseRDFAnnotation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_parseRDFAnnotation" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (ModelHistory *)RDFAnnotationParser::parseRDFAnnotation((XMLNode const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ModelHistory, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_createAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":RDFAnnotationParser_createAnnotation")) SWIG_fail;
  result = (XMLNode *)RDFAnnotationParser::createAnnotation();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_createRDFAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":RDFAnnotationParser_createRDFAnnotation")) SWIG_fail;
  result = (XMLNode *)RDFAnnotationParser::createRDFAnnotation();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_deleteRDFAnnotation(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RDFAnnotationParser_deleteRDFAnnotation",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_deleteRDFAnnotation" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::deleteRDFAnnotation((XMLNode const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_createRDFDescription(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RDFAnnotationParser_createRDFDescription",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_createRDFDescription" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::createRDFDescription((SBase const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_createCVTerms(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RDFAnnotationParser_createCVTerms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_createCVTerms" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::createCVTerms((SBase const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_parseCVTerms(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RDFAnnotationParser_parseCVTerms",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_parseCVTerms" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::parseCVTerms((SBase const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_parseModelHistory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  SBase *arg1 = (SBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  XMLNode *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:RDFAnnotationParser_parseModelHistory",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_SBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_parseModelHistory" "', argument " "1"" of type '" "SBase const *""'"); 
  }
  arg1 = reinterpret_cast< SBase * >(argp1);
  result = (XMLNode *)RDFAnnotationParser::parseModelHistory((SBase const *)arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_XMLNode, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_parseRDFAnnotation__SWIG_1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  XMLNode *arg1 = (XMLNode *) 0 ;
  ListWrapper< CVTerm > *arg2 = (ListWrapper< CVTerm > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"OO:RDFAnnotationParser_parseRDFAnnotation",&obj0,&obj1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_XMLNode, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RDFAnnotationParser_parseRDFAnnotation" "', argument " "1"" of type '" "XMLNode const *""'"); 
  }
  arg1 = reinterpret_cast< XMLNode * >(argp1);
  res2 = SWIG_ConvertPtr(obj1, &argp2,SWIGTYPE_p_ListWrapperT_CVTerm_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RDFAnnotationParser_parseRDFAnnotation" "', argument " "2"" of type '" "ListWrapper< CVTerm > *""'"); 
  }
  arg2 = reinterpret_cast< ListWrapper< CVTerm > * >(argp2);
  RDFAnnotationParser_parseRDFAnnotation__SWIG_1((XMLNode const *)arg1,arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RDFAnnotationParser_parseRDFAnnotation(PyObject *self, PyObject *args) {
  int argc;
  PyObject *argv[3];
  int ii;
  
  if (!PyTuple_Check(args)) SWIG_fail;
  argc = (int)PyObject_Length(args);
  for (ii = 0; (ii < argc) && (ii < 2); ii++) {
    argv[ii] = PyTuple_GET_ITEM(args,ii);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_RDFAnnotationParser_parseRDFAnnotation__SWIG_0(self, args);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_XMLNode, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_ListWrapperT_CVTerm_t, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_RDFAnnotationParser_parseRDFAnnotation__SWIG_1(self, args);
      }
    }
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number of arguments for overloaded function 'RDFAnnotationParser_parseRDFAnnotation'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    parseRDFAnnotation(XMLNode const *)\n"
    "    RDFAnnotationParser_parseRDFAnnotation__SWIG_1(XMLNode const *,ListWrapper< CVTerm > *)\n");
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_RDFAnnotationParser(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  RDFAnnotationParser *result = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)":new_RDFAnnotationParser")) SWIG_fail;
  result = (RDFAnnotationParser *)new RDFAnnotationParser();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RDFAnnotationParser, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RDFAnnotationParser(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  RDFAnnotationParser *arg1 = (RDFAnnotationParser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject * obj0 = 0 ;
  
  if (!PyArg_ParseTuple(args,(char *)"O:delete_RDFAnnotationParser",&obj0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(obj0, &argp1,SWIGTYPE_p_RDFAnnotationParser, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RDFAnnotationParser" "', argument " "1"" of type '" "RDFAnnotationParser *""'"); 
  }
  arg1 = reinterpret_cast< RDFAnnotationParser * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *RDFAnnotationParser_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!PyArg_ParseTuple(args,(char*)"O:swigregister", &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_RDFAnnotationParser, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

static PyMethodDef SwigMethods[] = {
	 { (char *)"SWIG_PyInstanceMethod_New", (PyCFunction)SWIG_PyInstanceMethod_New, METH_O, NULL},
	 { (char *)"new_ModelCreatorList", _wrap_new_ModelCreatorList, METH_VARARGS, NULL},
	 { (char *)"delete_ModelCreatorList", _wrap_delete_ModelCreatorList, METH_VARARGS, NULL},
	 { (char *)"ModelCreatorList_add", _wrap_ModelCreatorList_add, METH_VARARGS, NULL},
	 { (char *)"ModelCreatorList_get", _wrap_ModelCreatorList_get, METH_VARARGS, NULL},
	 { (char *)"ModelCreatorList_prepend", _wrap_ModelCreatorList_prepend, METH_VARARGS, NULL},
	 { (char *)"ModelCreatorList_remove", _wrap_ModelCreatorList_remove, METH_VARARGS, NULL},
	 { (char *)"ModelCreatorList_getSize", _wrap_ModelCreatorList_getSize, METH_VARARGS, NULL},
	 { (char *)"ModelCreatorList_swigregister", ModelCreatorList_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_DateList", _wrap_new_DateList, METH_VARARGS, NULL},
	 { (char *)"delete_DateList", _wrap_delete_DateList, METH_VARARGS, NULL},
	 { (char *)"DateList_add", _wrap_DateList_add, METH_VARARGS, NULL},
	 { (char *)"DateList_get", _wrap_DateList_get, METH_VARARGS, NULL},
	 { (char *)"DateList_prepend", _wrap_DateList_prepend, METH_VARARGS, NULL},
	 { (char *)"DateList_remove", _wrap_DateList_remove, METH_VARARGS, NULL},
	 { (char *)"DateList_getSize", _wrap_DateList_getSize, METH_VARARGS, NULL},
	 { (char *)"DateList_swigregister", DateList_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_CVTermList", _wrap_new_CVTermList, METH_VARARGS, NULL},
	 { (char *)"delete_CVTermList", _wrap_delete_CVTermList, METH_VARARGS, NULL},
	 { (char *)"CVTermList_add", _wrap_CVTermList_add, METH_VARARGS, NULL},
	 { (char *)"CVTermList_get", _wrap_CVTermList_get, METH_VARARGS, NULL},
	 { (char *)"CVTermList_prepend", _wrap_CVTermList_prepend, METH_VARARGS, NULL},
	 { (char *)"CVTermList_remove", _wrap_CVTermList_remove, METH_VARARGS, NULL},
	 { (char *)"CVTermList_getSize", _wrap_CVTermList_getSize, METH_VARARGS, NULL},
	 { (char *)"CVTermList_swigregister", CVTermList_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_ASTNodeList", _wrap_new_ASTNodeList, METH_VARARGS, NULL},
	 { (char *)"delete_ASTNodeList", _wrap_delete_ASTNodeList, METH_VARARGS, NULL},
	 { (char *)"ASTNodeList_add", _wrap_ASTNodeList_add, METH_VARARGS, NULL},
	 { (char *)"ASTNodeList_get", _wrap_ASTNodeList_get, METH_VARARGS, NULL},
	 { (char *)"ASTNodeList_prepend", _wrap_ASTNodeList_prepend, METH_VARARGS, NULL},
	 { (char *)"ASTNodeList_remove", _wrap_ASTNodeList_remove, METH_VARARGS, NULL},
	 { (char *)"ASTNodeList_getSize", _wrap_ASTNodeList_getSize, METH_VARARGS, NULL},
	 { (char *)"ASTNodeList_swigregister", ASTNodeList_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_SBMLNamespacesList", _wrap_new_SBMLNamespacesList, METH_VARARGS, NULL},
	 { (char *)"delete_SBMLNamespacesList", _wrap_delete_SBMLNamespacesList, METH_VARARGS, NULL},
	 { (char *)"SBMLNamespacesList_add", _wrap_SBMLNamespacesList_add, METH_VARARGS, NULL},
	 { (char *)"SBMLNamespacesList_get", _wrap_SBMLNamespacesList_get, METH_VARARGS, NULL},
	 { (char *)"SBMLNamespacesList_prepend", _wrap_SBMLNamespacesList_prepend, METH_VARARGS, NULL},
	 { (char *)"SBMLNamespacesList_remove", _wrap_SBMLNamespacesList_remove, METH_VARARGS, NULL},
	 { (char *)"SBMLNamespacesList_getSize", _wrap_SBMLNamespacesList_getSize, METH_VARARGS, NULL},
	 { (char *)"SBMLNamespacesList_swigregister", SBMLNamespacesList_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_SwigPyIterator", _wrap_delete_SwigPyIterator, METH_VARARGS, (char *)"delete_SwigPyIterator(SwigPyIterator self)"},
	 { (char *)"SwigPyIterator_value", _wrap_SwigPyIterator_value, METH_VARARGS, (char *)"SwigPyIterator_value(SwigPyIterator self) -> PyObject"},
	 { (char *)"SwigPyIterator_incr", _wrap_SwigPyIterator_incr, METH_VARARGS, (char *)"\n"
		"incr(size_t n = 1) -> SwigPyIterator\n"
		"SwigPyIterator_incr(SwigPyIterator self) -> SwigPyIterator\n"
		""},
	 { (char *)"SwigPyIterator_decr", _wrap_SwigPyIterator_decr, METH_VARARGS, (char *)"\n"
		"decr(size_t n = 1) -> SwigPyIterator\n"
		"SwigPyIterator_decr(SwigPyIterator self) -> SwigPyIterator\n"
		""},
	 { (char *)"SwigPyIterator_distance", _wrap_SwigPyIterator_distance, METH_VARARGS, (char *)"SwigPyIterator_distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"},
	 { (char *)"SwigPyIterator_equal", _wrap_SwigPyIterator_equal, METH_VARARGS, (char *)"SwigPyIterator_equal(SwigPyIterator self, SwigPyIterator x) -> bool"},
	 { (char *)"SwigPyIterator_copy", _wrap_SwigPyIterator_copy, METH_VARARGS, (char *)"SwigPyIterator_copy(SwigPyIterator self) -> SwigPyIterator"},
	 { (char *)"SwigPyIterator_next", _wrap_SwigPyIterator_next, METH_VARARGS, (char *)"SwigPyIterator_next(SwigPyIterator self) -> PyObject"},
	 { (char *)"SwigPyIterator___next__", _wrap_SwigPyIterator___next__, METH_VARARGS, (char *)"SwigPyIterator___next__(SwigPyIterator self) -> PyObject"},
	 { (char *)"SwigPyIterator_previous", _wrap_SwigPyIterator_previous, METH_VARARGS, (char *)"SwigPyIterator_previous(SwigPyIterator self) -> PyObject"},
	 { (char *)"SwigPyIterator_advance", _wrap_SwigPyIterator_advance, METH_VARARGS, (char *)"SwigPyIterator_advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"},
	 { (char *)"SwigPyIterator___eq__", _wrap_SwigPyIterator___eq__, METH_VARARGS, (char *)"SwigPyIterator___eq__(SwigPyIterator self, SwigPyIterator x) -> bool"},
	 { (char *)"SwigPyIterator___ne__", _wrap_SwigPyIterator___ne__, METH_VARARGS, (char *)"SwigPyIterator___ne__(SwigPyIterator self, SwigPyIterator x) -> bool"},
	 { (char *)"SwigPyIterator___iadd__", _wrap_SwigPyIterator___iadd__, METH_VARARGS, (char *)"SwigPyIterator___iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"},
	 { (char *)"SwigPyIterator___isub__", _wrap_SwigPyIterator___isub__, METH_VARARGS, (char *)"SwigPyIterator___isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"},
	 { (char *)"SwigPyIterator___add__", _wrap_SwigPyIterator___add__, METH_VARARGS, (char *)"SwigPyIterator___add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"},
	 { (char *)"SwigPyIterator___sub__", _wrap_SwigPyIterator___sub__, METH_VARARGS, (char *)"\n"
		"__sub__(ptrdiff_t n) -> SwigPyIterator\n"
		"SwigPyIterator___sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t\n"
		""},
	 { (char *)"SwigPyIterator_swigregister", SwigPyIterator_swigregister, METH_VARARGS, NULL},
	 { (char *)"string_length", _wrap_string_length, METH_VARARGS, (char *)"string_length(string self) -> size_type"},
	 { (char *)"string_max_size", _wrap_string_max_size, METH_VARARGS, (char *)"string_max_size(string self) -> size_type"},
	 { (char *)"string_copy", _wrap_string_copy, METH_VARARGS, (char *)"\n"
		"copy(char __s, size_type __n, size_type __pos = 0) -> size_type\n"
		"string_copy(string self, char __s, size_type __n) -> size_type\n"
		""},
	 { (char *)"string_c_str", _wrap_string_c_str, METH_VARARGS, (char *)"string_c_str(string self) -> char"},
	 { (char *)"string_find", _wrap_string_find, METH_VARARGS, (char *)"\n"
		"find(char __s, size_type __pos, size_type __n) -> size_type\n"
		"find(string __str, size_type __pos = 0) -> size_type\n"
		"find(string __str) -> size_type\n"
		"find(char __c, size_type __pos = 0) -> size_type\n"
		"string_find(string self, char __c) -> size_type\n"
		""},
	 { (char *)"string_rfind", _wrap_string_rfind, METH_VARARGS, (char *)"\n"
		"rfind(string __str, size_type __pos = std::basic_string< char >::npos) -> size_type\n"
		"rfind(string __str) -> size_type\n"
		"rfind(char __s, size_type __pos, size_type __n) -> size_type\n"
		"rfind(char __c, size_type __pos = std::basic_string< char >::npos) -> size_type\n"
		"string_rfind(string self, char __c) -> size_type\n"
		""},
	 { (char *)"string_find_first_of", _wrap_string_find_first_of, METH_VARARGS, (char *)"\n"
		"find_first_of(string __str, size_type __pos = 0) -> size_type\n"
		"find_first_of(string __str) -> size_type\n"
		"find_first_of(char __s, size_type __pos, size_type __n) -> size_type\n"
		"find_first_of(char __c, size_type __pos = 0) -> size_type\n"
		"string_find_first_of(string self, char __c) -> size_type\n"
		""},
	 { (char *)"string_find_last_of", _wrap_string_find_last_of, METH_VARARGS, (char *)"\n"
		"find_last_of(string __str, size_type __pos = std::basic_string< char >::npos) -> size_type\n"
		"find_last_of(string __str) -> size_type\n"
		"find_last_of(char __s, size_type __pos, size_type __n) -> size_type\n"
		"find_last_of(char __c, size_type __pos = std::basic_string< char >::npos) -> size_type\n"
		"string_find_last_of(string self, char __c) -> size_type\n"
		""},
	 { (char *)"string_find_first_not_of", _wrap_string_find_first_not_of, METH_VARARGS, (char *)"\n"
		"find_first_not_of(string __str, size_type __pos = 0) -> size_type\n"
		"find_first_not_of(string __str) -> size_type\n"
		"find_first_not_of(char __s, size_type __pos, size_type __n) -> size_type\n"
		"find_first_not_of(char __c, size_type __pos = 0) -> size_type\n"
		"string_find_first_not_of(string self, char __c) -> size_type\n"
		""},
	 { (char *)"string_find_last_not_of", _wrap_string_find_last_not_of, METH_VARARGS, (char *)"\n"
		"find_last_not_of(string __str, size_type __pos = std::basic_string< char >::npos) -> size_type\n"
		"find_last_not_of(string __str) -> size_type\n"
		"find_last_not_of(char __s, size_type __pos, size_type __n) -> size_type\n"
		"find_last_not_of(char __c, size_type __pos = std::basic_string< char >::npos) -> size_type\n"
		"string_find_last_not_of(string self, char __c) -> size_type\n"
		""},
	 { (char *)"string_substr", _wrap_string_substr, METH_VARARGS, (char *)"\n"
		"substr(size_type __pos = 0, size_type __n = std::basic_string< char >::npos) -> string\n"
		"substr(size_type __pos = 0) -> string\n"
		"string_substr(string self) -> string\n"
		""},
	 { (char *)"string_empty", _wrap_string_empty, METH_VARARGS, (char *)"string_empty(string self) -> bool"},
	 { (char *)"string_size", _wrap_string_size, METH_VARARGS, (char *)"string_size(string self) -> size_type"},
	 { (char *)"string_swap", _wrap_string_swap, METH_VARARGS, (char *)"string_swap(string self, string v)"},
	 { (char *)"string_erase", _wrap_string_erase, METH_VARARGS, (char *)"\n"
		"erase(size_type __pos = 0, size_type __n = std::basic_string< char >::npos) -> string\n"
		"erase(size_type __pos = 0) -> string\n"
		"erase() -> string\n"
		"erase(iterator pos) -> iterator\n"
		"string_erase(string self, iterator first, iterator last) -> iterator\n"
		""},
	 { (char *)"new_string", _wrap_new_string, METH_VARARGS, (char *)"\n"
		"string(char __s, size_type __n)\n"
		"string()\n"
		"string(string arg0)\n"
		"new_string(size_type size, value_type value) -> string\n"
		""},
	 { (char *)"string_assign", _wrap_string_assign, METH_VARARGS, (char *)"\n"
		"assign(string __str) -> string\n"
		"assign(string __str, size_type __pos, size_type __n) -> string\n"
		"assign(char __s, size_type __n) -> string\n"
		"string_assign(string self, size_type n, value_type x)\n"
		""},
	 { (char *)"string_resize", _wrap_string_resize, METH_VARARGS, (char *)"\n"
		"resize(size_type new_size)\n"
		"string_resize(string self, size_type new_size, value_type x)\n"
		""},
	 { (char *)"string_iterator", _wrap_string_iterator, METH_VARARGS, (char *)"string_iterator(string self) -> SwigPyIterator"},
	 { (char *)"string___nonzero__", _wrap_string___nonzero__, METH_VARARGS, (char *)"string___nonzero__(string self) -> bool"},
	 { (char *)"string___bool__", _wrap_string___bool__, METH_VARARGS, (char *)"string___bool__(string self) -> bool"},
	 { (char *)"string___len__", _wrap_string___len__, METH_VARARGS, (char *)"string___len__(string self) -> size_type"},
	 { (char *)"string___getslice__", _wrap_string___getslice__, METH_VARARGS, (char *)"string___getslice__(string self, difference_type i, difference_type j) -> string"},
	 { (char *)"string___setslice__", _wrap_string___setslice__, METH_VARARGS, (char *)"\n"
		"string___setslice__(string self, difference_type i, difference_type j, \n"
		"    string v)\n"
		""},
	 { (char *)"string___delslice__", _wrap_string___delslice__, METH_VARARGS, (char *)"string___delslice__(string self, difference_type i, difference_type j)"},
	 { (char *)"string___delitem__", _wrap_string___delitem__, METH_VARARGS, (char *)"\n"
		"__delitem__(difference_type i)\n"
		"string___delitem__(string self, PySliceObject slice)\n"
		""},
	 { (char *)"string___getitem__", _wrap_string___getitem__, METH_VARARGS, (char *)"\n"
		"__getitem__(PySliceObject slice) -> string\n"
		"string___getitem__(string self, difference_type i) -> value_type\n"
		""},
	 { (char *)"string___setitem__", _wrap_string___setitem__, METH_VARARGS, (char *)"\n"
		"__setitem__(PySliceObject slice, string v)\n"
		"string___setitem__(string self, difference_type i, value_type x)\n"
		""},
	 { (char *)"string_insert", _wrap_string_insert, METH_VARARGS, (char *)"\n"
		"insert(size_type __pos1, string __str) -> string\n"
		"insert(size_type __pos1, string __str, size_type __pos2, size_type __n) -> string\n"
		"insert(size_type __pos, char __s, size_type __n) -> string\n"
		"insert(size_type __pos, size_type __n, char __c) -> string\n"
		"insert(iterator pos, value_type x) -> iterator\n"
		"insert(iterator pos, size_type n, value_type x)\n"
		"string_insert(string self, iterator __p, size_type __n, char __c)\n"
		""},
	 { (char *)"string_replace", _wrap_string_replace, METH_VARARGS, (char *)"\n"
		"replace(size_type __pos, size_type __n, string __str) -> string\n"
		"replace(size_type __pos1, size_type __n1, string __str, size_type __pos2, \n"
		"    size_type __n2) -> string\n"
		"replace(size_type __pos, size_type __n1, char __s, size_type __n2) -> string\n"
		"replace(size_type __pos, size_type __n1, size_type __n2, char __c) -> string\n"
		"replace(iterator __i1, iterator __i2, string __str) -> string\n"
		"replace(iterator __i1, iterator __i2, char __s, size_type __n) -> string\n"
		"replace(iterator __i1, iterator __i2, size_type __n, char __c) -> string\n"
		"replace(iterator __i1, iterator __i2, char __k1, char __k2) -> string\n"
		"string_replace(string self, iterator __i1, iterator __i2, const_iterator __k1, \n"
		"    const_iterator __k2) -> string\n"
		""},
	 { (char *)"string___iadd__", _wrap_string___iadd__, METH_VARARGS, (char *)"string___iadd__(string self, string v) -> string"},
	 { (char *)"string___add__", _wrap_string___add__, METH_VARARGS, (char *)"string___add__(string self, string v) -> string"},
	 { (char *)"string___radd__", _wrap_string___radd__, METH_VARARGS, (char *)"string___radd__(string self, string v) -> string"},
	 { (char *)"string___str__", _wrap_string___str__, METH_VARARGS, (char *)"string___str__(string self) -> string"},
	 { (char *)"string___rlshift__", _wrap_string___rlshift__, METH_VARARGS, (char *)"string___rlshift__(string self, ostream out) -> ostream"},
	 { (char *)"string___eq__", _wrap_string___eq__, METH_VARARGS, (char *)"string___eq__(string self, string v) -> bool"},
	 { (char *)"string___ne__", _wrap_string___ne__, METH_VARARGS, (char *)"string___ne__(string self, string v) -> bool"},
	 { (char *)"string___gt__", _wrap_string___gt__, METH_VARARGS, (char *)"string___gt__(string self, string v) -> bool"},
	 { (char *)"string___lt__", _wrap_string___lt__, METH_VARARGS, (char *)"string___lt__(string self, string v) -> bool"},
	 { (char *)"string___ge__", _wrap_string___ge__, METH_VARARGS, (char *)"string___ge__(string self, string v) -> bool"},
	 { (char *)"string___le__", _wrap_string___le__, METH_VARARGS, (char *)"string___le__(string self, string v) -> bool"},
	 { (char *)"delete_string", _wrap_delete_string, METH_VARARGS, (char *)"delete_string(string self)"},
	 { (char *)"string_swigregister", string_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_ostream", _wrap_new_ostream, METH_VARARGS, (char *)"new_ostream(std::basic_streambuf<(char,std::char_traits<(char)>)> __sb) -> ostream"},
	 { (char *)"delete_ostream", _wrap_delete_ostream, METH_VARARGS, (char *)"delete_ostream(ostream self)"},
	 { (char *)"ostream_swigregister", ostream_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_ostringstream", _wrap_new_ostringstream, METH_VARARGS, (char *)"\n"
		"ostringstream(std::ios_base::openmode __mode = std::ios_base::out)\n"
		"new_ostringstream() -> ostringstream\n"
		""},
	 { (char *)"delete_ostringstream", _wrap_delete_ostringstream, METH_VARARGS, (char *)"delete_ostringstream(ostringstream self)"},
	 { (char *)"ostringstream_str", _wrap_ostringstream_str, METH_VARARGS, (char *)"\n"
		"str() -> string\n"
		"ostringstream_str(ostringstream self, string __s)\n"
		""},
	 { (char *)"ostringstream_swigregister", ostringstream_swigregister, METH_VARARGS, NULL},
	 { (char *)"endl", _wrap_endl, METH_VARARGS, (char *)"endl(ostream arg0) -> ostream"},
	 { (char *)"flush", _wrap_flush, METH_VARARGS, (char *)"flush(ostream arg0) -> ostream"},
	 { (char *)"ASTNode_true", _wrap_ASTNode_true, METH_VARARGS, (char *)"ASTNode_true(ASTNode node) -> int"},
	 { (char *)"getLibSBMLVersion", _wrap_getLibSBMLVersion, METH_VARARGS, (char *)"\n"
		"getLibSBMLVersion() -> int\n"
		"\n"
		"Returns the version number of this copy of libSBML as an integer.\n"
		"\n"
		"@return the libSBML version as an integer; version 1.2.3 becomes 10203.\n"
		"\n"
		"\n"
		""},
	 { (char *)"getLibSBMLDottedVersion", _wrap_getLibSBMLDottedVersion, METH_VARARGS, (char *)"\n"
		"getLibSBMLDottedVersion() -> char\n"
		"\n"
		"Returns the version number of this copy of libSBML as a string.\n"
		"\n"
		"@return the libSBML version as a string; version 1.2.3 becomes\n"
		"'1.2.3'.\n"
		"\n"
		"@see getLibSBMLVersionString()\n"
		"\n"
		"\n"
		""},
	 { (char *)"getLibSBMLVersionString", _wrap_getLibSBMLVersionString, METH_VARARGS, (char *)"\n"
		"getLibSBMLVersionString() -> char\n"
		"\n"
		"Returns the version number of this copy of libSBML as a string without\n"
		"periods.\n"
		"\n"
		"@return the libSBML version as a string: version 1.2.3 becomes '10203'.\n"
		"\n"
		"@see getLibSBMLDottedVersion()\n"
		"\n"
		"\n"
		""},
	 { (char *)"new_SBMLReader", _wrap_new_SBMLReader, METH_VARARGS, (char *)"\n"
		"new_SBMLReader() -> SBMLReader\n"
		"\n"
		"Creates a new SBMLReader and returns it. \n"
		"\n"
		"The libSBML SBMLReader objects offer methods for reading SBML in\n"
		"XML form from files and text strings.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_SBMLReader", _wrap_delete_SBMLReader, METH_VARARGS, (char *)"delete_SBMLReader(SBMLReader self)"},
	 { (char *)"SBMLReader_readSBML", _wrap_SBMLReader_readSBML, METH_VARARGS, (char *)"\n"
		"SBMLReader_readSBML(SBMLReader self, string filename) -> SBMLDocument\n"
		"\n"
		"Reads an SBML document from a file.\n"
		"\n"
		"This method is identical to SBMLReader.readSBMLFromFile().\n"
		"\n"
		"If the file named @p filename does not exist or its content is not\n"
		"valid SBML, one or more errors will be logged with the SBMLDocument\n"
		"object returned by this method.  Callers can use the methods on\n"
		"SBMLDocument such as SBMLDocument.getNumErrors() and\n"
		"SBMLDocument.getError() to get the errors.  The object returned by\n"
		"SBMLDocument.getError() is an SBMLError object, and it has methods to\n"
		"get the error code, category, and severity level of the problem, as\n"
		"well as a textual description of the problem.  The possible severity\n"
		"levels range from informational messages to fatal errors; see the\n"
		"documentation for SBMLError for more information.\n"
		"\n"
		"If the file @p filename could not be read, the file-reading error will\n"
		"appear first.  The error code @if clike (a value drawn from the enumeration\n"
		"#XMLErrorCode_t) @endif can provide a clue about what happened.  For example,\n"
		"a file might be unreadable (either because it does not actually exist\n"
		"or because the user does not have the necessary access priviledges to\n"
		"read it) or some sort of file operation error may have been reported\n"
		"by the underlying operating system.  Callers can check for these\n"
		"situations using a program fragment such as the following:\n"
		"@if clike\n"
		"  @verbatim\n"
		"  SBMLReader reader = new SBMLReader();\n"
		"  SBMLDocument doc  = reader.readSBMLFromFile(filename);\n"
		"  \n"
		"  if (doc->getNumErrors() > 0)\n"
		"  {\n"
		"    if (doc->getError(0)->getErrorId() == XMLError::FileUnreadable)\n"
		"    {\n"
		"      // Handle case of unreadable file here.\n"
		"    } \n"
		"    else if (doc->getError(0)->getErrorId() == XMLError::FileOperationError)\n"
		"    {\n"
		"      // Handle case of other file operation error here.\n"
		"    }\n"
		"    else\n"
		"    {\n"
		"      // Handle other cases -- see error codes defined in XMLErrorCode_t\n"
		"      // for other possible cases to check.\n"
		"    }\n"
		"  }\n"
		"  @endverbatim\n"
		"@endif@if java\n"
		"  @verbatim\n"
		"  SBMLReader reader = new SBMLReader();\n"
		"  SBMLDocument doc  = reader.readSBMLFromFile(filename);\n"
		"  \n"
		"  if (doc.getNumErrors() > 0)\n"
		"  {\n"
		"      if (doc.getError(0).getErrorId() == libsbmlConstants.XMLFileUnreadable)\n"
		"      {\n"
		"          // Handle case of unreadable file here.\n"
		"      } \n"
		"      else if (doc.getError(0).getErrorId() == libsbmlConstants.XMLFileOperationError)\n"
		"      {\n"
		"          // Handle case of other file operation error here.\n"
		"      }\n"
		"      else\n"
		"      {\n"
		"          // Handle other error cases.\n"
		"      }\n"
		"  }\n"
		"  @endverbatim\n"
		"@endif@if python\n"
		"  @verbatim\n"
		"  reader = SBMLReader()\n"
		"  doc    = reader.readSBMLFromFile(filename)\n"
		"  \n"
		"  if doc.getNumErrors() > 0:\n"
		"    if doc.getError(0).getErrorId() == libsbml.XMLFileUnreadable:\n"
		"      # Handle case of unreadable file here.\n"
		"    elif doc.getError(0).getErrorId() == libsbml.XMLFileOperationError:\n"
		"      # Handle case of other file error here.\n"
		"    else:\n"
		"      # Handle other error cases here.\n"
		"    \n"
		"  @endverbatim\n"
		"@endif@if csharp\n"
		"  @verbatim\n"
		"  SBMLReader reader = new SBMLReader();\n"
		"  SBMLDocument doc = reader.readSBMLFromFile(filename);\n"
		"\n"
		"  if (doc.getNumErrors() > 0)\n"
		"  {\n"
		"      if (doc.getError(0).getErrorId() == libsbml.libsbml.XMLFileUnreadable)\n"
		"      {\n"
		"           // Handle case of unreadable file here.\n"
		"      }\n"
		"      else if (doc.getError(0).getErrorId() == libsbml.libsbml.XMLFileOperationError)\n"
		"      {\n"
		"           // Handle case of other file operation error here.\n"
		"      }\n"
		"      else\n"
		"      {\n"
		"           // Handle other cases -- see error codes defined in XMLErrorCode_t\n"
		"           // for other possible cases to check.\n"
		"      }\n"
		"   }\n"
		"  @endverbatim\n"
		"@endif\n"
		"\n"
		"If the given filename ends with the suffix @c '.gz' (for example, @c\n"
		"'myfile.xml.gz'), the file is assumed to be compressed in @em gzip\n"
		"format and will be automatically decompressed upon reading.\n"
		"Similarly, if the given filename ends with @c '.zip' or @c '.bz2', the\n"
		"file is assumed to be compressed in @em zip or @em bzip2 format\n"
		"(respectively).  Files whose names lack these suffixes will be read\n"
		"uncompressed.  Note that if the file is in @em zip format but the\n"
		"archive contains more than one file, only the first file in the\n"
		"archive will be read and the rest ignored.\n"
		"\n"
		"@htmlinclude note-reading-zipped-files.html\n"
		"\n"
		"@param filename the name or full pathname of the file to be read.\n"
		"\n"
		"@return a pointer to the SBMLDocument created from the SBML content.\n"
		"\n"
		"@note LibSBML versions 2.x and later versions behave differently in\n"
		"error handling in several respects.  One difference is how early some\n"
		"errors are caught and whether libSBML continues processing a file in\n"
		"the face of some early errors.  In general, libSBML versions after 2.x\n"
		"stop parsing SBML inputs sooner than libSBML version 2.x in the face\n"
		"of XML errors, because the errors may invalidate any further SBML\n"
		"content.  For example, a missing XML declaration at the beginning of\n"
		"the file was ignored by libSBML 2.x but in version 3.x and later, it\n"
		"will cause libSBML to stop parsing the rest of the input altogether.\n"
		"While this behavior may seem more severe and intolerant, it was\n"
		"necessary in order to provide uniform behavior regardless of which\n"
		"underlying XML parser (Expat, Xerces, libxml2) is being used by\n"
		"libSBML.  The XML parsers themselves behave differently in their error\n"
		"reporting, and sometimes libSBML has to resort to the lowest common\n"
		"denominator.\n"
		"\n"
		"@see SBMLError\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLReader_readSBMLFromFile", _wrap_SBMLReader_readSBMLFromFile, METH_VARARGS, (char *)"\n"
		"SBMLReader_readSBMLFromFile(SBMLReader self, string filename) -> SBMLDocument\n"
		"\n"
		"Reads an SBML document from a file.\n"
		"\n"
		"This method is identical to SBMLReader.readSBML().\n"
		"\n"
		"If the file named @p filename does not exist or its content is not\n"
		"valid SBML, one or more errors will be logged with the SBMLDocument\n"
		"object returned by this method.  Callers can use the methods on\n"
		"SBMLDocument such as SBMLDocument.getNumErrors() and\n"
		"SBMLDocument.getError() to get the errors.  The object returned by\n"
		"SBMLDocument.getError() is an SBMLError object, and it has methods to\n"
		"get the error code, category, and severity level of the problem, as\n"
		"well as a textual description of the problem.  The possible severity\n"
		"levels range from informational messages to fatal errors; see the\n"
		"documentation for SBMLError for more information.\n"
		"\n"
		"If the file @p filename could not be read, the file-reading error will\n"
		"appear first.  The error code @if clike (a value drawn from the enumeration\n"
		"#XMLErrorCode_t)@endif can provide a clue about what happened.  For example,\n"
		"a file might be unreadable (either because it does not actually exist\n"
		"or because the user does not have the necessary access priviledges to\n"
		"read it) or some sort of file operation error may have been reported\n"
		"by the underlying operating system.  Callers can check for these\n"
		"situations using a program fragment such as the following:\n"
		"@if clike\n"
		"  @verbatim\n"
		"  SBMLReader reader = new SBMLReader();\n"
		"  SBMLDocument doc  = reader.readSBML(filename);\n"
		"  \n"
		"  if (doc->getNumErrors() > 0)\n"
		"  {\n"
		"    if (doc->getError(0)->getErrorId() == XMLError::FileUnreadable)\n"
		"    {\n"
		"      // Handle case of unreadable file here.\n"
		"    } \n"
		"    else if (doc->getError(0)->getErrorId() == XMLError::FileOperationError)\n"
		"    {\n"
		"      // Handle case of other file operation error here.\n"
		"    }\n"
		"    else\n"
		"    {\n"
		"      // Handle other cases -- see error codes defined in XMLErrorCode_t\n"
		"      // for other possible cases to check.\n"
		"    }\n"
		"  }\n"
		"  @endverbatim\n"
		"@endif@if java\n"
		"  @verbatim\n"
		"  SBMLReader reader = new SBMLReader();\n"
		"  SBMLDocument doc  = reader.readSBMLFromFile(filename);\n"
		"  \n"
		"  if (doc.getNumErrors() > 0)\n"
		"  {\n"
		"      if (doc.getError(0).getErrorId() == libsbmlConstants.XMLFileUnreadable)\n"
		"      {\n"
		"          // Handle case of unreadable file here.\n"
		"      } \n"
		"      else if (doc.getError(0).getErrorId() == libsbmlConstants.XMLFileOperationError)\n"
		"      {\n"
		"          // Handle case of other file operation error here.\n"
		"      }\n"
		"      else\n"
		"      {\n"
		"          // Handle other error cases.\n"
		"      }\n"
		"  }\n"
		"  @endverbatim\n"
		"@endif@if python\n"
		"  @verbatim\n"
		"  reader = SBMLReader()\n"
		"  doc    = reader.readSBMLFromFile(filename)\n"
		"  \n"
		"  if doc.getNumErrors() > 0:\n"
		"    if doc.getError(0).getErrorId() == libsbml.XMLFileUnreadable:\n"
		"      # Handle case of unreadable file here.\n"
		"    elif doc.getError(0).getErrorId() == libsbml.XMLFileOperationError:\n"
		"      # Handle case of other file error here.\n"
		"    else:\n"
		"      # Handle other error cases here.\n"
		"    \n"
		"  @endverbatim\n"
		"@endif\n"
		"\n"
		"If the given filename ends with the suffix @c '.gz' (for example, @c\n"
		"'myfile.xml.gz'), the file is assumed to be compressed in @em gzip\n"
		"format and will be automatically decompressed upon reading.\n"
		"Similarly, if the given filename ends with @c '.zip' or @c '.bz2', the\n"
		"file is assumed to be compressed in @em zip or @em bzip2 format\n"
		"(respectively).  Files whose names lack these suffixes will be read\n"
		"uncompressed.  Note that if the file is in @em zip format but the\n"
		"archive contains more than one file, only the first file in the\n"
		"archive will be read and the rest ignored.\n"
		"\n"
		"@htmlinclude note-reading-zipped-files.html\n"
		"\n"
		"@param filename the name or full pathname of the file to be read.\n"
		"\n"
		"@return a pointer to the SBMLDocument created from the SBML content.\n"
		"\n"
		"@note LibSBML versions 2.x and later versions behave differently in\n"
		"error handling in several respects.  One difference is how early some\n"
		"errors are caught and whether libSBML continues processing a file in\n"
		"the face of some early errors.  In general, libSBML versions after 2.x\n"
		"stop parsing SBML inputs sooner than libSBML version 2.x in the face\n"
		"of XML errors, because the errors may invalidate any further SBML\n"
		"content.  For example, a missing XML declaration at the beginning of\n"
		"the file was ignored by libSBML 2.x but in version 3.x and later, it\n"
		"will cause libSBML to stop parsing the rest of the input altogether.\n"
		"While this behavior may seem more severe and intolerant, it was\n"
		"necessary in order to provide uniform behavior regardless of which\n"
		"underlying XML parser (Expat, Xerces, libxml2) is being used by\n"
		"libSBML.  The XML parsers themselves behave differently in their error\n"
		"reporting, and sometimes libSBML has to resort to the lowest common\n"
		"denominator.\n"
		"\n"
		"@see SBMLError\n"
		"@see SBMLDocument\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLReader_readSBMLFromString", _wrap_SBMLReader_readSBMLFromString, METH_VARARGS, (char *)"\n"
		"SBMLReader_readSBMLFromString(SBMLReader self, string xml) -> SBMLDocument\n"
		"\n"
		"Reads an SBML document from the given XML string.\n"
		"\n"
		"This method is flexible with respect to the presence of an XML\n"
		"declaration at the beginning of the string.  In particular, if the\n"
		"string in @p xml does not begin with the XML declaration\n"
		"<code>&lt;?xml version='1.0' encoding='UTF-8'?&gt;</code>, then this\n"
		"method will automatically prepend the declaration to @p xml.\n"
		"\n"
		"This method will log a fatal error if the content given in the\n"
		"parameter @p xml is not SBML.  See the method documentation for\n"
		"SBMLReader.readSBML()\n"
		"for an example of code for testing the returned error code.\n"
		"\n"
		"@param xml a string containing a full SBML model\n"
		"\n"
		"@return a pointer to the SBMLDocument created from the SBML content.\n"
		"\n"
		"@see SBMLReader:@if java :readSBML(String filename@endif)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLReader_hasZlib", _wrap_SBMLReader_hasZlib, METH_VARARGS, (char *)"\n"
		"SBMLReader_hasZlib() -> bool\n"
		"\n"
		"Predicate returning @c true if this copy\n"
		"of libSBML supports <i>gzip</I> and <i>zip</i> format compression.\n"
		"\n"
		"@return @c true if libSBML has been linked with the <i>zlib</i>\n"
		"library, @c false otherwise.\n"
		"\n"
		"@see hasBzip2()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLReader_hasBzip2", _wrap_SBMLReader_hasBzip2, METH_VARARGS, (char *)"\n"
		"SBMLReader_hasBzip2() -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"this copy of libSBML supports <i>bzip2</i> format compression.\n"
		"\n"
		"@return @c true if libSBML is linked with the <i>bzip2</i>\n"
		"libraries, @c false otherwise.\n"
		"\n"
		"@see hasZlib()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLReader_swigregister", SBMLReader_swigregister, METH_VARARGS, NULL},
	 { (char *)"readSBMLFromFile", _wrap_readSBMLFromFile, METH_VARARGS, (char *)"\n"
		"readSBMLFromFile(char filename) -> SBMLDocument_t\n"
		"\n"
		"Reads an SBML document from the given file @p filename.\n"
		"\n"
		"If @p filename does not exist, or it is not an SBML file, an error will\n"
		"be logged in the error log of the SBMLDocument object returned by this\n"
		"method.  Calling programs can inspect this error log to determine\n"
		"the nature of the problem.  Please refer to the definition of\n"
		"SBMLDocument for more information about the error reporting mechanism.\n"
		"\n"
		"@return a pointer to the SBMLDocument read.\n"
		"\n"
		"\n"
		""},
	 { (char *)"readSBMLFromString", _wrap_readSBMLFromString, METH_VARARGS, (char *)"\n"
		"readSBMLFromString(char xml) -> SBMLDocument_t\n"
		"\n"
		"Reads an SBML document from a string assumed to be in XML format.\n"
		"\n"
		"If the string does not begin with XML declaration,\n"
		" @verbatim\n"
		" <?xml version='1.0' encoding='UTF-8'?>\n"
		" @endverbatim\n"
		"\n"
		"an XML declaration string will be prepended.\n"
		"\n"
		"This method will report an error if the given string @p xml is not SBML.\n"
		"The error will be logged in the error log of the SBMLDocument object\n"
		"returned by this method.  Calling programs can inspect this error log to\n"
		"determine the nature of the problem.  Please refer to the definition of\n"
		"SBMLDocument for more information about the error reporting mechanism.\n"
		"\n"
		"@return a pointer to the SBMLDocument read.\n"
		"\n"
		"\n"
		""},
	 { (char *)"new_SBMLWriter", _wrap_new_SBMLWriter, METH_VARARGS, (char *)"\n"
		"new_SBMLWriter() -> SBMLWriter\n"
		"\n"
		"Creates a new SBMLWriter.\n"
		"\n"
		"The libSBML SBMLWriter objects offer methods for writing SBML in\n"
		"XML form to files and text strings.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_SBMLWriter", _wrap_delete_SBMLWriter, METH_VARARGS, (char *)"delete_SBMLWriter(SBMLWriter self)"},
	 { (char *)"SBMLWriter_setProgramName", _wrap_SBMLWriter_setProgramName, METH_VARARGS, (char *)"\n"
		"SBMLWriter_setProgramName(SBMLWriter self, string name) -> int\n"
		"\n"
		"Sets the name of this program, i.e., the program that is about to\n"
		"write out the SBMLDocument.\n"
		"\n"
		"If the program name and version are set (see\n"
		"SBMLWriter.setProgramVersion()), the\n"
		"following XML comment, intended for human consumption, will be written\n"
		"at the beginning of the XML document:\n"
		"@code\n"
		"!-- Created by <program name> version <program version>\n"
		"n yyyy-MM-dd HH:mm with libSBML version <libsbml version>. -->\n"
		"endcode\n"
		"\n"
		"If the program name and version are not set at some point before\n"
		"calling the writeSBML() methods, no such comment is written out.\n"
		"\n"
		"@param name the name of this program (where 'this program' refers to\n"
		"program in which libSBML is embedded, not libSBML itself!)\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see setProgramVersion()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_setProgramVersion", _wrap_SBMLWriter_setProgramVersion, METH_VARARGS, (char *)"\n"
		"SBMLWriter_setProgramVersion(SBMLWriter self, string version) -> int\n"
		"\n"
		"Sets the version of this program, i.e., the program that is about to\n"
		"write out the SBMLDocument.\n"
		"\n"
		"If the program version and name are set (see\n"
		"SBMLWriter.setProgramName()), the\n"
		"following XML comment, intended for human consumption, will be written\n"
		"at the beginning of the document:\n"
		"@code\n"
		"!-- Created by <program name> version <program version>\n"
		"n yyyy-MM-dd HH:mm with libSBML version <libsbml version>. -->\n"
		"endcode\n"
		"\n"
		"If the program version and name are not set at some point before\n"
		"calling the writeSBML() methods, no such comment is written out.\n"
		"\n"
		"@param version the version of this program (where 'this program'\n"
		"refers to program in which libSBML is embedded, not libSBML itself!)\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see setProgramName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_writeSBML", _wrap_SBMLWriter_writeSBML, METH_VARARGS, (char *)"\n"
		"writeSBML(SBMLDocument d, string filename) -> bool\n"
		"SBMLWriter_writeSBML(SBMLWriter self, SBMLDocument d, ostream stream) -> bool\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeSBML(SBMLDocument d, string filename)</pre>\n"
		"\n"
		"Writes the given SBML document to filename.\n"
		"\n"
		"@htmlinclude assuming-compressed-file.html\n"
		"\n"
		"@param d the SBML document to be written\n"
		"\n"
		"@param filename the name or full pathname of the file where the SBML\n"
		"is to be written. \n"
		"\n"
		"@return @c true on success and @c false if the filename could not be\n"
		"opened for writing.\n"
		"\n"
		"@note @htmlinclude note-writing-zipped-files.html\n"
		"\n"
		"@see setProgramVersion()\n"
		"@see setProgramName()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeSBML(SBMLDocument d, std::ostream& stream)</pre>\n"
		"\n"
		"Writes the given SBML document to the output stream.\n"
		"\n"
		"@param d the SBML document to be written\n"
		"\n"
		"@param stream the stream object where the SBML is to be written.\n"
		"\n"
		"@return @c true on success and @c false if one of the underlying\n"
		"parser components fail (rare).\n"
		"\n"
		"@see setProgramVersion()\n"
		"@see setProgramName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_writeToString", _wrap_SBMLWriter_writeToString, METH_VARARGS, (char *)"\n"
		"SBMLWriter_writeToString(SBMLWriter self, SBMLDocument d) -> char\n"
		"\n"
		"@internal\n"
		"rites the given SBML document to an in-memory string and returns a\n"
		"ointer to it.\n"
		"\n"
		"he string is owned by the caller and should be freed (with @c free())\n"
		"hen no longer needed.\n"
		"\n"
		"param d the SBML document to be written\n"
		"\n"
		"return the string on success and @c 0 if one of the underlying parser\n"
		"omponents fail.\n"
		"\n"
		"see setProgramVersion()\n"
		"see setProgramName()\n"
		" \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_writeSBMLToFile", _wrap_SBMLWriter_writeSBMLToFile, METH_VARARGS, (char *)"\n"
		"SBMLWriter_writeSBMLToFile(SBMLWriter self, SBMLDocument d, string filename) -> bool\n"
		"\n"
		"Writes the given SBML document to filename.\n"
		"\n"
		"@htmlinclude assuming-compressed-file.html\n"
		"\n"
		"@param d the SBML document to be written\n"
		"\n"
		"@param filename the name or full pathname of the file where the SBML\n"
		"is to be written. \n"
		"\n"
		"@return @c true on success and @c false if the filename could not be\n"
		"opened for writing.\n"
		"\n"
		"@note @htmlinclude note-writing-zipped-files.html\n"
		"\n"
		"@see setProgramVersion()\n"
		"@see setProgramName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_writeSBMLToString", _wrap_SBMLWriter_writeSBMLToString, METH_VARARGS, (char *)"\n"
		"SBMLWriter_writeSBMLToString(SBMLWriter self, SBMLDocument d) -> char\n"
		"\n"
		"Writes the given SBML document to an in-memory string and returns a\n"
		"pointer to it.\n"
		"\n"
		"The string is owned by the caller and should be freed (with @c free())\n"
		"when no longer needed.\n"
		"\n"
		"@param d the SBML document to be written\n"
		"\n"
		"@return the string on success and @c 0 if one of the underlying parser\n"
		"components fail.\n"
		"\n"
		"@see setProgramVersion()\n"
		"@see setProgramName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_hasZlib", _wrap_SBMLWriter_hasZlib, METH_VARARGS, (char *)"\n"
		"SBMLWriter_hasZlib() -> bool\n"
		"\n"
		"Predicate returning @c true if this copy of libSBML has been linked\n"
		"with the <em>zlib</em> library.\n"
		"\n"
		"LibSBML supports reading and writing files compressed with either\n"
		"bzip2 or zip/gzip compression.  The facility depends on libSBML having\n"
		"been compiled with the necessary support libraries.  This method\n"
		"allows a calling program to inquire whether that is the case for the\n"
		"copy of libSBML it is using.\n"
		"\n"
		"@return @c true if libSBML is linked with zlib, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_hasBzip2", _wrap_SBMLWriter_hasBzip2, METH_VARARGS, (char *)"\n"
		"SBMLWriter_hasBzip2() -> bool\n"
		"\n"
		"Predicate returning @c true if this copy of libSBML has been linked\n"
		"with the <em>bzip2</em> library.\n"
		"\n"
		"LibSBML supports reading and writing files compressed with either\n"
		"bzip2 or zip/gzip compression.  The facility depends on libSBML having\n"
		"been compiled with the necessary support libraries.  This method\n"
		"allows a calling program to inquire whether that is the case for the\n"
		"copy of libSBML it is using.\n"
		"\n"
		"@return @c true if libSBML is linked with bzip2, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLWriter_swigregister", SBMLWriter_swigregister, METH_VARARGS, NULL},
	 { (char *)"writeSBML", _wrap_writeSBML, METH_VARARGS, (char *)"\n"
		"writeSBML(SBMLDocument_t d, char filename) -> int\n"
		"\n"
		"Writes the given SBML document @p d to the file named by @p filename.\n"
		"\n"
		"This function is identical to @if clike SBMLWriter.writeSBMLToFile ()@endif@if java <a href='#writeSBMLToFile(org.sbml.libsbml.SBMLDocument, java.lang.String)'><code>writeSBMLToFile(SBMLDocument d, String filename)</code></a>@endif.\n"
		"\n"
		"@htmlinclude assuming-compressed-file.html\n"
		"\n"
		"@param d the SBMLDocument object to be written out in XML format\n"
		"\n"
		"@param filename a string giving the path to a file where the XML\n"
		"content is to be written.\n"
		"\n"
		"@return @c 1 on success and @c 0 (zero) if @p filename could not be\n"
		"written.  Some possible reasons for failure include (a) being unable to\n"
		"open the file, and (b) using a filename that indicates a compressed SBML\n"
		"file (i.e., a filename ending in <code>&quot;.zip&quot;</code> or\n"
		"similar) when the compression functionality has not been enabled in\n"
		"the underlying copy of libSBML.\n"
		"\n"
		"@if clike @warning Note that the string is owned by the caller and\n"
		"should be freed (with the normal string <code>free()</code> C++\n"
		"function) after it is no longer needed.@endif\n"
		"\n"
		"@see SBMLWriter.hasZlib()\n"
		"@see SBMLWriter.hasBzip2()\n"
		"\n"
		"\n"
		""},
	 { (char *)"writeSBMLToString", _wrap_writeSBMLToString, METH_VARARGS, (char *)"\n"
		"writeSBMLToString(SBMLDocument_t d) -> char\n"
		"\n"
		"Writes the given SBML document @p d to an in-memory string and\n"
		"returns the string.\n"
		"\n"
		"This is a convenience function that uses the\n"
		"SBMLWriter.writeSBMLToString() method internally,\n"
		"yet does not require the caller to create an SBMLWriter object first.\n"
		"\n"
		"@param d an SBMLDocument object to be written out in XML format\n"
		"\n"
		"@return the string on success and @c None if one of the underlying parser\n"
		"components fail.\n"
		"\n"
		"@if clike @warning Note that the string is owned by the caller and\n"
		"should be freed (with the normal string <code>free()</code> C++\n"
		"function) after it is no longer needed.@endif\n"
		"\n"
		"\n"
		""},
	 { (char *)"writeSBMLToFile", _wrap_writeSBMLToFile, METH_VARARGS, (char *)"\n"
		"writeSBMLToFile(SBMLDocument_t d, char filename) -> int\n"
		"\n"
		"Writes the given SBML document @p d to the file @p filename.\n"
		"\n"
		"This is a convenience function that uses the\n"
		"SBMLWriter.writeSBMLToFile() method internally, yet does not require the caller to create\n"
		"an SBMLWriter object first.\n"
		"\n"
		"@htmlinclude assuming-compressed-file.html\n"
		"\n"
		"@param d an SBMLDocument object to be written out in XML format\n"
		"\n"
		"@param filename a string giving the path to a file where the XML\n"
		"content is to be written.\n"
		"\n"
		"@return @c 1 on success and @c 0 (zero) if @p filename could not be\n"
		"written.  Some possible reasons for failure include (a) being unable to\n"
		"open the file, and (b) using a filename that indicates a compressed SBML\n"
		"file (i.e., a filename ending in <code>&quot;.zip&quot;</code> or\n"
		"similar) when the compression functionality has not been enabled in\n"
		"the underlying copy of libSBML.\n"
		"\n"
		"@if clike @warning Note that the string is owned by the caller and\n"
		"should be freed (with the normal string <code>free()</code> C++\n"
		"function) after it is no longer needed.@endif\n"
		"\n"
		"@see SBMLWriter.hasZlib()\n"
		"@see SBMLWriter.hasBzip2()\n"
		"\n"
		"\n"
		""},
	 { (char *)"SBMLTypeCode_toString", _wrap_SBMLTypeCode_toString, METH_VARARGS, (char *)"\n"
		"SBMLTypeCode_toString(SBMLTypeCode_t tc) -> char\n"
		"\n"
		"This method takes an SBML type code and returns a string representing\n"
		"the code.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return a human readable name for the given\n"
		"@if clike #SBMLTypeCode_t value@else SBML type code@endif.\n"
		"\n"
		"@note The caller does not own the returned string and is therefore not\n"
		"allowed to modify it.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_SBase", _wrap_delete_SBase, METH_VARARGS, (char *)"delete_SBase(SBase self)"},
	 { (char *)"SBase_clone", _wrap_SBase_clone, METH_VARARGS, (char *)"\n"
		"SBase_clone(SBase self) -> SBase\n"
		"\n"
		"Creates and returns a deep copy of this SBase object.\n"
		"\n"
		"@return a (deep) copy of this SBase object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getMetaId", _wrap_SBase_getMetaId, METH_VARARGS, (char *)"\n"
		"SBase_getMetaId(SBase self) -> string\n"
		"\n"
		"Returns the value of the 'metaid' attribute of this object.\n"
		"\n"
		"The optional attribute named 'metaid', present on every major SBML\n"
		"component type, is for supporting metadata annotations using RDF\n"
		"(Resource Description Format). The attribute value has the data type\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"identifier type, which means each 'metaid' value must be globally\n"
		"unique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"applies across any attribute with type <a\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"'metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"application-specific XML content inside the 'annotation' subelement\n"
		"happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"The 'metaid' value serves to identify a model\n"
		"component for purposes such as referencing that component from\n"
		"metadata placed within 'annotation' subelements.\n"
		" \n"
		"@return the metaid of this SBML object.\n"
		"\n"
		"@see isSetMetaId()\n"
		"@see setMetaId()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getId", _wrap_SBase_getId, METH_VARARGS, (char *)"\n"
		"SBase_getId(SBase self) -> string\n"
		"\n"
		"@internal\n"
		"eturns the value of the 'metaid' attribute of this object.\n"
		"\n"
		"he optional attribute named 'metaid', present on every major SBML\n"
		"omponent type, is for supporting metadata annotations using RDF\n"
		"Resource Description Format).  The attribute value has the data type\n"
		"a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"dentifier type, which means each 'metaid' value must be globally\n"
		"nique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"pplies across any attribute with type <a\n"
		"ref='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"pplication-specific XML content inside the 'annotation' subelement\n"
		"appens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"he 'metaid' value serves to identify a model\n"
		"omponent for purposes such as referencing that component from\n"
		"etadata placed within 'annotation' subelements.\n"
		"\n"
		"return the metaid of this SBML object, as a string.\n"
		"\n"
		"see isSetMetaId()\n"
		"see setMetaId()\n"
		" \n"
		"\n"
		""},
	 { (char *)"SBase_getName", _wrap_SBase_getName, METH_VARARGS, (char *)"\n"
		"SBase_getName(SBase self) -> string\n"
		"\n"
		"@internal\n"
		"eturns the value of the 'metaid' attribute of this object.\n"
		"\n"
		"he optional attribute named 'metaid', present on every major SBML\n"
		"omponent type, is for supporting metadata annotations using RDF\n"
		"Resource Description Format).  The attribute value has the data type\n"
		"a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"dentifier type, which means each 'metaid' value must be globally\n"
		"nique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"pplies across any attribute with type <a\n"
		"ref='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"pplication-specific XML content inside the 'annotation' subelement\n"
		"appens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"he 'metaid' value serves to identify a model\n"
		"omponent for purposes such as referencing that component from\n"
		"etadata placed within 'annotation' subelements.\n"
		"\n"
		"return the metaid of this SBML object, as a string.\n"
		"\n"
		"see isSetMetaId()\n"
		"see setMetaId()\n"
		" \n"
		"\n"
		""},
	 { (char *)"SBase_getNotes", _wrap_SBase_getNotes, METH_VARARGS, (char *)"\n"
		"SBase_getNotes(SBase self) -> XMLNode\n"
		"\n"
		"Returns the content of the 'notes' subelement of this object as\n"
		"a tree of XMLNode objects.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"The 'notes' element content returned by this method will be in XML\n"
		"form, but libSBML does not provide an object model specifically for\n"
		"the content of notes.  Callers will need to traverse the XML tree\n"
		"structure using the facilities available on XMLNode and related\n"
		"objects.  For an alternative method of accessing the notes, see\n"
		"getNotesString().\n"
		"\n"
		"@return the content of the 'notes' subelement of this SBML object as a\n"
		"tree structure composed of XMLNode objects.\n"
		"\n"
		"@see getNotesString()\n"
		"@see isSetNotes()\n"
		"@see setNotes()\n"
		"@see setNotes()\n"
		"@see appendNotes()\n"
		"@see appendNotes()\n"
		"@see unsetNotes()\n"
		"@see SyntaxChecker.hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getNotesString", _wrap_SBase_getNotesString, METH_VARARGS, (char *)"\n"
		"SBase_getNotesString(SBase self) -> string\n"
		"\n"
		"Returns the content of the 'notes' subelement of this object as a\n"
		"string.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"For an alternative method of accessing the notes, see getNotes(),\n"
		"which returns the content as an XMLNode tree structure.  Depending on\n"
		"an application's needs, one or the other method may be more\n"
		"convenient.\n"
		"\n"
		"@return the content of the 'notes' subelement of this SBML object as a\n"
		"string.\n"
		"\n"
		"@see getNotes()\n"
		"@see isSetNotes()\n"
		"@see setNotes()\n"
		"@see setNotes()\n"
		"@see appendNotes()\n"
		"@see appendNotes()\n"
		"@see unsetNotes()\n"
		"@see SyntaxChecker.hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getAnnotation", _wrap_SBase_getAnnotation, METH_VARARGS, (char *)"\n"
		"SBase_getAnnotation(SBase self) -> XMLNode\n"
		"\n"
		"Returns the content of the 'annotation' subelement of this object as\n"
		"a tree of XMLNode objects.\n"
		"\n"
		"Whereas the SBML 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type\n"
		"'any'</a>, allowing essentially arbitrary well-formed XML data\n"
		"content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"The annotations returned by this method will be in XML form.  LibSBML\n"
		"provides an object model and related interfaces for certain specific\n"
		"kinds of annotations, namely model history information and RDF\n"
		"content.  See the ModelHistory, CVTerm and RDFAnnotationParser classes\n"
		"for more information about the facilities available.\n"
		"\n"
		"@return the annotation of this SBML object as a tree of XMLNode objects.\n"
		"\n"
		"@see getAnnotationString()\n"
		"@see isSetAnnotation()\n"
		"@see setAnnotation()\n"
		"@see setAnnotation()\n"
		"@see appendAnnotation()\n"
		"@see appendAnnotation()\n"
		"@see unsetAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getAnnotationString", _wrap_SBase_getAnnotationString, METH_VARARGS, (char *)"\n"
		"SBase_getAnnotationString(SBase self) -> string\n"
		"\n"
		"Returns the content of the 'annotation' subelement of this object as a\n"
		"character string.\n"
		"\n"
		"Whereas the SBML 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type\n"
		"'any'</a>, allowing essentially arbitrary well-formed XML data\n"
		"content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"The annotations returned by this method will be in string form.\n"
		"\n"
		"@return the annotation of this SBML object as a character string.\n"
		"\n"
		"@see getAnnotation()\n"
		"@see isSetAnnotation()\n"
		"@see setAnnotation()\n"
		"@see setAnnotation()\n"
		"@see appendAnnotation()\n"
		"@see appendAnnotation()\n"
		"@see unsetAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getNamespaces", _wrap_SBase_getNamespaces, METH_VARARGS, (char *)"\n"
		"SBase_getNamespaces(SBase self) -> XMLNamespaces\n"
		"\n"
		"Returns a list of the XML Namespaces declared on this SBML document.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in SBML Level&nbsp;3) packages used in addition to SBML Level&nbsp;3\n"
		"Core.\n"
		"\n"
		"@return the XML Namespaces associated with this SBML object\n"
		"\n"
		"@see getLevel()\n"
		"@see getVersion()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getSBMLDocument", _wrap_SBase_getSBMLDocument, METH_VARARGS, (char *)"\n"
		"getSBMLDocument() -> SBMLDocument\n"
		"SBase_getSBMLDocument(SBase self) -> SBMLDocument\n"
		"\n"
		"Returns the SBMLDocument object containing @em this object instance.\n"
		"\n"
		"LibSBML uses the class SBMLDocument as a top-level container for\n"
		"storing SBML content and data associated with it (such as warnings and\n"
		"error messages).  An SBML model in libSBML is contained inside an\n"
		"SBMLDocument object.  SBMLDocument corresponds roughly to the class\n"
		"<i>SBML</i> defined in the SBML Level&nbsp;3 and Level&nbsp;2\n"
		"specifications, but it does not have a direct correspondence in SBML\n"
		"Level&nbsp;1.  (But, it is created by libSBML no matter whether the\n"
		"model is Level&nbsp;1, Level&nbsp;2 or Level&nbsp;3.)\n"
		"\n"
		"This method allows the caller to obtain the SBMLDocument for the\n"
		"current object.\n"
		"\n"
		"@return the parent SBMLDocument object of this SBML object.\n"
		"\n"
		"@see getParentSBMLObject()\n"
		"@see getModel()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getParentSBMLObject", _wrap_SBase_getParentSBMLObject, METH_VARARGS, (char *)"\n"
		"SBase_getParentSBMLObject(SBase self) -> SBase\n"
		"\n"
		"Returns the parent SBML object containing this object.\n"
		"\n"
		"This returns the immediately-containing object.  This method is\n"
		"convenient when holding an object nested inside other objects in an\n"
		"SBML model.  \n"
		"\n"
		"@return the parent SBML object of this SBML object.\n"
		"\n"
		"@see getSBMLDocument()\n"
		"@see getModel()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getAncestorOfType", _wrap_SBase_getAncestorOfType, METH_VARARGS, (char *)"\n"
		"SBase_getAncestorOfType(SBase self, SBMLTypeCode_t type) -> SBase\n"
		"\n"
		"Returns the ancestor SBML object that corresponds to the given\n"
		"SBML type code value.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the ancestor SBML object of this SBML object that corresponds\n"
		"to the given @if clike #SBMLTypeCode_t value@else SBML object type\n"
		"code@endif, or @c None if no ancestor exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getSBOTerm", _wrap_SBase_getSBOTerm, METH_VARARGS, (char *)"\n"
		"SBase_getSBOTerm(SBase self) -> int\n"
		"\n"
		"Returns the integer portion of the value of the 'sboTerm' attribute of\n"
		"this object.\n"
		"\n"
		"Beginning with SBML Level 2 Version 3, objects derived from SBase have\n"
		"an optional attribute named 'sboTerm' for supporting the use of the\n"
		"Systems Biology Ontology.  In SBML proper, the data type of the\n"
		"attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a\n"
		"seven digit integer number; libSBML simplifies the representation by\n"
		"only storing the 'NNNNNNN' integer portion.  Thus, in libSBML, the\n"
		"'sboTerm' attribute on SBase has data type @c int, and SBO identifiers\n"
		"are stored simply as integers.  (For convenience, libSBML offers\n"
		"methods for returning both the integer form and a text-string form of\n"
		"the SBO identifier.)\n"
		"\n"
		"SBO terms are a type of optional annotation, and each different class\n"
		"of SBML object derived from SBase imposes its own requirements about\n"
		"the values permitted for 'sboTerm'.  Please consult the SBML\n"
		"Level&nbsp;2 Version&nbsp;4 specification for more information about\n"
		"the use of SBO and the 'sboTerm' attribute.\n"
		"\n"
		"@return the value of the 'sboTerm' attribute as an integer, or @c -1\n"
		"if the value is not set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getSBOTermID", _wrap_SBase_getSBOTermID, METH_VARARGS, (char *)"\n"
		"SBase_getSBOTermID(SBase self) -> string\n"
		"\n"
		"Returns the string representation of the 'sboTerm' attribute of\n"
		"this object.\n"
		"\n"
		"Beginning with SBML Level 2 Version 3, objects derived from SBase have\n"
		"an optional attribute named 'sboTerm' for supporting the use of the\n"
		"Systems Biology Ontology.  In SBML proper, the data type of the\n"
		"attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a\n"
		"seven digit integer number; libSBML simplifies the representation by\n"
		"only storing the 'NNNNNNN' integer portion.  Thus, in libSBML, the\n"
		"'sboTerm' attribute on SBase has data type @c int, and SBO identifiers\n"
		"are stored simply as integers.  This method returns the entire SBO\n"
		"identifier as a text string in the form 'SBO:NNNNNNN'.\n"
		"\n"
		"SBO terms are a type of optional annotation, and each different class\n"
		"of SBML object derived from SBase imposes its own requirements about\n"
		"the values permitted for 'sboTerm'.  Please consult the SBML\n"
		"Level&nbsp;2 Version&nbsp;4 specification for more information about\n"
		"the use of SBO and the 'sboTerm' attribute.\n"
		"\n"
		"@return the value of the 'sboTerm' attribute as a string (its value\n"
		"will be of the form 'SBO:NNNNNNN'), or an empty string if\n"
		"the value is not set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getLine", _wrap_SBase_getLine, METH_VARARGS, (char *)"\n"
		"SBase_getLine(SBase self) -> unsigned int\n"
		"\n"
		"Returns the line number on which this object first appears in the XML\n"
		"representation of the SBML document.\n"
		"\n"
		"@return the line number of this SBML object.\n"
		"\n"
		"@note The line number for each construct in an SBML model is set upon\n"
		"reading the model.  The accuracy of the line number depends on the\n"
		"correctness of the XML representation of the model, and on the\n"
		"particular XML parser library being used.  The former limitation\n"
		"relates to the following problem: if the model is actually invalid\n"
		"XML, then the parser may not be able to interpret the data correctly\n"
		"and consequently may not be able to establish the real line number.\n"
		"The latter limitation is simply that different parsers seem to have\n"
		"their own accuracy limitations, and out of all the parsers supported\n"
		"by libSBML, none have been 100% accurate in all situations. (At this\n"
		"time, libSBML supports the use of <a target='_blank'\n"
		"href='http://xmlsoft.org'>libxml2</a>, <a target='_blank'\n"
		"href='http://expat.sourceforge.net/'>Expat</a> and <a target='_blank'\n"
		"href='http://http://xerces.apache.org/xerces-c/'>Xerces</a>.)\n"
		"\n"
		"@see getColumn()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getColumn", _wrap_SBase_getColumn, METH_VARARGS, (char *)"\n"
		"SBase_getColumn(SBase self) -> unsigned int\n"
		"\n"
		"Returns the column number on which this object first appears in the XML\n"
		"representation of the SBML document.\n"
		"\n"
		"@return the column number of this SBML object.\n"
		"\n"
		"@note The column number for each construct in an SBML model is set\n"
		"upon reading the model.  The accuracy of the column number depends on\n"
		"the correctness of the XML representation of the model, and on the\n"
		"particular XML parser library being used.  The former limitation\n"
		"relates to the following problem: if the model is actually invalid\n"
		"XML, then the parser may not be able to interpret the data correctly\n"
		"and consequently may not be able to establish the real column number.\n"
		"The latter limitation is simply that different parsers seem to have\n"
		"their own accuracy limitations, and out of all the parsers supported\n"
		"by libSBML, none have been 100% accurate in all situations. (At this\n"
		"time, libSBML supports the use of <a target='_blank'\n"
		"href='http://xmlsoft.org'>libxml2</a>, <a target='_blank'\n"
		"href='http://expat.sourceforge.net/'>Expat</a> and <a target='_blank'\n"
		"href='http://http://xerces.apache.org/xerces-c/'>Xerces</a>.)\n"
		"\n"
		"@see getLine()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getModelHistory", _wrap_SBase_getModelHistory, METH_VARARGS, (char *)"\n"
		"getModelHistory() -> ModelHistory\n"
		"SBase_getModelHistory(SBase self) -> ModelHistory\n"
		"\n"
		"Returns the ModelHistory object, if any, attached to this object.\n"
		"\n"
		"@return the ModelHistory object attached to this object, or @c None if\n"
		"none exist.\n"
		"\n"
		"@note In SBML Level&nbsp;2, model history annotations were only\n"
		"permitted on the Model element.  In SBML Level&nbsp;3, they are\n"
		"permitted on all SBML components derived from SBase.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_isSetMetaId", _wrap_SBase_isSetMetaId, METH_VARARGS, (char *)"\n"
		"SBase_isSetMetaId(SBase self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object's 'metaid' attribute is set.\n"
		"\n"
		"The optional attribute named 'metaid', present on every major SBML\n"
		"component type, is for supporting metadata annotations using RDF\n"
		"(Resource Description Format). The attribute value has the data type\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"identifier type, which means each 'metaid' value must be globally\n"
		"unique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"applies across any attribute with type <a\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"'metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"application-specific XML content inside the 'annotation' subelement\n"
		"happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"The 'metaid' value serves to identify a model component for purposes\n"
		"such as referencing that component from metadata placed within\n"
		"'annotation' subelements.\n"
		"\n"
		"@return @c true if the 'metaid' attribute of this SBML object is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@see getMetaId()\n"
		"@see setMetaId()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_isSetId", _wrap_SBase_isSetId, METH_VARARGS, (char *)"\n"
		"SBase_isSetId(SBase self) -> bool\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if this\n"
		"bject's 'metaid' attribute is set.\n"
		"\n"
		"he optional attribute named 'metaid', present on every major SBML\n"
		"omponent type, is for supporting metadata annotations using RDF\n"
		"Resource Description Format). The attribute value has the data type\n"
		"a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"dentifier type, which means each 'metaid' value must be globally\n"
		"nique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"pplies across any attribute with type <a\n"
		"ref='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"pplication-specific XML content inside the 'annotation' subelement\n"
		"appens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"he 'metaid' value serves to identify a model component for purposes\n"
		"uch as referencing that component from metadata placed within\n"
		"annotation' subelements.\n"
		"\n"
		"return @c true if the 'metaid' attribute of this SBML object is\n"
		"et, @c false otherwise.\n"
		"\n"
		"see getMetaId()\n"
		"see setMetaId()\n"
		" \n"
		"\n"
		""},
	 { (char *)"SBase_isSetName", _wrap_SBase_isSetName, METH_VARARGS, (char *)"\n"
		"SBase_isSetName(SBase self) -> bool\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if this\n"
		"bject's 'metaid' attribute is set.\n"
		"\n"
		"he optional attribute named 'metaid', present on every major SBML\n"
		"omponent type, is for supporting metadata annotations using RDF\n"
		"Resource Description Format). The attribute value has the data type\n"
		"a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"dentifier type, which means each 'metaid' value must be globally\n"
		"nique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"pplies across any attribute with type <a\n"
		"ref='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"pplication-specific XML content inside the 'annotation' subelement\n"
		"appens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"he 'metaid' value serves to identify a model component for purposes\n"
		"uch as referencing that component from metadata placed within\n"
		"annotation' subelements.\n"
		"\n"
		"return @c true if the 'metaid' attribute of this SBML object is\n"
		"et, @c false otherwise.\n"
		"\n"
		"see getMetaId()\n"
		"see setMetaId()\n"
		" \n"
		"\n"
		""},
	 { (char *)"SBase_isSetNotes", _wrap_SBase_isSetNotes, METH_VARARGS, (char *)"\n"
		"SBase_isSetNotes(SBase self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object's 'notes' subelement exists and has content.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"@return @c true if a 'notes' subelement exists, @c false otherwise.\n"
		"\n"
		"@see getNotes()\n"
		"@see getNotesString()\n"
		"@see setNotes()\n"
		"@see setNotes()\n"
		"@see appendNotes()\n"
		"@see appendNotes()\n"
		"@see unsetNotes()\n"
		"@see SyntaxChecker.hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_isSetAnnotation", _wrap_SBase_isSetAnnotation, METH_VARARGS, (char *)"\n"
		"SBase_isSetAnnotation(SBase self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object's 'annotation' subelement exists and has content.\n"
		"\n"
		"Whereas the SBase 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type\n"
		"'any'</a>, allowing essentially arbitrary well-formed XML data\n"
		"content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"@return @c true if a 'annotation' subelement exists, @c false\n"
		"otherwise.\n"
		"\n"
		"@see getAnnotation()\n"
		"@see getAnnotationString()\n"
		"@see setAnnotation()\n"
		"@see setAnnotation()\n"
		"@see appendAnnotation()\n"
		"@see appendAnnotation()\n"
		"@see unsetAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_isSetSBOTerm", _wrap_SBase_isSetSBOTerm, METH_VARARGS, (char *)"\n"
		"SBase_isSetSBOTerm(SBase self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object's 'sboTerm' attribute is set.\n"
		"\n"
		"@return @c true if the 'sboTerm' attribute of this SBML object is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_setMetaId", _wrap_SBase_setMetaId, METH_VARARGS, (char *)"\n"
		"SBase_setMetaId(SBase self, string metaid) -> int\n"
		"\n"
		"Sets the value of the 'metaid' attribute of this object.\n"
		"\n"
		"The string @p metaid is copied.  The value of @p metaid must be an\n"
		"identifier conforming to the syntax defined by the XML 1.0 data type\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>ID</a>.  Among other\n"
		"things, this type requires that a value is unique among all the values\n"
		"of type XML ID in an SBMLDocument.  Although SBML only uses <a\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a> for the 'metaid'\n"
		"attribute, callers should be careful if they use\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>'s in XML\n"
		"portions of a model that are not defined by SBML, such as in the\n"
		"application-specific content of the 'annotation' subelement.\n"
		"\n"
		"@param metaid the identifier string to use as the value of the\n"
		"'metaid' attribute\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@see getMetaId()\n"
		"@see isSetMetaId()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_isSetModelHistory", _wrap_SBase_isSetModelHistory, METH_VARARGS, (char *)"\n"
		"SBase_isSetModelHistory(SBase self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object has a ModelHistory object attached to it.\n"
		"\n"
		"@return @c true if the ModelHistory of this object is set, @c\n"
		"false otherwise.\n"
		"\n"
		"@note In SBML Level&nbsp;2, model history annotations were only\n"
		"permitted on the Model element.  In SBML Level&nbsp;3, they are\n"
		"permitted on all SBML components derived from SBase.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_setId", _wrap_SBase_setId, METH_VARARGS, (char *)"\n"
		"SBase_setId(SBase self, string sid) -> int\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if this\n"
		"bject has a ModelHistory object attached to it.\n"
		"\n"
		"return @c true if the ModelHistory of this object is set, @c\n"
		"alse otherwise.\n"
		"\n"
		"note In SBML Level&nbsp;2, model history annotations were only\n"
		"ermitted on the Model element.  In SBML Level&nbsp;3, they are\n"
		"ermitted on all SBML components derived from SBase.\n"
		" \n"
		"\n"
		""},
	 { (char *)"SBase_setName", _wrap_SBase_setName, METH_VARARGS, (char *)"\n"
		"SBase_setName(SBase self, string name) -> int\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if this\n"
		"bject has a ModelHistory object attached to it.\n"
		"\n"
		"return @c true if the ModelHistory of this object is set, @c\n"
		"alse otherwise.\n"
		"\n"
		"note In SBML Level&nbsp;2, model history annotations were only\n"
		"ermitted on the Model element.  In SBML Level&nbsp;3, they are\n"
		"ermitted on all SBML components derived from SBase.\n"
		" \n"
		"\n"
		""},
	 { (char *)"SBase_setAnnotation", _wrap_SBase_setAnnotation, METH_VARARGS, (char *)"\n"
		"setAnnotation(XMLNode annotation) -> int\n"
		"SBase_setAnnotation(SBase self, string annotation) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setAnnotation(XMLNode annotation)</pre>\n"
		"\n"
		"Sets the value of the 'annotation' subelement of this SBML object.\n"
		"\n"
		"The content of @p annotation is copied, and any previous content of\n"
		"this object's 'annotation' subelement is deleted.\n"
		"\n"
		"Whereas the SBase 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type\n"
		"'any'</a>, allowing essentially arbitrary well-formed XML data\n"
		"content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"Call this method will result in any existing content of the\n"
		"'annotation' subelement to be discarded.  Unless you have taken steps\n"
		"to first copy and reconstitute any existing annotations into the @p\n"
		"annotation that is about to be assigned, it is likely that performing\n"
		"such wholesale replacement is unfriendly towards other software\n"
		"applications whose annotations are discarded.  An alternative may be\n"
		"to use SBase.appendAnnotation() or\n"
		"SBase.appendAnnotation().\n"
		"\n"
		"@param annotation an XML structure that is to be used as the new content\n"
		"of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see getAnnotationString()\n"
		"@see isSetAnnotation()\n"
		"@see setAnnotation()\n"
		"@see appendAnnotation()\n"
		"@see appendAnnotation()\n"
		"@see unsetAnnotation()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setAnnotation(string annotation)</pre>\n"
		"\n"
		"Sets the value of the 'annotation' subelement of this SBML object.\n"
		"\n"
		"The content of @p annotation is copied, and any previous content of\n"
		"this object's 'annotation' subelement is deleted.\n"
		"\n"
		"Whereas the SBase 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type\n"
		"'any'</a>, allowing essentially arbitrary well-formed XML data\n"
		"content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"Call this method will result in any existing content of the\n"
		"'annotation' subelement to be discarded.  Unless you have taken steps\n"
		"to first copy and reconstitute any existing annotations into the @p\n"
		"annotation that is about to be assigned, it is likely that performing\n"
		"such wholesale replacement is unfriendly towards other software\n"
		"applications whose annotations are discarded.  An alternative may be\n"
		"to use SBase.appendAnnotation() or\n"
		"SBase.appendAnnotation().\n"
		"\n"
		"@param annotation an XML string that is to be used as the content\n"
		"of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see getAnnotationString()\n"
		"@see isSetAnnotation()\n"
		"@see setAnnotation()\n"
		"@see appendAnnotation()\n"
		"@see appendAnnotation()\n"
		"@see unsetAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_appendAnnotation", _wrap_SBase_appendAnnotation, METH_VARARGS, (char *)"\n"
		"appendAnnotation(XMLNode annotation) -> int\n"
		"SBase_appendAnnotation(SBase self, string annotation) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>appendAnnotation(XMLNode annotation)</pre>\n"
		"\n"
		"Appends the given @p annotation to the 'annotation' subelement of this\n"
		"object.\n"
		"\n"
		"Whereas the SBase 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a\n"
		"target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type 'any'</a>,\n"
		"allowing essentially arbitrary well-formed XML data content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"Unlike SBase.setAnnotation() or\n"
		"SBase.setAnnotation(), this method\n"
		"allows other annotations to be preserved when an application adds its\n"
		"own data.\n"
		"\n"
		"@param annotation an XML structure that is to be copied and appended\n"
		"to the content of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see getAnnotationString()\n"
		"@see isSetAnnotation()\n"
		"@see setAnnotation()\n"
		"@see setAnnotation()\n"
		"@see appendAnnotation()\n"
		"@see unsetAnnotation()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>appendAnnotation(string annotation)</pre>\n"
		"\n"
		"Appends the given @p annotation to the 'annotation' subelement of this\n"
		"object.\n"
		"\n"
		"Whereas the SBase 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a\n"
		"target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type 'any'</a>,\n"
		"allowing essentially arbitrary well-formed XML data content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"Unlike SBase.setAnnotation() or\n"
		"SBase.setAnnotation(), this method\n"
		"allows other annotations to be preserved when an application adds its\n"
		"own data.\n"
		"\n"
		"@param annotation an XML string that is to be copied and appended\n"
		"to the content of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see getAnnotationString()\n"
		"@see isSetAnnotation()\n"
		"@see setAnnotation()\n"
		"@see setAnnotation()\n"
		"@see appendAnnotation()\n"
		"@see unsetAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_setNotes", _wrap_SBase_setNotes, METH_VARARGS, (char *)"\n"
		"setNotes(XMLNode notes) -> int\n"
		"SBase_setNotes(SBase self, string notes) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setNotes(XMLNode notes)</pre>\n"
		"\n"
		"Sets the value of the 'notes' subelement of this SBML object.\n"
		"\n"
		"The content of @p notes is copied, and any existing content of this\n"
		"object's 'notes' subelement is deleted.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"@param notes an XML structure that is to be used as the content of the\n"
		"'notes' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@see getNotesString()\n"
		"@see isSetNotes()\n"
		"@see setNotes()\n"
		"@see appendNotes()\n"
		"@see appendNotes()\n"
		"@see unsetNotes()\n"
		"@see SyntaxChecker.hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setNotes(string notes)</pre>\n"
		"\n"
		"Sets the value of the 'notes' subelement of this SBML object to a copy\n"
		"of the string @p notes.\n"
		"\n"
		"The content of @p notes is copied, and any existing content of this\n"
		"object's 'notes' subelement is deleted.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"The following code illustrates a very simple way of setting the notes\n"
		"using this method.  Here, the object being annotated is the whole SBML\n"
		"document, but that is for illustration purposes only; you could of\n"
		"course use this same approach to annotate any other SBML component.\n"
		"@if clike\n"
		" @verbatim\n"
		" SBMLDocument s = new SBMLDocument(3, 1);\n"
		" s->setNotes('<body xmlns='http://www.w3.org/1999/xhtml'><p>here is my note</p></body>');\n"
		" @endverbatim\n"
		"@endif@if java\n"
		" @verbatim\n"
		" SBMLDocument s = new SBMLDocument(3, 1);\n"
		" s.setNotes('<body xmlns='http://www.w3.org/1999/xhtml'><p>here is my note</p></body>');\n"
		" @endverbatim\n"
		"@endif@if csharp\n"
		" @verbatim\n"
		" SBMLDocument s = new SBMLDocument(3, 1);\n"
		" s.setNotes('<body xmlns='http://www.w3.org/1999/xhtml'><p>here is my note</p></body>');\n"
		" @endverbatim\n"
		"@endif\n"
		"\n"
		"@param notes an XML string that is to be used as the content of the\n"
		"'notes' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see getNotesString()\n"
		"@see isSetNotes()\n"
		"@see setNotes()\n"
		"@see appendNotes()\n"
		"@see appendNotes()\n"
		"@see unsetNotes()\n"
		"@see SyntaxChecker.hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_appendNotes", _wrap_SBase_appendNotes, METH_VARARGS, (char *)"\n"
		"appendNotes(XMLNode notes) -> int\n"
		"SBase_appendNotes(SBase self, string notes) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>appendNotes(XMLNode notes)</pre>\n"
		"\n"
		"Appends the given @p notes to the 'notes' subelement of this object.\n"
		"\n"
		"The content of @p notes is copied.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"@param notes an XML node structure that is to appended to the content\n"
		"of the 'notes' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see getNotesString()\n"
		"@see isSetNotes()\n"
		"@see setNotes()\n"
		"@see setNotes()\n"
		"@see appendNotes()\n"
		"@see unsetNotes()\n"
		"@see SyntaxChecker.hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>appendNotes(string notes)</pre>\n"
		"\n"
		"Appends the given @p notes to the 'notes' subelement of this object.\n"
		"\n"
		"The content of the parameter @p notes is copied.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"@param notes an XML string that is to appended to the content of\n"
		"the 'notes' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see getNotesString()\n"
		"@see isSetNotes()\n"
		"@see setNotes()\n"
		"@see setNotes()\n"
		"@see appendNotes()\n"
		"@see unsetNotes()\n"
		"@see SyntaxChecker.hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_setModelHistory", _wrap_SBase_setModelHistory, METH_VARARGS, (char *)"\n"
		"SBase_setModelHistory(SBase self, ModelHistory history) -> int\n"
		"\n"
		"Sets the ModelHistory of this object.\n"
		"\n"
		"The content of @p history is copied, and this object's existing model\n"
		"history content is deleted.\n"
		"\n"
		"@param history ModelHistory of this object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note In SBML Level&nbsp;2, model history annotations were only\n"
		"permitted on the Model element.  In SBML Level&nbsp;3, they are\n"
		"permitted on all SBML components derived from SBase.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_setSBOTerm", _wrap_SBase_setSBOTerm, METH_VARARGS, (char *)"\n"
		"setSBOTerm(int value) -> int\n"
		"SBase_setSBOTerm(SBase self, string sboid) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setSBOTerm(int value)</pre>\n"
		"\n"
		"Sets the value of the 'sboTerm' attribute.\n"
		"\n"
		"Beginning with SBML Level 2 Version 3, objects derived from SBase have\n"
		"an optional attribute named 'sboTerm' for supporting the use of the\n"
		"Systems Biology Ontology.  In SBML proper, the data type of the\n"
		"attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a\n"
		"seven digit integer number; libSBML simplifies the representation by\n"
		"only storing the 'NNNNNNN' integer portion.  Thus, in libSBML, the\n"
		"'sboTerm' attribute on SBase has data type @c int, and SBO identifiers\n"
		"are stored simply as integers. \n"
		"\n"
		"SBO terms are a type of optional annotation, and each different class\n"
		"of SBML object derived from SBase imposes its own requirements about\n"
		"the values permitted for 'sboTerm'.  Please consult the SBML\n"
		"Level&nbsp;2 Version&nbsp;4 specification for more information about\n"
		"the use of SBO and the 'sboTerm' attribute.\n"
		"\n"
		"@param value the NNNNNNN integer portion of the SBO identifier\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@see setSBOTerm()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setSBOTerm(string &sboid)</pre>\n"
		"\n"
		"Sets the value of the 'sboTerm' attribute by string.\n"
		"\n"
		"Beginning with SBML Level 2 Version 3, objects derived from SBase have\n"
		"an optional attribute named 'sboTerm' for supporting the use of the\n"
		"Systems Biology Ontology.  In SBML proper, the data type of the\n"
		"attribute is a string of the form 'SBO:NNNNNNN', where 'NNNNNNN' is a\n"
		"seven digit integer number; libSBML simplifies the representation by\n"
		"only storing the 'NNNNNNN' integer portion.  Thus, in libSBML, the\n"
		"'sboTerm' attribute on SBase has data type @c int, and SBO identifiers\n"
		"are stored simply as integers.  This method lets you set the value of\n"
		"'sboTerm' as a complete string of the form 'SBO:NNNNNNN', whereas\n"
		"setSBOTerm(int value) allows you to set it using the integer form.\n"
		"\n"
		"SBO terms are a type of optional annotation, and each different class\n"
		"of SBML object derived from SBase imposes its own requirements about\n"
		"the values permitted for 'sboTerm'.  Please consult the SBML\n"
		"Level&nbsp;2 Version&nbsp;4 specification for more information about\n"
		"the use of SBO and the 'sboTerm' attribute.\n"
		"\n"
		"@param sboid the SBO identifier string of the form 'SBO:NNNNNNN'\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@see setSBOTerm()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_setNamespaces", _wrap_SBase_setNamespaces, METH_VARARGS, (char *)"\n"
		"SBase_setNamespaces(SBase self, XMLNamespaces xmlns) -> int\n"
		"\n"
		"Sets the namespaces relevant of this SBML object.\n"
		"\n"
		"The content of @p xmlns is copied, and this object's existing\n"
		"namespace content is deleted.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"\n"
		"@param xmlns the namespaces to set\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_unsetMetaId", _wrap_SBase_unsetMetaId, METH_VARARGS, (char *)"\n"
		"SBase_unsetMetaId(SBase self) -> int\n"
		"\n"
		"Unsets the value of the 'metaid' attribute of this SBML object.\n"
		"\n"
		"The optional attribute named 'metaid', present on every major SBML\n"
		"component type, is for supporting metadata annotations using RDF\n"
		"(Resource Description Format). The attribute value has the data type\n"
		"<a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, the XML\n"
		"identifier type, which means each 'metaid' value must be globally\n"
		"unique within an SBML file.  (Importantly, this uniqueness criterion\n"
		"applies across any attribute with type <a\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>, not just the\n"
		"'metaid' attribute used by SBML&mdash;something to be aware of if your\n"
		"application-specific XML content inside the 'annotation' subelement\n"
		"happens to use <a href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.)\n"
		"The 'metaid' value serves to identify a model component for purposes\n"
		"such as referencing that component from metadata placed within\n"
		"'annotation' subelements.\n"
		" \n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_unsetNotes", _wrap_SBase_unsetNotes, METH_VARARGS, (char *)"\n"
		"SBase_unsetNotes(SBase self) -> int\n"
		"\n"
		"Unsets the value of the 'notes' subelement of this SBML object.\n"
		"\n"
		"The optional SBML element named 'notes', present on every major SBML\n"
		"component type, is intended as a place for storing optional\n"
		"information intended to be seen by humans.  An example use of the\n"
		"'notes' element would be to contain formatted user comments about the\n"
		"model element in which the 'notes' element is enclosed.  Every object\n"
		"derived directly or indirectly from type SBase can have a separate\n"
		"value for 'notes', allowing users considerable freedom when adding\n"
		"comments to their models.\n"
		"\n"
		"The format of 'notes' elements must be <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a>.  To help\n"
		"verify the formatting of 'notes' content, libSBML provides the static\n"
		"utility method SyntaxChecker.hasExpectedXHTMLSyntax(); however,\n"
		"readers are urged to consult the appropriate <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML specification\n"
		"document</a> for the Level and Version of their model for more\n"
		"in-depth explanations.  The SBML Level&nbsp;2 and &nbsp;3\n"
		"specifications have considerable detail about how 'notes' element\n"
		"content must be structured.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see getNotesString()\n"
		"@see isSetNotes()\n"
		"@see setNotes()\n"
		"@see setNotes()\n"
		"@see appendNotes()\n"
		"@see appendNotes()\n"
		"@see SyntaxChecker.hasExpectedXHTMLSyntax()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_unsetAnnotation", _wrap_SBase_unsetAnnotation, METH_VARARGS, (char *)"\n"
		"SBase_unsetAnnotation(SBase self) -> int\n"
		"\n"
		"Unsets the value of the 'annotation' subelement of this SBML object.\n"
		"\n"
		"Whereas the SBase 'notes' subelement is a container for content to be\n"
		"shown directly to humans, the 'annotation' element is a container for\n"
		"optional software-generated content @em not meant to be shown to\n"
		"humans.  Every object derived from SBase can have its own value for\n"
		"'annotation'.  The element's content type is <a target='_blank'\n"
		"href='http://www.w3.org/TR/2004/REC-xml-20040204/#elemdecls'>XML type\n"
		"'any'</a>, allowing essentially arbitrary well-formed XML data\n"
		"content.\n"
		"\n"
		"SBML places a few restrictions on the organization of the content of\n"
		"annotations; these are intended to help software tools read and write\n"
		"the data as well as help reduce conflicts between annotations added by\n"
		"different tools.  Please see the SBML specifications for more details.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see getAnnotation()\n"
		"@see getAnnotationString()\n"
		"@see isSetAnnotation()\n"
		"@see setAnnotation()\n"
		"@see setAnnotation()\n"
		"@see appendAnnotation()\n"
		"@see appendAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_unsetSBOTerm", _wrap_SBase_unsetSBOTerm, METH_VARARGS, (char *)"\n"
		"SBase_unsetSBOTerm(SBase self) -> int\n"
		"\n"
		"Unsets the value of the 'sboTerm' attribute of this SBML object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_addCVTerm", _wrap_SBase_addCVTerm, METH_VARARGS, (char *)"\n"
		"addCVTerm(CVTerm term, bool newBag = False) -> int\n"
		"SBase_addCVTerm(SBase self, CVTerm term) -> int\n"
		"\n"
		"Adds a copy of the given CVTerm object to this SBML object.\n"
		"\n"
		"@param term the CVTerm to assign\n"
		"\n"
		"@param newBag if @c true, creates a new RDF bag with the same identifier\n"
		"as a previous bag, and if @c false, adds the term to an existing\n"
		"RDF bag with the same type of qualifier as the term being added.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink, if\n"
		"this object lacks a 'metaid' attribute\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note Since the CV Term uses the 'metaid' attribute of the object as a\n"
		"reference, if the object has no 'metaid' attribute value set, then the\n"
		"CVTerm will not be added.\n"
		"\n"
		"@warning The fact that this method @em copies the object passed to it\n"
		"means that the caller will be left holding a physically different\n"
		"object instance than the one contained in @em this object.  Changes\n"
		"made to the original object instance (such as resetting attribute\n"
		"values) will <em>not affect the instance added here</em>.  In\n"
		"addition, the caller should make sure to free the original object if\n"
		"it is no longer being used, or else a memory leak will result.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getCVTerms", _wrap_SBase_getCVTerms, METH_VARARGS, (char *)"\n"
		"getCVTerms() -> List\n"
		"SBase_getCVTerms(SBase self) -> List\n"
		"\n"
		"Returns a list of CVTerm objects in the annotations of this SBML\n"
		"object.\n"
		"\n"
		"@return the list of CVTerms for this SBML object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getNumCVTerms", _wrap_SBase_getNumCVTerms, METH_VARARGS, (char *)"\n"
		"SBase_getNumCVTerms(SBase self) -> unsigned int\n"
		"\n"
		"Returns the number of CVTerm objects in the annotations of this SBML\n"
		"object.\n"
		"\n"
		"@return the number of CVTerms for this SBML object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getCVTerm", _wrap_SBase_getCVTerm, METH_VARARGS, (char *)"\n"
		"SBase_getCVTerm(SBase self, unsigned int n) -> CVTerm\n"
		"\n"
		"Returns the nth CVTerm in the list of CVTerms of this SBML\n"
		"object.\n"
		"\n"
		"@param n long the index of the CVTerm to retrieve\n"
		"\n"
		"@return the nth CVTerm in the list of CVTerms for this SBML object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_unsetCVTerms", _wrap_SBase_unsetCVTerms, METH_VARARGS, (char *)"\n"
		"SBase_unsetCVTerms(SBase self) -> int\n"
		"\n"
		"Clears the list of CVTerm objects attached to this SBML object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_unsetModelHistory", _wrap_SBase_unsetModelHistory, METH_VARARGS, (char *)"\n"
		"SBase_unsetModelHistory(SBase self) -> int\n"
		"\n"
		"Unsets the ModelHistory object attached to this object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note In SBML Level&nbsp;2, model history annotations were only\n"
		"permitted on the Model element.  In SBML Level&nbsp;3, they are\n"
		"permitted on all SBML components derived from SBase.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getResourceBiologicalQualifier", _wrap_SBase_getResourceBiologicalQualifier, METH_VARARGS, (char *)"\n"
		"SBase_getResourceBiologicalQualifier(SBase self, string resource) -> BiolQualifierType_t\n"
		"\n"
		"Returns the MIRIAM <em>biological qualifier</em> associated with the\n"
		"given resource.\n"
		"\n"
		"In <a target='_blank' href='http://biomodels.net/miriam'>MIRIAM</a>,\n"
		"qualifiers are an optional means of indicating the relationship\n"
		"between a model component and its annotations.  There are two broad\n"
		"kinds of annotations: <em>model</em> and <em>biological</em>.  The\n"
		"latter kind is used to qualify the relationship between a model\n"
		"component and a biological entity which it represents.  Examples of\n"
		"relationships include 'is' and 'has part', but many others are\n"
		"possible.  MIRIAM defines <a target='_blank'\n"
		"href='http://www.ebi.ac.uk/miriam/main/qualifiers/'>numerous\n"
		"relationship qualifiers</a> to enable different software tools to\n"
		"qualify biological annotations in the same standardized way.  In\n"
		"libSBML, the MIRIAM controlled-vocabulary annotations on an SBML model\n"
		"element are represented using lists of CVTerm objects, and the\n"
		"the MIRIAM biological qualifiers are represented using\n"
		"values @if clike from the enumeration\n"
		"type #BiolQualifierType_t.@endif@if python whose\n"
		"names begin with <code>BQB_</code> in the interface class\n"
		"@link libsbml libsbml@endlink.@endif@if java whose\n"
		"names begin with <code>BQB_</code> in the interface class\n"
		"{@link libsbmlConstants}.@endif\n"
		"\n"
		"This method searches the controlled-vocabulary annotations\n"
		"(i.e., the list of CVTerm objects) on the present object, then out of\n"
		"those that have biological qualifiers, looks for an annotation to the\n"
		"given @p resource.  If such an annotation is found, it returns the\n"
		"type of biological qualifier associated with that resource as a \n"
		"value @if clike from the enumeration type\n"
		"#BiolQualifierType_t.@endif@if python whose name begins with\n"
		"<code>BQB_</code> from the interface\n"
		"class @link libsbml libsbml@endlink.@endif@if java whose name\n"
		"begins with <code>BQB_</code> from the interface\n"
		"class {@link libsbmlConstants}.@endif\n"
		"\n"
		"@param resource string representing the resource; e.g.,\n"
		"<code>'http://www.geneontology.org/#GO:0005892'</code>.\n"
		"\n"
		"@return the qualifier associated with the resource,\n"
		"or @link libsbml.BQB_UNKNOWN BQB_UNKNOWN@endlink if the\n"
		"resource does not exist.\n"
		"\n"
		"@if clike\n"
		"@note The set of MIRIAM biological qualifiers grows over\n"
		"time, although relatively slowly.  The values in the enumeration\n"
		"#BiolQualifierType_t are up to date with MIRIAM at the time of a given\n"
		"libSBML release.  The set of values may be expanded in later libSBML\n"
		"releases, to match the values defined by MIRIAM at that later time.\n"
		"@endif@if python\n"
		"@note The set of MIRIAM biological qualifiers grows over\n"
		"time, although relatively slowly.  The values are up to date with\n"
		"MIRIAM at the time of a given libSBML release.  The set of values in\n"
		"list of <code>BQB_</code> constants defined in @link libsbml\n"
		"libsbml@endlink may be expanded in later libSBML releases, to match\n"
		"the values defined by MIRIAM at that later time.\n"
		"@endif@if java\n"
		"@note The set of MIRIAM biological qualifiers grows over\n"
		"time, although relatively slowly.  The values are up to date with\n"
		"MIRIAM at the time of a given libSBML release.  The set of values in\n"
		"list of <code>BQB_</code> constants defined in {@link libsbmlConstants}\n"
		"may be expanded in later libSBML releases, to match\n"
		"the values defined by MIRIAM at that later time.\n"
		"@endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getResourceModelQualifier", _wrap_SBase_getResourceModelQualifier, METH_VARARGS, (char *)"\n"
		"SBase_getResourceModelQualifier(SBase self, string resource) -> ModelQualifierType_t\n"
		"\n"
		"Returns the MIRIAM <em>model qualifier</em> associated with the\n"
		"given resource.\n"
		"\n"
		"In <a target='_blank' href='http://biomodels.net/miriam'>MIRIAM</a>,\n"
		"qualifiers are an optional means of indicating the relationship\n"
		"between a model component and its annotations.  There are two broad\n"
		"kinds of annotations: <em>model</em> and <em>biological</em>.  The\n"
		"former kind is used to qualify the relationship between a model\n"
		"component and another modeling object.  An example qualifier is\n"
		"'isDerivedFrom', to indicate that a given component of the model is\n"
		"derived from the modeling object represented by the referenced\n"
		"resource.  MIRIAM defines <a target='_blank'\n"
		"href='http://www.ebi.ac.uk/miriam/main/qualifiers/'>numerous\n"
		"relationship qualifiers</a> to enable different software tools to\n"
		"qualify model annotations in the same standardized way.  In libSBML,\n"
		"the MIRIAM controlled-vocabulary annotations on an SBML model element\n"
		"are represented using lists of CVTerm objects, and the \n"
		"the MIRIAM model qualifiers are represented using\n"
		"values @if clike from the enumeration\n"
		"type #ModelQualifierType_t.@endif@if python whose\n"
		"names begin with <code>BQM_</code> in the interface class\n"
		"@link libsbml libsbml@endlink.@endif@if java whose\n"
		"names begin with <code>BQM_</code> in the interface class\n"
		"{@link libsbmlConstants}.@endif\n"
		"\n"
		"This method method searches the controlled-vocabulary annotations\n"
		"(i.e., the list of CVTerm objects) on the present object, then out of\n"
		"those that have model qualifiers, looks for an annotation to the given\n"
		"@p resource.  If such an annotation is found, it returns the type of\n"
		"type of model qualifier associated with that resource as a \n"
		"value @if clike from the enumeration type\n"
		"#ModelQualifierType_t.@endif@if python whose name begins with\n"
		"<code>BQM_</code> from the interface\n"
		"class @link libsbml libsbml@endlink.@endif@if java whose name\n"
		"begins with <code>BQM_</code> from the interface\n"
		"class {@link libsbmlConstants}.@endif\n"
		"\n"
		"@param resource string representing the resource; e.g.,\n"
		"<code>'http://www.geneontology.org/#GO:0005892'</code>.\n"
		"\n"
		"@return the @if clike #ModelQualifierType_t value@else model qualifier\n"
		"type@endif associated with the resource, or @link\n"
		"libsbml.BQM_UNKNOWN BQM_UNKNOWN@endlink if the resource\n"
		"does not exist.\n"
		"\n"
		"@if clike\n"
		"@note The set of MIRIAM biological qualifiers grows over\n"
		"time, although relatively slowly.  The values in the enumeration\n"
		"#ModelQualifierType_t are up to date with MIRIAM at the time of a given\n"
		"libSBML release.  The set of values may be expanded in later libSBML\n"
		"releases, to match the values defined by MIRIAM at that later time.\n"
		"@endif@if python\n"
		"@note The set of MIRIAM model qualifiers grows over\n"
		"time, although relatively slowly.  The values are up to date with\n"
		"MIRIAM at the time of a given libSBML release.  The set of values in\n"
		"list of <code>BQM_</code> constants defined in @link libsbml\n"
		"libsbml@endlink may be expanded in later libSBML releases, to match\n"
		"the values defined by MIRIAM at that later time.\n"
		"@endif@if java\n"
		"@note The set of MIRIAM model qualifiers grows over\n"
		"time, although relatively slowly.  The values are up to date with\n"
		"MIRIAM at the time of a given libSBML release.  The set of values in\n"
		"list of <code>BQM_</code> constants defined in {@link libsbmlConstants}\n"
		"may be expanded in later libSBML releases, to match\n"
		"the values defined by MIRIAM at that later time.\n"
		"@endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getModel", _wrap_SBase_getModel, METH_VARARGS, (char *)"\n"
		"SBase_getModel(SBase self) -> Model\n"
		"\n"
		"Returns the Model object in which the current object is located.\n"
		"\n"
		"@return the parent Model of this SBML object.\n"
		"\n"
		"@see getParentSBMLObject()\n"
		"@see getSBMLDocument()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getLevel", _wrap_SBase_getLevel, METH_VARARGS, (char *)"\n"
		"SBase_getLevel(SBase self) -> unsigned int\n"
		"\n"
		"Returns the SBML Level of the SBMLDocument object containing this\n"
		"object.\n"
		"\n"
		"@return the SBML level of this SBML object.\n"
		"\n"
		"@see getVersion()\n"
		"@see getNamespaces()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getVersion", _wrap_SBase_getVersion, METH_VARARGS, (char *)"\n"
		"SBase_getVersion(SBase self) -> unsigned int\n"
		"\n"
		"Returns the Version within the SBML Level of the SBMLDocument object\n"
		"containing this object.\n"
		"\n"
		"@return the SBML version of this SBML object.\n"
		"\n"
		"@see getLevel()\n"
		"@see getNamespaces()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getTypeCode", _wrap_SBase_getTypeCode, METH_VARARGS, (char *)"\n"
		"SBase_getTypeCode(SBase self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this object.\n"
		"\n"
		"This method may return the type code of this SBML object, or it may\n"
		"return @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink.  This\n"
		"is because subclasses of SBase are not required to implement this\n"
		"method to return a type code.  This method is meant primarily for the\n"
		"LibSBML C interface, in which class and subclass information is not\n"
		"readily available.\n"
		"\n"
		"@return the @if clike #SBMLTypeCode_t value@else SBML object type code@endif\n"
		"of this SBML object or\n"
		"@link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (the default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_hasValidLevelVersionNamespaceCombination", _wrap_SBase_hasValidLevelVersionNamespaceCombination, METH_VARARGS, (char *)"\n"
		"SBase_hasValidLevelVersionNamespaceCombination(SBase self) -> bool\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>hasValidLevelVersionNamespaceCombination()</pre>\n"
		"\n"
		"Predicate returning @c true if this\n"
		"object's level/version and namespace values correspond to a valid\n"
		"SBML specification.\n"
		"\n"
		"The valid combinations of SBML Level, Version and Namespace as of this\n"
		"release of libSBML are the following:\n"
		"<ul>\n"
		"<li> Level&nbsp;1 Version&nbsp;2: <code>'http://www.sbml.org/sbml/level1'</code>\n"
		"<li> Level&nbsp;2 Version&nbsp;1: <code>'http://www.sbml.org/sbml/level2'</code>\n"
		"<li> Level&nbsp;2 Version&nbsp;2: <code>'http://www.sbml.org/sbml/level2/version2'</code>\n"
		"<li> Level&nbsp;2 Version&nbsp;3: <code>'http://www.sbml.org/sbml/level2/version3'</code>\n"
		"<li> Level&nbsp;2 Version&nbsp;4: <code>'http://www.sbml.org/sbml/level2/version4'</code>\n"
		"<li> Level&nbsp;3 Version&nbsp;1 Core: <code>'http://www.sbml.org/sbml/level3/version1/core'</code>\n"
		"</ul>\n"
		"\n"
		"@return @c true if the level, version and namespace values of this \n"
		"SBML object correspond to a valid set of values, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_getElementName", _wrap_SBase_getElementName, METH_VARARGS, (char *)"\n"
		"SBase_getElementName(SBase self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"This is overridden by subclasses to return a string appropriate to the\n"
		"SBML component.  For example, Model defines it as returning @c\n"
		"'model', CompartmentType defines it as returning @c 'compartmentType',\n"
		"and so on.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_toSBML", _wrap_SBase_toSBML, METH_VARARGS, (char *)"\n"
		"SBase_toSBML(SBase self) -> char\n"
		"\n"
		"Returns a string consisting of a partial SBML corresponding to just\n"
		"this object.\n"
		"\n"
		"@return the partial SBML that describes this SBML object.\n"
		"\n"
		"@warning This is primarily provided for testing and debugging\n"
		"purposes.  It may be removed in a future version of libSBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBase_hasRequiredAttributes", _wrap_SBase_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"SBase_hasRequiredAttributes(SBase self) -> bool\n"
		"\n"
		"@internal\n"
		"ubclasses should override this method to write out their contained\n"
		"BML objects as XML elements.  Be sure to call your parents\n"
		"mplementation of this method as well.  For example:@if clike\n"
		"pre>\n"
		" SBase.writeElements();\n"
		" mReactans.write(stream);\n"
		" mProducts.write(stream);\n"
		" ...\n"
		"/pre>@endif\n"
		" \n"
		"\n"
		""},
	 { (char *)"SBase_hasRequiredElements", _wrap_SBase_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"SBase_hasRequiredElements(SBase self) -> bool\n"
		"\n"
		"@internal\n"
		"ubclasses should override this method to write out their contained\n"
		"BML objects as XML elements.  Be sure to call your parents\n"
		"mplementation of this method as well.  For example:@if clike\n"
		"pre>\n"
		" SBase.writeElements();\n"
		" mReactans.write(stream);\n"
		" mProducts.write(stream);\n"
		" ...\n"
		"/pre>@endif\n"
		" \n"
		"\n"
		""},
	 { (char *)"SBase_checkMathMLNamespace", _wrap_SBase_checkMathMLNamespace, METH_VARARGS, (char *)"\n"
		"SBase_checkMathMLNamespace(SBase self, XMLToken elem) -> string\n"
		"\n"
		"@internal\n"
		"ubclasses should override this method to write out their contained\n"
		"BML objects as XML elements.  Be sure to call your parents\n"
		"mplementation of this method as well.  For example:@if clike\n"
		"pre>\n"
		" SBase.writeElements();\n"
		" mReactans.write(stream);\n"
		" mProducts.write(stream);\n"
		" ...\n"
		"/pre>@endif\n"
		" \n"
		"\n"
		""},
	 { (char *)"SBase_swigregister", SBase_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_ListOf", _wrap_delete_ListOf, METH_VARARGS, (char *)"delete_ListOf(ListOf self)"},
	 { (char *)"new_ListOf", _wrap_new_ListOf, METH_VARARGS, (char *)"\n"
		"ListOf()\n"
		"new_ListOf(ListOf orig) -> ListOf\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>ListOf()</pre>\n"
		"\n"
		"Creates a new ListOf.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>ListOf(ListOf orig)</pre>\n"
		"\n"
		"Copy constructor.  Creates a copy of this ListOf.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_clone", _wrap_ListOf_clone, METH_VARARGS, (char *)"\n"
		"ListOf_clone(ListOf self) -> SBase\n"
		"\n"
		"Creates and returns a deep copy of this ListOf.\n"
		"\n"
		"@return a (deep) copy of this ListOf.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_append", _wrap_ListOf_append, METH_VARARGS, (char *)"\n"
		"ListOf_append(ListOf self, SBase item) -> int\n"
		"\n"
		"Adds item to the end of this ListOf.\n"
		"\n"
		"This variant of the method makes a clone of the @p item handed to it.\n"
		"This means that when the ListOf is destroyed, the original items will\n"
		"not be destroyed.\n"
		"\n"
		"@param item the item to be added to the list.\n"
		"\n"
		"@see appendAndOwn()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_appendAndOwn", _wrap_ListOf_appendAndOwn, METH_VARARGS, (char *)"\n"
		"ListOf_appendAndOwn(ListOf self, SBase item) -> int\n"
		"\n"
		"Adds item to the end of this ListOf.\n"
		"\n"
		"This variant of the method does not clone the @p item handed to it;\n"
		"instead, it assumes ownership of it.  This means that when the ListOf\n"
		"is destroyed, the item will be destroyed along with it.\n"
		"\n"
		"@param item the item to be added to the list.\n"
		"\n"
		"@see append()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_get", _wrap_ListOf_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> SBase\n"
		"ListOf_get(ListOf self, unsigned int n) -> SBase\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get an item from the list.\n"
		"\n"
		"@param n the index number of the item to get.\n"
		"\n"
		"@return the nth item in this ListOf items.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get an item from the list.\n"
		"\n"
		"@param n the index number of the item to get.\n"
		"\n"
		"@return the nth item in this ListOf items.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get an item from the list based on its identifier.\n"
		"\n"
		"@param sid a string representing the the identifier of the item to get.\n"
		"\n"
		"@return item in this ListOf items with the given id or None if no such\n"
		"item exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get an item from the list based on its identifier.\n"
		"\n"
		"@param sid a string representing the the identifier of the item to get.\n"
		"\n"
		"@return item in this ListOf items with the given id or None if no such\n"
		"item exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_clear", _wrap_ListOf_clear, METH_VARARGS, (char *)"\n"
		"clear(bool doDelete = True)\n"
		"ListOf_clear(ListOf self)\n"
		"\n"
		"Removes all items in this ListOf object.\n"
		"\n"
		"If @p doDelete is @c true (default), all items in this ListOf object\n"
		"are deleted and cleared, and thus the caller doesn't have to delete\n"
		"those items.  Otherwise, all items are just cleared from this ListOf\n"
		"object and the caller is responsible for deleting all items.  (In that\n"
		"case, pointers to all items should be stored elsewhere before calling\n"
		"this function.)\n"
		"\n"
		"@param doDelete if @c true (default), all items are deleted and cleared.\n"
		"Otherwise, all items are just cleared and not deleted.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"   \n"
		"\n"
		""},
	 { (char *)"ListOf_remove", _wrap_ListOf_remove, METH_VARARGS, (char *)"\n"
		"ListOf_remove(ListOf self, unsigned int n) -> SBase\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the <em>n</em>th item from this ListOf items and returns a\n"
		"pointer to it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes item in this ListOf items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"None is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_size", _wrap_ListOf_size, METH_VARARGS, (char *)"\n"
		"ListOf_size(ListOf self) -> unsigned int\n"
		"\n"
		"Get the size of this ListOf.\n"
		"\n"
		"@return the number of items in this ListOf items.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_getTypeCode", _wrap_ListOf_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOf_getTypeCode(ListOf self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this object, namely, @c\n"
		"SBML_LIST_OF.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_getItemTypeCode", _wrap_ListOf_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOf_getItemTypeCode(ListOf self) -> SBMLTypeCode_t\n"
		"\n"
		"Get the type code of the objects contained in this ListOf.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf_getElementName", _wrap_ListOf_getElementName, METH_VARARGS, (char *)"\n"
		"ListOf_getElementName(ListOf self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for ListOf, is\n"
		"always @c 'listOf'.\n"
		"\n"
		"@return the XML name of this element.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOf___len__", _wrap_ListOf___len__, METH_VARARGS, (char *)"ListOf___len__(ListOf self) -> int"},
	 { (char *)"ListOf_swigregister", ListOf_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Model", _wrap_delete_Model, METH_VARARGS, (char *)"delete_Model(Model self)"},
	 { (char *)"new_Model", _wrap_new_Model, METH_VARARGS, (char *)"\n"
		"Model(unsigned int level, unsigned int version)\n"
		"Model(SBMLNamespaces sbmlns)\n"
		"new_Model(Model orig) -> Model\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Model(long level, long version)</pre>\n"
		"\n"
		"Creates a new Model using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this Model\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"Model\n"
		"\n"
		"@note Upon the addition of a Model object to an SBMLDocument\n"
		"(e.g., using SBMLDocument.setModel()), the SBML Level, SBML Version\n"
		"and XML namespace of the document @em override the values used\n"
		"when creating the Model object via this constructor.  This is\n"
		"necessary to ensure that an SBML document is a consistent structure.\n"
		"Nevertheless, the ability to supply the values at the time of creation\n"
		"of a Model is an important aid to producing valid SBML.  Knowledge\n"
		"of the intented SBML Level and Version determine whether it is valid\n"
		"to assign a particular value to an attribute, or whether it is valid\n"
		"to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Model(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new Model using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a Model object to an SBMLDocument (e.g.,\n"
		"using SBMLDocument.setModel()), the SBML XML namespace of the document @em\n"
		"overrides the value used when creating the Model object via this\n"
		"constructor.  This is necessary to ensure that an SBML document is a\n"
		"consistent structure.  Nevertheless, the ability to supply the values\n"
		"at the time of creation of a Model is an important aid to producing\n"
		"valid SBML.  Knowledge of the intented SBML Level and Version\n"
		"determine whether it is valid to assign a particular value to an\n"
		"attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Model(Model orig)</pre>\n"
		"\n"
		"Copy constructor; creates a (deep) copy of the given Model object.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_clone", _wrap_Model_clone, METH_VARARGS, (char *)"\n"
		"Model_clone(Model self) -> Model\n"
		"\n"
		"Creates and returns a deep copy of this Model object.\n"
		"\n"
		"@return a (deep) copy of this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getId", _wrap_Model_getId, METH_VARARGS, (char *)"\n"
		"Model_getId(Model self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this Model.\n"
		"\n"
		"@return the id of this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getName", _wrap_Model_getName, METH_VARARGS, (char *)"\n"
		"Model_getName(Model self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this Model.\n"
		"\n"
		"@return the name of this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getSubstanceUnits", _wrap_Model_getSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Model_getSubstanceUnits(Model self) -> string\n"
		"\n"
		"Returns the value of the 'substanceUnits' attribute of this Model.\n"
		"\n"
		"@return the substanceUnits of this Model.\n"
		"\n"
		"@note The 'substanceUnits' attribute is available in\n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getTimeUnits", _wrap_Model_getTimeUnits, METH_VARARGS, (char *)"\n"
		"Model_getTimeUnits(Model self) -> string\n"
		"\n"
		"Returns the value of the 'timeUnits' attribute of this Model.\n"
		"\n"
		"@return the timeUnits of this Model.\n"
		"\n"
		"@note The 'timeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getVolumeUnits", _wrap_Model_getVolumeUnits, METH_VARARGS, (char *)"\n"
		"Model_getVolumeUnits(Model self) -> string\n"
		"\n"
		"Returns the value of the 'volumeUnits' attribute of this Model.\n"
		"\n"
		"@return the volumeUnits of this Model.\n"
		"\n"
		"@note The 'volumeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getAreaUnits", _wrap_Model_getAreaUnits, METH_VARARGS, (char *)"\n"
		"Model_getAreaUnits(Model self) -> string\n"
		"\n"
		"Returns the value of the 'areaUnits' attribute of this Model.\n"
		"\n"
		"@return the areaUnits of this Model.\n"
		"\n"
		"@note The 'areaUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getLengthUnits", _wrap_Model_getLengthUnits, METH_VARARGS, (char *)"\n"
		"Model_getLengthUnits(Model self) -> string\n"
		"\n"
		"Returns the value of the 'lengthUnits' attribute of this Model.\n"
		"\n"
		"@return the lengthUnits of this Model.\n"
		"\n"
		"@note The 'lengthUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getExtentUnits", _wrap_Model_getExtentUnits, METH_VARARGS, (char *)"\n"
		"Model_getExtentUnits(Model self) -> string\n"
		"\n"
		"Returns the value of the 'extentUnits' attribute of this Model.\n"
		"\n"
		"@return the extentUnits of this Model.\n"
		"\n"
		"@note The 'extentUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getConversionFactor", _wrap_Model_getConversionFactor, METH_VARARGS, (char *)"\n"
		"Model_getConversionFactor(Model self) -> string\n"
		"\n"
		"Returns the value of the 'conversionFactor' attribute of this Model.\n"
		"\n"
		"@return the conversionFactor of this Model.\n"
		"\n"
		"@note The 'conversionFactor' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetId", _wrap_Model_isSetId, METH_VARARGS, (char *)"\n"
		"Model_isSetId(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'id' attribute is set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this Model is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetName", _wrap_Model_isSetName, METH_VARARGS, (char *)"\n"
		"Model_isSetName(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'name' attribute is set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this Model is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetSubstanceUnits", _wrap_Model_isSetSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Model_isSetSubstanceUnits(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'substanceUnits' attribute is set.\n"
		"\n"
		"@return @c true if the 'substanceUnits' attribute of this Model is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'substanceUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetTimeUnits", _wrap_Model_isSetTimeUnits, METH_VARARGS, (char *)"\n"
		"Model_isSetTimeUnits(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'timeUnits' attribute is set.\n"
		"\n"
		"@return @c true if the 'timeUnits' attribute of this Model is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'substanceUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetVolumeUnits", _wrap_Model_isSetVolumeUnits, METH_VARARGS, (char *)"\n"
		"Model_isSetVolumeUnits(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'volumeUnits' attribute is set.\n"
		"\n"
		"@return @c true if the 'volumeUnits' attribute of this Model is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'volumeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetAreaUnits", _wrap_Model_isSetAreaUnits, METH_VARARGS, (char *)"\n"
		"Model_isSetAreaUnits(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'areaUnits' attribute is set.\n"
		"\n"
		"@return @c true if the 'areaUnits' attribute of this Model is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'areaUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetLengthUnits", _wrap_Model_isSetLengthUnits, METH_VARARGS, (char *)"\n"
		"Model_isSetLengthUnits(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'lengthUnits' attribute is set.\n"
		"\n"
		"@return @c true if the 'lengthUnits' attribute of this Model is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'lengthUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetExtentUnits", _wrap_Model_isSetExtentUnits, METH_VARARGS, (char *)"\n"
		"Model_isSetExtentUnits(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'extentUnits' attribute is set.\n"
		"\n"
		"@return @c true if the 'extentUnits' attribute of this Model is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'extentUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isSetConversionFactor", _wrap_Model_isSetConversionFactor, METH_VARARGS, (char *)"\n"
		"Model_isSetConversionFactor(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Model's 'conversionFactor' attribute is set.\n"
		"\n"
		"@return @c true if the 'conversionFactor' attribute of this Model is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'conversionFactor' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setId", _wrap_Model_setId, METH_VARARGS, (char *)"\n"
		"Model_setId(Model self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this Model.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setName", _wrap_Model_setName, METH_VARARGS, (char *)"\n"
		"Model_setName(Model self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this Model.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setSubstanceUnits", _wrap_Model_setSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Model_setSubstanceUnits(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'substanceUnits' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new substanceUnits for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'substanceUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setTimeUnits", _wrap_Model_setTimeUnits, METH_VARARGS, (char *)"\n"
		"Model_setTimeUnits(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'timeUnits' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new timeUnits for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'timeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setVolumeUnits", _wrap_Model_setVolumeUnits, METH_VARARGS, (char *)"\n"
		"Model_setVolumeUnits(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'volumeUnits' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new volumeUnits for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'volumeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setAreaUnits", _wrap_Model_setAreaUnits, METH_VARARGS, (char *)"\n"
		"Model_setAreaUnits(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'areaUnits' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new areaUnits for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'areaUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setLengthUnits", _wrap_Model_setLengthUnits, METH_VARARGS, (char *)"\n"
		"Model_setLengthUnits(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'lengthUnits' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new lengthUnits for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'lengthUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setExtentUnits", _wrap_Model_setExtentUnits, METH_VARARGS, (char *)"\n"
		"Model_setExtentUnits(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'extentUnits' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new extentUnits for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'extentUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setConversionFactor", _wrap_Model_setConversionFactor, METH_VARARGS, (char *)"\n"
		"Model_setConversionFactor(Model self, string units) -> int\n"
		"\n"
		"Sets the value of the 'conversionFactor' attribute of this Model.\n"
		"\n"
		"The string in @p units is copied.\n"
		"\n"
		"@param units the new conversionFactor for the Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'conversionFactor' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetId", _wrap_Model_unsetId, METH_VARARGS, (char *)"\n"
		"Model_unsetId(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'id' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetName", _wrap_Model_unsetName, METH_VARARGS, (char *)"\n"
		"Model_unsetName(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetSubstanceUnits", _wrap_Model_unsetSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Model_unsetSubstanceUnits(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'substanceUnits' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'substanceUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetTimeUnits", _wrap_Model_unsetTimeUnits, METH_VARARGS, (char *)"\n"
		"Model_unsetTimeUnits(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'timeUnits' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'timeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetVolumeUnits", _wrap_Model_unsetVolumeUnits, METH_VARARGS, (char *)"\n"
		"Model_unsetVolumeUnits(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'volumeUnits' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'volumeUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetAreaUnits", _wrap_Model_unsetAreaUnits, METH_VARARGS, (char *)"\n"
		"Model_unsetAreaUnits(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'areaUnits' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'areaUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetLengthUnits", _wrap_Model_unsetLengthUnits, METH_VARARGS, (char *)"\n"
		"Model_unsetLengthUnits(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'lengthUnits' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'lengthUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetExtentUnits", _wrap_Model_unsetExtentUnits, METH_VARARGS, (char *)"\n"
		"Model_unsetExtentUnits(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'extentUnits' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'extentUnits' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_unsetConversionFactor", _wrap_Model_unsetConversionFactor, METH_VARARGS, (char *)"\n"
		"Model_unsetConversionFactor(Model self) -> int\n"
		"\n"
		"Unsets the value of the 'conversionFactor' attribute of this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'conversionFactor' attribute is available in \n"
		"SBML Level&nbsp;3 but is not present on Model in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addFunctionDefinition", _wrap_Model_addFunctionDefinition, METH_VARARGS, (char *)"\n"
		"Model_addFunctionDefinition(Model self, FunctionDefinition fd) -> int\n"
		"\n"
		"Adds a copy of the given FunctionDefinition object to this Model.\n"
		"\n"
		"@param fd the FunctionDefinition to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model.createFunctionDefinition()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createFunctionDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addUnitDefinition", _wrap_Model_addUnitDefinition, METH_VARARGS, (char *)"\n"
		"Model_addUnitDefinition(Model self, UnitDefinition ud) -> int\n"
		"\n"
		"Adds a copy of the given UnitDefinition object to this Model.\n"
		"\n"
		"@param ud the UnitDefinition object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model.createUnitDefinition() for\n"
		"a method that does not lead to these issues.\n"
		"\n"
		"@see createUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addCompartmentType", _wrap_Model_addCompartmentType, METH_VARARGS, (char *)"\n"
		"Model_addCompartmentType(Model self, CompartmentType ct) -> int\n"
		"\n"
		"Adds a copy of the given CompartmentType object to this Model.\n"
		"\n"
		"@param ct the CompartmentType object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model.createCompartmentType()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@note The CompartmentType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"\n"
		"@see createCompartmentType()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addSpeciesType", _wrap_Model_addSpeciesType, METH_VARARGS, (char *)"\n"
		"Model_addSpeciesType(Model self, SpeciesType st) -> int\n"
		"\n"
		"Adds a copy of the given SpeciesType object to this Model.\n"
		"\n"
		"@param st the SpeciesType object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model.createSpeciesType() for a\n"
		"method that does not lead to these issues.\n"
		"\n"
		"@note The SpeciesType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"\n"
		"@see createSpeciesType()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addCompartment", _wrap_Model_addCompartment, METH_VARARGS, (char *)"\n"
		"Model_addCompartment(Model self, Compartment c) -> int\n"
		"\n"
		"Adds a copy of the given Compartment object to this Model.\n"
		"\n"
		"@param c the Compartment object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model.createCompartment() for a\n"
		"method that does not lead to these issues.\n"
		"\n"
		"@see createCompartment()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addSpecies", _wrap_Model_addSpecies, METH_VARARGS, (char *)"\n"
		"Model_addSpecies(Model self, Species s) -> int\n"
		"\n"
		"Adds a copy of the given Species object to this Model.\n"
		"\n"
		"@param s the Species object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model.createSpecies() for a\n"
		"method that does not lead to these issues.\n"
		"\n"
		"@see createSpecies()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addParameter", _wrap_Model_addParameter, METH_VARARGS, (char *)"\n"
		"Model_addParameter(Model self, Parameter p) -> int\n"
		"\n"
		"Adds a copy of the given Parameter object to this Model.\n"
		"\n"
		"@param p the Parameter object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model.createParameter() for a\n"
		"method that does not lead to these issues.\n"
		"\n"
		"@see createParameter()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addInitialAssignment", _wrap_Model_addInitialAssignment, METH_VARARGS, (char *)"\n"
		"Model_addInitialAssignment(Model self, InitialAssignment ia) -> int\n"
		"\n"
		"Adds a copy of the given InitialAssignment object to this Model.\n"
		"\n"
		"@param ia the InitialAssignment object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model.createInitialAssignment()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createInitialAssignment()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addRule", _wrap_Model_addRule, METH_VARARGS, (char *)"\n"
		"Model_addRule(Model self, Rule r) -> int\n"
		"\n"
		"Adds a copy of the given Rule object to this Model.\n"
		"\n"
		"@param r the Rule object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see the methods\n"
		"Model.createAlgebraicRule(), Model.createAssignmentRule() and\n"
		"Model.createRateRule() for methods that do not lead to these issues.\n"
		"\n"
		"@see createAlgebraicRule()\n"
		"@see createAssignmentRule()\n"
		"@see createRateRule()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addConstraint", _wrap_Model_addConstraint, METH_VARARGS, (char *)"\n"
		"Model_addConstraint(Model self, Constraint c) -> int\n"
		"\n"
		"Adds a copy of the given Constraint object to this Model.\n"
		"\n"
		"@param c the Constraint object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model.createConstraint() for a\n"
		"method that does not lead to these issues.\n"
		"\n"
		"@see createConstraint()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addReaction", _wrap_Model_addReaction, METH_VARARGS, (char *)"\n"
		"Model_addReaction(Model self, Reaction r) -> int\n"
		"\n"
		"Adds a copy of the given Reaction object to this Model.\n"
		"\n"
		"@param r the Reaction object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model.createReaction() for a\n"
		"method that does not lead to these issues.\n"
		"\n"
		"@see createReaction()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_addEvent", _wrap_Model_addEvent, METH_VARARGS, (char *)"\n"
		"Model_addEvent(Model self, Event e) -> int\n"
		"\n"
		"Adds a copy of the given Event object to this Model.\n"
		"\n"
		"@param e the Event object to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Model.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Model</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Model.createEvent() for a method\n"
		"that does not lead to these issues.\n"
		"\n"
		"@see createEvent()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createFunctionDefinition", _wrap_Model_createFunctionDefinition, METH_VARARGS, (char *)"\n"
		"Model_createFunctionDefinition(Model self) -> FunctionDefinition\n"
		"\n"
		"Creates a new FunctionDefinition inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the FunctionDefinition object created\n"
		"\n"
		"@see addFunctionDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createUnitDefinition", _wrap_Model_createUnitDefinition, METH_VARARGS, (char *)"\n"
		"Model_createUnitDefinition(Model self) -> UnitDefinition\n"
		"\n"
		"Creates a new UnitDefinition inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the UnitDefinition object created\n"
		"\n"
		"@see addUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createUnit", _wrap_Model_createUnit, METH_VARARGS, (char *)"\n"
		"Model_createUnit(Model self) -> Unit\n"
		"\n"
		"Creates a new Unit object within the last UnitDefinition object\n"
		"created in this model and returns a pointer to it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"The mechanism by which the UnitDefinition was created is not\n"
		"significant.  If a UnitDefinition object does not exist in this model,\n"
		"a new Unit is @em not created and @c None is returned instead.\n"
		"\n"
		"@return the Unit object created\n"
		"\n"
		"@see addUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createCompartmentType", _wrap_Model_createCompartmentType, METH_VARARGS, (char *)"\n"
		"Model_createCompartmentType(Model self) -> CompartmentType\n"
		"\n"
		"Creates a new CompartmentType inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the CompartmentType object created\n"
		"\n"
		"@note The CompartmentType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"\n"
		"@see addCompartmentType()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createSpeciesType", _wrap_Model_createSpeciesType, METH_VARARGS, (char *)"\n"
		"Model_createSpeciesType(Model self) -> SpeciesType\n"
		"\n"
		"Creates a new SpeciesType inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the SpeciesType object created\n"
		"\n"
		"@note The SpeciesType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"\n"
		"@see addSpeciesType()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createCompartment", _wrap_Model_createCompartment, METH_VARARGS, (char *)"\n"
		"Model_createCompartment(Model self) -> Compartment\n"
		"\n"
		"Creates a new Compartment inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the Compartment object created\n"
		"\n"
		"@see addCompartment()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createSpecies", _wrap_Model_createSpecies, METH_VARARGS, (char *)"\n"
		"Model_createSpecies(Model self) -> Species\n"
		"\n"
		"Creates a new Species inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the Species object created\n"
		"\n"
		"@see addSpecies()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createParameter", _wrap_Model_createParameter, METH_VARARGS, (char *)"\n"
		"Model_createParameter(Model self) -> Parameter\n"
		"\n"
		"Creates a new Parameter inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the Parameter object created\n"
		"\n"
		"@see addParameter()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createInitialAssignment", _wrap_Model_createInitialAssignment, METH_VARARGS, (char *)"\n"
		"Model_createInitialAssignment(Model self) -> InitialAssignment\n"
		"\n"
		"Creates a new InitialAssignment inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the InitialAssignment object created\n"
		"\n"
		"@see addInitialAssignment()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createAlgebraicRule", _wrap_Model_createAlgebraicRule, METH_VARARGS, (char *)"\n"
		"Model_createAlgebraicRule(Model self) -> AlgebraicRule\n"
		"\n"
		"Creates a new AlgebraicRule inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the AlgebraicRule object created\n"
		"\n"
		"@see addRule()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createAssignmentRule", _wrap_Model_createAssignmentRule, METH_VARARGS, (char *)"\n"
		"Model_createAssignmentRule(Model self) -> AssignmentRule\n"
		"\n"
		"Creates a new AssignmentRule inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the AssignmentRule object created\n"
		"\n"
		"@see addRule()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createRateRule", _wrap_Model_createRateRule, METH_VARARGS, (char *)"\n"
		"Model_createRateRule(Model self) -> RateRule\n"
		"\n"
		"Creates a new RateRule inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the RateRule object created\n"
		"\n"
		"@see addRule()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createConstraint", _wrap_Model_createConstraint, METH_VARARGS, (char *)"\n"
		"Model_createConstraint(Model self) -> Constraint\n"
		"\n"
		"Creates a new Constraint inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the Constraint object created\n"
		"\n"
		"@see addConstraint()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createReaction", _wrap_Model_createReaction, METH_VARARGS, (char *)"\n"
		"Model_createReaction(Model self) -> Reaction\n"
		"\n"
		"Creates a new Reaction inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the Reaction object created\n"
		"\n"
		"@see addReaction()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createReactant", _wrap_Model_createReactant, METH_VARARGS, (char *)"\n"
		"Model_createReactant(Model self) -> SpeciesReference\n"
		"\n"
		"Creates a new SpeciesReference object for a reactant inside the last\n"
		"Reaction object in this Model, and returns a pointer to it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"The mechanism by which the last Reaction object was created and added\n"
		"to this Model is not significant.  It could have been created in a\n"
		"variety of ways, for example using createReaction().  If a Reaction\n"
		"does not exist for this model, a new SpeciesReference is @em not\n"
		"created and @c None is returned instead.\n"
		"\n"
		"@return the SpeciesReference object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createProduct", _wrap_Model_createProduct, METH_VARARGS, (char *)"\n"
		"Model_createProduct(Model self) -> SpeciesReference\n"
		"\n"
		"Creates a new SpeciesReference object for a product inside the last\n"
		"Reaction object in this Model, and returns a pointer to it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"The mechanism by which the last Reaction object was created and added\n"
		"to this Model is not significant.  It could have been created in a\n"
		"variety of ways, for example using createReaction().  If a Reaction\n"
		"does not exist for this model, a new SpeciesReference is @em not\n"
		"created and @c None is returned instead.\n"
		"\n"
		"@return the SpeciesReference object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createModifier", _wrap_Model_createModifier, METH_VARARGS, (char *)"\n"
		"Model_createModifier(Model self) -> ModifierSpeciesReference\n"
		"\n"
		"Creates a new ModifierSpeciesReference object for a modifier species\n"
		"inside the last Reaction object in this Model, and returns a pointer\n"
		"to it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"The mechanism by which the last Reaction object was created and added\n"
		"to this Model is not significant.  It could have been created in a\n"
		"variety of ways, for example using createReaction().  If a Reaction\n"
		"does not exist for this model, a new ModifierSpeciesReference is @em\n"
		"not created and @c None is returned instead.\n"
		"\n"
		"@return the SpeciesReference object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createKineticLaw", _wrap_Model_createKineticLaw, METH_VARARGS, (char *)"\n"
		"Model_createKineticLaw(Model self) -> KineticLaw\n"
		"\n"
		"Creates a new KineticLaw inside the last Reaction object created in\n"
		"this Model, and returns a pointer to it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"The mechanism by which the last Reaction object was created and added\n"
		"to this Model is not significant.  It could have been created in a\n"
		"variety of ways, for example using createReaction().  If a Reaction\n"
		"does not exist for this model, or a Reaction exists but already has a\n"
		"KineticLaw, a new KineticLaw is @em not created and @c None is returned\n"
		"instead.\n"
		"\n"
		"@return the KineticLaw object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createKineticLawParameter", _wrap_Model_createKineticLawParameter, METH_VARARGS, (char *)"\n"
		"Model_createKineticLawParameter(Model self) -> Parameter\n"
		"\n"
		"Creates a new local Parameter inside the KineticLaw object of the last\n"
		"Reaction created inside this Model, and returns a pointer to it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"The last KineticLaw object in this Model could have been created in a\n"
		"variety of ways.  For example, it could have been added using\n"
		"createKineticLaw(), or it could be the result of using\n"
		"Reaction.createKineticLaw() on the Reaction object created by a\n"
		"createReaction().  If a Reaction does not exist for this model, or the\n"
		"last Reaction does not contain a KineticLaw object, a new Parameter is\n"
		"@em not created and @c None is returned instead.\n"
		"\n"
		"@return the Parameter object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createKineticLawLocalParameter", _wrap_Model_createKineticLawLocalParameter, METH_VARARGS, (char *)"\n"
		"Model_createKineticLawLocalParameter(Model self) -> LocalParameter\n"
		"\n"
		"Creates a new LocalParameter inside the KineticLaw object of the last\n"
		"Reaction created inside this Model, and returns a pointer to it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"The last KineticLaw object in this Model could have been created in a\n"
		"variety of ways.  For example, it could have been added using\n"
		"createKineticLaw(), or it could be the result of using\n"
		"Reaction.createKineticLaw() on the Reaction object created by a\n"
		"createReaction().  If a Reaction does not exist for this model, or the\n"
		"last Reaction does not contain a KineticLaw object, a new Parameter is\n"
		"@em not created and @c None is returned instead.\n"
		"\n"
		"@return the Parameter object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createEvent", _wrap_Model_createEvent, METH_VARARGS, (char *)"\n"
		"Model_createEvent(Model self) -> Event\n"
		"\n"
		"Creates a new Event inside this Model and returns it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"@return the Event object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createEventAssignment", _wrap_Model_createEventAssignment, METH_VARARGS, (char *)"\n"
		"Model_createEventAssignment(Model self) -> EventAssignment\n"
		"\n"
		"Creates a new EventAssignment inside the last Event object created in\n"
		"this Model, and returns a pointer to it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"The mechanism by which the last Event object in this model was created\n"
		"is not significant.  It could have been created in a variety of ways,\n"
		"for example by using createEvent().  If no Event object exists in this\n"
		"Model object, a new EventAssignment is @em not created and @c None is\n"
		"returned instead.\n"
		"\n"
		"@return the EventAssignment object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createTrigger", _wrap_Model_createTrigger, METH_VARARGS, (char *)"\n"
		"Model_createTrigger(Model self) -> Trigger\n"
		"\n"
		"Creates a new Trigger inside the last Event object created in\n"
		"this Model, and returns a pointer to it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"The mechanism by which the last Event object in this model was created\n"
		"is not significant.  It could have been created in a variety of ways,\n"
		"for example by using createEvent().  If no Event object exists in this\n"
		"Model object, a new Trigger is @em not created and @c None is\n"
		"returned instead.\n"
		"\n"
		"@return the Trigger object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_createDelay", _wrap_Model_createDelay, METH_VARARGS, (char *)"\n"
		"Model_createDelay(Model self) -> Delay\n"
		"\n"
		"Creates a new Delay inside the last Event object created in\n"
		"this Model, and returns a pointer to it.\n"
		"\n"
		"The SBML Level and Version of the enclosing Model object, as well as\n"
		"any SBML package namespaces, are used to initialize this\n"
		"object's corresponding attributes.\n"
		"\n"
		"The mechanism by which the last Event object in this model was created\n"
		"is not significant.  It could have been created in a variety of ways,\n"
		"for example by using createEvent().  If no Event object exists in this\n"
		"Model object, a new Delay is @em not created and @c None is\n"
		"returned instead.\n"
		"\n"
		"@return the Delay object created\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_setAnnotation", _wrap_Model_setAnnotation, METH_VARARGS, (char *)"\n"
		"setAnnotation(XMLNode annotation) -> int\n"
		"Model_setAnnotation(Model self, string annotation) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setAnnotation(XMLNode annotation)</pre>\n"
		"\n"
		"Sets the value of the 'annotation' subelement of this SBML object to a\n"
		"copy of @p annotation.\n"
		"\n"
		"Any existing content of the 'annotation' subelement is discarded.\n"
		"Unless you have taken steps to first copy and reconstitute any\n"
		"existing annotations into the @p annotation that is about to be\n"
		"assigned, it is likely that performing such wholesale replacement is\n"
		"unfriendly towards other software applications whose annotations are\n"
		"discarded.  An alternative may be to use appendAnnotation().\n"
		"\n"
		"@param annotation an XML structure that is to be used as the content\n"
		"of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see appendAnnotation()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setAnnotation(string annotation)</pre>\n"
		"\n"
		"Sets the value of the 'annotation' subelement of this SBML object to a\n"
		"copy of @p annotation.\n"
		"\n"
		"Any existing content of the 'annotation' subelement is discarded.\n"
		"Unless you have taken steps to first copy and reconstitute any\n"
		"existing annotations into the @p annotation that is about to be\n"
		"assigned, it is likely that performing such wholesale replacement is\n"
		"unfriendly towards other software applications whose annotations are\n"
		"discarded.  An alternative may be to use appendAnnotation().\n"
		"\n"
		"@param annotation an XML string that is to be used as the content\n"
		"of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see appendAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_appendAnnotation", _wrap_Model_appendAnnotation, METH_VARARGS, (char *)"\n"
		"appendAnnotation(XMLNode annotation) -> int\n"
		"Model_appendAnnotation(Model self, string annotation) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>appendAnnotation(XMLNode annotation)</pre>\n"
		"\n"
		"Appends annotation content to any existing content in the 'annotation'\n"
		"subelement of this object.\n"
		"\n"
		"The content in @p annotation is copied.  Unlike setAnnotation(), this\n"
		"method allows other annotations to be preserved when an application\n"
		"adds its own data.\n"
		"\n"
		"@param annotation an XML structure that is to be copied and appended\n"
		"to the content of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see setAnnotation()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>appendAnnotation(string annotation)</pre>\n"
		"\n"
		"Appends annotation content to any existing content in the 'annotation'\n"
		"subelement of this object.\n"
		"\n"
		"The content in @p annotation is copied.  Unlike setAnnotation(), this \n"
		"method allows other annotations to be preserved when an application\n"
		"adds its own data.\n"
		"\n"
		"@param annotation an XML string that is to be copied and appended\n"
		"to the content of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see setAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfFunctionDefinitions", _wrap_Model_getListOfFunctionDefinitions, METH_VARARGS, (char *)"\n"
		"getListOfFunctionDefinitions() -> ListOfFunctionDefinitions\n"
		"Model_getListOfFunctionDefinitions(Model self) -> ListOfFunctionDefinitions\n"
		"\n"
		"Get the ListOfFunctionDefinitions object in this Model.\n"
		"\n"
		"@return the list of FunctionDefinitions for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfUnitDefinitions", _wrap_Model_getListOfUnitDefinitions, METH_VARARGS, (char *)"\n"
		"getListOfUnitDefinitions() -> ListOfUnitDefinitions\n"
		"Model_getListOfUnitDefinitions(Model self) -> ListOfUnitDefinitions\n"
		"\n"
		"Get the ListOfUnitDefinitions object in this Model.\n"
		"\n"
		"@return the list of UnitDefinitions for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfCompartmentTypes", _wrap_Model_getListOfCompartmentTypes, METH_VARARGS, (char *)"\n"
		"getListOfCompartmentTypes() -> ListOfCompartmentTypes\n"
		"Model_getListOfCompartmentTypes(Model self) -> ListOfCompartmentTypes\n"
		"\n"
		"Get the ListOfCompartmentTypes object in this Model.\n"
		"\n"
		"@return the list of CompartmentTypes for this Model.\n"
		"\n"
		"@note The CompartmentType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfSpeciesTypes", _wrap_Model_getListOfSpeciesTypes, METH_VARARGS, (char *)"\n"
		"getListOfSpeciesTypes() -> ListOfSpeciesTypes\n"
		"Model_getListOfSpeciesTypes(Model self) -> ListOfSpeciesTypes\n"
		"\n"
		"Get the ListOfSpeciesTypes object in this Model.\n"
		"\n"
		"@return the list of SpeciesTypes for this Model.\n"
		"\n"
		"@note The SpeciesType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfCompartments", _wrap_Model_getListOfCompartments, METH_VARARGS, (char *)"\n"
		"getListOfCompartments() -> ListOfCompartments\n"
		"Model_getListOfCompartments(Model self) -> ListOfCompartments\n"
		"\n"
		"Get the ListOfCompartments object in this Model.\n"
		"\n"
		"@return the list of Compartments for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfSpecies", _wrap_Model_getListOfSpecies, METH_VARARGS, (char *)"\n"
		"getListOfSpecies() -> ListOfSpecies\n"
		"Model_getListOfSpecies(Model self) -> ListOfSpecies\n"
		"\n"
		"Get the ListOfSpecies object in this Model.\n"
		"\n"
		"@return the list of Species for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfParameters", _wrap_Model_getListOfParameters, METH_VARARGS, (char *)"\n"
		"getListOfParameters() -> ListOfParameters\n"
		"Model_getListOfParameters(Model self) -> ListOfParameters\n"
		"\n"
		"Get the ListOfParameters object in this Model.\n"
		"\n"
		"@return the list of Parameters for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfInitialAssignments", _wrap_Model_getListOfInitialAssignments, METH_VARARGS, (char *)"\n"
		"getListOfInitialAssignments() -> ListOfInitialAssignments\n"
		"Model_getListOfInitialAssignments(Model self) -> ListOfInitialAssignments\n"
		"\n"
		"Get the ListOfInitialAssignments object in this Model.\n"
		"\n"
		"@return the list of InitialAssignments for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfRules", _wrap_Model_getListOfRules, METH_VARARGS, (char *)"\n"
		"getListOfRules() -> ListOfRules\n"
		"Model_getListOfRules(Model self) -> ListOfRules\n"
		"\n"
		"Get the ListOfRules object in this Model.\n"
		"\n"
		"@return the list of Rules for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfConstraints", _wrap_Model_getListOfConstraints, METH_VARARGS, (char *)"\n"
		"getListOfConstraints() -> ListOfConstraints\n"
		"Model_getListOfConstraints(Model self) -> ListOfConstraints\n"
		"\n"
		"Get the ListOfConstraints object in this Model.\n"
		"\n"
		"@return the list of Constraints for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfReactions", _wrap_Model_getListOfReactions, METH_VARARGS, (char *)"\n"
		"getListOfReactions() -> ListOfReactions\n"
		"Model_getListOfReactions(Model self) -> ListOfReactions\n"
		"\n"
		"Get the ListOfReactions object in this Model.\n"
		"\n"
		"@return the list of Reactions for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getListOfEvents", _wrap_Model_getListOfEvents, METH_VARARGS, (char *)"\n"
		"getListOfEvents() -> ListOfEvents\n"
		"Model_getListOfEvents(Model self) -> ListOfEvents\n"
		"\n"
		"Get the ListOfEvents object in this Model.\n"
		"\n"
		"@return the list of Events for this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getFunctionDefinition", _wrap_Model_getFunctionDefinition, METH_VARARGS, (char *)"\n"
		"getFunctionDefinition(unsigned int n) -> FunctionDefinition\n"
		"getFunctionDefinition(unsigned int n) -> FunctionDefinition\n"
		"getFunctionDefinition(string sid) -> FunctionDefinition\n"
		"Model_getFunctionDefinition(Model self, string sid) -> FunctionDefinition\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getFunctionDefinition(long n)</pre>\n"
		"\n"
		"Get the nth FunctionDefinitions object in this Model.\n"
		"\n"
		"@return the nth FunctionDefinition of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getFunctionDefinition(long n)</pre>\n"
		"\n"
		"Get the nth FunctionDefinitions object in this Model.\n"
		"\n"
		"@return the nth FunctionDefinition of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getFunctionDefinition(string sid)</pre>\n"
		"\n"
		"Get a FunctionDefinition object based on its identifier.\n"
		"\n"
		"@return the FunctionDefinition in this Model with the identifier\n"
		"@p sid or @c None if no such FunctionDefinition exists.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getFunctionDefinition(string sid)</pre>\n"
		"\n"
		"Get a FunctionDefinition object based on its identifier.\n"
		"\n"
		"@return the FunctionDefinition in this Model with the identifier\n"
		"@p sid or @c None if no such FunctionDefinition exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getUnitDefinition", _wrap_Model_getUnitDefinition, METH_VARARGS, (char *)"\n"
		"getUnitDefinition(unsigned int n) -> UnitDefinition\n"
		"getUnitDefinition(unsigned int n) -> UnitDefinition\n"
		"getUnitDefinition(string sid) -> UnitDefinition\n"
		"Model_getUnitDefinition(Model self, string sid) -> UnitDefinition\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getUnitDefinition(long n)</pre>\n"
		"\n"
		"Get the nth UnitDefinition object in this Model.\n"
		"\n"
		"@return the nth UnitDefinition of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getUnitDefinition(long n)</pre>\n"
		"\n"
		"Get the nth UnitDefinition object in this Model.\n"
		"\n"
		"@return the nth UnitDefinition of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getUnitDefinition(string sid)</pre>\n"
		"\n"
		"Get a UnitDefinition based on its identifier.\n"
		"\n"
		"@return the UnitDefinition in this Model with the identifier @p sid or\n"
		"@c None if no such UnitDefinition exists.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getUnitDefinition(string sid)</pre>\n"
		"\n"
		"Get a UnitDefinition based on its identifier.\n"
		"\n"
		"@return the UnitDefinition in this Model with the identifier @p sid or\n"
		"@c None if no such UnitDefinition exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getCompartmentType", _wrap_Model_getCompartmentType, METH_VARARGS, (char *)"\n"
		"getCompartmentType(unsigned int n) -> CompartmentType\n"
		"getCompartmentType(unsigned int n) -> CompartmentType\n"
		"getCompartmentType(string sid) -> CompartmentType\n"
		"Model_getCompartmentType(Model self, string sid) -> CompartmentType\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getCompartmentType(long n)</pre>\n"
		"\n"
		"Get the nth CompartmentType object in this Model.\n"
		"\n"
		"@return the nth CompartmentType of this Model.\n"
		"\n"
		"@note The CompartmentType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getCompartmentType(long n)</pre>\n"
		"\n"
		"Get the nth CompartmentType object in this Model.\n"
		"\n"
		"@return the nth CompartmentType of this Model.\n"
		"\n"
		"@note The CompartmentType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getCompartmentType(string sid)</pre>\n"
		"\n"
		"Get a CompartmentType object based on its identifier.\n"
		"\n"
		"@return the CompartmentType in this Model with the identifier @p sid\n"
		"or @c None if no such CompartmentType exists.\n"
		"\n"
		"@note The CompartmentType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getCompartmentType(string sid)</pre>\n"
		"\n"
		"Get a CompartmentType object based on its identifier.\n"
		"\n"
		"@return the CompartmentType in this Model with the identifier @p sid\n"
		"or @c None if no such CompartmentType exists.\n"
		"\n"
		"@note The CompartmentType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getSpeciesType", _wrap_Model_getSpeciesType, METH_VARARGS, (char *)"\n"
		"getSpeciesType(unsigned int n) -> SpeciesType\n"
		"getSpeciesType(unsigned int n) -> SpeciesType\n"
		"getSpeciesType(string sid) -> SpeciesType\n"
		"Model_getSpeciesType(Model self, string sid) -> SpeciesType\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getSpeciesType(long n)</pre>\n"
		"\n"
		"Get the nth SpeciesType object in this Model.\n"
		"\n"
		"@return the nth SpeciesType of this Model.\n"
		"\n"
		"@note The SpeciesType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getSpeciesType(long n)</pre>\n"
		"\n"
		"Get the nth SpeciesType object in this Model.\n"
		"\n"
		"@return the nth SpeciesType of this Model.\n"
		"\n"
		"@note The SpeciesType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getSpeciesType(string sid)</pre>\n"
		"\n"
		"Get a SpeciesType object based on its identifier.\n"
		"\n"
		"@return the SpeciesType in this Model with the identifier @p sid or\n"
		"@c None if no such SpeciesType exists.\n"
		"\n"
		"@note The SpeciesType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getSpeciesType(string sid)</pre>\n"
		"\n"
		"Get a SpeciesType object based on its identifier.\n"
		"\n"
		"@return the SpeciesType in this Model with the identifier @p sid or\n"
		"@c None if no such SpeciesType exists.\n"
		"\n"
		"@note The SpeciesType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getCompartment", _wrap_Model_getCompartment, METH_VARARGS, (char *)"\n"
		"getCompartment(unsigned int n) -> Compartment\n"
		"getCompartment(unsigned int n) -> Compartment\n"
		"getCompartment(string sid) -> Compartment\n"
		"Model_getCompartment(Model self, string sid) -> Compartment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getCompartment(long n)</pre>\n"
		"\n"
		"Get the nth Compartment object in this Model.\n"
		"\n"
		"@return the nth Compartment of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getCompartment(long n)</pre>\n"
		"\n"
		"Get the nth Compartment object in this Model.\n"
		"\n"
		"@return the nth Compartment of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getCompartment(string sid)</pre>\n"
		"\n"
		"Get a Compartment object based on its identifier.\n"
		"\n"
		"@return the Compartment in this Model with the identifier @p sid or\n"
		"@c None if no such Compartment exists.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getCompartment(string sid)</pre>\n"
		"\n"
		"Get a Compartment object based on its identifier.\n"
		"\n"
		"@return the Compartment in this Model with the identifier @p sid or\n"
		"@c None if no such Compartment exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getSpecies", _wrap_Model_getSpecies, METH_VARARGS, (char *)"\n"
		"getSpecies(unsigned int n) -> Species\n"
		"getSpecies(unsigned int n) -> Species\n"
		"getSpecies(string sid) -> Species\n"
		"Model_getSpecies(Model self, string sid) -> Species\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getSpecies(long n)</pre>\n"
		"\n"
		"Get the nth Species object in this Model.\n"
		"\n"
		"@return the nth Species of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getSpecies(long n)</pre>\n"
		"\n"
		"Get the nth Species object in this Model.\n"
		"\n"
		"@return the nth Species of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getSpecies(string sid)</pre>\n"
		"\n"
		"Get a Species object based on its identifier.\n"
		"\n"
		"@return the Species in this Model with the identifier @p sid or @c None\n"
		"if no such Species exists.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getSpecies(string sid)</pre>\n"
		"\n"
		"Get a Species object based on its identifier.\n"
		"\n"
		"@return the Species in this Model with the identifier @p sid or @c None\n"
		"if no such Species exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getParameter", _wrap_Model_getParameter, METH_VARARGS, (char *)"\n"
		"getParameter(unsigned int n) -> Parameter\n"
		"getParameter(unsigned int n) -> Parameter\n"
		"getParameter(string sid) -> Parameter\n"
		"Model_getParameter(Model self, string sid) -> Parameter\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getParameter(long n)</pre>\n"
		"\n"
		"Get the nth Parameter object in this Model.\n"
		"\n"
		"@return the nth Parameter of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getParameter(long n)</pre>\n"
		"\n"
		"Get the nth Parameter object in this Model.\n"
		"\n"
		"@return the nth Parameter of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getParameter(string sid)</pre>\n"
		"\n"
		"Get a Parameter object based on its identifier.\n"
		"\n"
		"@return the Parameter in this Model with the identifier @p sid or @c None\n"
		"if no such Parameter exists.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getParameter(string sid)</pre>\n"
		"\n"
		"Get a Parameter object based on its identifier.\n"
		"\n"
		"@return the Parameter in this Model with the identifier @p sid or @c None\n"
		"if no such Parameter exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getInitialAssignment", _wrap_Model_getInitialAssignment, METH_VARARGS, (char *)"\n"
		"getInitialAssignment(unsigned int n) -> InitialAssignment\n"
		"getInitialAssignment(unsigned int n) -> InitialAssignment\n"
		"getInitialAssignment(string symbol) -> InitialAssignment\n"
		"Model_getInitialAssignment(Model self, string symbol) -> InitialAssignment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getInitialAssignment(long n)</pre>\n"
		"\n"
		"Get the nth InitialAssignment object in this Model.\n"
		"\n"
		"@return the nth InitialAssignment of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getInitialAssignment(long n)</pre>\n"
		"\n"
		"Get the nth InitialAssignment object in this Model.\n"
		"\n"
		"@return the nth InitialAssignment of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getInitialAssignment(string symbol)</pre>\n"
		"\n"
		"Get an InitialAssignment object based on the symbol to which it\n"
		"assigns a value.\n"
		"\n"
		"@return the InitialAssignment in this Model with the given 'symbol'\n"
		"attribute value or @c None if no such InitialAssignment exists.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getInitialAssignment(string symbol)</pre>\n"
		"\n"
		"Get an InitialAssignment object based on the symbol to which it\n"
		"assigns a value.\n"
		"\n"
		"@return the InitialAssignment in this Model with the given 'symbol'\n"
		"attribute value or @c None if no such InitialAssignment exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getRule", _wrap_Model_getRule, METH_VARARGS, (char *)"\n"
		"getRule(unsigned int n) -> Rule\n"
		"getRule(unsigned int n) -> Rule\n"
		"getRule(string variable) -> Rule\n"
		"Model_getRule(Model self, string variable) -> Rule\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getRule(long n)</pre>\n"
		"\n"
		"Get the nth Rule object in this Model.\n"
		"\n"
		"@return the nth Rule of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getRule(long n)</pre>\n"
		"\n"
		"Get the nth Rule object in this Model.\n"
		"\n"
		"@return the nth Rule of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getRule(string variable)</pre>\n"
		"\n"
		"Get a Rule object based on the variable to which it assigns a value.\n"
		"\n"
		"@return the Rule in this Model with the given 'variable' attribute\n"
		"value or @c None if no such Rule exists.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getRule(string variable)</pre>\n"
		"\n"
		"Get a Rule object based on the variable to which it assigns a value.\n"
		"\n"
		"@return the Rule in this Model with the given 'variable' attribute\n"
		"value or @c None if no such Rule exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getConstraint", _wrap_Model_getConstraint, METH_VARARGS, (char *)"\n"
		"getConstraint(unsigned int n) -> Constraint\n"
		"Model_getConstraint(Model self, unsigned int n) -> Constraint\n"
		"\n"
		"Get the nth Constraint object in this Model.\n"
		"\n"
		"@return the nth Constraint of this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getReaction", _wrap_Model_getReaction, METH_VARARGS, (char *)"\n"
		"getReaction(unsigned int n) -> Reaction\n"
		"getReaction(unsigned int n) -> Reaction\n"
		"getReaction(string sid) -> Reaction\n"
		"Model_getReaction(Model self, string sid) -> Reaction\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getReaction(long n)</pre>\n"
		"\n"
		"Get the nth Reaction object in this Model.\n"
		"\n"
		"@return the nth Reaction of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getReaction(long n)</pre>\n"
		"\n"
		"Get the nth Reaction object in this Model.\n"
		"\n"
		"@return the nth Reaction of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getReaction(string sid)</pre>\n"
		"\n"
		"Get a Reaction object based on its identifier.\n"
		"\n"
		"@return the Reaction in this Model with the identifier @p sid or @c None\n"
		"if no such Reaction exists.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getReaction(string sid)</pre>\n"
		"\n"
		"Get a Reaction object based on its identifier.\n"
		"\n"
		"@return the Reaction in this Model with the identifier @p sid or @c None\n"
		"if no such Reaction exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getSpeciesReference", _wrap_Model_getSpeciesReference, METH_VARARGS, (char *)"\n"
		"getSpeciesReference(string sid) -> SpeciesReference\n"
		"Model_getSpeciesReference(Model self, string sid) -> SpeciesReference\n"
		"\n"
		"Get a SpeciesReference object based on its identifier.\n"
		"\n"
		"@return the SpeciesReference in this Model with the identifier @p sid or @c None\n"
		"if no such SpeciesReference exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getEvent", _wrap_Model_getEvent, METH_VARARGS, (char *)"\n"
		"getEvent(unsigned int n) -> Event\n"
		"getEvent(unsigned int n) -> Event\n"
		"getEvent(string sid) -> Event\n"
		"Model_getEvent(Model self, string sid) -> Event\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getEvent(long n)</pre>\n"
		"\n"
		"Get the nth Event object in this Model.\n"
		"\n"
		"@return the nth Event of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getEvent(long n)</pre>\n"
		"\n"
		"Get the nth Event object in this Model.\n"
		"\n"
		"@return the nth Event of this Model.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getEvent(string sid)</pre>\n"
		"\n"
		"Get an Event object based on its identifier.\n"
		"\n"
		"@return the Event in this Model with the identifier @p sid or @c None if\n"
		"no such Event exists.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getEvent(string sid)</pre>\n"
		"\n"
		"Get an Event object based on its identifier.\n"
		"\n"
		"@return the Event in this Model with the identifier @p sid or @c None if\n"
		"no such Event exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumFunctionDefinitions", _wrap_Model_getNumFunctionDefinitions, METH_VARARGS, (char *)"\n"
		"Model_getNumFunctionDefinitions(Model self) -> unsigned int\n"
		"\n"
		"Get the number of FunctionDefinition objects in this Model.\n"
		"\n"
		"@return the number of FunctionDefinitions in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumUnitDefinitions", _wrap_Model_getNumUnitDefinitions, METH_VARARGS, (char *)"\n"
		"Model_getNumUnitDefinitions(Model self) -> unsigned int\n"
		"\n"
		"Get the number of UnitDefinition objects in this Model.\n"
		"\n"
		"@return the number of UnitDefinitions in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumCompartmentTypes", _wrap_Model_getNumCompartmentTypes, METH_VARARGS, (char *)"\n"
		"Model_getNumCompartmentTypes(Model self) -> unsigned int\n"
		"\n"
		"Get the number of CompartmentType objects in this Model.\n"
		"\n"
		"@return the number of CompartmentTypes in this Model.\n"
		"\n"
		"@note The CompartmentType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumSpeciesTypes", _wrap_Model_getNumSpeciesTypes, METH_VARARGS, (char *)"\n"
		"Model_getNumSpeciesTypes(Model self) -> unsigned int\n"
		"\n"
		"Get the number of SpeciesType objects in this Model.\n"
		"\n"
		"@return the number of SpeciesTypes in this Model.\n"
		"\n"
		"@note The SpeciesType object class is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.  It is not available in\n"
		"Level&nbsp;1 nor Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumCompartments", _wrap_Model_getNumCompartments, METH_VARARGS, (char *)"\n"
		"Model_getNumCompartments(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Compartment objects in this Model.\n"
		"\n"
		"@return the number of Compartments in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumSpecies", _wrap_Model_getNumSpecies, METH_VARARGS, (char *)"\n"
		"Model_getNumSpecies(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Specie objects in this Model.\n"
		"\n"
		"@return the number of Species in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumSpeciesWithBoundaryCondition", _wrap_Model_getNumSpeciesWithBoundaryCondition, METH_VARARGS, (char *)"\n"
		"Model_getNumSpeciesWithBoundaryCondition(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Species in this Model having their\n"
		"'boundaryCondition' attribute value set to @c true.\n"
		"\n"
		"@return the number of Species in this Model with boundaryCondition set\n"
		"to true.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumParameters", _wrap_Model_getNumParameters, METH_VARARGS, (char *)"\n"
		"Model_getNumParameters(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Parameter objects in this Model.\n"
		"\n"
		"@return the number of Parameters in this Model.  Parameters defined in\n"
		"KineticLaws are not included.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumInitialAssignments", _wrap_Model_getNumInitialAssignments, METH_VARARGS, (char *)"\n"
		"Model_getNumInitialAssignments(Model self) -> unsigned int\n"
		"\n"
		"Get the number of InitialAssignment objects in this Model.\n"
		"\n"
		"@return the number of InitialAssignments in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumRules", _wrap_Model_getNumRules, METH_VARARGS, (char *)"\n"
		"Model_getNumRules(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Rule objects in this Model.\n"
		"\n"
		"@return the number of Rules in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumConstraints", _wrap_Model_getNumConstraints, METH_VARARGS, (char *)"\n"
		"Model_getNumConstraints(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Constraint objects in this Model.\n"
		"\n"
		"@return the number of Constraints in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumReactions", _wrap_Model_getNumReactions, METH_VARARGS, (char *)"\n"
		"Model_getNumReactions(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Reaction objects in this Model.\n"
		"\n"
		"@return the number of Reactions in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getNumEvents", _wrap_Model_getNumEvents, METH_VARARGS, (char *)"\n"
		"Model_getNumEvents(Model self) -> unsigned int\n"
		"\n"
		"Get the number of Event objects in this Model.\n"
		"\n"
		"@return the number of Events in this Model.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_convertL1ToL2", _wrap_Model_convertL1ToL2, METH_VARARGS, (char *)"\n"
		"Model_convertL1ToL2(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_convertL1ToL3", _wrap_Model_convertL1ToL3, METH_VARARGS, (char *)"\n"
		"Model_convertL1ToL3(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_convertL2ToL3", _wrap_Model_convertL2ToL3, METH_VARARGS, (char *)"\n"
		"Model_convertL2ToL3(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_convertL2ToL1", _wrap_Model_convertL2ToL1, METH_VARARGS, (char *)"\n"
		"convertL2ToL1(bool strict = False)\n"
		"Model_convertL2ToL1(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_convertL3ToL1", _wrap_Model_convertL3ToL1, METH_VARARGS, (char *)"\n"
		"Model_convertL3ToL1(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_convertL3ToL2", _wrap_Model_convertL3ToL2, METH_VARARGS, (char *)"\n"
		"Model_convertL3ToL2(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_addModifiers", _wrap_Model_addModifiers, METH_VARARGS, (char *)"\n"
		"Model_addModifiers(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_addConstantAttribute", _wrap_Model_addConstantAttribute, METH_VARARGS, (char *)"\n"
		"Model_addConstantAttribute(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_setSpatialDimensions", _wrap_Model_setSpatialDimensions, METH_VARARGS, (char *)"\n"
		"setSpatialDimensions(double dims = 3.0)\n"
		"Model_setSpatialDimensions(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_addDefinitionsForDefaultUnits", _wrap_Model_addDefinitionsForDefaultUnits, METH_VARARGS, (char *)"\n"
		"Model_addDefinitionsForDefaultUnits(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_convertParametersToLocals", _wrap_Model_convertParametersToLocals, METH_VARARGS, (char *)"\n"
		"Model_convertParametersToLocals(Model self, unsigned int level, unsigned int version)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_setSpeciesReferenceConstantValueAndStoichiometry", _wrap_Model_setSpeciesReferenceConstantValueAndStoichiometry, METH_VARARGS, (char *)"\n"
		"Model_setSpeciesReferenceConstantValueAndStoichiometry(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_removeParameterRuleUnits", _wrap_Model_removeParameterRuleUnits, METH_VARARGS, (char *)"\n"
		"Model_removeParameterRuleUnits(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_convertStoichiometryMath", _wrap_Model_convertStoichiometryMath, METH_VARARGS, (char *)"\n"
		"Model_convertStoichiometryMath(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_assignRequiredValues", _wrap_Model_assignRequiredValues, METH_VARARGS, (char *)"\n"
		"Model_assignRequiredValues(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_dealWithModelUnits", _wrap_Model_dealWithModelUnits, METH_VARARGS, (char *)"\n"
		"Model_dealWithModelUnits(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_dealWithStoichiometry", _wrap_Model_dealWithStoichiometry, METH_VARARGS, (char *)"\n"
		"Model_dealWithStoichiometry(Model self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if the\n"
		"iven ASTNode is a boolean.\n"
		"\n"
		"ften times, this question can be answered with the ASTNode's own\n"
		"sBoolean() method, but if the AST is an expression that calls a\n"
		"unction defined in the Model's ListOfFunctionDefinitions, the model\n"
		"s needed for lookup context.\n"
		"\n"
		"return true if the given ASTNode is a boolean.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Model_getTypeCode", _wrap_Model_getTypeCode, METH_VARARGS, (char *)"\n"
		"Model_getTypeCode(Model self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_getElementName", _wrap_Model_getElementName, METH_VARARGS, (char *)"\n"
		"Model_getElementName(Model self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Model, is\n"
		"always @c 'model'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'model'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_populateListFormulaUnitsData", _wrap_Model_populateListFormulaUnitsData, METH_VARARGS, (char *)"\n"
		"Model_populateListFormulaUnitsData(Model self)\n"
		"\n"
		"Populates the list of FormulaDataUnits with the units derived \n"
		"for the model. The list contains elements of class\n"
		"FormulaUnitsData. \n"
		"\n"
		"The first element of the list refers to the default units\n"
		"of 'substance per time' derived from the model and has the\n"
		"unitReferenceId 'subs_per_time'. This facilitates the comparison of units\n"
		"derived from mathematical formula with the expected units.\n"
		"\n"
		"The next elements of the list record the units of the \n"
		"compartments and species established from either explicitly\n"
		"declared or default units.\n"
		"\n"
		"The next elements record the units of any parameters.\n"
		"\n"
		"Subsequent elements of the list record the units derived for\n"
		"each mathematical expression encountered within the model.\n"
		"\n"
		"@note This function is utilised by the Unit Consistency Validator.\n"
		"The list is populated prior to running the validation and thus\n"
		"the consistency of units can be checked by accessing the members\n"
		"of the list and comparing the appropriate data.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_isPopulatedListFormulaUnitsData", _wrap_Model_isPopulatedListFormulaUnitsData, METH_VARARGS, (char *)"\n"
		"Model_isPopulatedListFormulaUnitsData(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if \n"
		"the list of FormulaUnitsData is populated.\n"
		"\n"
		"@return @c true if the list of FormulaUnitsData is populated, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_hasRequiredElements", _wrap_Model_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"Model_hasRequiredElements(Model self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Model object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Model object are:\n"
		"listOfCompartments (L1 only); listOfSpecies (L1V1 only);\n"
		"listOfReactions(L1V1 only)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeFunctionDefinition", _wrap_Model_removeFunctionDefinition, METH_VARARGS, (char *)"\n"
		"removeFunctionDefinition(unsigned int n) -> FunctionDefinition\n"
		"Model_removeFunctionDefinition(Model self, string sid) -> FunctionDefinition\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeFunctionDefinition(long n)</pre>\n"
		"\n"
		"Removes the nth FunctionDefinition object from this Model object and \n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the FunctionDefinition object to remove\n"
		"\n"
		"@return the FunctionDefinition object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeFunctionDefinition(string sid)</pre>\n"
		"\n"
		"Removes the FunctionDefinition object with the given identifier from this Model \n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the FunctionDefinition objects in this Model object have the identifier \n"
		"@p sid, then @c None is returned.\n"
		"\n"
		"@param sid the identifier of the FunctionDefinition object to remove\n"
		"\n"
		"@return the FunctionDefinition object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no FunctionDefinition\n"
		"object with the identifier exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeUnitDefinition", _wrap_Model_removeUnitDefinition, METH_VARARGS, (char *)"\n"
		"removeUnitDefinition(unsigned int n) -> UnitDefinition\n"
		"Model_removeUnitDefinition(Model self, string sid) -> UnitDefinition\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeUnitDefinition(long n)</pre>\n"
		"\n"
		"Removes the nth UnitDefinition object from this Model object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the UnitDefinition object to remove\n"
		"\n"
		"@return the UnitDefinition object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeUnitDefinition(string sid)</pre>\n"
		"\n"
		"Removes the UnitDefinition object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the UnitDefinition objects in this Model object have the identifier \n"
		"@p sid, then @c None is returned.\n"
		"\n"
		"@param sid the identifier of the UnitDefinition object to remove\n"
		"\n"
		"@return the UnitDefinition object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no UnitDefinition\n"
		"object with the identifier exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeCompartmentType", _wrap_Model_removeCompartmentType, METH_VARARGS, (char *)"\n"
		"removeCompartmentType(unsigned int n) -> CompartmentType\n"
		"Model_removeCompartmentType(Model self, string sid) -> CompartmentType\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeCompartmentType(long n)</pre>\n"
		"\n"
		"Removes the nth CompartmentType object from this Model object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the CompartmentType object to remove\n"
		"\n"
		"@return the ComapartmentType object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeCompartmentType(string sid)</pre>\n"
		"\n"
		"Removes the CompartmentType object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the CompartmentType objects in this Model object have the identifier \n"
		"@p sid, then @c None is returned.\n"
		"\n"
		"@param sid the identifier of the object to remove\n"
		"\n"
		"@return the CompartmentType object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no CompartmentType\n"
		"object with the identifier exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeSpeciesType", _wrap_Model_removeSpeciesType, METH_VARARGS, (char *)"\n"
		"removeSpeciesType(unsigned int n) -> SpeciesType\n"
		"Model_removeSpeciesType(Model self, string sid) -> SpeciesType\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeSpeciesType(long n)</pre>\n"
		"\n"
		"Removes the nth SpeciesType object from this Model object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the SpeciesType object to remove\n"
		"\n"
		"@return the SpeciesType object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeSpeciesType(string sid)</pre>\n"
		"\n"
		"Removes the SpeciesType object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the SpeciesType objects in this Model object have the identifier \n"
		"@p sid, then @c None is returned.\n"
		"\n"
		"@param sid the identifier of the SpeciesType object to remove\n"
		"\n"
		"@return the SpeciesType object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no SpeciesType\n"
		"object with the identifier exists in this Model object.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeCompartment", _wrap_Model_removeCompartment, METH_VARARGS, (char *)"\n"
		"removeCompartment(unsigned int n) -> Compartment\n"
		"Model_removeCompartment(Model self, string sid) -> Compartment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeCompartment(long n)</pre>\n"
		"\n"
		"Removes the nth Compartment object from this Model object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the Compartment object to remove\n"
		"\n"
		"@return the Compartment object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeCompartment(string sid)</pre>\n"
		"\n"
		"Removes the Compartment object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the Compartment objects in this Model object have the identifier \n"
		"@p sid, then @c None is returned.\n"
		"\n"
		"@param sid the identifier of the Compartment object to remove\n"
		"\n"
		"@return the Compartment object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no Compartment\n"
		"object with the identifier exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeSpecies", _wrap_Model_removeSpecies, METH_VARARGS, (char *)"\n"
		"removeSpecies(unsigned int n) -> Species\n"
		"Model_removeSpecies(Model self, string sid) -> Species\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeSpecies(long n)</pre>\n"
		"\n"
		"Removes the nth Species object from this Model object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the Species object to remove\n"
		"\n"
		"@return the Species object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeSpecies(string sid)</pre>\n"
		"\n"
		"Removes the Species object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the Species objects in this Model object have the identifier \n"
		"@p sid, then @c None is returned.\n"
		"\n"
		"@param sid the identifier of the Species object to remove\n"
		"\n"
		"@return the Species object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no Species\n"
		"object with the identifier exists in this Model object.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeParameter", _wrap_Model_removeParameter, METH_VARARGS, (char *)"\n"
		"removeParameter(unsigned int n) -> Parameter\n"
		"Model_removeParameter(Model self, string sid) -> Parameter\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeParameter(long n)</pre>\n"
		"\n"
		"Removes the nth Parameter object from this Model object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the Parameter object to remove\n"
		"\n"
		"@return the Parameter object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeParameter(string sid)</pre>\n"
		"\n"
		"Removes the Parameter object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the Parameter objects in this Model object have the identifier \n"
		"@p sid, then @c None is returned.\n"
		"\n"
		"@param sid the identifier of the Parameter object to remove\n"
		"\n"
		"@return the Parameter object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no Parameter\n"
		"object with the identifier exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeInitialAssignment", _wrap_Model_removeInitialAssignment, METH_VARARGS, (char *)"\n"
		"removeInitialAssignment(unsigned int n) -> InitialAssignment\n"
		"Model_removeInitialAssignment(Model self, string symbol) -> InitialAssignment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeInitialAssignment(long n)</pre>\n"
		"\n"
		"Removes the nth InitialAssignment object from this Model object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the InitialAssignment object to remove\n"
		"\n"
		"@return the InitialAssignment object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeInitialAssignment(string symbol)</pre>\n"
		"\n"
		"Removes the InitialAssignment object with the given 'symbol' attribute \n"
		"from this Model object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the InitialAssignment objects in this Model object have the\n"
		"'symbol' attribute @p symbol, then @c None is returned.\n"
		"\n"
		"@param symbol the 'symbol' attribute of the InitialAssignment object to remove\n"
		"\n"
		"@return the InitialAssignment object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no InitialAssignment\n"
		"object with the 'symbol' attribute exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeRule", _wrap_Model_removeRule, METH_VARARGS, (char *)"\n"
		"removeRule(unsigned int n) -> Rule\n"
		"Model_removeRule(Model self, string variable) -> Rule\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeRule(long n)</pre>\n"
		"\n"
		"Removes the nth Rule object from this Model object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the Rule object to remove\n"
		"\n"
		"@return the Rule object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeRule(string variable)</pre>\n"
		"\n"
		"Removes the Rule object with the given 'variable' attribute from this Model \n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the Rule objects in this Model object have the 'variable' attribute\n"
		"@p variable, then @c None is returned.\n"
		"\n"
		"@param variable the 'variable' attribute of the Rule object to remove\n"
		"\n"
		"@return the Rule object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no Rule\n"
		"object with the 'variable' attribute exists in this Model object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeConstraint", _wrap_Model_removeConstraint, METH_VARARGS, (char *)"\n"
		"Model_removeConstraint(Model self, unsigned int n) -> Constraint\n"
		"\n"
		"Removes the nth Constraint object from this Model object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the Constraint object to remove\n"
		"\n"
		"@return the Constraint object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeReaction", _wrap_Model_removeReaction, METH_VARARGS, (char *)"\n"
		"removeReaction(unsigned int n) -> Reaction\n"
		"Model_removeReaction(Model self, string sid) -> Reaction\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeReaction(long n)</pre>\n"
		"\n"
		"Removes the nth Reaction object from this Model object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the Reaction object to remove\n"
		"\n"
		"@return the Reaction object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeReaction(string sid)</pre>\n"
		"\n"
		"Removes the Reaction object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the Reaction objects in this Model object have the identifier \n"
		"@p sid, then @c None is returned.\n"
		"\n"
		"@param sid the identifier of the Reaction object to remove\n"
		"\n"
		"@return the Reaction object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no Reaction\n"
		"object with the identifier exists in this Model object.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_removeEvent", _wrap_Model_removeEvent, METH_VARARGS, (char *)"\n"
		"removeEvent(unsigned int n) -> Event\n"
		"Model_removeEvent(Model self, string sid) -> Event\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeEvent(long n)</pre>\n"
		"\n"
		"Removes the nth Event object from this Model object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the Event object to remove\n"
		"\n"
		"@return the Event object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeEvent(string sid)</pre>\n"
		"\n"
		"Removes the Event object with the given identifier from this Model\n"
		"object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the Event objects in this Model object have the identifier \n"
		"@p sid, then @c None is returned.\n"
		"\n"
		"@param sid the identifier of the Event object to remove\n"
		"\n"
		"@return the Event object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no Event\n"
		"object with the identifier exists in this Model object.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Model_swigregister", Model_swigregister, METH_VARARGS, NULL},
	 { (char *)"SBMLDocument_getDefaultLevel", _wrap_SBMLDocument_getDefaultLevel, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getDefaultLevel() -> unsigned int\n"
		"\n"
		"The default SBML Level of new SBMLDocument objects.\n"
		"\n"
		"This 'default Level' corresponds to the most recent SBML specification\n"
		"Level available at the time libSBML version @htmlinclude libsbml-version.html\n"
		"was released.  For this copy of libSBML, the value is <code>3</code>.\n"
		"The default Level is used by SBMLDocument if no Level is explicitly\n"
		"specified at the time of the construction of an SBMLDocument instance.\n"
		"\n"
		"@return an integer indicating the most recent SBML specification Level\n"
		"\n"
		"@see getDefaultVersion()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getDefaultVersion", _wrap_SBMLDocument_getDefaultVersion, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getDefaultVersion() -> unsigned int\n"
		"\n"
		"The default Version of new SBMLDocument objects.\n"
		"\n"
		"This 'default Version' corresponds to the most recent Version\n"
		"within the most recent Level of SBML available at the time libSBML\n"
		"version @htmlinclude libsbml-version.html\n"
		"was released.  For this copy of libSBML, the value is <code>1</code>\n"
		"(where the default Level of SBML is <code>3</code>).  The default\n"
		"Version is used by SBMLDocument if no Version is explicitly specified\n"
		"at the time of the construction of an SBMLDocument instance.\n"
		"\n"
		"@return an integer indicating the most recent SBML specification\n"
		"Version\n"
		"\n"
		"@see getDefaultLevel()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_SBMLDocument", _wrap_delete_SBMLDocument, METH_VARARGS, (char *)"delete_SBMLDocument(SBMLDocument self)"},
	 { (char *)"new_SBMLDocument", _wrap_new_SBMLDocument, METH_VARARGS, (char *)"\n"
		"SBMLDocument(unsigned int level = 0, unsigned int version = 0)\n"
		"SBMLDocument(unsigned int level = 0)\n"
		"SBMLDocument()\n"
		"SBMLDocument(SBMLNamespaces sbmlns)\n"
		"new_SBMLDocument(SBMLDocument rhs) -> SBMLDocument\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>SBMLDocument(long level = 0, long version = 0)</pre>\n"
		"\n"
		"Creates a new SBMLDocument, optionally with given values for the SBML\n"
		"Level and Version.\n"
		"\n"
		"If <em>both</em> the SBML Level and Version attributes are not\n"
		"specified, the SBML document is treated as having the latest Level and\n"
		"Version of SBML as determined by SBMLDocument.getDefaultLevel() and\n"
		"SBMLDocument.getDefaultVersion(); <em>however</em>, the SBMLDocument\n"
		"object is otherwise left blank.  In particular, the blank SBMLDocument\n"
		"object has no associated XML attributes, including (but not limited\n"
		"to) an XML namespace declaration.  The XML namespace declaration is\n"
		"not added until the model is written out, <em>or</em> the method\n"
		"SBMLDocument.setLevelAndVersion()\n"
		"is called.  This may be important to keep in mind\n"
		"if an application needs to add additional XML namespace declarations\n"
		"on the <code>&lt;sbml&gt;</code> element.  Application writers should\n"
		"either provide values for @p level and @p version on the call to this\n"
		"constructor, or else call\n"
		"SBMLDocument.setLevelAndVersion()\n"
		"shortly after creating the SBMLDocument object.\n"
		"\n"
		"@param level an integer for the SBML Level\n"
		"\n"
		"@param version an integer for the Version within the SBML Level\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"\n"
		"@see SBMLDocument.setLevelAndVersion()\n"
		"@see getDefaultLevel()\n"
		"@see getDefaultVersion()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>SBMLDocument(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new Compartment using the given SBMLNamespaces object \n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"It is worth emphasizing that although this constructor does not take\n"
		"an identifier argument, in SBML Level&nbsp;2 and beyond, the 'id'\n"
		"(identifier) attribute of a Compartment is required to have a value.\n"
		"Thus, callers are cautioned to assign a value after calling this\n"
		"constructor.  Setting the identifier can be accomplished using the\n"
		"method Compartment.setId().\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a Compartment object to an SBMLDocument\n"
		"(e.g., using Model.addCompartment()), the SBML XML namespace of the\n"
		"document @em overrides the value used when creating the Compartment\n"
		"object via this constructor.  This is necessary to ensure that an SBML\n"
		"document is a consistent structure.  Nevertheless, the ability to\n"
		"supply the values at the time of creation of a Compartment is an\n"
		"important aid to producing valid SBML.  Knowledge of the intented SBML\n"
		"Level and Version determine whether it is valid to assign a particular\n"
		"value to an attribute, or whether it is valid to add an object to an\n"
		"existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>SBMLDocument(SBMLDocument rhs)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this SBMLDocument.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_clone", _wrap_SBMLDocument_clone, METH_VARARGS, (char *)"\n"
		"SBMLDocument_clone(SBMLDocument self) -> SBMLDocument\n"
		"\n"
		"Creates and returns a deep copy of this SBMLDocument.\n"
		"\n"
		"@return a (deep) copy of this SBMLDocument.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getModel", _wrap_SBMLDocument_getModel, METH_VARARGS, (char *)"\n"
		"getModel() -> Model\n"
		"SBMLDocument_getModel(SBMLDocument self) -> Model\n"
		"\n"
		"Returns the Model object stored in this SBMLDocument.\n"
		"\n"
		"It is important to note that this method <em>does not create</em> a\n"
		"Model instance.  The model in the SBMLDocument must have been created\n"
		"at some prior time, for example using SBMLDocument.createModel() \n"
		"or SBMLDocument.setModel().\n"
		"This method returns @c None if a model does not yet exist.\n"
		"\n"
		"@return the Model contained in this SBMLDocument.\n"
		"\n"
		"@see createModel()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_expandFunctionDefinitions", _wrap_SBMLDocument_expandFunctionDefinitions, METH_VARARGS, (char *)"\n"
		"SBMLDocument_expandFunctionDefinitions(SBMLDocument self) -> bool\n"
		"\n"
		"Removes FunctionDefinition constructs from the document and expands\n"
		"any instances of their use within <code>&lt;math&gt;</code> elements.\n"
		"\n"
		"For example, suppose a Model contains a FunctionDefinition with\n"
		"identifier @c 'f' representing the math expression: <em>f(x, y) = x *\n"
		"y</em>.  Suppose further that there is a reaction in which the\n"
		"<code>&lt;math&gt;</code> element of the KineticLaw object contains\n"
		"<code>f(s, p)</code>, where @c s and @c p are other identifiers\n"
		"defined in the model.  The outcome of invoking this method is that the\n"
		"<code>&lt;math&gt;</code> of the KineticLaw now represents the\n"
		"expression <em>s * p</em> and the model no longer contains any\n"
		"FunctionDefinition objects.\n"
		"\n"
		"@return bool @c true if the transformation was successful, \n"
		"@c false, otherwise.\n"
		"\n"
		"@note This function will check the consistency of a model before\n"
		"attemptimg the transformation.  If the model is not valid SBML, the\n"
		"transformation will not be performed and the function will return @c\n"
		"false.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_expandInitialAssignments", _wrap_SBMLDocument_expandInitialAssignments, METH_VARARGS, (char *)"\n"
		"SBMLDocument_expandInitialAssignments(SBMLDocument self) -> bool\n"
		"\n"
		"Removes InitialAssignment constructs from the document and\n"
		"replaces them with appropriate values.\n"
		"\n"
		"For example, suppose a Model contains a InitialAssignment to a symbol\n"
		"@c 'k' where @c 'k' is the identifier of a Parameter.  The outcome of\n"
		"invoking this method is that the 'value' attribute of the Parameter\n"
		"definition is set to the result calculated using the InitialAssignment\n"
		"object's <code>&lt;math&gt;</code> formula, and the corresponding\n"
		"InitialAssignment is then removed from the Model.\n"
		"\n"
		"@return bool @c true if the transformation was successful, \n"
		"@c false, otherwise.\n"
		"\n"
		"@note This function will check the consistency of a model before\n"
		"attemptimg the transformation.  If the model is not valid SBML, the\n"
		"transformation will not be performed and the function will return @c\n"
		"false.  As part of that process, this method will check that it has\n"
		"values for any components referred to by the <code>&lt;math&gt;</code>\n"
		"elements of InitialAssignment objects.  In cases where not all of the\n"
		"values have been declared (e.g., if the mathematical expression refers\n"
		"to model entities that have no declared values), the InitialAssignment\n"
		"in question will @em not be removed and this method will return @c\n"
		"false.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_setLevelAndVersion", _wrap_SBMLDocument_setLevelAndVersion, METH_VARARGS, (char *)"\n"
		"setLevelAndVersion(unsigned int level, unsigned int version, bool strict = True) -> bool\n"
		"SBMLDocument_setLevelAndVersion(SBMLDocument self, unsigned int level, unsigned int version) -> bool\n"
		"\n"
		"Sets the SBML Level and Version of this SBMLDocument instance,\n"
		"attempting to convert the model as needed.\n"
		"\n"
		"This method is the principal way in libSBML to convert models between\n"
		"Levels and Versions of SBML.  Generally, models can be converted\n"
		"upward without difficulty (e.g., from SBML Level&nbsp;1 to\n"
		"Level&nbsp;2, or from an earlier Version of Level&nbsp;2 to the latest\n"
		"Version of Level&nbsp;2).  Sometimes models can be translated downward\n"
		"as well, if they do not use constructs specific to more advanced\n"
		"Levels of SBML.\n"
		"\n"
		"Before calling this method, callers may check compatibility directly\n"
		"using the methods SBMLDocument.checkL1Compatibility(),\n"
		"SBMLDocument.checkL2v1Compatibility(),\n"
		"SBMLDocument.checkL2v2Compatibility(),\n"
		"SBMLDocument.checkL2v3Compatibility(),\n"
		"SBMLDocument.checkL2v4Compatibility(), and\n"
		"SBMLDocument.checkL3v1Compatibility().\n"
		"\n"
		"The valid combinations of SBML Level and Version as of this release\n"
		"of libSBML are the following: \n"
		"<ul>\n"
		"<li> Level&nbsp;1 Version&nbsp;2\n"
		"<li> Level&nbsp;2 Version&nbsp;1\n"
		"<li> Level&nbsp;2 Version&nbsp;2\n"
		"<li> Level&nbsp;2 Version&nbsp;3\n"
		"<li> Level&nbsp;2 Version&nbsp;4\n"
		"<li> Level&nbsp;3 Version&nbsp;1\n"
		"</ul>\n"
		"\n"
		"Strict conversion applies the additional criteria that both the\n"
		"source and the target model must be consistent SBML.  Users can\n"
		"control the consistency checks that are applied using the\n"
		"SBMLDocument.setConsistencyChecksForConversion() method.  If either\n"
		"the source or the potential target model have validation errors, the\n"
		"conversion is not performed.  When a strict conversion is successful,\n"
		"the underlying SBML object model is altered to reflect the new level\n"
		"and version.  Thus, information that cannot be converted\n"
		"(e.g. sboTerms) will be lost.\n"
		"\n"
		"@param level the desired SBML Level\n"
		" \n"
		"@param version the desired Version within the SBML Level\n"
		"\n"
		"@param strict boolean indicating whether to check consistency\n"
		"of both the source and target model when performing\n"
		"conversion (defaults to <code> true </code>)\n"
		"\n"
		"@note Calling this method will not @em necessarily lead to a successful\n"
		"conversion.  If the conversion fails, it will be logged in the error\n"
		"list associated with this SBMLDocument.  Callers should consult\n"
		"getNumErrors() to find out if the conversion succeeded without\n"
		"problems.  For conversions from Level&nbsp;2 to Level&nbsp;1, callers\n"
		"can also check the Level of the model after calling this method to\n"
		"find out whether it is Level&nbsp;1.  (If the conversion to\n"
		"Level&nbsp;1 failed, the Level of this model will be left unchanged.)\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"\n"
		"@see checkL1Compatibility()\n"
		"@see checkL2v1Compatibility()\n"
		"@see checkL2v2Compatibility()\n"
		"@see checkL2v3Compatibility()\n"
		"@see checkL2v4Compatibility()\n"
		"@see checkL3v1Compatibility()\n"
		"@see checkL3v1Compatibility()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_setModel", _wrap_SBMLDocument_setModel, METH_VARARGS, (char *)"\n"
		"SBMLDocument_setModel(SBMLDocument self, Model m) -> int\n"
		"\n"
		"Sets the Model for this SBMLDocument to a copy of the given Model.\n"
		"\n"
		"@param m the new Model to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"\n"
		"@see createModel()\n"
		"@see getModel()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_createModel", _wrap_SBMLDocument_createModel, METH_VARARGS, (char *)"\n"
		"createModel(string sid = \"\") -> Model\n"
		"SBMLDocument_createModel(SBMLDocument self) -> Model\n"
		"\n"
		"Creates a new Model inside this SBMLDocument, and returns a pointer to\n"
		"it.\n"
		"\n"
		"In SBML Level&nbsp;2, the use of an identifier on a Model object is\n"
		"optional.  This method takes an optional argument, @p sid, for setting\n"
		"the identifier.  If not supplied, the identifier attribute on the\n"
		"Model instance is not set.\n"
		"\n"
		"@param sid the identifier of the new Model to create.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"\n"
		"@see getModel()\n"
		"@see SBMLDocument.setModel()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_setConsistencyChecks", _wrap_SBMLDocument_setConsistencyChecks, METH_VARARGS, (char *)"\n"
		"SBMLDocument_setConsistencyChecks(SBMLDocument self, SBMLErrorCategory_t category, bool apply)\n"
		"\n"
		"Controls the consistency checks that are performed when\n"
		"SBMLDocument.checkConsistency() is called.\n"
		"\n"
		"This method works by adding or subtracting consistency checks from the\n"
		"set of all possible checks that SBMLDocument.checkConsistency() knows\n"
		"how to perform.  This method may need to be called multiple times in\n"
		"order to achieve the desired combination of checks.  The first\n"
		"argument (@p category) in a call to this method indicates the category\n"
		"of consistency/error checks that are to be turned on or off, and the\n"
		"second argument (@p apply, a boolean) indicates whether to turn it on\n"
		"(value of @c true) or off (value of @c false).\n"
		"\n"
		"@if clike\n"
		"The possible categories (values to the argument @p category) are the\n"
		"set of values from the enumeration #SBMLErrorCategory_t.\n"
		"The following are the possible choices:\n"
		"@endif@if java\n"
		"The possible categories (values to the argument @p category) are the\n"
		"set of constants whose names begin with the characters <code>LIBSBML_CAT_</code>\n"
		"in the interface class {@link libsbmlConstants}.\n"
		"The following are the possible choices:\n"
		"@endif@if python \n"
		"The possible categories (values to the argument @p category) are the\n"
		"set of constants whose names begin with the characters <code>LIBSBML_CAT_</code>\n"
		"in the interface class @link libsbml libsbml@endlink.\n"
		"The following are the possible choices:\n"
		"@endif\n"
		"<ul>\n"
		"<li> @link libsbml.LIBSBML_CAT_GENERAL_CONSISTENCY\n"
		"LIBSBML_CAT_GENERAL_CONSISTENCY@endlink: Correctness and consistency\n"
		"of specific SBML language constructs.  Performing this set of checks\n"
		"is highly recommended.  With respect to the SBML specification, these\n"
		"concern failures in applying the validation rules numbered 2xxxx in\n"
		"the Level&nbsp;2 Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1\n"
		"specifications.\n"
		"\n"
		"<li> @link libsbml.LIBSBML_CAT_IDENTIFIER_CONSISTENCY\n"
		"LIBSBML_CAT_IDENTIFIER_CONSISTENCY@endlink: Correctness and\n"
		"consistency of identifiers used for model entities.  An example of\n"
		"inconsistency would be using a species identifier in a reaction rate\n"
		"formula without first having declared the species.  With respect to\n"
		"the SBML specification, these concern failures in applying the\n"
		"validation rules numbered 103xx in the Level&nbsp;2 Versions&nbsp;2&ndash;4\n"
		"and Level&nbsp;3 Version&nbsp;1 specifications.\n"
		"\n"
		"<li> @link libsbml.LIBSBML_CAT_UNITS_CONSISTENCY\n"
		"LIBSBML_CAT_UNITS_CONSISTENCY@endlink: Consistency of measurement\n"
		"units associated with quantities in a model.  With respect to the SBML\n"
		"specification, these concern failures in applying the validation rules\n"
		"numbered 105xx in the Level&nbsp;2 Versions&nbsp;2&ndash;4 and Level&nbsp;3\n"
		"Version&nbsp;1 specifications.\n"
		"\n"
		"<li> @link libsbml.LIBSBML_CAT_MATHML_CONSISTENCY\n"
		"LIBSBML_CAT_MATHML_CONSISTENCY@endlink: Syntax of MathML constructs.\n"
		"With respect to the SBML specification, these concern failures in\n"
		"applying the validation rules numbered 102xx in the Level&nbsp;2\n"
		"Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1 specifications.\n"
		"\n"
		"<li> @link libsbml.LIBSBML_CAT_SBO_CONSISTENCY\n"
		"LIBSBML_CAT_SBO_CONSISTENCY@endlink: Consistency and validity of %SBO\n"
		"identifiers (if any) used in the model.  With respect to the SBML\n"
		"specification, these concern failures in applying the validation rules\n"
		"numbered 107xx in the Level&nbsp;2 Versions&nbsp;2&ndash;4 and Level&nbsp;3\n"
		"Version&nbsp;1 specifications.\n"
		"\n"
		"<li> @link libsbml.LIBSBML_CAT_OVERDETERMINED_MODEL\n"
		"LIBSBML_CAT_OVERDETERMINED_MODEL@endlink: Static analysis of whether\n"
		"the system of equations implied by a model is mathematically\n"
		"overdetermined.  With respect to the SBML specification, this is\n"
		"validation rule #10601 in the Level&nbsp;2 Versions&nbsp;2&ndash;4 and\n"
		"Level&nbsp;3 Version&nbsp;1 specifications.\n"
		"\n"
		"<li> @link libsbml.LIBSBML_CAT_MODELING_PRACTICE\n"
		"LIBSBML_CAT_MODELING_PRACTICE@endlink: Additional checks for\n"
		"recommended good modeling practice. (These are tests performed by\n"
		"libSBML and do not have equivalent SBML validation rules.)\n"
		"</ul>\n"
		"\n"
		"<em>By default, all validation checks are applied</em> to the model in\n"
		"an SBMLDocument object @em unless\n"
		"SBMLDocument.setConsistencyChecks()\n"
		"is called to indicate that only a subset should be applied.  Further,\n"
		"this default (i.e., performing all checks) applies separately to\n"
		"<em>each new SBMLDocument object</em> created.  In other words, each\n"
		"time a model is read using SBMLReader.readSBML(),\n"
		"SBMLReader.readSBMLFromString(),\n"
		"or the global functions readSBML() and readSBMLFromString(), a new\n"
		"SBMLDocument is created and for that document, a call to\n"
		"SBMLDocument.checkConsistency() will default to applying all possible checks.\n"
		"Calling programs must invoke\n"
		"SBMLDocument.setConsistencyChecks()\n"
		"for each such new model if they wish to change the consistency checks\n"
		"applied.\n"
		"\n"
		"@param category a value drawn from @if clike #SBMLErrorCategory_t@else\n"
		"the set of SBML error categories@endif indicating the\n"
		"consistency checking/validation to be turned on or off.\n"
		"\n"
		"@param apply a boolean indicating whether the checks indicated by\n"
		"@p category should be applied or not.\n"
		"\n"
		"@see SBMLDocument.checkConsistency()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_setConsistencyChecksForConversion", _wrap_SBMLDocument_setConsistencyChecksForConversion, METH_VARARGS, (char *)"\n"
		"SBMLDocument_setConsistencyChecksForConversion(SBMLDocument self, SBMLErrorCategory_t category, bool apply)\n"
		"\n"
		"Controls the consistency checks that are performed when\n"
		"SBMLDocument.setLevelAndVersion() is called.\n"
		"\n"
		"This method works by adding or subtracting consistency checks from the\n"
		"set of all possible checks that may be performed to avoid conversion\n"
		"to or from an invalid document.  This method may need to be called \n"
		"multiple times in\n"
		"order to achieve the desired combination of checks.  The first\n"
		"argument (@p category) in a call to this method indicates the category\n"
		"of consistency/error checks that are to be turned on or off, and the\n"
		"second argument (@p apply, a boolean) indicates whether to turn it on\n"
		"(value of @c true) or off (value of @c false).\n"
		"\n"
		"@if clike\n"
		"The possible categories (values to the argument @p category) are the\n"
		"set of values from the enumeration #SBMLErrorCategory_t.\n"
		"The following are the possible choices:\n"
		"@endif@if java\n"
		"The possible categories (values to the argument @p category) are the\n"
		"set of constants whose names begin with the characters <code>LIBSBML_CAT_</code>\n"
		"in the interface class {@link libsbmlConstants}.\n"
		"The following are the possible choices:\n"
		"@endif@if python \n"
		"The possible categories (values to the argument @p category) are the\n"
		"set of constants whose names begin with the characters <code>LIBSBML_CAT_</code>\n"
		"in the interface class @link libsbml libsbml@endlink.\n"
		"The following are the possible choices:\n"
		"@endif\n"
		"<ul>\n"
		"<li> @link libsbml.LIBSBML_CAT_GENERAL_CONSISTENCY\n"
		"LIBSBML_CAT_GENERAL_CONSISTENCY@endlink: Correctness and consistency\n"
		"of specific SBML language constructs.  Performing this set of checks\n"
		"is highly recommended.  With respect to the SBML specification, these\n"
		"concern failures in applying the validation rules numbered 2xxxx in\n"
		"the Level&nbsp;2 Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1\n"
		"specifications.\n"
		"\n"
		"<li> @link libsbml.LIBSBML_CAT_IDENTIFIER_CONSISTENCY\n"
		"LIBSBML_CAT_IDENTIFIER_CONSISTENCY@endlink: Correctness and\n"
		"consistency of identifiers used for model entities.  An example of\n"
		"inconsistency would be using a species identifier in a reaction rate\n"
		"formula without first having declared the species.  With respect to\n"
		"the SBML specification, these concern failures in applying the\n"
		"validation rules numbered 103xx in the Level&nbsp;2 Versions&nbsp;2&ndash;4\n"
		"and Level&nbsp;3 Version&nbsp;1 specifications.\n"
		"\n"
		"<li> @link libsbml.LIBSBML_CAT_UNITS_CONSISTENCY\n"
		"LIBSBML_CAT_UNITS_CONSISTENCY@endlink: Consistency of measurement\n"
		"units associated with quantities in a model.  With respect to the SBML\n"
		"specification, these concern failures in applying the validation rules\n"
		"numbered 105xx in the Level&nbsp;2 Versions&nbsp;2&ndash;4 and Level&nbsp;3\n"
		"Version&nbsp;1 specifications.\n"
		"\n"
		"<li> @link libsbml.LIBSBML_CAT_MATHML_CONSISTENCY\n"
		"LIBSBML_CAT_MATHML_CONSISTENCY@endlink: Syntax of MathML constructs.\n"
		"With respect to the SBML specification, these concern failures in\n"
		"applying the validation rules numbered 102xx in the Level&nbsp;2\n"
		"Versions&nbsp;2&ndash;4 and Level&nbsp;3 Version&nbsp;1 specifications.\n"
		"\n"
		"<li> @link libsbml.LIBSBML_CAT_SBO_CONSISTENCY\n"
		"LIBSBML_CAT_SBO_CONSISTENCY@endlink: Consistency and validity of %SBO\n"
		"identifiers (if any) used in the model.  With respect to the SBML\n"
		"specification, these concern failures in applying the validation rules\n"
		"numbered 107xx in the Level&nbsp;2 Versions&nbsp;2&ndash;4 and Level&nbsp;3\n"
		"Version&nbsp;1 specifications.\n"
		"\n"
		"<li> @link libsbml.LIBSBML_CAT_OVERDETERMINED_MODEL\n"
		"LIBSBML_CAT_OVERDETERMINED_MODEL@endlink: Static analysis of whether\n"
		"the system of equations implied by a model is mathematically\n"
		"overdetermined.  With respect to the SBML specification, this is\n"
		"validation rule #10601 in the Level&nbsp;2 Versions&nbsp;2&ndash;4 and\n"
		"Level&nbsp;3 Version&nbsp;1 specifications.\n"
		"\n"
		"<li> @link libsbml.LIBSBML_CAT_MODELING_PRACTICE\n"
		"LIBSBML_CAT_MODELING_PRACTICE@endlink: Additional checks for\n"
		"recommended good modeling practice. (These are tests performed by\n"
		"libSBML and do not have equivalent SBML validation rules.)\n"
		"</ul>\n"
		"\n"
		"<em>By default, all validation checks are applied</em> to the model in\n"
		"an SBMLDocument object @em unless\n"
		"SBMLDocument.setConsistencyChecks()\n"
		"is called to indicate that only a subset should be applied.  Further,\n"
		"this default (i.e., performing all checks) applies separately to\n"
		"<em>each new SBMLDocument object</em> created.  In other words, each\n"
		"time a model is read using SBMLReader.readSBML(),\n"
		"SBMLReader.readSBMLFromString(),\n"
		"or the global functions readSBML() and readSBMLFromString(), a new\n"
		"SBMLDocument is created and for that document, a call to\n"
		"SBMLDocument.checkConsistency() will default to applying all possible checks.\n"
		"Calling programs must invoke\n"
		"SBMLDocument.setConsistencyChecks()\n"
		"for each such new model if they wish to change the consistency checks\n"
		"applied.\n"
		"\n"
		"@param category a value drawn from @if clike #SBMLErrorCategory_t@else\n"
		"the set of SBML error categories@endif indicating the consistency\n"
		"checking/validation to be turned on or off.\n"
		"\n"
		"@param apply a boolean indicating whether the checks indicated by\n"
		"@p category should be applied or not.\n"
		"\n"
		"@see SBMLDocument.setLevelAndVersion()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkConsistency", _wrap_SBMLDocument_checkConsistency, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkConsistency(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs consistency checking and validation on this SBML document.\n"
		"\n"
		"If this method returns a nonzero value (meaning, one or more\n"
		"consistency checks have failed for SBML document), the failures may be\n"
		"due to warnings @em or errors.  Callers should inspect the severity\n"
		"flag in the individual SBMLError objects returned by\n"
		"SBMLDocument.getError() to determine the nature of the failures.\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"\n"
		"@see SBMLDocument.checkInternalConsistency()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkInternalConsistency", _wrap_SBMLDocument_checkInternalConsistency, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkInternalConsistency(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs consistency checking on libSBML's internal representation of \n"
		"an SBML Model.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"SBMLDocument.getError().\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"\n"
		"The distinction between this method and\n"
		"SBMLDocument.checkConsistency() is that this method reports on\n"
		"fundamental syntactic and structural errors that violate the XML\n"
		"Schema for SBML; by contrast, SBMLDocument.checkConsistency()\n"
		"performs more elaborate model verifications and also validation\n"
		"according to the validation rules written in the appendices of the\n"
		"SBML Level&nbsp;2 Versions&nbsp;2&ndash;4 specification documents.\n"
		"\n"
		"@see SBMLDocument.checkConsistency()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkL1Compatibility", _wrap_SBMLDocument_checkL1Compatibility, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkL1Compatibility(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs a set of consistency checks on the document to establish\n"
		"whether it is compatible with SBML Level&nbsp;1 and can be converted\n"
		"to Level&nbsp;1.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"SBMLDocument.getError().\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkL2v1Compatibility", _wrap_SBMLDocument_checkL2v1Compatibility, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkL2v1Compatibility(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs a set of consistency checks on the document to establish\n"
		"whether it is compatible with SBML Level&nbsp;2 Version&nbsp;1 and can\n"
		"be converted to Level&nbsp;2 Version&nbsp;1.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"SBMLDocument.getError().\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkL2v2Compatibility", _wrap_SBMLDocument_checkL2v2Compatibility, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkL2v2Compatibility(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs a set of consistency checks on the document to establish\n"
		"whether it is compatible with SBML Level&nbsp;2 Version&nbsp;2 and can\n"
		"be converted to Level&nbsp;2 Version&nbsp;2.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"SBMLDocument.getError().\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkL2v3Compatibility", _wrap_SBMLDocument_checkL2v3Compatibility, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkL2v3Compatibility(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs a set of consistency checks on the document to establish\n"
		"whether it is compatible with SBML Level&nbsp;2 Version&nbsp;3 and can\n"
		"be converted to Level&nbsp;2 Version&nbsp;3.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"SBMLDocument.getError().\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkL2v4Compatibility", _wrap_SBMLDocument_checkL2v4Compatibility, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkL2v4Compatibility(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs a set of consistency checks on the document to establish\n"
		"whether it is compatible with SBML Level&nbsp;2 Version&nbsp;4 and can\n"
		"be converted to Level&nbsp;2 Version&nbsp;4.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"SBMLDocument.getError().\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_checkL3v1Compatibility", _wrap_SBMLDocument_checkL3v1Compatibility, METH_VARARGS, (char *)"\n"
		"SBMLDocument_checkL3v1Compatibility(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Performs a set of consistency checks on the document to establish\n"
		"whether it is compatible with SBML Level&nbsp;3 Version&nbsp;1 and can\n"
		"be converted to Level&nbsp;3 Version&nbsp;1.\n"
		"\n"
		"Callers should query the results of the consistency check by calling\n"
		"SBMLDocument.getError().\n"
		"\n"
		"@return the number of failed checks (errors) encountered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getError", _wrap_SBMLDocument_getError, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getError(SBMLDocument self, unsigned int n) -> SBMLError\n"
		"\n"
		"Returns the nth error or warning encountered during parsing,\n"
		"consistency checking, or attempted translation of this model.\n"
		"\n"
		"Callers can use method XMLError.getSeverity() on the result to assess\n"
		"the severity of the problem.  The possible severity levels range from\n"
		"informational messages to fatal errors.\n"
		"\n"
		"@return the error or warning indexed by integer @p n, or return @c\n"
		"None if <code>n &gt; (getNumErrors() - 1)</code>.\n"
		"\n"
		"@param n the integer index of the error sought.\n"
		"\n"
		"@see SBMLDocument.getNumErrors()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getNumErrors", _wrap_SBMLDocument_getNumErrors, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getNumErrors(SBMLDocument self) -> unsigned int\n"
		"\n"
		"Returns the number of errors or warnings encountered during parsing,\n"
		"consistency checking, or attempted translation of this model.\n"
		"\n"
		"@return the number of errors or warnings encountered\n"
		"\n"
		"@see SBMLDocument.getError()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_printErrors", _wrap_SBMLDocument_printErrors, METH_VARARGS, (char *)"\n"
		"printErrors(ostream stream = cerr)\n"
		"SBMLDocument_printErrors(SBMLDocument self)\n"
		"\n"
		"Prints to the given output stream all the errors or warnings\n"
		"encountered during parsing, consistency checking, or attempted\n"
		"translation of this model.\n"
		"\n"
		"If no errors have occurred, i.e., <code>getNumErrors() == 0</code>, no\n"
		"output will be sent to the stream.\n"
		"\n"
		"The format of the output is:\n"
		"  @verbatim\n"
		"    N error(s):\n"
		"      line NNN: (id) message\n"
		" @endverbatim\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getTypeCode", _wrap_SBMLDocument_getTypeCode, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getTypeCode(SBMLDocument self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see SBMLDocument.getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getElementName", _wrap_SBMLDocument_getElementName, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getElementName(SBMLDocument self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for SBMLDocument,\n"
		"is always @c 'sbml'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'sbml'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getErrorLog", _wrap_SBMLDocument_getErrorLog, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getErrorLog(SBMLDocument self) -> SBMLErrorLog\n"
		"\n"
		"Returns the list of errors or warnings logged during parsing, \n"
		"consistency checking, or attempted translation of this model.\n"
		"\n"
		"@return the SBMLErrorLog used for this SBMLDocument\n"
		"\n"
		"@see SBMLDocument.getNumErrors()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_getNamespaces", _wrap_SBMLDocument_getNamespaces, METH_VARARGS, (char *)"\n"
		"SBMLDocument_getNamespaces(SBMLDocument self) -> XMLNamespaces\n"
		"\n"
		"Returns a list of XML Namespaces associated with the XML content\n"
		"of this SBML document.\n"
		"\n"
		"@return the XML Namespaces associated with this SBML object\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLDocument_swigregister", SBMLDocument_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_FunctionDefinition", _wrap_delete_FunctionDefinition, METH_VARARGS, (char *)"delete_FunctionDefinition(FunctionDefinition self)"},
	 { (char *)"new_FunctionDefinition", _wrap_new_FunctionDefinition, METH_VARARGS, (char *)"\n"
		"FunctionDefinition(unsigned int level, unsigned int version)\n"
		"FunctionDefinition(SBMLNamespaces sbmlns)\n"
		"new_FunctionDefinition(FunctionDefinition orig) -> FunctionDefinition\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>FunctionDefinition(long level, long version)</pre>\n"
		"\n"
		"Creates a new FunctionDefinition using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this FunctionDefinition\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"FunctionDefinition\n"
		"\n"
		"@note Upon the addition of a FunctionDefinition object to an\n"
		"SBMLDocument (e.g., using Model.addFunctionDefinition()), the SBML\n"
		"Level, SBML Version and XML namespace of the document @em\n"
		"override the values used when creating the FunctionDefinition object\n"
		"via this constructor.  This is necessary to ensure that an SBML\n"
		"document is a consistent structure.  Nevertheless, the ability to\n"
		"supply the values at the time of creation of a FunctionDefinition is\n"
		"an important aid to producing valid SBML.  Knowledge of the intented\n"
		"SBML Level and Version determine whether it is valid to assign a\n"
		"particular value to an attribute, or whether it is valid to add an\n"
		"object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>FunctionDefinition(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new FunctionDefinition using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a FunctionDefinition object to an\n"
		"SBMLDocument (e.g., using Model.addFunctionDefinition()), the SBML\n"
		"XML namespace of the document @em overrides the value used when\n"
		"creating the FunctionDefinition object via this constructor.  This is\n"
		"necessary to ensure that an SBML document is a consistent structure.\n"
		"Nevertheless, the ability to supply the values at the time of creation\n"
		"of a FunctionDefinition is an important aid to producing valid SBML.\n"
		"Knowledge of the intented SBML Level and Version determine whether it\n"
		"is valid to assign a particular value to an attribute, or whether it\n"
		"is valid to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>FunctionDefinition(FunctionDefinition orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this FunctionDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_clone", _wrap_FunctionDefinition_clone, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_clone(FunctionDefinition self) -> FunctionDefinition\n"
		"\n"
		"Creates and returns a deep copy of this FunctionDefinition.\n"
		"\n"
		"@return a (deep) copy of this FunctionDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getId", _wrap_FunctionDefinition_getId, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_getId(FunctionDefinition self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this FunctionDefinition.\n"
		"\n"
		"@return the id of this FunctionDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getName", _wrap_FunctionDefinition_getName, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_getName(FunctionDefinition self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this FunctionDefinition.\n"
		"\n"
		"@return the name of this FunctionDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getMath", _wrap_FunctionDefinition_getMath, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_getMath(FunctionDefinition self) -> ASTNode\n"
		"\n"
		"Get the mathematical formula of this FunctionDefinition.\n"
		"\n"
		"@return an ASTNode, the value of the 'math' subelement of this\n"
		"FunctionDefinition\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_isSetId", _wrap_FunctionDefinition_isSetId, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_isSetId(FunctionDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"FunctionDefinition's 'id' attribute is set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this FunctionDefinition is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_isSetName", _wrap_FunctionDefinition_isSetName, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_isSetName(FunctionDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"FunctionDefinition's 'name' attribute is set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this FunctionDefinition is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_isSetMath", _wrap_FunctionDefinition_isSetMath, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_isSetMath(FunctionDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"FunctionDefinition's 'math' subelement contains a value.\n"
		"\n"
		"@return @c true if the 'math' for this FunctionDefinition is set,\n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_setId", _wrap_FunctionDefinition_setId, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_setId(FunctionDefinition self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this FunctionDefinition.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this FunctionDefinition\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_setName", _wrap_FunctionDefinition_setName, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_setName(FunctionDefinition self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this FunctionDefinition.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the FunctionDefinition\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_setMath", _wrap_FunctionDefinition_setMath, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_setMath(FunctionDefinition self, ASTNode math) -> int\n"
		"\n"
		"Sets the 'math' subelement of this FunctionDefinition to the Abstract\n"
		"Syntax Tree given in @p math.\n"
		"\n"
		"@param math an AST containing the mathematical expression to\n"
		"be used as the formula for this FunctionDefinition.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_unsetName", _wrap_FunctionDefinition_unsetName, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_unsetName(FunctionDefinition self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this FunctionDefinition.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getArgument", _wrap_FunctionDefinition_getArgument, METH_VARARGS, (char *)"\n"
		"getArgument(unsigned int n) -> ASTNode\n"
		"FunctionDefinition_getArgument(FunctionDefinition self, string name) -> ASTNode\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getArgument(long n)</pre>\n"
		"\n"
		"Get the <code>n</code>th argument to this function.\n"
		"\n"
		"Callers should first find out the number of arguments to the function\n"
		"by calling getNumArguments().\n"
		"\n"
		"@param n an integer index for the argument sought.\n"
		"\n"
		"@return the nth argument (bound variable) passed to this\n"
		"FunctionDefinition.\n"
		"\n"
		"@see getNumArguments()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getArgument(string name)</pre>\n"
		"\n"
		"Get the argument named @p name to this FunctionDefinition.\n"
		"\n"
		"@param name the exact name (case-sensitive) of the sought-after\n"
		"argument\n"
		"\n"
		"@return the argument (bound variable) having the given name, or @c None if\n"
		"no such argument exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getBody", _wrap_FunctionDefinition_getBody, METH_VARARGS, (char *)"\n"
		"getBody() -> ASTNode\n"
		"FunctionDefinition_getBody(FunctionDefinition self) -> ASTNode\n"
		"\n"
		"Get the mathematical expression that is the body of this\n"
		"FunctionDefinition object.\n"
		"\n"
		"@return the body of this FunctionDefinition as an Abstract Syntax\n"
		"Tree, or @c None if no body is defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getNumArguments", _wrap_FunctionDefinition_getNumArguments, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_getNumArguments(FunctionDefinition self) -> unsigned int\n"
		"\n"
		"Get the number of arguments (bound variables) taken by this\n"
		"FunctionDefinition.\n"
		"\n"
		"@return the number of arguments (bound variables) that must be passed\n"
		"to this FunctionDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getTypeCode", _wrap_FunctionDefinition_getTypeCode, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_getTypeCode(FunctionDefinition self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_getElementName", _wrap_FunctionDefinition_getElementName, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_getElementName(FunctionDefinition self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for\n"
		"FunctionDefinition, is always @c 'functionDefinition'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'functionDefinition'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_hasRequiredAttributes", _wrap_FunctionDefinition_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_hasRequiredAttributes(FunctionDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this FunctionDefinition object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a FunctionDefinition object are:\n"
		"@li 'id'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_hasRequiredElements", _wrap_FunctionDefinition_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"FunctionDefinition_hasRequiredElements(FunctionDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this FunctionDefinition object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a FunctionDefinition object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"FunctionDefinition_swigregister", FunctionDefinition_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfFunctionDefinitions_clone", _wrap_ListOfFunctionDefinitions_clone, METH_VARARGS, (char *)"\n"
		"ListOfFunctionDefinitions_clone(ListOfFunctionDefinitions self) -> ListOfFunctionDefinitions\n"
		"\n"
		"Creates and returns a deep copy of this ListOfFunctionDefinitions instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfFunctionDefinitions.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfFunctionDefinitions_getTypeCode", _wrap_ListOfFunctionDefinitions_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfFunctionDefinitions_getTypeCode(ListOfFunctionDefinitions self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfFunctionDefinitions_getItemTypeCode", _wrap_ListOfFunctionDefinitions_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfFunctionDefinitions_getItemTypeCode(ListOfFunctionDefinitions self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., FunctionDefinition objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfFunctionDefinitions_getElementName", _wrap_ListOfFunctionDefinitions_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfFunctionDefinitions_getElementName(ListOfFunctionDefinitions self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfFunctionDefinitions, the XML element name is @c\n"
		"'listOfFunctionDefinitions'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfFunctionDefinitions'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfFunctionDefinitions_get", _wrap_ListOfFunctionDefinitions_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> FunctionDefinition\n"
		"get(unsigned int n) -> FunctionDefinition\n"
		"get(string sid) -> FunctionDefinition\n"
		"ListOfFunctionDefinitions_get(ListOfFunctionDefinitions self, string sid) -> FunctionDefinition\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a FunctionDefinition from the ListOfFunctionDefinitions.\n"
		"\n"
		"@param n the index number of the FunctionDefinition to get.\n"
		"\n"
		"@return the nth FunctionDefinition in this ListOfFunctionDefinitions.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a FunctionDefinition from the ListOfFunctionDefinitions.\n"
		"\n"
		"@param n the index number of the FunctionDefinition to get.\n"
		"\n"
		"@return the nth FunctionDefinition in this ListOfFunctionDefinitions.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a FunctionDefinition from the ListOfFunctionDefinitions\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the FunctionDefinition to get.\n"
		"\n"
		"@return FunctionDefinition in this ListOfFunctionDefinitions\n"
		"with the given id or @c None if no such\n"
		"FunctionDefinition exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a FunctionDefinition from the ListOfFunctionDefinitions\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the FunctionDefinition to get.\n"
		"\n"
		"@return FunctionDefinition in this ListOfFunctionDefinitions\n"
		"with the given id or @c None if no such\n"
		"FunctionDefinition exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfFunctionDefinitions_remove", _wrap_ListOfFunctionDefinitions_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> FunctionDefinition\n"
		"ListOfFunctionDefinitions_remove(ListOfFunctionDefinitions self, string sid) -> FunctionDefinition\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfFunctionDefinitions items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes item in this ListOfFunctionDefinitions items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"None is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfFunctionDefinitions", _wrap_new_ListOfFunctionDefinitions, METH_VARARGS, (char *)"new_ListOfFunctionDefinitions() -> ListOfFunctionDefinitions"},
	 { (char *)"delete_ListOfFunctionDefinitions", _wrap_delete_ListOfFunctionDefinitions, METH_VARARGS, (char *)"delete_ListOfFunctionDefinitions(ListOfFunctionDefinitions self)"},
	 { (char *)"ListOfFunctionDefinitions_swigregister", ListOfFunctionDefinitions_swigregister, METH_VARARGS, NULL},
	 { (char *)"UnitKind_equals", _wrap_UnitKind_equals, METH_VARARGS, (char *)"\n"
		"UnitKind_equals(UnitKind_t uk1, UnitKind_t uk2) -> int\n"
		"\n"
		"Tests for logical equality between two given <code>UNIT_KIND_</code>\n"
		"code values.\n"
		"\n"
		"This function behaves exactly like C's <code>==</code> operator, except\n"
		"for the following two cases:\n"
		"<ul>\n"
		"<li>@link libsbml.UNIT_KIND_LITER UNIT_KIND_LITER@endlink <code>==</code> @link libsbml.UNIT_KIND_LITRE UNIT_KIND_LITRE@endlink\n"
		"<li>@link libsbml.UNIT_KIND_METER UNIT_KIND_METER@endlink <code>==</code> @link libsbml.UNIT_KIND_METRE UNIT_KIND_METRE@endlink\n"
		"</ul>\n"
		"\n"
		"In the two cases above, C equality comparison would yield @c false\n"
		"(because each of the above is a distinct enumeration value), but\n"
		"this function returns @c true.\n"
		"\n"
		"@param uk1 a <code>UNIT_KIND_</code> value \n"
		"@param uk2 a second <code>UNIT_KIND_</code> value to compare to @p uk1\n"
		"\n"
		"@return nonzero (for @c true) if @p uk1 is logically equivalent to @p\n"
		"uk2, zero (for @c false) otherwise.\n"
		"\n"
		"@note For more information about the libSBML unit codes, please refer to\n"
		"the class documentation for Unit.\n"
		"\n"
		"\n"
		""},
	 { (char *)"UnitKind_forName", _wrap_UnitKind_forName, METH_VARARGS, (char *)"\n"
		"UnitKind_forName(char name) -> UnitKind_t\n"
		"\n"
		"Converts a text string naming a kind of unit to its corresponding\n"
		"libSBML <code>UNIT_KIND_</code> constant/enumeration value.\n"
		"\n"
		"@param name a string, the name of a predefined base unit in SBML\n"
		"\n"
		"@return @if clike a value from UnitKind_t corresponding to the given\n"
		"string @p name (determined in a case-insensitive manner).\n"
		"@endif@if python a value the set of <code>UNIT_KIND_</code> codes\n"
		"defined in class @link libsbml libsbml@endlink, corresponding to the\n"
		"string @p name (determined in a case-insensitive\n"
		"manner).@endif@if java a value the set of <code>UNIT_KIND_</code> codes\n"
		"defined in class {@link libsbmlConstants}, corresponding to the string\n"
		"@p name (determined in a case-insensitive manner).@endif\n"
		"\n"
		"@note For more information about the libSBML unit codes, please refer to\n"
		"the class documentation for Unit.\n"
		"\n"
		"\n"
		""},
	 { (char *)"UnitKind_toString", _wrap_UnitKind_toString, METH_VARARGS, (char *)"\n"
		"UnitKind_toString(UnitKind_t uk) -> char\n"
		"\n"
		"Converts a unit code to a text string equivalent.\n"
		"\n"
		"@param uk @if clike a value from the UnitKind_t enumeration\n"
		"@endif@if python a value from the set of <code>UNIT_KIND_</code> codes\n"
		"defined in the class @link libsbml libsbml@endlink\n"
		"@endif@if java a value from the set of <code>UNIT_KIND_</code> codes\n"
		"defined in the class {@link libsbmlConstants}\n"
		"@endif\n"
		"\n"
		"@return the name corresponding to the given unit code.\n"
		"\n"
		"@note For more information about the libSBML unit codes, please refer to\n"
		"the class documentation for Unit.\n"
		"\n"
		"@warning The string returned is a static data value.  The caller does not\n"
		"own the returned string and is therefore not allowed to modify it.\n"
		"\n"
		"\n"
		""},
	 { (char *)"UnitKind_isValidUnitKindString", _wrap_UnitKind_isValidUnitKindString, METH_VARARGS, (char *)"\n"
		"UnitKind_isValidUnitKindString(char unit, unsigned int level, unsigned int version) -> int\n"
		"\n"
		"Predicate for testing whether a given string corresponds to a\n"
		"predefined libSBML unit code.\n"
		"\n"
		"@param unit a text string naming a base unit defined by SBML\n"
		"@param level the Level of SBML\n"
		"@param version the Version within the Level of SBML\n"
		"\n"
		"@return nonzero (for @c true) if string is the name of a valid\n"
		"<code>UNIT_KIND_</code> value, zero (for @c false) otherwise.\n"
		"\n"
		"@note For more information about the libSBML unit codes, please refer to\n"
		"the class documentation for Unit.\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_Unit", _wrap_delete_Unit, METH_VARARGS, (char *)"delete_Unit(Unit self)"},
	 { (char *)"new_Unit", _wrap_new_Unit, METH_VARARGS, (char *)"\n"
		"Unit(unsigned int level, unsigned int version)\n"
		"Unit(SBMLNamespaces sbmlns)\n"
		"new_Unit(Unit orig) -> Unit\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Unit(long level, long version)</pre>\n"
		"\n"
		"Creates a new Unit using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this Unit\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"Unit\n"
		"\n"
		"@note Upon the addition of a Unit object to an SBMLDocument, the SBML\n"
		"Level, SBML Version and XML namespace of the document @em\n"
		"override the values used when creating the Unit object via this\n"
		"constructor.  This is necessary to ensure that an SBML document is a\n"
		"consistent structure.  Nevertheless, the ability to supply the values\n"
		"at the time of creation of a Unit is an important aid to producing\n"
		"valid SBML.  Knowledge of the intented SBML Level and Version\n"
		"determine whether it is valid to assign a particular value to an\n"
		"attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Unit(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new Unit using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a Unit object to an SBMLDocument, the SBML\n"
		"XML namespace of the document @em overrides the value used when\n"
		"creating the Unit object via this constructor.  This is necessary to\n"
		"ensure that an SBML document is a consistent structure.  Nevertheless,\n"
		"the ability to supply the values at the time of creation of a Unit is\n"
		"an important aid to producing valid SBML.  Knowledge of the intented\n"
		"SBML Level and Version determine whether it is valid to assign a\n"
		"particular value to an attribute, or whether it is valid to add an\n"
		"object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Unit(Unit orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this Unit.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Unit_clone", _wrap_Unit_clone, METH_VARARGS, (char *)"\n"
		"Unit_clone(Unit self) -> Unit\n"
		"\n"
		"Creates and returns a deep copy of this Unit.\n"
		"\n"
		"@return a (deep) copy of this Unit.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_initDefaults", _wrap_Unit_initDefaults, METH_VARARGS, (char *)"\n"
		"Unit_initDefaults(Unit self)\n"
		"\n"
		"Initializes the fields of this Unit object to 'typical' default\n"
		"values.\n"
		"\n"
		"The SBML Unit component has slightly different aspects and default\n"
		"attribute values in different SBML Levels and Versions.  This method\n"
		"sets the values to certain common defaults, based mostly on what they\n"
		"are in SBML Level&nbsp;2.  Specifically:\n"
		"<ul>\n"
		"<li> Sets attribute 'exponent' to @c 1\n"
		"<li> Sets attribute 'scale' to @c 0\n"
		"<li> Sets attribute 'multiplier' to @c 1.0\n"
		"</ul>\n"
		"\n"
		"The 'kind' attribute is left unchanged.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getKind", _wrap_Unit_getKind, METH_VARARGS, (char *)"\n"
		"Unit_getKind(Unit self) -> UnitKind_t\n"
		"\n"
		"Returns the 'kind' of Unit this is.\n"
		"\n"
		"@if clike\n"
		"@return the value of the 'kind' attribute of this Unit as a\n"
		"value from the <a class='el' href='#UnitKind_t'>UnitKind_t</a> enumeration.\n"
		"@endif@if java\n"
		"@return the value of the 'kind' attribute of this Unit as a\n"
		"value from the set of constants whose names begin\n"
		"with <code>UNIT_KIND_</code> defined in the class\n"
		"<code><a href='libsbmlConstants.html'>libsbmlConstants</a></code>.\n"
		"@endif@if python\n"
		"@return the value of the 'kind' attribute of this Unit as a\n"
		"value from the set of constants whose names begin\n"
		"with <code>UNIT_KIND_</code> defined in the class\n"
		"@link libsbml libsbml@endlink.\n"
		"@endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getExponent", _wrap_Unit_getExponent, METH_VARARGS, (char *)"\n"
		"Unit_getExponent(Unit self) -> int\n"
		"\n"
		"Returns the value of the 'exponent' attribute of this unit.\n"
		"\n"
		"@return the 'exponent' value of this Unit, as an integer.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getExponentAsDouble", _wrap_Unit_getExponentAsDouble, METH_VARARGS, (char *)"\n"
		"Unit_getExponentAsDouble(Unit self) -> double\n"
		"\n"
		"Returns the value of the 'exponent' attribute of this unit.\n"
		"\n"
		"@return the 'exponent' value of this Unit, as a double.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getScale", _wrap_Unit_getScale, METH_VARARGS, (char *)"\n"
		"Unit_getScale(Unit self) -> int\n"
		"\n"
		"Returns the value of the 'scale' attribute of this unit.\n"
		"\n"
		"@return the 'scale' value of this Unit, as an integer.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getMultiplier", _wrap_Unit_getMultiplier, METH_VARARGS, (char *)"\n"
		"Unit_getMultiplier(Unit self) -> double\n"
		"\n"
		"Returns the value of the 'multiplier' attribute of this Unit.\n"
		"\n"
		"@return the 'multiplier' value of this Unit, as a double.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getOffset", _wrap_Unit_getOffset, METH_VARARGS, (char *)"\n"
		"Unit_getOffset(Unit self) -> double\n"
		"\n"
		"Returns the value of the 'offset' attribute of this Unit.\n"
		"\n"
		"@warning The 'offset' attribute is only available in SBML Level&nbsp;2\n"
		"Version&nbsp;1.  This attribute is not present in SBML Level&nbsp;2\n"
		"Version&nbsp;2 or above.  When producing SBML models using these later\n"
		"specifications, modelers and software tools need to account for units\n"
		"with offsets explicitly.  The %SBML specification document offers a\n"
		"number of suggestions for how to achieve this.  LibSBML methods such\n"
		"as this one related to 'offset' are retained for compatibility with\n"
		"earlier versions of SBML Level&nbsp;2, but their use is strongly\n"
		"discouraged.\n"
		"\n"
		"@return the 'offset' value of this Unit, as a double.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isAmpere", _wrap_Unit_isAmpere, METH_VARARGS, (char *)"\n"
		"Unit_isAmpere(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c ampere.\n"
		"\n"
		"@return @c true if the kind of this Unit is @c ampere, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isAvogadro", _wrap_Unit_isAvogadro, METH_VARARGS, (char *)"\n"
		"Unit_isAvogadro(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c avogadro.\n"
		"\n"
		"@return @c true if the kind of this Unit is @c avogadro, @c false\n"
		"otherwise.\n"
		"\n"
		"@note The unit @c avogadro was introduced in SBML Level&nbsp;3, and\n"
		"is only permitted for use in SBML Level&nbsp;3 models.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isBecquerel", _wrap_Unit_isBecquerel, METH_VARARGS, (char *)"\n"
		"Unit_isBecquerel(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c becquerel\n"
		"\n"
		"@return @c true if the kind of this Unit is @c becquerel, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isCandela", _wrap_Unit_isCandela, METH_VARARGS, (char *)"\n"
		"Unit_isCandela(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c candela\n"
		"\n"
		"@return @c true if the kind of this Unit is @c candela, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isCelsius", _wrap_Unit_isCelsius, METH_VARARGS, (char *)"\n"
		"Unit_isCelsius(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c Celsius\n"
		"\n"
		"@return @c true if the kind of this Unit is @c Celsius, @c false\n"
		"otherwise. \n"
		"\n"
		"@warning The predefined unit @c Celsius was removed from the list of\n"
		"predefined units in SBML Level&nbsp;2 Version&nbsp;2 at the same time\n"
		"that the 'offset' attribute was removed from Unit definitions.\n"
		"LibSBML methods such as this one related to @c Celsius are retained in\n"
		"order to support SBML Level&nbsp;2 Version&nbsp;1, but their use is\n"
		"strongly discouraged.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isCoulomb", _wrap_Unit_isCoulomb, METH_VARARGS, (char *)"\n"
		"Unit_isCoulomb(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c coulomb\n"
		"\n"
		"@return @c true if the kind of this Unit is @c coulomb, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isDimensionless", _wrap_Unit_isDimensionless, METH_VARARGS, (char *)"\n"
		"Unit_isDimensionless(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c\n"
		"dimensionless.\n"
		"\n"
		"@return @c true if the kind of this Unit is @c dimensionless, @c false\n"
		"\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isFarad", _wrap_Unit_isFarad, METH_VARARGS, (char *)"\n"
		"Unit_isFarad(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c farad\n"
		"\n"
		"@return @c true if the kind of this Unit is @c farad, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isGram", _wrap_Unit_isGram, METH_VARARGS, (char *)"\n"
		"Unit_isGram(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c gram\n"
		"\n"
		"@return @c true if the kind of this Unit is @c gram, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isGray", _wrap_Unit_isGray, METH_VARARGS, (char *)"\n"
		"Unit_isGray(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c gray\n"
		"\n"
		"@return @c true if the kind of this Unit is @c gray, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isHenry", _wrap_Unit_isHenry, METH_VARARGS, (char *)"\n"
		"Unit_isHenry(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c henry\n"
		"\n"
		"@return @c true if the kind of this Unit is @c henry, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isHertz", _wrap_Unit_isHertz, METH_VARARGS, (char *)"\n"
		"Unit_isHertz(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c hertz\n"
		"\n"
		"@return @c true if the kind of this Unit is @c hertz, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isItem", _wrap_Unit_isItem, METH_VARARGS, (char *)"\n"
		"Unit_isItem(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c item\n"
		"\n"
		"@return @c true if the kind of this Unit is @c item, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isJoule", _wrap_Unit_isJoule, METH_VARARGS, (char *)"\n"
		"Unit_isJoule(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c joule\n"
		"\n"
		"@return @c true if the kind of this Unit is @c joule, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isKatal", _wrap_Unit_isKatal, METH_VARARGS, (char *)"\n"
		"Unit_isKatal(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c katal\n"
		"\n"
		"@return @c true if the kind of this Unit is @c katal, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isKelvin", _wrap_Unit_isKelvin, METH_VARARGS, (char *)"\n"
		"Unit_isKelvin(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c kelvin\n"
		"\n"
		"@return @c true if the kind of this Unit is @c kelvin, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isKilogram", _wrap_Unit_isKilogram, METH_VARARGS, (char *)"\n"
		"Unit_isKilogram(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c kilogram\n"
		"\n"
		"@return @c true if the kind of this Unit is @c kilogram, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isLitre", _wrap_Unit_isLitre, METH_VARARGS, (char *)"\n"
		"Unit_isLitre(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c litre\n"
		"\n"
		"@return @c true if the kind of this Unit is @c litre or 'liter', @c\n"
		"false \n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isLumen", _wrap_Unit_isLumen, METH_VARARGS, (char *)"\n"
		"Unit_isLumen(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c lumen\n"
		"\n"
		"@return @c true if the kind of this Unit is @c lumen, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isLux", _wrap_Unit_isLux, METH_VARARGS, (char *)"\n"
		"Unit_isLux(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c lux\n"
		"\n"
		"@return @c true if the kind of this Unit is @c lux, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isMetre", _wrap_Unit_isMetre, METH_VARARGS, (char *)"\n"
		"Unit_isMetre(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c metre\n"
		"\n"
		"@return @c true if the kind of this Unit is @c metre or 'meter', @c\n"
		"false \n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isMole", _wrap_Unit_isMole, METH_VARARGS, (char *)"\n"
		"Unit_isMole(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c mole\n"
		"\n"
		"@return @c true if the kind of this Unit is @c mole, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isNewton", _wrap_Unit_isNewton, METH_VARARGS, (char *)"\n"
		"Unit_isNewton(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c newton\n"
		"\n"
		"@return @c true if the kind of this Unit is @c newton, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isOhm", _wrap_Unit_isOhm, METH_VARARGS, (char *)"\n"
		"Unit_isOhm(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c ohm\n"
		"\n"
		"@return @c true if the kind of this Unit is @c ohm, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isPascal", _wrap_Unit_isPascal, METH_VARARGS, (char *)"\n"
		"Unit_isPascal(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c pascal\n"
		"\n"
		"@return @c true if the kind of this Unit is @c pascal, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isRadian", _wrap_Unit_isRadian, METH_VARARGS, (char *)"\n"
		"Unit_isRadian(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c radian\n"
		"\n"
		"@return @c true if the kind of this Unit is @c radian, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSecond", _wrap_Unit_isSecond, METH_VARARGS, (char *)"\n"
		"Unit_isSecond(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c second\n"
		"\n"
		"@return @c true if the kind of this Unit is @c second, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSiemens", _wrap_Unit_isSiemens, METH_VARARGS, (char *)"\n"
		"Unit_isSiemens(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c siemens\n"
		"\n"
		"@return @c true if the kind of this Unit is @c siemens, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSievert", _wrap_Unit_isSievert, METH_VARARGS, (char *)"\n"
		"Unit_isSievert(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c sievert\n"
		"\n"
		"@return @c true if the kind of this Unit is @c sievert, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSteradian", _wrap_Unit_isSteradian, METH_VARARGS, (char *)"\n"
		"Unit_isSteradian(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c steradian\n"
		"\n"
		"@return @c true if the kind of this Unit is @c steradian, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isTesla", _wrap_Unit_isTesla, METH_VARARGS, (char *)"\n"
		"Unit_isTesla(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c tesla\n"
		"\n"
		"@return @c true if the kind of this Unit is @c tesla, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isVolt", _wrap_Unit_isVolt, METH_VARARGS, (char *)"\n"
		"Unit_isVolt(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c volt\n"
		"\n"
		"@return @c true if the kind of this Unit is @c volt, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isWatt", _wrap_Unit_isWatt, METH_VARARGS, (char *)"\n"
		"Unit_isWatt(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c watt\n"
		"\n"
		"@return @c true if the kind of this Unit is @c watt, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isWeber", _wrap_Unit_isWeber, METH_VARARGS, (char *)"\n"
		"Unit_isWeber(Unit self) -> bool\n"
		"\n"
		"Predicate for testing whether this Unit is of the kind @c weber\n"
		"\n"
		"@return @c true if the kind of this Unit is @c weber, @c false\n"
		"otherwise. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSetKind", _wrap_Unit_isSetKind, METH_VARARGS, (char *)"\n"
		"Unit_isSetKind(Unit self) -> bool\n"
		"\n"
		"Predicate to test whether the 'kind' attribute of this Unit is set.\n"
		"\n"
		"@return @c true if the 'kind' attribute of this Unit is set, @c\n"
		"false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSetExponent", _wrap_Unit_isSetExponent, METH_VARARGS, (char *)"\n"
		"Unit_isSetExponent(Unit self) -> bool\n"
		"\n"
		"Predicate to test whether the 'exponent' attribute of this Unit \n"
		"is set.\n"
		"\n"
		"@return @c true if the 'exponent' attribute of this Unit is set, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSetScale", _wrap_Unit_isSetScale, METH_VARARGS, (char *)"\n"
		"Unit_isSetScale(Unit self) -> bool\n"
		"\n"
		"Predicate to test whether the 'scale' attribute of this Unit \n"
		"is set.\n"
		"\n"
		"@return @c true if the 'scale' attribute of this Unit is set, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isSetMultiplier", _wrap_Unit_isSetMultiplier, METH_VARARGS, (char *)"\n"
		"Unit_isSetMultiplier(Unit self) -> bool\n"
		"\n"
		"Predicate to test whether the 'multiplier' attribute of this Unit \n"
		"is set.\n"
		"\n"
		"@return @c true if the 'multiplier' attribute of this Unit is set, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_setKind", _wrap_Unit_setKind, METH_VARARGS, (char *)"\n"
		"Unit_setKind(Unit self, UnitKind_t kind) -> int\n"
		"\n"
		"Sets the 'kind' attribute value of this Unit.\n"
		"\n"
		"@if clike\n"
		"@param kind a value from the <a class='el'\n"
		"href='#UnitKind_t'>UnitKind_t</a> enumeration.\n"
		"@endif@if java\n"
		"@param kind a unit identifier chosen from the set of constants whose\n"
		"names begin with <code>UNIT_KIND_</code> in <code><a\n"
		"href='libsbmlConstants.html'>libsbmlConstants</a></code>.\n"
		"@endif@if python\n"
		"@param kind a unit identifier chosen from the set of constants whose\n"
		"names begin with <code>UNIT_KIND_</code> in @link libsbml libsbml@endlink.\n"
		"@endif\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_setExponent", _wrap_Unit_setExponent, METH_VARARGS, (char *)"\n"
		"setExponent(int value) -> int\n"
		"Unit_setExponent(Unit self, double value) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setExponent(int value)</pre>\n"
		"\n"
		"Sets the 'exponent' attribute value of this Unit.\n"
		"\n"
		"@param value the integer to which the attribute 'exponent' should be set\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setExponent(double value)</pre>\n"
		"\n"
		"Sets the 'exponent' attribute value of this Unit.\n"
		"\n"
		"@param value the double to which the attribute 'exponent' should be set\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_setScale", _wrap_Unit_setScale, METH_VARARGS, (char *)"\n"
		"Unit_setScale(Unit self, int value) -> int\n"
		"\n"
		"Sets the 'scale' attribute value of this Unit.\n"
		"\n"
		"@param value the integer to which the attribute 'scale' should be set\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_setMultiplier", _wrap_Unit_setMultiplier, METH_VARARGS, (char *)"\n"
		"Unit_setMultiplier(Unit self, double value) -> int\n"
		"\n"
		"Sets the 'multipler' attribute value of this Unit.\n"
		"\n"
		"@param value the floating-point value to which the attribute\n"
		"'multiplier' should be set\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_setOffset", _wrap_Unit_setOffset, METH_VARARGS, (char *)"\n"
		"Unit_setOffset(Unit self, double value) -> int\n"
		"\n"
		"Sets the 'offset' attribute value of this Unit.\n"
		"\n"
		"@param value the float-point value to which the attribute 'offset'\n"
		"should set\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@warning The 'offset' attribute is only available in SBML Level&nbsp;2\n"
		"Version&nbsp;1.  This attribute is not present in SBML Level&nbsp;2\n"
		"Version&nbsp;2 or above.  When producing SBML models using these later\n"
		"specifications, modelers and software tools need to account for units\n"
		"with offsets explicitly.  The %SBML specification document offers a\n"
		"number of suggestions for how to achieve this.  LibSBML methods such\n"
		"as this one related to 'offset' are retained for compatibility with\n"
		"earlier versions of SBML Level&nbsp;2, but their use is strongly\n"
		"discouraged.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getTypeCode", _wrap_Unit_getTypeCode, METH_VARARGS, (char *)"\n"
		"Unit_getTypeCode(Unit self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code of this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_getElementName", _wrap_Unit_getElementName, METH_VARARGS, (char *)"\n"
		"Unit_getElementName(Unit self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Unit, is\n"
		"always @c 'unit'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'unit'. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isBuiltIn", _wrap_Unit_isBuiltIn, METH_VARARGS, (char *)"\n"
		"Unit_isBuiltIn(string name, unsigned int level) -> bool\n"
		"\n"
		"Predicate to test whether a given string is the name of a\n"
		"predefined SBML unit.\n"
		"\n"
		"@param name a string to be tested against the predefined unit names\n"
		"\n"
		"@param level the Level of SBML for which the determination should be\n"
		"made.  This is necessary because there are a few small differences\n"
		"in allowed units between SBML Level&nbsp;1 and Level&nbsp;2.\n"
		"\n"
		"@return @c true if @p name is one of the five SBML predefined unit\n"
		"identifiers (@c 'substance', @c 'volume', @c 'area', @c 'length' or @c\n"
		"'time'), @c false otherwise.\n"
		"\n"
		"@note The predefined unit identifiers @c 'length' and @c 'area' were\n"
		"added in Level&nbsp;2 Version&nbsp;1\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_isUnitKind", _wrap_Unit_isUnitKind, METH_VARARGS, (char *)"\n"
		"Unit_isUnitKind(string name, unsigned int level, unsigned int version) -> bool\n"
		"\n"
		"Predicate to test whether a given string is the name of a valid\n"
		"base unit in SBML (such as @c 'gram' or @c 'mole').\n"
		"\n"
		"This method exists because prior to SBML Level&nbsp;2 Version&nbsp;3,\n"
		"an enumeration called @c UnitKind was defined by SBML.  This enumeration\n"
		"was removed in SBML Level&nbsp;2 Version&nbsp;3 and its values were\n"
		"folded into the space of values of a type called @c UnitSId.  This method\n"
		"therefore has less significance in SBML Level&nbsp;2 Version&nbsp;3\n"
		"and Level&nbsp;2 Version&nbsp;4, but remains for backward\n"
		"compatibility and support for reading models in older Versions of\n"
		"Level&nbsp;2.\n"
		"\n"
		"@param name a string to be tested\n"
		"\n"
		"@param level a long integer representing the SBML specification\n"
		"Level \n"
		"\n"
		"@param version a long integer representing the SBML specification\n"
		"Version\n"
		"\n"
		"@return @c true if name is a valid SBML UnitKind, @c false otherwise\n"
		"\n"
		"@note The allowed unit names differ between SBML Levels&nbsp;1\n"
		"and&nbsp;2 and again slightly between Level&nbsp;2 Versions&nbsp;1\n"
		"and&nbsp;2.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_areIdentical", _wrap_Unit_areIdentical, METH_VARARGS, (char *)"\n"
		"Unit_areIdentical(Unit unit1, Unit unit2) -> bool\n"
		"\n"
		"Predicate returning @c true if two\n"
		"Unit objects are identical.\n"
		"\n"
		"Two Unit objects are considered to be @em identical if they match in\n"
		"all attributes.  (Contrast this to the method areEquivalent(@if java Unit u1, %Unit u2@endif), which\n"
		"compares Unit objects only with respect to certain attributes.)\n"
		"\n"
		"@param unit1 the first Unit object to compare\n"
		"@param unit2 the second Unit object to compare\n"
		"\n"
		"@return @c true if all the attributes of unit1 are identical\n"
		"to the attributes of unit2, @c false otherwise.\n"
		"\n"
		"@see areEquivalent()\n"
		" \n"
		"\n"
		""},
	 { (char *)"Unit_areEquivalent", _wrap_Unit_areEquivalent, METH_VARARGS, (char *)"\n"
		"Unit_areEquivalent(Unit unit1, Unit unit2) -> bool\n"
		"\n"
		"Predicate returning @c true if \n"
		"Unit objects are equivalent.\n"
		"\n"
		"Two Unit objects are considered to be @em equivalent either if (1) both\n"
		"have a 'kind' attribute value of @c dimensionless, or (2) their 'kind',\n"
		"'exponent' and (for SBML Level&nbsp;2 Version&nbsp;1) 'offset'\n"
		"attribute values are equal. (Contrast this to the method\n"
		"areIdentical(@if java Unit u1, %Unit u2@endif), which compares Unit objects with respect to all\n"
		"attributes, not just the 'kind' and 'exponent'.)\n"
		"\n"
		"@param unit1 the first Unit object to compare\n"
		"@param unit2 the second Unit object to compare\n"
		"\n"
		"@return @c true if the 'kind' and 'exponent' attributes of unit1 are\n"
		"identical to the kind and exponent attributes of unit2, @c false\n"
		"otherwise.\n"
		"\n"
		"@see areIdentical()\n"
		" \n"
		"\n"
		""},
	 { (char *)"Unit_removeScale", _wrap_Unit_removeScale, METH_VARARGS, (char *)"\n"
		"Unit_removeScale(Unit unit) -> int\n"
		"\n"
		"Manipulates the attributes of the Unit to express the unit with the \n"
		"value of the scale attribute reduced to zero.\n"
		"\n"
		"For example, 1 millimetre can be expressed as a Unit with kind=@c\n"
		"'metre' multiplier=@c '1' scale=@c '-3' exponent=@c '1'. It can also be\n"
		"expressed as a Unit with kind=@c 'metre'\n"
		"multiplier=<code>'0.001'</code> scale=@c '0' exponent=@c '1'.\n"
		"\n"
		"@param unit the Unit object to manipulate.\n"
		"\n"
		"@return integer value indicating success/failure of the function.  The\n"
		"possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see convertToSI()\n"
		"@see merge()\n"
		" \n"
		"\n"
		""},
	 { (char *)"Unit_merge", _wrap_Unit_merge, METH_VARARGS, (char *)"\n"
		"Unit_merge(Unit unit1, Unit unit2)\n"
		"\n"
		"Merges two Unit objects with the same 'kind' attribute value into a\n"
		"single Unit.\n"
		"\n"
		"For example, the following,\n"
		"@code\n"
		"<unit kind='metre' exponent='2'/>\n"
		"<unit kind='metre' exponent='1'/>\n"
		"@endcode\n"
		"would be merged to become\n"
		"@code\n"
		"<unit kind='metre' exponent='3'/>\n"
		"@endcode\n"
		"\n"
		"@param unit1 the first Unit object; the result of the operation is\n"
		"left as a new version of this unit, modified in-place.\n"
		"\n"
		"@param unit2 the second Unit object to merge with the first\n"
		"\n"
		"@see convertToSI()\n"
		"@see removeScale()\n"
		" \n"
		"\n"
		""},
	 { (char *)"Unit_convertToSI", _wrap_Unit_convertToSI, METH_VARARGS, (char *)"\n"
		"Unit_convertToSI(Unit unit) -> UnitDefinition\n"
		"\n"
		"Returns a UnitDefinition object containing the given @p unit converted\n"
		"to the appropriate SI unit.\n"
		"\n"
		"This method exists because some units can be expressed in terms of\n"
		"others when the same physical dimension is involved.  For example, one\n"
		"hertz is identical to 1&nbsp;sec<sup>-1</sup>, one litre is equivalent\n"
		"to 1 cubic decametre, and so on.\n"
		"\n"
		"@param unit the Unit object to convert to SI\n"
		"\n"
		"@return a UnitDefinition object containing the SI unit.\n"
		"\n"
		"@see merge()\n"
		" \n"
		"\n"
		""},
	 { (char *)"Unit_hasRequiredAttributes", _wrap_Unit_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Unit_hasRequiredAttributes(Unit self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this Unit object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a Unit object are:\n"
		"@li 'kind'\n"
		"@li 'exponent' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)\n"
		"@li 'multiplier' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)\n"
		"@li 'scale' (required in SBML Level&nbsp;3; optional in Level&nbsp;2)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Unit_swigregister", Unit_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfUnits_clone", _wrap_ListOfUnits_clone, METH_VARARGS, (char *)"\n"
		"ListOfUnits_clone(ListOfUnits self) -> ListOfUnits\n"
		"\n"
		"Creates and returns a deep copy of this ListOfUnits.\n"
		"\n"
		"@return a (deep) copy of this ListOfUnits.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnits_getTypeCode", _wrap_ListOfUnits_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfUnits_getTypeCode(ListOfUnits self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnits_getItemTypeCode", _wrap_ListOfUnits_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfUnits_getItemTypeCode(ListOfUnits self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Unit objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnits_getElementName", _wrap_ListOfUnits_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfUnits_getElementName(ListOfUnits self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfUnits, the XML element name is @c 'listOfUnits'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfUnits'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnits_get", _wrap_ListOfUnits_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Unit\n"
		"ListOfUnits_get(ListOfUnits self, unsigned int n) -> Unit\n"
		"\n"
		"Get a Unit from the ListOfUnits.\n"
		"\n"
		"@param n the index number of the Unit to get.\n"
		"\n"
		"@return the nth Unit in this ListOfUnits.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnits_remove", _wrap_ListOfUnits_remove, METH_VARARGS, (char *)"\n"
		"ListOfUnits_remove(ListOfUnits self, unsigned int n) -> Unit\n"
		"\n"
		"Removes the nth item from this ListOfUnits items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfUnits", _wrap_new_ListOfUnits, METH_VARARGS, (char *)"new_ListOfUnits() -> ListOfUnits"},
	 { (char *)"delete_ListOfUnits", _wrap_delete_ListOfUnits, METH_VARARGS, (char *)"delete_ListOfUnits(ListOfUnits self)"},
	 { (char *)"ListOfUnits_swigregister", ListOfUnits_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_UnitDefinition", _wrap_delete_UnitDefinition, METH_VARARGS, (char *)"delete_UnitDefinition(UnitDefinition self)"},
	 { (char *)"new_UnitDefinition", _wrap_new_UnitDefinition, METH_VARARGS, (char *)"\n"
		"UnitDefinition(unsigned int level, unsigned int version)\n"
		"UnitDefinition(SBMLNamespaces sbmlns)\n"
		"new_UnitDefinition(UnitDefinition orig) -> UnitDefinition\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>UnitDefinition(long level, long version)</pre>\n"
		"\n"
		"Creates a new UnitDefinition using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this UnitDefinition\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"UnitDefinition\n"
		"\n"
		"@note Upon the addition of a UnitDefinition object to an SBMLDocument\n"
		"(e.g., using Model.addUnitDefinition()), the SBML Level, SBML Version\n"
		"and XML namespace of the document @em override the values used\n"
		"when creating the UnitDefinition object via this constructor.  This is\n"
		"necessary to ensure that an SBML document is a consistent structure.\n"
		"Nevertheless, the ability to supply the values at the time of creation\n"
		"of a UnitDefinition is an important aid to producing valid SBML.\n"
		"Knowledge of the intented SBML Level and Version determine whether it\n"
		"is valid to assign a particular value to an attribute, or whether it\n"
		"is valid to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>UnitDefinition(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new UnitDefinition using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a UnitDefinition object to an SBMLDocument\n"
		"(e.g., using Model.addUnitDefinition()), the SBML XML namespace of\n"
		"the document @em overrides the value used when creating the\n"
		"UnitDefinition object via this constructor.  This is necessary to\n"
		"ensure that an SBML document is a consistent structure.  Nevertheless,\n"
		"the ability to supply the values at the time of creation of a\n"
		"UnitDefinition is an important aid to producing valid SBML.  Knowledge\n"
		"of the intented SBML Level and Version determine whether it is valid\n"
		"to assign a particular value to an attribute, or whether it is valid\n"
		"to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>UnitDefinition(UnitDefinition orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this UnitDefinition.\n"
		" \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_clone", _wrap_UnitDefinition_clone, METH_VARARGS, (char *)"\n"
		"UnitDefinition_clone(UnitDefinition self) -> UnitDefinition\n"
		"\n"
		"Creates and returns a deep copy of this UnitDefinition.\n"
		"\n"
		"@return a (deep) copy of this UnitDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getId", _wrap_UnitDefinition_getId, METH_VARARGS, (char *)"\n"
		"UnitDefinition_getId(UnitDefinition self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this UnitDefinition.\n"
		"\n"
		"@return the id of this UnitDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getName", _wrap_UnitDefinition_getName, METH_VARARGS, (char *)"\n"
		"UnitDefinition_getName(UnitDefinition self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this UnitDefinition.\n"
		"\n"
		"@return the name of this UnitDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isSetId", _wrap_UnitDefinition_isSetId, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isSetId(UnitDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"UnitDefinition's 'id' attribute is set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this UnitDefinition is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isSetName", _wrap_UnitDefinition_isSetName, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isSetName(UnitDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"UnitDefinition's 'name' attribute is set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this UnitDefinition is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_setId", _wrap_UnitDefinition_setId, METH_VARARGS, (char *)"\n"
		"UnitDefinition_setId(UnitDefinition self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this UnitDefinition.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this UnitDefinition\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_setName", _wrap_UnitDefinition_setName, METH_VARARGS, (char *)"\n"
		"UnitDefinition_setName(UnitDefinition self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this UnitDefinition.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the UnitDefinition\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_unsetName", _wrap_UnitDefinition_unsetName, METH_VARARGS, (char *)"\n"
		"UnitDefinition_unsetName(UnitDefinition self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this UnitDefinition.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfArea", _wrap_UnitDefinition_isVariantOfArea, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfArea(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit identifier @c 'area'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of the predefined\n"
		"unit @c area, meaning square metres with only abritrary variations\n"
		"in scale or multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfLength", _wrap_UnitDefinition_isVariantOfLength, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfLength(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit identifier @c 'length'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of the predefined\n"
		"unit @c length, meaning metres with only abritrary variations in scale\n"
		"or multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfSubstance", _wrap_UnitDefinition_isVariantOfSubstance, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfSubstance(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit identifier @c 'substance'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of the predefined\n"
		"unit @c substance, meaning moles or items (and grams or kilograms from\n"
		"SBML Level&nbsp;2 Version&nbsp;2 onwards) with only abritrary variations\n"
		"in scale or multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfTime", _wrap_UnitDefinition_isVariantOfTime, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfTime(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit identifier @c 'time'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of the predefined\n"
		"unit @c time, meaning seconds with only abritrary variations in scale or\n"
		"multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfVolume", _wrap_UnitDefinition_isVariantOfVolume, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfVolume(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit identifier @c 'volume'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of the predefined\n"
		"unit @c volume, meaning litre or cubic metre with only abritrary\n"
		"variations in scale or multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfDimensionless", _wrap_UnitDefinition_isVariantOfDimensionless, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfDimensionless(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the unit @c 'dimensionless'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of @c\n"
		"dimensionless, meaning dimensionless with only abritrary variations in\n"
		"scale or multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfMass", _wrap_UnitDefinition_isVariantOfMass, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfMass(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit identifier @c 'mass'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of mass units,\n"
		"meaning gram or kilogram with only abritrary variations in scale or\n"
		"multiplier values; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_isVariantOfSubstancePerTime", _wrap_UnitDefinition_isVariantOfSubstancePerTime, METH_VARARGS, (char *)"\n"
		"UnitDefinition_isVariantOfSubstancePerTime(UnitDefinition self) -> bool\n"
		"\n"
		"Convenience function for testing if a given unit definition is a\n"
		"variant of the predefined unit @c 'substance' divided by the predefined\n"
		"unit @c 'time'.\n"
		"\n"
		"@return @c true if this UnitDefinition is a variant of the predefined\n"
		"unit @c substance per predefined unit @c time, meaning it contains two\n"
		"units one of which is a variant of substance and the other is a\n"
		"variant of time which an exponent of -1; @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_addUnit", _wrap_UnitDefinition_addUnit, METH_VARARGS, (char *)"\n"
		"UnitDefinition_addUnit(UnitDefinition self, Unit u) -> int\n"
		"\n"
		"Adds a copy of the given Unit to this UnitDefinition.\n"
		"\n"
		"@param u the Unit instance to add to this UnitDefinition.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this UnitDefinition.  Changes made to the original\n"
		"object instance (such as resetting attribute values) will <em>not\n"
		"affect the instance in the UnitDefinition</em>.  In addition, the\n"
		"caller should make sure to free the original object if it is no longer\n"
		"being used, or else a memory leak will result.  Please see\n"
		"UnitDefinition.createUnit() for a method that does not lead to these\n"
		"issues.\n"
		"\n"
		"@see createUnit()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_createUnit", _wrap_UnitDefinition_createUnit, METH_VARARGS, (char *)"\n"
		"UnitDefinition_createUnit(UnitDefinition self) -> Unit\n"
		"\n"
		"Creates a new and empty Unit, adds it to this UnitDefinition's list of\n"
		"units, and returns it.\n"
		"\n"
		"@return a newly constructed (and empty) Unit instance.\n"
		"\n"
		"@note It is worth emphasizing that the attribute 'kind' value of a\n"
		"Unit is a required attribute for a valid Unit definition.  The\n"
		"createUnit() method does not assign a valid kind to the constructed\n"
		"unit (instead, it sets the 'kind' to @link libsbml.UNIT_KIND_INVALID UNIT_KIND_INVALID@endlink).\n"
		"Callers are cautioned to set the newly-constructed Unit's kind using\n"
		"Unit.setKind() soon after calling this method.\n"
		"\n"
		"@see addUnit()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getListOfUnits", _wrap_UnitDefinition_getListOfUnits, METH_VARARGS, (char *)"\n"
		"getListOfUnits() -> ListOfUnits\n"
		"UnitDefinition_getListOfUnits(UnitDefinition self) -> ListOfUnits\n"
		"\n"
		"Returns the list of Units for this UnitDefinition instance.\n"
		"@return the ListOfUnits value for this UnitDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getUnit", _wrap_UnitDefinition_getUnit, METH_VARARGS, (char *)"\n"
		"getUnit(unsigned int n) -> Unit\n"
		"UnitDefinition_getUnit(UnitDefinition self, unsigned int n) -> Unit\n"
		"\n"
		"Returns a specific Unit instance belonging to this UnitDefinition.\n"
		"\n"
		"@param n an integer, the index of the Unit to be returned.\n"
		"\n"
		"@return the nth Unit of this UnitDefinition.\n"
		"\n"
		"@see getNumUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getNumUnits", _wrap_UnitDefinition_getNumUnits, METH_VARARGS, (char *)"\n"
		"UnitDefinition_getNumUnits(UnitDefinition self) -> unsigned int\n"
		"\n"
		"Returns the number of Unit objects contained within this\n"
		"UnitDefinition.\n"
		"\n"
		"@return an integer representing the number of Units in this\n"
		"UnitDefinition.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_removeUnit", _wrap_UnitDefinition_removeUnit, METH_VARARGS, (char *)"\n"
		"UnitDefinition_removeUnit(UnitDefinition self, unsigned int n) -> Unit\n"
		"\n"
		"Removes the nth Unit object from this UnitDefinition object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the Unit object to remove\n"
		"\n"
		"@return the Unit object removed, or @c None if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getTypeCode", _wrap_UnitDefinition_getTypeCode, METH_VARARGS, (char *)"\n"
		"UnitDefinition_getTypeCode(UnitDefinition self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_getElementName", _wrap_UnitDefinition_getElementName, METH_VARARGS, (char *)"\n"
		"UnitDefinition_getElementName(UnitDefinition self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for UnitDefinition,\n"
		"is always @c 'unitDefinition'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'unitDefinition'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_simplify", _wrap_UnitDefinition_simplify, METH_VARARGS, (char *)"\n"
		"UnitDefinition_simplify(UnitDefinition ud)\n"
		"\n"
		"Simplifies the UnitDefinition such that any given kind of Unit object\n"
		"occurs only once in the ListOfUnits.\n"
		"\n"
		"For example, the following definition,\n"
		"@code\n"
		"<unitDefinition>\n"
		" <listOfUnits>\n"
		"   <unit kind='metre' exponent='1'/>\n"
		"   <unit kind='metre' exponent='2'/>\n"
		" </listOfUnits>\n"
		"<unitDefinition>\n"
		"@endcode\n"
		"will be simplified to \n"
		"@code\n"
		"<unitDefinition>\n"
		"  <listOfUnits>\n"
		"    <unit kind='metre' exponent='3'/>\n"
		"  </listOfUnits>\n"
		"<unitDefinition>\n"
		"@endcode\n"
		"\n"
		"@param ud the UnitDefinition object to be simplified.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_reorder", _wrap_UnitDefinition_reorder, METH_VARARGS, (char *)"\n"
		"UnitDefinition_reorder(UnitDefinition ud)\n"
		"\n"
		"Alphabetically orders the Unit objects within the ListOfUnits of a\n"
		"UnitDefinition.\n"
		"\n"
		"@param ud the UnitDefinition object whose units are to be reordered.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_convertToSI", _wrap_UnitDefinition_convertToSI, METH_VARARGS, (char *)"\n"
		"UnitDefinition_convertToSI(UnitDefinition ud) -> UnitDefinition\n"
		"\n"
		"Convert a given UnitDefinition into a new UnitDefinition object\n"
		"that uses SI units.\n"
		"\n"
		"@param ud the UnitDefinition object to convert to SI\n"
		"\n"
		"@return a new UnitDefinition object representing the results of the\n"
		"conversion.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_areIdentical", _wrap_UnitDefinition_areIdentical, METH_VARARGS, (char *)"\n"
		"UnitDefinition_areIdentical(UnitDefinition ud1, UnitDefinition ud2) -> bool\n"
		"\n"
		"Predicate returning @c true if two\n"
		"UnitDefinition objects are identical.\n"
		"\n"
		"For the purposes of performing this comparison, two UnitDefinition\n"
		"objects are considered identical when they contain identical lists of\n"
		"Unit objects.  Pairs of Unit objects in the lists are in turn\n"
		"considered identical if they satisfy the predicate\n"
		"Unit.areIdentical().\n"
		"The predicate compares every attribute of the\n"
		"Unit objects.\n"
		"\n"
		"@param ud1 the first UnitDefinition object to compare\n"
		"@param ud2 the second UnitDefinition object to compare\n"
		"\n"
		"@return @c true if all the Unit objects in ud1 are identical to the\n"
		"Unit objects of ud2, @c false otherwise.\n"
		"\n"
		"@see areEquivalent()\n"
		"@see Unit.areIdentical()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_areEquivalent", _wrap_UnitDefinition_areEquivalent, METH_VARARGS, (char *)"\n"
		"UnitDefinition_areEquivalent(UnitDefinition ud1, UnitDefinition ud2) -> bool\n"
		"\n"
		"Predicate returning @c true if two\n"
		"UnitDefinition objects are equivalent.\n"
		"\n"
		"For the purposes of performing this comparison, two UnitDefinition\n"
		"objects are considered equivalent when they contain @em equivalent\n"
		"list of Unit objects.  Unit objects are in turn considered equivalent\n"
		"if they satisfy the predicate\n"
		"Unit.areEquivalent().\n"
		"The predicate tests a subset of the objects's attributes.\n"
		"\n"
		"@param ud1 the first UnitDefinition object to compare\n"
		"\n"
		"@param ud2 the second UnitDefinition object to compare\n"
		"\n"
		"@return @c true if all the Unit objects in ud1 are equivalent\n"
		"to the Unit objects in ud2, @c false otherwise.\n"
		"\n"
		"@see areIdentical()\n"
		"@see Unit.areEquivalent()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_combine", _wrap_UnitDefinition_combine, METH_VARARGS, (char *)"\n"
		"UnitDefinition_combine(UnitDefinition ud1, UnitDefinition ud2) -> UnitDefinition\n"
		"\n"
		"Combines two UnitDefinition objects into a single UnitDefinition.\n"
		"\n"
		"This takes UnitDefinition objects @p ud1 and @p ud2, and creates a\n"
		"UnitDefinition object that expresses the product of the units of @p\n"
		"ud1 and @p ud2.\n"
		"\n"
		"@param ud1 the first UnitDefinition object \n"
		"@param ud2 the second UnitDefinition object\n"
		"\n"
		"@return a UnitDefinition which represents the product of the \n"
		"units of the two argument UnitDefinitions.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_printUnits", _wrap_UnitDefinition_printUnits, METH_VARARGS, (char *)"\n"
		"printUnits(UnitDefinition ud, bool compact = False) -> string\n"
		"UnitDefinition_printUnits(UnitDefinition ud) -> string\n"
		"\n"
		"Expresses the given definition in a plain-text form.\n"
		"\n"
		"For example,\n"
		"UnitDefinition.printUnits()\n"
		"applied to\n"
		"@code\n"
		"<unitDefinition>\n"
		" <listOfUnits>\n"
		"   <unit kind='metre' exponent='1'/>\n"
		"   <unit kind='second' exponent='-2'/>\n"
		" </listOfUnits>\n"
		"<unitDefinition>\n"
		"@endcode\n"
		"will return the string <code>'metre (exponent = 1, multiplier = 1,\n"
		"scale = 0) second (exponent = -2, multiplier = 1, scale = 0)'</code>\n"
		"or, if the optional parameter @p compact is given the value @c true,\n"
		"the string <code>'(1 metre)^1 (1 second)^-2'</code>.  This method may\n"
		"be useful for printing unit information to human users, or in\n"
		"debugging software, or other situations.\n"
		"\n"
		"@param ud the UnitDefinition object\n"
		"@param compact boolean indicating whether the compact form\n"
		"should be used (defaults to false)\n"
		"\n"
		"@return a string expressing the unit definition defined by the given\n"
		"UnitDefinition object @p ud.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_hasRequiredAttributes", _wrap_UnitDefinition_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"UnitDefinition_hasRequiredAttributes(UnitDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this UnitDefinition object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a UnitDefinition object are:\n"
		"@li 'id'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_hasRequiredElements", _wrap_UnitDefinition_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"UnitDefinition_hasRequiredElements(UnitDefinition self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this UnitDefinition object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Constraint object are:\n"
		"@li 'listOfUnits' (required in SBML Level&nbsp;2 only, optional in Level&nbsp;3)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"UnitDefinition_swigregister", UnitDefinition_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfUnitDefinitions_clone", _wrap_ListOfUnitDefinitions_clone, METH_VARARGS, (char *)"\n"
		"ListOfUnitDefinitions_clone(ListOfUnitDefinitions self) -> ListOfUnitDefinitions\n"
		"\n"
		"Creates and returns a deep copy of this ListOfUnitDefinitions instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfUnitDefinitions.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnitDefinitions_getTypeCode", _wrap_ListOfUnitDefinitions_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfUnitDefinitions_getTypeCode(ListOfUnitDefinitions self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnitDefinitions_getItemTypeCode", _wrap_ListOfUnitDefinitions_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfUnitDefinitions_getItemTypeCode(ListOfUnitDefinitions self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., UnitDefinition objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnitDefinitions_getElementName", _wrap_ListOfUnitDefinitions_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfUnitDefinitions_getElementName(ListOfUnitDefinitions self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfUnitDefinitions, the XML element name is @c\n"
		"'listOfUnitDefinitions'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfUnitDefinitions'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnitDefinitions_get", _wrap_ListOfUnitDefinitions_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> UnitDefinition\n"
		"get(unsigned int n) -> UnitDefinition\n"
		"get(string sid) -> UnitDefinition\n"
		"ListOfUnitDefinitions_get(ListOfUnitDefinitions self, string sid) -> UnitDefinition\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a UnitDefinition from the ListOfUnitDefinitions.\n"
		"\n"
		"@param n the index number of the UnitDefinition to get.\n"
		"\n"
		"@return the nth UnitDefinition in this ListOfUnitDefinitions.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a UnitDefinition from the ListOfUnitDefinitions.\n"
		"\n"
		"@param n the index number of the UnitDefinition to get.\n"
		"\n"
		"@return the nth UnitDefinition in this ListOfUnitDefinitions.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a UnitDefinition from the ListOfUnitDefinitions\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the UnitDefinition to get.\n"
		"\n"
		"@return UnitDefinition in this ListOfUnitDefinitions\n"
		"with the given id or @c None if no such\n"
		"UnitDefinition exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a UnitDefinition from the ListOfUnitDefinitions\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the UnitDefinition to get.\n"
		"\n"
		"@return UnitDefinition in this ListOfUnitDefinitions\n"
		"with the given id or @c None if no such\n"
		"UnitDefinition exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfUnitDefinitions_remove", _wrap_ListOfUnitDefinitions_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> UnitDefinition\n"
		"ListOfUnitDefinitions_remove(ListOfUnitDefinitions self, string sid) -> UnitDefinition\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfUnitDefinitions items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes item in this ListOfUnitDefinitions items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"None is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfUnitDefinitions", _wrap_new_ListOfUnitDefinitions, METH_VARARGS, (char *)"new_ListOfUnitDefinitions() -> ListOfUnitDefinitions"},
	 { (char *)"delete_ListOfUnitDefinitions", _wrap_delete_ListOfUnitDefinitions, METH_VARARGS, (char *)"delete_ListOfUnitDefinitions(ListOfUnitDefinitions self)"},
	 { (char *)"ListOfUnitDefinitions_swigregister", ListOfUnitDefinitions_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_CompartmentType", _wrap_delete_CompartmentType, METH_VARARGS, (char *)"delete_CompartmentType(CompartmentType self)"},
	 { (char *)"new_CompartmentType", _wrap_new_CompartmentType, METH_VARARGS, (char *)"\n"
		"CompartmentType(unsigned int level, unsigned int version)\n"
		"CompartmentType(SBMLNamespaces sbmlns)\n"
		"new_CompartmentType(CompartmentType orig) -> CompartmentType\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>CompartmentType(long level, long version)</pre>\n"
		"\n"
		"Creates a new CompartmentType using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this CompartmentType\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"CompartmentType\n"
		"\n"
		"@note Upon the addition of a CompartmentType object to an SBMLDocument\n"
		"(e.g., using Model.addCompartmentType()), the SBML Level, SBML\n"
		"Version and XML namespace of the document @em override the\n"
		"values used when creating the CompartmentType object via this\n"
		"constructor.  This is necessary to ensure that an SBML document is a\n"
		"consistent structure.  Nevertheless, the ability to supply the values\n"
		"at the time of creation of a CompartmentType is an important aid to\n"
		"producing valid SBML.  Knowledge of the intented SBML Level and\n"
		"Version determine whether it is valid to assign a particular value to\n"
		"an attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>CompartmentType(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new CompartmentType using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"It is worth emphasizing that although this constructor does not take\n"
		"an identifier argument, in SBML Level&nbsp;2 and beyond, the 'id'\n"
		"(identifier) attribute of a CompartmentType is required to have a value.\n"
		"Thus, callers are cautioned to assign a value after calling this\n"
		"constructor.  Setting the identifier can be accomplished using the\n"
		"method setId(@if java String id@endif).\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a CompartmentType object to an SBMLDocument\n"
		"(e.g., using Model.addCompartmentType()), the SBML XML namespace of\n"
		"the document @em overrides the value used when creating the\n"
		"CompartmentType object via this constructor.  This is necessary to\n"
		"ensure that an SBML document is a consistent structure.  Nevertheless,\n"
		"the ability to supply the values at the time of creation of a\n"
		"CompartmentType is an important aid to producing valid SBML.\n"
		"Knowledge of the intented SBML Level and Version determine whether it\n"
		"is valid to assign a particular value to an attribute, or whether it\n"
		"is valid to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>CompartmentType(CompartmentType orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this CompartmentType.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_clone", _wrap_CompartmentType_clone, METH_VARARGS, (char *)"\n"
		"CompartmentType_clone(CompartmentType self) -> CompartmentType\n"
		"\n"
		"Creates and returns a deep copy of this CompartmentType.\n"
		"\n"
		"@return a (deep) copy of this CompartmentType.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_getId", _wrap_CompartmentType_getId, METH_VARARGS, (char *)"\n"
		"CompartmentType_getId(CompartmentType self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this CompartmentType.\n"
		"\n"
		"@return the id of this CompartmentType.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_getName", _wrap_CompartmentType_getName, METH_VARARGS, (char *)"\n"
		"CompartmentType_getName(CompartmentType self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this CompartmentType.\n"
		"\n"
		"@return the name of this CompartmentType.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_isSetId", _wrap_CompartmentType_isSetId, METH_VARARGS, (char *)"\n"
		"CompartmentType_isSetId(CompartmentType self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"CompartmentType's 'id' attribute is set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this CompartmentType is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_isSetName", _wrap_CompartmentType_isSetName, METH_VARARGS, (char *)"\n"
		"CompartmentType_isSetName(CompartmentType self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"CompartmentType's 'name' attribute is set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this CompartmentTypeType is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_setId", _wrap_CompartmentType_setId, METH_VARARGS, (char *)"\n"
		"CompartmentType_setId(CompartmentType self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this CompartmentType.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this CompartmentType\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_setName", _wrap_CompartmentType_setName, METH_VARARGS, (char *)"\n"
		"CompartmentType_setName(CompartmentType self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this CompartmentType.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the CompartmentType\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_unsetName", _wrap_CompartmentType_unsetName, METH_VARARGS, (char *)"\n"
		"CompartmentType_unsetName(CompartmentType self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this CompartmentType.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_getTypeCode", _wrap_CompartmentType_getTypeCode, METH_VARARGS, (char *)"\n"
		"CompartmentType_getTypeCode(CompartmentType self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_getElementName", _wrap_CompartmentType_getElementName, METH_VARARGS, (char *)"\n"
		"CompartmentType_getElementName(CompartmentType self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for\n"
		"CompartmentType, is always @c 'compartmentType'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'compartmentType'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_hasRequiredAttributes", _wrap_CompartmentType_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"CompartmentType_hasRequiredAttributes(CompartmentType self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this CompartmentType object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a CompartmentType object are:\n"
		"@li 'id'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CompartmentType_swigregister", CompartmentType_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfCompartmentTypes_clone", _wrap_ListOfCompartmentTypes_clone, METH_VARARGS, (char *)"\n"
		"ListOfCompartmentTypes_clone(ListOfCompartmentTypes self) -> ListOfCompartmentTypes\n"
		"\n"
		"Creates and returns a deep copy of this ListOfCompartmentTypes instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfCompartmentTypes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartmentTypes_getTypeCode", _wrap_ListOfCompartmentTypes_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfCompartmentTypes_getTypeCode(ListOfCompartmentTypes self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartmentTypes_getItemTypeCode", _wrap_ListOfCompartmentTypes_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfCompartmentTypes_getItemTypeCode(ListOfCompartmentTypes self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., CompartmentType objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartmentTypes_getElementName", _wrap_ListOfCompartmentTypes_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfCompartmentTypes_getElementName(ListOfCompartmentTypes self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfCompartmentTypes, the XML element name is @c\n"
		"'listOfCompartmentTypes'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfCompartmentTypes'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartmentTypes_get", _wrap_ListOfCompartmentTypes_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> CompartmentType\n"
		"get(unsigned int n) -> CompartmentType\n"
		"get(string sid) -> CompartmentType\n"
		"ListOfCompartmentTypes_get(ListOfCompartmentTypes self, string sid) -> CompartmentType\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a CompartmentType from the ListOfCompartmentTypes.\n"
		"\n"
		"@param n the index number of the CompartmentType to get.\n"
		"\n"
		"@return the nth CompartmentType in this ListOfCompartmentTypes.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a CompartmentType from the ListOfCompartmentTypes.\n"
		"\n"
		"@param n the index number of the CompartmentType to get.\n"
		"\n"
		"@return the nth CompartmentType in this ListOfCompartmentTypes.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a CompartmentType from the ListOfCompartmentTypes\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the CompartmentType to get.\n"
		"\n"
		"@return CompartmentType in this ListOfCompartmentTypes\n"
		"with the given id or @c None if no such\n"
		"CompartmentType exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a CompartmentType from the ListOfCompartmentTypes\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the CompartmentType to get.\n"
		"\n"
		"@return CompartmentType in this ListOfCompartmentTypes\n"
		"with the given id or @c None if no such\n"
		"CompartmentType exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartmentTypes_remove", _wrap_ListOfCompartmentTypes_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> CompartmentType\n"
		"ListOfCompartmentTypes_remove(ListOfCompartmentTypes self, string sid) -> CompartmentType\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfCompartmentTypes items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes item in this ListOfCompartmentTypes items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"None is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfCompartmentTypes", _wrap_new_ListOfCompartmentTypes, METH_VARARGS, (char *)"new_ListOfCompartmentTypes() -> ListOfCompartmentTypes"},
	 { (char *)"delete_ListOfCompartmentTypes", _wrap_delete_ListOfCompartmentTypes, METH_VARARGS, (char *)"delete_ListOfCompartmentTypes(ListOfCompartmentTypes self)"},
	 { (char *)"ListOfCompartmentTypes_swigregister", ListOfCompartmentTypes_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_SpeciesType", _wrap_delete_SpeciesType, METH_VARARGS, (char *)"delete_SpeciesType(SpeciesType self)"},
	 { (char *)"new_SpeciesType", _wrap_new_SpeciesType, METH_VARARGS, (char *)"\n"
		"SpeciesType(unsigned int level, unsigned int version)\n"
		"SpeciesType(SBMLNamespaces sbmlns)\n"
		"new_SpeciesType(SpeciesType orig) -> SpeciesType\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>SpeciesType(long level, long version)</pre>\n"
		"\n"
		"Creates a new SpeciesType using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this SpeciesType\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"SpeciesType\n"
		"\n"
		"@note Upon the addition of a SpeciesType object to an SBMLDocument\n"
		"(e.g., using Model.addSpeciesType()),\n"
		"the SBML Level, SBML Version and XML namespace of the document @em\n"
		"override the values used when creating the SpeciesType object via this\n"
		"constructor.  This is necessary to ensure that an SBML document is a\n"
		"consistent structure.  Nevertheless, the ability to supply the values\n"
		"at the time of creation of a SpeciesType is an important aid to\n"
		"producing valid SBML.  Knowledge of the intented SBML Level and\n"
		"Version determine whether it is valid to assign a particular value to\n"
		"an attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>SpeciesType(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new SpeciesType using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"It is worth emphasizing that although this constructor does not take\n"
		"an identifier argument, in SBML Level&nbsp;2 and beyond, the 'id'\n"
		"(identifier) attribute of a SpeciesType object is required to have a value.\n"
		"Thus, callers are cautioned to assign a value after calling this\n"
		"constructor.  Setting the identifier can be accomplished using the\n"
		"method SBase.setId().\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a SpeciesType object to an SBMLDocument\n"
		"(e.g., using Model.addSpeciesType()),\n"
		"the SBML XML namespace of the document @em overrides the value used\n"
		"when creating the SpeciesType object via this constructor.  This is\n"
		"necessary to ensure that an SBML document is a consistent structure.\n"
		"Nevertheless, the ability to supply the values at the time of creation\n"
		"of a SpeciesType is an important aid to producing valid SBML.\n"
		"Knowledge of the intented SBML Level and Version determine whether it\n"
		"is valid to assign a particular value to an attribute, or whether it\n"
		"is valid to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>SpeciesType(SpeciesType orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this SpeciesType.\n"
		" \n"
		"\n"
		""},
	 { (char *)"SpeciesType_clone", _wrap_SpeciesType_clone, METH_VARARGS, (char *)"\n"
		"SpeciesType_clone(SpeciesType self) -> SpeciesType\n"
		"\n"
		"Creates and returns a deep copy of this SpeciesType.\n"
		"\n"
		"@return a (deep) copy of this SpeciesType.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_getId", _wrap_SpeciesType_getId, METH_VARARGS, (char *)"\n"
		"SpeciesType_getId(SpeciesType self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this SpeciesType.\n"
		"\n"
		"@return the id of this SpeciesType.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_getName", _wrap_SpeciesType_getName, METH_VARARGS, (char *)"\n"
		"SpeciesType_getName(SpeciesType self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this SpeciesType.\n"
		"\n"
		"@return the name of this SpeciesType.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_isSetId", _wrap_SpeciesType_isSetId, METH_VARARGS, (char *)"\n"
		"SpeciesType_isSetId(SpeciesType self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SpeciesType's 'id' attribute is set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this SpeciesType is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_isSetName", _wrap_SpeciesType_isSetName, METH_VARARGS, (char *)"\n"
		"SpeciesType_isSetName(SpeciesType self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SpeciesType's 'name' attribute is set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this SpeciesType is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_setId", _wrap_SpeciesType_setId, METH_VARARGS, (char *)"\n"
		"SpeciesType_setId(SpeciesType self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this SpeciesType.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this SpeciesType\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_setName", _wrap_SpeciesType_setName, METH_VARARGS, (char *)"\n"
		"SpeciesType_setName(SpeciesType self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this SpeciesType.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the SpeciesType\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_unsetName", _wrap_SpeciesType_unsetName, METH_VARARGS, (char *)"\n"
		"SpeciesType_unsetName(SpeciesType self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this SpeciesType.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_getTypeCode", _wrap_SpeciesType_getTypeCode, METH_VARARGS, (char *)"\n"
		"SpeciesType_getTypeCode(SpeciesType self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_getElementName", _wrap_SpeciesType_getElementName, METH_VARARGS, (char *)"\n"
		"SpeciesType_getElementName(SpeciesType self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for\n"
		"SpeciesType, is always @c 'compartmentType'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'compartmentType'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_hasRequiredAttributes", _wrap_SpeciesType_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"SpeciesType_hasRequiredAttributes(SpeciesType self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this SpeciesType object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a SpeciesType object are:\n"
		"@li 'id'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesType_swigregister", SpeciesType_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfSpeciesTypes_clone", _wrap_ListOfSpeciesTypes_clone, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesTypes_clone(ListOfSpeciesTypes self) -> ListOfSpeciesTypes\n"
		"\n"
		"Creates and returns a deep copy of this ListOfSpeciesTypes instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfSpeciesTypes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesTypes_getTypeCode", _wrap_ListOfSpeciesTypes_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesTypes_getTypeCode(ListOfSpeciesTypes self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesTypes_getItemTypeCode", _wrap_ListOfSpeciesTypes_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesTypes_getItemTypeCode(ListOfSpeciesTypes self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., SpeciesType objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesTypes_getElementName", _wrap_ListOfSpeciesTypes_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesTypes_getElementName(ListOfSpeciesTypes self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfSpeciesTypes, the XML element name is @c\n"
		"'listOfSpeciesTypes'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfSpeciesTypes'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesTypes_get", _wrap_ListOfSpeciesTypes_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> SpeciesType\n"
		"get(unsigned int n) -> SpeciesType\n"
		"get(string sid) -> SpeciesType\n"
		"ListOfSpeciesTypes_get(ListOfSpeciesTypes self, string sid) -> SpeciesType\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a SpeciesType from the ListOfSpeciesTypes.\n"
		"\n"
		"@param n the index number of the SpeciesType to get.\n"
		"\n"
		"@return the nth SpeciesType in this ListOfSpeciesTypes.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a SpeciesType from the ListOfSpeciesTypes.\n"
		"\n"
		"@param n the index number of the SpeciesType to get.\n"
		"\n"
		"@return the nth SpeciesType in this ListOfSpeciesTypes.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a SpeciesType from the ListOfSpeciesTypes\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the SpeciesType to get.\n"
		"\n"
		"@return SpeciesType in this ListOfSpeciesTypes\n"
		"with the given id or @c None if no such\n"
		"SpeciesType exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a SpeciesType from the ListOfSpeciesTypes\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the SpeciesType to get.\n"
		"\n"
		"@return SpeciesType in this ListOfSpeciesTypes\n"
		"with the given id or @c None if no such\n"
		"SpeciesType exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesTypes_remove", _wrap_ListOfSpeciesTypes_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> SpeciesType\n"
		"ListOfSpeciesTypes_remove(ListOfSpeciesTypes self, string sid) -> SpeciesType\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfSpeciesTypes items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes item in this ListOfSpeciesTypes items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"None is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfSpeciesTypes", _wrap_new_ListOfSpeciesTypes, METH_VARARGS, (char *)"new_ListOfSpeciesTypes() -> ListOfSpeciesTypes"},
	 { (char *)"delete_ListOfSpeciesTypes", _wrap_delete_ListOfSpeciesTypes, METH_VARARGS, (char *)"delete_ListOfSpeciesTypes(ListOfSpeciesTypes self)"},
	 { (char *)"ListOfSpeciesTypes_swigregister", ListOfSpeciesTypes_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Compartment", _wrap_delete_Compartment, METH_VARARGS, (char *)"delete_Compartment(Compartment self)"},
	 { (char *)"new_Compartment", _wrap_new_Compartment, METH_VARARGS, (char *)"\n"
		"Compartment(unsigned int level, unsigned int version)\n"
		"Compartment(SBMLNamespaces sbmlns)\n"
		"new_Compartment(Compartment orig) -> Compartment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Compartment(long level, long version)</pre>\n"
		"\n"
		"Creates a new Compartment using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this Compartment\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"Compartment\n"
		"\n"
		"@note Upon the addition of a Compartment object to an SBMLDocument\n"
		"(e.g., using Model.addCompartment()), the SBML Level, SBML Version\n"
		"and XML namespace of the document @em override the values used\n"
		"when creating the Compartment object via this constructor.  This is\n"
		"necessary to ensure that an SBML document is a consistent structure.\n"
		"Nevertheless, the ability to supply the values at the time of creation\n"
		"of a Compartment is an important aid to producing valid SBML.\n"
		"Knowledge of the intented SBML Level and Version determine whether it\n"
		"is valid to assign a particular value to an attribute, or whether it\n"
		"is valid to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Compartment(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new Compartment using the given SBMLNamespaces object \n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"It is worth emphasizing that although this constructor does not take\n"
		"an identifier argument, in SBML Level&nbsp;2 and beyond, the 'id'\n"
		"(identifier) attribute of a Compartment is required to have a value.\n"
		"Thus, callers are cautioned to assign a value after calling this\n"
		"constructor.  Setting the identifier can be accomplished using the\n"
		"method @if java Compartment.setId()@else setId()@endif.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a Compartment object to an SBMLDocument\n"
		"(e.g., using Model.addCompartment()), the SBML XML namespace of the\n"
		"document @em overrides the value used when creating the Compartment\n"
		"object via this constructor.  This is necessary to ensure that an SBML\n"
		"document is a consistent structure.  Nevertheless, the ability to\n"
		"supply the values at the time of creation of a Compartment is an\n"
		"important aid to producing valid SBML.  Knowledge of the intented SBML\n"
		"Level and Version determine whether it is valid to assign a particular\n"
		"value to an attribute, or whether it is valid to add an object to an\n"
		"existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Compartment(Compartment orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of a Compartment.\n"
		"\n"
		"@param orig the Compartment instance to copy.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_clone", _wrap_Compartment_clone, METH_VARARGS, (char *)"\n"
		"Compartment_clone(Compartment self) -> Compartment\n"
		"\n"
		"Creates and returns a deep copy of this Compartment object.\n"
		"\n"
		"@return a (deep) copy of this Compartment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_initDefaults", _wrap_Compartment_initDefaults, METH_VARARGS, (char *)"\n"
		"Compartment_initDefaults(Compartment self)\n"
		"\n"
		"Initializes the fields of this Compartment object to 'typical' default\n"
		"values.\n"
		"\n"
		"The SBML Compartment component has slightly different aspects and\n"
		"default attribute values in different SBML Levels and Versions.\n"
		"This method sets the values to certain common defaults, based\n"
		"mostly on what they are in SBML Level&nbsp;2.  Specifically:\n"
		"<ul>\n"
		"<li> Sets attribute 'spatialDimensions' to @c 3\n"
		"<li> Sets attribute 'constant' to @c true\n"
		"<li> (Applies to Level&nbsp;1 models only) Sets attribute 'volume' to @c 1.0\n"
		"<li> (Applies to Level&nbsp;3 models only) Sets attribute 'units' to @c litre\n"
		"</ul>\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getId", _wrap_Compartment_getId, METH_VARARGS, (char *)"\n"
		"Compartment_getId(Compartment self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this Compartment object.\n"
		"\n"
		"@return the id of this Compartment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getName", _wrap_Compartment_getName, METH_VARARGS, (char *)"\n"
		"Compartment_getName(Compartment self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this Compartment object.\n"
		"\n"
		"@return the name of this Compartment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getCompartmentType", _wrap_Compartment_getCompartmentType, METH_VARARGS, (char *)"\n"
		"Compartment_getCompartmentType(Compartment self) -> string\n"
		"\n"
		"Get the value of the 'compartmentType' attribute of this Compartment\n"
		"object.\n"
		"\n"
		"@return the value of the 'compartmentType' attribute of this\n"
		"Compartment as a string.\n"
		"\n"
		"@note The 'compartmentType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getSpatialDimensions", _wrap_Compartment_getSpatialDimensions, METH_VARARGS, (char *)"\n"
		"Compartment_getSpatialDimensions(Compartment self) -> unsigned int\n"
		"\n"
		"Get the number of spatial dimensions of this Compartment object.\n"
		"\n"
		"@note In SBML Level&nbsp;3, the data type of the 'spatialDimensions'\n"
		"attribute is @c double, whereas in Level&nbsp;2, it is @c integer.\n"
		"LibSBML provides a separate method for obtaining the value as a double,\n"
		"for models where it is relevant.\n"
		"\n"
		"@return the value of the 'spatialDimensions' attribute of this\n"
		"Compartment as a long integereger\n"
		"\n"
		"@see getSpatialDimensionsAsDouble()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getSpatialDimensionsAsDouble", _wrap_Compartment_getSpatialDimensionsAsDouble, METH_VARARGS, (char *)"\n"
		"Compartment_getSpatialDimensionsAsDouble(Compartment self) -> double\n"
		"\n"
		"Get the number of spatial dimensions of this Compartment object\n"
		"as a double.\n"
		"\n"
		"@note In SBML Level&nbsp;3, the data type of the 'spatialDimensions'\n"
		"attribute is @c double, whereas in Level&nbsp;2, it is @c integer.  To\n"
		"avoid backward compatibility issues, libSBML provides a separate\n"
		"method for obtaining the value as a double, for models where it is\n"
		"relevant.\n"
		"\n"
		"@return the value of the 'spatialDimensions' attribute of this\n"
		"Compartment as a double, or @c NaN if this model is not in SBML\n"
		"Level&nbsp;3 format.\n"
		"\n"
		"@see getSpatialDimensions()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getSize", _wrap_Compartment_getSize, METH_VARARGS, (char *)"\n"
		"Compartment_getSize(Compartment self) -> double\n"
		"\n"
		"Get the size of this Compartment.\n"
		"\n"
		"This method is identical to\n"
		"@if java Compartment.getVolume()@else getVolume()@endif.\n"
		"In SBML Level&nbsp;1, compartments are always three-dimensional\n"
		"constructs and only have volumes, whereas in SBML Level&nbsp;2,\n"
		"compartments may be other than three-dimensional and therefore the\n"
		"'volume' attribute is named 'size' in Level&nbsp;2.  LibSBML provides\n"
		"both\n"
		"@if java Compartment.getSize()@else getSize()@endif and\n"
		"@if java Compartment.getVolume()@else getVolume()@endif for\n"
		"easier compatibility between SBML Levels.\n"
		"\n"
		"@return the value of the 'size' attribute ('volume' in Level&nbsp;1) of\n"
		"this Compartment as a float-point number.\n"
		"\n"
		"@see isSetSize()\n"
		"@see getVolume()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getVolume", _wrap_Compartment_getVolume, METH_VARARGS, (char *)"\n"
		"Compartment_getVolume(Compartment self) -> double\n"
		"\n"
		"Get the volume of this Compartment.\n"
		"\n"
		"This method is identical to\n"
		"@if java Compartment.getSize()@else getSize()@endif.  In\n"
		"SBML Level&nbsp;1, compartments are always three-dimensional\n"
		"constructs and only have volumes, whereas in SBML Level&nbsp;2,\n"
		"compartments may be other than three-dimensional and therefore the\n"
		"'volume' attribute is named 'size' in Level&nbsp;2.  LibSBML provides\n"
		"both\n"
		"@if java Compartment.getSize()@else getSize()@endif and\n"
		"@if java Compartment.getVolume()@else getVolume()@endif\n"
		"for easier compatibility between SBML Levels.\n"
		"\n"
		"@return the value of the 'volume' attribute ('size' in Level&nbsp;2) of\n"
		"this Compartment, as a floating-point number.\n"
		"\n"
		"@note The attribute 'volume' only exists by that name in SBML\n"
		"Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is\n"
		"named 'size'.\n"
		"\n"
		"@see isSetVolume()\n"
		"@see getSize()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getUnits", _wrap_Compartment_getUnits, METH_VARARGS, (char *)"\n"
		"Compartment_getUnits(Compartment self) -> string\n"
		"\n"
		"Get the units of this compartment's size.\n"
		"\n"
		"The value of an SBML compartment's 'units' attribute establishes the\n"
		"unit of measurement associated with the compartment's size.\n"
		"\n"
		"@return the value of the 'units' attribute of this Compartment, as a\n"
		"string.  An empty string indicates that no units have been assigned to\n"
		"the value of the size.\n"
		"\n"
		"@note @htmlinclude unassigned-units-are-not-a-default.html\n"
		"\n"
		"@see isSetUnits()\n"
		"@see @if java Compartment.setUnits()@else setUnits()@endif\n"
		"@see getSize()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getOutside", _wrap_Compartment_getOutside, METH_VARARGS, (char *)"\n"
		"Compartment_getOutside(Compartment self) -> string\n"
		"\n"
		"Get the identifier, if any, of the compartment that is designated\n"
		"as being outside of this one.\n"
		"\n"
		"@return the value of the 'outside' attribute of this Compartment.\n"
		"\n"
		"@note The 'outside' attribute is defined in SBML Level&nbsp;1 and\n"
		"Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1\n"
		"Core.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getConstant", _wrap_Compartment_getConstant, METH_VARARGS, (char *)"\n"
		"Compartment_getConstant(Compartment self) -> bool\n"
		"\n"
		"Get the value of the 'constant' attribute of this Compartment.\n"
		"\n"
		"@return @c true if this Compartment's size is flagged as being\n"
		"constant, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetId", _wrap_Compartment_isSetId, METH_VARARGS, (char *)"\n"
		"Compartment_isSetId(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'id' attribute is set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this Compartment is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetName", _wrap_Compartment_isSetName, METH_VARARGS, (char *)"\n"
		"Compartment_isSetName(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'name' attribute is set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this Compartment is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetCompartmentType", _wrap_Compartment_isSetCompartmentType, METH_VARARGS, (char *)"\n"
		"Compartment_isSetCompartmentType(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'compartmentType' attribute is set.\n"
		"\n"
		"@return @c true if the 'compartmentType' attribute of this Compartment\n"
		"is set, @c false otherwise.\n"
		"\n"
		"@note The 'compartmentType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetSize", _wrap_Compartment_isSetSize, METH_VARARGS, (char *)"\n"
		"Compartment_isSetSize(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'size' attribute is set.\n"
		"\n"
		"This method is similar but not identical to\n"
		"@if java Compartment.isSetVolume()@else isSetVolume()@endif.  The latter\n"
		"should be used in the context of SBML Level&nbsp;1 models instead of\n"
		"@if java Compartment.isSetSize()@else isSetSize()@endif\n"
		"because @if java Compartment.isSetVolume()@else isSetVolume()@endif\n"
		"performs extra processing to take into account the difference in\n"
		"default values between SBML Levels 1 and 2.\n"
		"\n"
		"@return @c true if the 'size' attribute ('volume' in Level&nbsp;2) of\n"
		"this Compartment is set, @c false otherwise.\n"
		"\n"
		"@see isSetVolume()\n"
		"@see setSize()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetVolume", _wrap_Compartment_isSetVolume, METH_VARARGS, (char *)"\n"
		"Compartment_isSetVolume(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this Compartment's\n"
		"'volume' attribute is set.\n"
		"\n"
		"This method is similar but not identical to\n"
		"@if java Compartment.isSetSize()@else isSetSize()@endif.  The latter\n"
		"should not be used in the context of SBML Level&nbsp;1 models because this\n"
		"method performs extra processing to take into account\n"
		"the difference in default values between SBML Levels 1 and 2.\n"
		"\n"
		"@return @c true if the 'volume' attribute ('size' in Level&nbsp;2 and\n"
		"above) of this Compartment is set, @c false otherwise.\n"
		"\n"
		"@note The attribute 'volume' only exists by that name in SBML\n"
		"Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is\n"
		"named 'size'.  In SBML Level&nbsp;1, a compartment's volume has a\n"
		"default value (@c 1.0) and therefore this method will always return @c\n"
		"true.  In Level 2, a compartment's size (the equivalent of SBML\n"
		"Level&nbsp;1's 'volume') is optional and has no default value, and\n"
		"therefore may or may not be set.\n"
		"\n"
		"@see isSetSize()\n"
		"@see @if java Compartment.setVolume()@else setVolume()@endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetUnits", _wrap_Compartment_isSetUnits, METH_VARARGS, (char *)"\n"
		"Compartment_isSetUnits(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'units' attribute is set.\n"
		"\n"
		"@return @c true if the 'units' attribute of this Compartment is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note @htmlinclude unassigned-units-are-not-a-default.html\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetOutside", _wrap_Compartment_isSetOutside, METH_VARARGS, (char *)"\n"
		"Compartment_isSetOutside(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'outside' attribute is set.\n"
		"\n"
		"@return @c true if the 'outside' attribute of this Compartment is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'outside' attribute is defined in SBML Level&nbsp;1 and\n"
		"Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1\n"
		"Core.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetSpatialDimensions", _wrap_Compartment_isSetSpatialDimensions, METH_VARARGS, (char *)"\n"
		"Compartment_isSetSpatialDimensions(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'spatialDimensions' attribute is set.\n"
		"\n"
		"@return @c true if the 'spatialDimensions' attribute of this\n"
		"Compartment is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_isSetConstant", _wrap_Compartment_isSetConstant, METH_VARARGS, (char *)"\n"
		"Compartment_isSetConstant(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Compartment's 'constant' attribute is set.\n"
		"\n"
		"@return @c true if the 'constant' attribute of this Compartment is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setId", _wrap_Compartment_setId, METH_VARARGS, (char *)"\n"
		"Compartment_setId(Compartment self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this Compartment.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this Compartment\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setName", _wrap_Compartment_setName, METH_VARARGS, (char *)"\n"
		"Compartment_setName(Compartment self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this Compartment.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the Compartment\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setCompartmentType", _wrap_Compartment_setCompartmentType, METH_VARARGS, (char *)"\n"
		"Compartment_setCompartmentType(Compartment self, string sid) -> int\n"
		"\n"
		"Sets the 'compartmentType' attribute of this Compartment.\n"
		"\n"
		"@param sid the identifier of a CompartmentType object defined\n"
		"elsewhere in this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The 'compartmentType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setSpatialDimensions", _wrap_Compartment_setSpatialDimensions, METH_VARARGS, (char *)"\n"
		"setSpatialDimensions(unsigned int value) -> int\n"
		"Compartment_setSpatialDimensions(Compartment self, double value) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setSpatialDimensions(long value)</pre>\n"
		"\n"
		"Sets the 'spatialDimensions' attribute of this Compartment.\n"
		"\n"
		"If @p value is not one of @c 0, @c 1, @c 2, or @c 3, this method will\n"
		"have no effect (i.e., the 'spatialDimensions' attribute will not be\n"
		"set).\n"
		"\n"
		"@param value a long integereger indicating the number of dimensions\n"
		"of this compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setSpatialDimensions(double value)</pre>\n"
		"\n"
		"Sets the 'spatialDimensions' attribute of this Compartment as a double.\n"
		"\n"
		"@param value a double indicating the number of dimensions\n"
		"of this compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setSize", _wrap_Compartment_setSize, METH_VARARGS, (char *)"\n"
		"Compartment_setSize(Compartment self, double value) -> int\n"
		"\n"
		"Sets the 'size' attribute (or 'volume' in SBML Level&nbsp;1) of this\n"
		"Compartment.\n"
		"\n"
		"This method is identical to\n"
		"@if java Compartment.setVolume()@else setVolume()@endif\n"
		"and is provided for compatibility between\n"
		"SBML Level&nbsp;1 and Level&nbsp;2.\n"
		"\n"
		"@param value a @c double representing the size of this compartment\n"
		"instance in whatever units are in effect for the compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@note The attribute 'volume' only exists by that name in SBML\n"
		"Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is\n"
		"named 'size'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setVolume", _wrap_Compartment_setVolume, METH_VARARGS, (char *)"\n"
		"Compartment_setVolume(Compartment self, double value) -> int\n"
		"\n"
		"Sets the 'volume' attribute (or 'size' in SBML Level&nbsp;2) of this\n"
		"Compartment.\n"
		"\n"
		"This method is identical to\n"
		"@if java Compartment.setVolume()@else setVolume()@endif\n"
		"and is provided for compatibility between SBML Level&nbsp;1 and\n"
		"Level&nbsp;2.\n"
		"\n"
		"@param value a @c double representing the volume of this compartment\n"
		"instance in whatever units are in effect for the compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@note The attribute 'volume' only exists by that name in SBML\n"
		"Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is\n"
		"named 'size'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setUnits", _wrap_Compartment_setUnits, METH_VARARGS, (char *)"\n"
		"Compartment_setUnits(Compartment self, string sid) -> int\n"
		"\n"
		"Sets the 'units' attribute of this Compartment.\n"
		"\n"
		"@param sid the identifier of the defined units to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setOutside", _wrap_Compartment_setOutside, METH_VARARGS, (char *)"\n"
		"Compartment_setOutside(Compartment self, string sid) -> int\n"
		"\n"
		"Sets the 'outside' attribute of this Compartment.\n"
		"\n"
		"@param sid the identifier of a compartment that encloses this one.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'outside' attribute is defined in SBML Level&nbsp;1 and\n"
		"Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1\n"
		"Core.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_setConstant", _wrap_Compartment_setConstant, METH_VARARGS, (char *)"\n"
		"Compartment_setConstant(Compartment self, bool value) -> int\n"
		"\n"
		"Sets the value of the 'constant' attribute of this Compartment.\n"
		"\n"
		"@param value a boolean indicating whether the size/volume of this\n"
		"compartment should be considered constant (@c true) or variable\n"
		"(@c false)\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetName", _wrap_Compartment_unsetName, METH_VARARGS, (char *)"\n"
		"Compartment_unsetName(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this Compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetCompartmentType", _wrap_Compartment_unsetCompartmentType, METH_VARARGS, (char *)"\n"
		"Compartment_unsetCompartmentType(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'compartmentType'\n"
		"attribute of this Compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The 'compartmentType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"\n"
		"@see setCompartmentType()\n"
		"@see isSetCompartmentType()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetSize", _wrap_Compartment_unsetSize, METH_VARARGS, (char *)"\n"
		"Compartment_unsetSize(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'size' attribute of this Compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The attribute 'volume' only exists by that name in SBML\n"
		"Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is\n"
		"named 'size'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetVolume", _wrap_Compartment_unsetVolume, METH_VARARGS, (char *)"\n"
		"Compartment_unsetVolume(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'volume' attribute of this\n"
		"Compartment.\n"
		"\n"
		"In SBML Level&nbsp;1, a Compartment volume has a default value (@c 1.0) and\n"
		"therefore <em>should always be set</em>.  In Level&nbsp;2, 'size' is\n"
		"optional with no default value and as such may or may not be set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The attribute 'volume' only exists by that name in SBML\n"
		"Level&nbsp;1.  In Level&nbsp;2 and above, the equivalent attribute is\n"
		"named 'size'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetUnits", _wrap_Compartment_unsetUnits, METH_VARARGS, (char *)"\n"
		"Compartment_unsetUnits(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'units' attribute of this Compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetOutside", _wrap_Compartment_unsetOutside, METH_VARARGS, (char *)"\n"
		"Compartment_unsetOutside(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'outside' attribute of this Compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'outside' attribute is defined in SBML Level&nbsp;1 and\n"
		"Level&nbsp;2, but does not exist in SBML Level&nbsp;3 Version&nbsp;1\n"
		"Core.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_unsetSpatialDimensions", _wrap_Compartment_unsetSpatialDimensions, METH_VARARGS, (char *)"\n"
		"Compartment_unsetSpatialDimensions(Compartment self) -> int\n"
		"\n"
		"Unsets the value of the 'spatialDimensions' attribute of this Compartment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note This function is only valid for SBML Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getDerivedUnitDefinition", _wrap_Compartment_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"Compartment_getDerivedUnitDefinition(Compartment self) -> UnitDefinition\n"
		"\n"
		"Constructs and returns a UnitDefinition that corresponds to the units\n"
		"of this Compartment's designated size.\n"
		"\n"
		"Compartments in SBML have an attribute ('units') for declaring the\n"
		"units of measurement intended for the value of the compartment's size.\n"
		"In the absence of a value given for this attribute, the units are\n"
		"inherited from values either defined on the enclosing Model (in SBML\n"
		"Level&nbsp;3) or in defaults (in SBML Level&nbsp;2).  This method\n"
		"returns a UnitDefinition object based on how this compartment's units\n"
		"are interpreted according to the relevant SBML guidelines, or it\n"
		"returns @c None if no units have been declared and no defaults are\n"
		"defined by the relevant SBML specification.\n"
		"\n"
		"Note that unit declarations for Compartment objects are specified in\n"
		"terms of the @em identifier of a unit (e.g., using\n"
		"@if java Compartment.setUnits()@else setUnits()@endif), but\n"
		"@em this method returns a UnitDefinition object, not a unit\n"
		"identifier.  It does this by constructing an appropriate\n"
		"UnitDefinition.  For SBML Level&nbsp;2 models, it will do this even\n"
		"when the value of the 'units' attribute is one of the special SBML\n"
		"Level&nbsp;2 unit identifiers @c 'substance', @c 'volume', @c 'area',\n"
		"@c 'length' or @c 'time'.  Callers may find this useful in conjunction\n"
		"with the helper methods provided by the UnitDefinition class for\n"
		"comparing different UnitDefinition objects.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of this \n"
		"Compartment, or @c None if one cannot be constructed.\n"
		"\n"
		"@note The libSBML system for unit analysis depends on the model as a\n"
		"whole.  In cases where the Compartment object has not yet been added\n"
		"to a model, or the model itself is incomplete, unit analysis is not\n"
		"possible, and consequently this method will return @c None.\n"
		"\n"
		"@see isSetUnits()\n"
		"@see getUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getTypeCode", _wrap_Compartment_getTypeCode, METH_VARARGS, (char *)"\n"
		"Compartment_getTypeCode(Compartment self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or\n"
		"@link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_getElementName", _wrap_Compartment_getElementName, METH_VARARGS, (char *)"\n"
		"Compartment_getElementName(Compartment self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Compartment, is\n"
		"always @c 'compartment'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'compartment'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_hasRequiredAttributes", _wrap_Compartment_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Compartment_hasRequiredAttributes(Compartment self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this Compartment object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a Compartment object are:\n"
		"@li 'id' (or 'name' in SBML Level&nbsp;1)\n"
		"@li 'constant' (in SBML Level&nbsp;3 only)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Compartment_swigregister", Compartment_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfCompartments_clone", _wrap_ListOfCompartments_clone, METH_VARARGS, (char *)"\n"
		"ListOfCompartments_clone(ListOfCompartments self) -> ListOfCompartments\n"
		"\n"
		"Creates and returns a deep copy of this ListOfCompartments instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfCompartments.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartments_getTypeCode", _wrap_ListOfCompartments_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfCompartments_getTypeCode(ListOfCompartments self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartments_getItemTypeCode", _wrap_ListOfCompartments_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfCompartments_getItemTypeCode(ListOfCompartments self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Compartment objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartments_getElementName", _wrap_ListOfCompartments_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfCompartments_getElementName(ListOfCompartments self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfCompartments, the XML element name is @c 'listOfCompartments'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfCompartments'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartments_get", _wrap_ListOfCompartments_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Compartment\n"
		"get(unsigned int n) -> Compartment\n"
		"get(string sid) -> Compartment\n"
		"ListOfCompartments_get(ListOfCompartments self, string sid) -> Compartment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a Compartment from the ListOfCompartments.\n"
		"\n"
		"@param n the index number of the Compartment to get.\n"
		"\n"
		"@return the nth Compartment in this ListOfCompartments.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a Compartment from the ListOfCompartments.\n"
		"\n"
		"@param n the index number of the Compartment to get.\n"
		"\n"
		"@return the nth Compartment in this ListOfCompartments.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a Compartment from the ListOfCompartments\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Compartment to get.\n"
		"\n"
		"@return Compartment in this ListOfCompartments\n"
		"with the given id or @c None if no such\n"
		"Compartment exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a Compartment from the ListOfCompartments\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Compartment to get.\n"
		"\n"
		"@return Compartment in this ListOfCompartments\n"
		"with the given id or @c None if no such\n"
		"Compartment exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfCompartments_remove", _wrap_ListOfCompartments_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> Compartment\n"
		"ListOfCompartments_remove(ListOfCompartments self, string sid) -> Compartment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfCompartments items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes item in this ListOfCompartments items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then\n"
		"@c None is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfCompartments", _wrap_new_ListOfCompartments, METH_VARARGS, (char *)"new_ListOfCompartments() -> ListOfCompartments"},
	 { (char *)"delete_ListOfCompartments", _wrap_delete_ListOfCompartments, METH_VARARGS, (char *)"delete_ListOfCompartments(ListOfCompartments self)"},
	 { (char *)"ListOfCompartments_swigregister", ListOfCompartments_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Species", _wrap_delete_Species, METH_VARARGS, (char *)"delete_Species(Species self)"},
	 { (char *)"new_Species", _wrap_new_Species, METH_VARARGS, (char *)"\n"
		"Species(unsigned int level, unsigned int version)\n"
		"Species(SBMLNamespaces sbmlns)\n"
		"new_Species(Species orig) -> Species\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Species(long level, long version)</pre>\n"
		"\n"
		"Creates a new Species using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this Species\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"Species\n"
		"\n"
		"@note Upon the addition of a Species object to an SBMLDocument (e.g.,\n"
		"using Model.addSpecies()), the SBML Level, SBML Version and XML\n"
		"namespace of the document @em override the values used when creating\n"
		"the Species object via this constructor.  This is necessary to ensure\n"
		"that an SBML document is a consistent structure.  Nevertheless, the\n"
		"ability to supply the values at the time of creation of a Species is\n"
		"an important aid to producing valid SBML.  Knowledge of the intented\n"
		"SBML Level and Version determine whether it is valid to assign a\n"
		"particular value to an attribute, or whether it is valid to add an\n"
		"object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Species(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new Species using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"It is worth emphasizing that although this constructor does not take\n"
		"an identifier argument, in SBML Level&nbsp;2 and beyond, the 'id'\n"
		"(identifier) attribute of a Species is required to have a value.\n"
		"Thus, callers are cautioned to assign a value after calling this\n"
		"constructor.  Setting the identifier can be accomplished using the\n"
		"method Species.setId().\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a Species object to an SBMLDocument (e.g.,\n"
		"using Model.addSpecies()), the SBML XML namespace of the document @em\n"
		"overrides the value used when creating the Species object via this\n"
		"constructor.  This is necessary to ensure that an SBML document is a\n"
		"consistent structure.  Nevertheless, the ability to supply the values\n"
		"at the time of creation of a Species is an important aid to producing\n"
		"valid SBML.  Knowledge of the intented SBML Level and Version\n"
		"determine whether it is valid to assign a particular value to an\n"
		"attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Species(Species orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this Species object.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Species_clone", _wrap_Species_clone, METH_VARARGS, (char *)"\n"
		"Species_clone(Species self) -> Species\n"
		"\n"
		"Creates and returns a deep copy of this Species object.\n"
		"\n"
		"@return a (deep) copy of this Species object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_initDefaults", _wrap_Species_initDefaults, METH_VARARGS, (char *)"\n"
		"Species_initDefaults(Species self)\n"
		"\n"
		"Initializes the fields of this Species object to 'typical' defaults\n"
		"values.\n"
		"\n"
		"The SBML Species component has slightly different aspects and\n"
		"default attribute values in different SBML Levels and Versions.\n"
		"This method sets the values to certain common defaults, based\n"
		"mostly on what they are in SBML Level&nbsp;2.  Specifically:\n"
		"<ul>\n"
		"<li> Sets 'boundaryCondition' to @c false\n"
		"<li> Sets 'constant' to @c false\n"
		"<li> sets 'hasOnlySubstanceUnits' to @c false\n"
		"<li> (Applies to Level&nbsp;3 models only) Sets attribute 'substanceUnits' to @c mole\n"
		"</ul>\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getId", _wrap_Species_getId, METH_VARARGS, (char *)"\n"
		"Species_getId(Species self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this Species object.\n"
		"\n"
		"@return the id of this Species object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getName", _wrap_Species_getName, METH_VARARGS, (char *)"\n"
		"Species_getName(Species self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this Species object.\n"
		"\n"
		"@return the name of this Species object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getSpeciesType", _wrap_Species_getSpeciesType, METH_VARARGS, (char *)"\n"
		"Species_getSpeciesType(Species self) -> string\n"
		"\n"
		"Get the type of this Species object object.\n"
		"\n"
		"@return the value of the 'speciesType' attribute of this\n"
		"Species as a string.\n"
		"\n"
		"@note The 'speciesType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getCompartment", _wrap_Species_getCompartment, METH_VARARGS, (char *)"\n"
		"Species_getCompartment(Species self) -> string\n"
		"\n"
		"Get the compartment in which this species is located.\n"
		"\n"
		"The compartment is designated by its identifier.\n"
		"\n"
		"@return the value of the 'compartment' attribute of this Species\n"
		"object, as a string.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getInitialAmount", _wrap_Species_getInitialAmount, METH_VARARGS, (char *)"\n"
		"Species_getInitialAmount(Species self) -> double\n"
		"\n"
		"Get the value of the 'initialAmount' attribute.\n"
		"\n"
		"@return the initialAmount of this Species, as a float-point number.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getInitialConcentration", _wrap_Species_getInitialConcentration, METH_VARARGS, (char *)"\n"
		"Species_getInitialConcentration(Species self) -> double\n"
		"\n"
		"Get the value of the 'initialConcentration' attribute.\n"
		"\n"
		"@return the initialConcentration of this Species,, as a float-point\n"
		"number.\n"
		"\n"
		"@note The attribute 'initialConcentration' is only available in SBML\n"
		"Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getSubstanceUnits", _wrap_Species_getSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_getSubstanceUnits(Species self) -> string\n"
		"\n"
		"Get the value of the 'substanceUnits' attribute.\n"
		"\n"
		"@return the value of the 'substanceUnits' attribute of this Species,\n"
		"as a string.  An empty string indicates that no units have been\n"
		"assigned.\n"
		"\n"
		"@note @htmlinclude unassigned-units-are-not-a-default.html\n"
		"\n"
		"@see isSetSubstanceUnits()\n"
		"@see setSubstanceUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getSpatialSizeUnits", _wrap_Species_getSpatialSizeUnits, METH_VARARGS, (char *)"\n"
		"Species_getSpatialSizeUnits(Species self) -> string\n"
		"\n"
		"Get the value of the 'spatialSizeUnits' attribute.\n"
		"\n"
		"@return the value of the 'spatialSizeUnits' attribute of this Species\n"
		"object, as a string.\n"
		"\n"
		"@warning In versions of SBML Level&nbsp;2 before Version&nbsp;3, the\n"
		"class Species included an attribute called 'spatialSizeUnits', which\n"
		"allowed explicitly setting the units of size for initial\n"
		"concentration.  This attribute was removed in SBML Level&nbsp;2\n"
		"Version&nbsp;3.  LibSBML retains this attribute for compatibility with\n"
		"older definitions of Level&nbsp;2, but its use is strongly discouraged\n"
		"because it is incompatible with Level&nbsp;2 Version&nbsp;3 and\n"
		"Level&nbsp;2 Version&nbsp;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getUnits", _wrap_Species_getUnits, METH_VARARGS, (char *)"\n"
		"Species_getUnits(Species self) -> string\n"
		"\n"
		"Get the value of the 'units' attribute.\n"
		"\n"
		"@return the units of this Species (L1 only).\n"
		"\n"
		"@note The 'units' attribute is defined only in SBML Level&nbsp;1.  In\n"
		"SBML Level&nbsp;2 and Level&nbsp;3, it has been replaced by a\n"
		"combination of 'substanceUnits' and the units of the Compartment\n"
		"object in which a species is located.  In SBML Level&nbsp;2\n"
		"Versions&nbsp;1&ndash;2, an additional attribute 'spatialSizeUnits'\n"
		"helps determine the units of the species quantity, but this attribute\n"
		"was removed in later versions of SBML Level&nbsp;2.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getHasOnlySubstanceUnits", _wrap_Species_getHasOnlySubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_getHasOnlySubstanceUnits(Species self) -> bool\n"
		"\n"
		"Get the value of the 'hasOnlySubstanceUnits' attribute.\n"
		"\n"
		"@return @c true if this Species' 'hasOnlySubstanceUnits' attribute\n"
		"value is nonzero, @c false otherwise.\n"
		"\n"
		"@note The 'hasOnlySubstanceUnits' attribute does not exist in SBML\n"
		"Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getBoundaryCondition", _wrap_Species_getBoundaryCondition, METH_VARARGS, (char *)"\n"
		"Species_getBoundaryCondition(Species self) -> bool\n"
		"\n"
		"Get the value of the 'boundaryCondition' attribute.\n"
		"\n"
		"@return @c true if this Species' 'boundaryCondition' attribute value\n"
		"is nonzero, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getCharge", _wrap_Species_getCharge, METH_VARARGS, (char *)"\n"
		"Species_getCharge(Species self) -> int\n"
		"\n"
		"Get the value of the 'charge' attribute.\n"
		"\n"
		"@return the charge of this Species object.\n"
		"\n"
		"@note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'\n"
		"attribute on Species is deprecated and in SBML Level&nbsp;3 it does\n"
		"not exist at all.  Its use strongly discouraged.  Its presence is\n"
		"considered a misfeature in earlier definitions of SBML because its\n"
		"implications for the mathematics of a model were never defined, and in\n"
		"any case, no known modeling system ever used it.  Instead, models take\n"
		"account of charge values directly in their definitions of species by\n"
		"(for example) having separate species identities for the charged and\n"
		"uncharged versions of the same species.  This allows the condition to\n"
		"affect model mathematics directly.  LibSBML retains this method for\n"
		"easier compatibility with SBML Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getConstant", _wrap_Species_getConstant, METH_VARARGS, (char *)"\n"
		"Species_getConstant(Species self) -> bool\n"
		"\n"
		"Get the value of the 'constant' attribute.\n"
		"\n"
		"@return @c true if this Species's 'constant' attribute value is\n"
		"nonzero, @c false otherwise.\n"
		"\n"
		"@note The attribute 'constant' is only available in SBML Levels&nbsp;2\n"
		"and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getConversionFactor", _wrap_Species_getConversionFactor, METH_VARARGS, (char *)"\n"
		"Species_getConversionFactor(Species self) -> string\n"
		"\n"
		"Get the value of the 'conversionFactor' attribute.\n"
		"\n"
		"@return the conversionFactor of this Species, as a string.\n"
		"\n"
		"@note The 'conversionFactor' attribute was introduced in SBML\n"
		"Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1\n"
		"and&nbsp;2.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetId", _wrap_Species_isSetId, METH_VARARGS, (char *)"\n"
		"Species_isSetId(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species object's 'id' attribute is set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetName", _wrap_Species_isSetName, METH_VARARGS, (char *)"\n"
		"Species_isSetName(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species object's 'name' attribute is set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetSpeciesType", _wrap_Species_isSetSpeciesType, METH_VARARGS, (char *)"\n"
		"Species_isSetSpeciesType(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this Species object's\n"
		"'speciesType' attribute is set.\n"
		"\n"
		"@return @c true if the 'speciesType' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'speciesType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetCompartment", _wrap_Species_isSetCompartment, METH_VARARGS, (char *)"\n"
		"Species_isSetCompartment(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species object's 'compartment' attribute is set.\n"
		"\n"
		"@return @c true if the 'compartment' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetInitialAmount", _wrap_Species_isSetInitialAmount, METH_VARARGS, (char *)"\n"
		"Species_isSetInitialAmount(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species object's 'initialAmount' attribute is set.\n"
		"\n"
		"@return @c true if the 'initialAmount' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note In SBML Level&nbsp;1, Species' 'initialAmount' is required and\n"
		"therefore <em>should always be set</em>.  (However, in Level&nbsp;1, the\n"
		"attribute has no default value either, so this method will not return\n"
		"@c true until a value has been assigned.)  In SBML Level&nbsp;2,\n"
		"'initialAmount' is optional and as such may or may not be set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetInitialConcentration", _wrap_Species_isSetInitialConcentration, METH_VARARGS, (char *)"\n"
		"Species_isSetInitialConcentration(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species object's 'initialConcentration' attribute is set.\n"
		"\n"
		"@return @c true if the 'initialConcentration' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The attribute 'initialConcentration' is only available in SBML\n"
		"Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetSubstanceUnits", _wrap_Species_isSetSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_isSetSubstanceUnits(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species object's 'substanceUnits' attribute is set.\n"
		"\n"
		"@return @c true if the 'substanceUnits' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetSpatialSizeUnits", _wrap_Species_isSetSpatialSizeUnits, METH_VARARGS, (char *)"\n"
		"Species_isSetSpatialSizeUnits(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species object's 'spatialSizeUnits' attribute is set.\n"
		"\n"
		"@return @c true if the 'spatialSizeUnits' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@warning In versions of SBML Level~2 before Version&nbsp;3, the class\n"
		"Species included an attribute called 'spatialSizeUnits', which allowed\n"
		"explicitly setting the units of size for initial concentration.  This\n"
		"attribute was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML\n"
		"retains this attribute for compatibility with older definitions of\n"
		"Level&nbsp;2, but its use is strongly discouraged because it is\n"
		"incompatible with Level&nbsp;2 Version&nbsp;3 and Level&nbsp;2 Version&nbsp;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetUnits", _wrap_Species_isSetUnits, METH_VARARGS, (char *)"\n"
		"Species_isSetUnits(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"this Species object's 'units' attribute is set.\n"
		"\n"
		"@return @c true if the 'units' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetCharge", _wrap_Species_isSetCharge, METH_VARARGS, (char *)"\n"
		"Species_isSetCharge(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species object's 'charge' attribute is set.\n"
		"\n"
		"@return @c true if the 'charge' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'\n"
		"attribute on Species in SBML is deprecated and in SBML Level&nbsp;3 it\n"
		"does not exist at all.  Its use strongly discouraged.  Its presence is\n"
		"considered a misfeature in earlier definitions of SBML because its\n"
		"implications for the mathematics of a model were never defined, and in\n"
		"any case, no known modeling system ever used it.  Instead, models take\n"
		"account of charge values directly in their definitions of species by\n"
		"(for example) having separate species identities for the charged and\n"
		"uncharged versions of the same species.  This allows the condition to\n"
		"affect model mathematics directly.  LibSBML retains this method for\n"
		"easier compatibility with SBML Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetConversionFactor", _wrap_Species_isSetConversionFactor, METH_VARARGS, (char *)"\n"
		"Species_isSetConversionFactor(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species object's 'conversionFactor' attribute is set.\n"
		"\n"
		"@return @c true if the 'conversionFactor' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'conversionFactor' attribute was introduced in SBML\n"
		"Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1\n"
		"and&nbsp;2.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetBoundaryCondition", _wrap_Species_isSetBoundaryCondition, METH_VARARGS, (char *)"\n"
		"Species_isSetBoundaryCondition(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species object's 'boundaryCondition' attribute is set.\n"
		"\n"
		"@return @c true if the 'boundaryCondition' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetHasOnlySubstanceUnits", _wrap_Species_isSetHasOnlySubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_isSetHasOnlySubstanceUnits(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species object's 'hasOnlySubstanceUnits' attribute is set.\n"
		"\n"
		"@return @c true if the 'hasOnlySubstanceUnits' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'hasOnlySubstanceUnits' attribute does not exist in SBML\n"
		"Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_isSetConstant", _wrap_Species_isSetConstant, METH_VARARGS, (char *)"\n"
		"Species_isSetConstant(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Species object's 'constant' attribute is set.\n"
		"\n"
		"@return @c true if the 'constant' attribute of this Species is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The attribute 'constant' is only available in SBML Levels&nbsp;2\n"
		"and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setId", _wrap_Species_setId, METH_VARARGS, (char *)"\n"
		"Species_setId(Species self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this Species object.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this Species\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setName", _wrap_Species_setName, METH_VARARGS, (char *)"\n"
		"Species_setName(Species self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this Species object.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the Species\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setSpeciesType", _wrap_Species_setSpeciesType, METH_VARARGS, (char *)"\n"
		"Species_setSpeciesType(Species self, string sid) -> int\n"
		"\n"
		"Sets the 'speciesType' attribute of this Species object.\n"
		"\n"
		"@param sid the identifier of a SpeciesType object defined elsewhere\n"
		"in this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The 'speciesType' attribute is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setCompartment", _wrap_Species_setCompartment, METH_VARARGS, (char *)"\n"
		"Species_setCompartment(Species self, string sid) -> int\n"
		"\n"
		"Sets the 'compartment' attribute of this Species object.\n"
		"\n"
		"@param sid the identifier of a Compartment object defined elsewhere\n"
		"in this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setInitialAmount", _wrap_Species_setInitialAmount, METH_VARARGS, (char *)"\n"
		"Species_setInitialAmount(Species self, double value) -> int\n"
		"\n"
		"Sets the 'initialAmount' attribute of this Species and marks the field\n"
		"as set.\n"
		"\n"
		"This method also unsets the 'initialConcentration' attribute.\n"
		"\n"
		"@param value the value to which the 'initialAmount' attribute should\n"
		"be set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setInitialConcentration", _wrap_Species_setInitialConcentration, METH_VARARGS, (char *)"\n"
		"Species_setInitialConcentration(Species self, double value) -> int\n"
		"\n"
		"Sets the 'initialConcentration' attribute of this Species and marks\n"
		"the field as set.\n"
		"\n"
		"This method also unsets the 'initialAmount' attribute.\n"
		"\n"
		"@param value the value to which the 'initialConcentration' attribute\n"
		"should be set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attribute 'initialConcentration' is only available in SBML\n"
		"Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setSubstanceUnits", _wrap_Species_setSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_setSubstanceUnits(Species self, string sid) -> int\n"
		"\n"
		"Sets the 'substanceUnits' attribute of this Species object.\n"
		"\n"
		"@param sid the identifier of the unit to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setSpatialSizeUnits", _wrap_Species_setSpatialSizeUnits, METH_VARARGS, (char *)"\n"
		"Species_setSpatialSizeUnits(Species self, string sid) -> int\n"
		"\n"
		"(SBML Level&nbsp;2 Versions&nbsp;1&ndash;2) Sets the 'spatialSizeUnits' attribute of this Species object.\n"
		"\n"
		"@param sid the identifier of the unit to use.\n"
		"\n"
		"@warning In versions of SBML Level~2 before Version&nbsp;3, the class\n"
		"Species included an attribute called 'spatialSizeUnits', which allowed\n"
		"explicitly setting the units of size for initial concentration.  This\n"
		"attribute was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML\n"
		"retains this attribute for compatibility with older definitions of\n"
		"Level&nbsp;2, but its use is strongly discouraged because it is\n"
		"incompatible with Level&nbsp;2 Version&nbsp;3 and Level&nbsp;2 Version&nbsp;4.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setUnits", _wrap_Species_setUnits, METH_VARARGS, (char *)"\n"
		"Species_setUnits(Species self, string sname) -> int\n"
		"\n"
		"(SBML Level&nbsp;1 only) Sets the units of this Species object.\n"
		"\n"
		"@param sname the identifier of the unit to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		" \n"
		"\n"
		""},
	 { (char *)"Species_setHasOnlySubstanceUnits", _wrap_Species_setHasOnlySubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_setHasOnlySubstanceUnits(Species self, bool value) -> int\n"
		"\n"
		"Sets the 'hasOnlySubstanceUnits' attribute of this Species object.\n"
		"\n"
		"@param value boolean value for the 'hasOnlySubstanceUnits' attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The 'hasOnlySubstanceUnits' attribute does not exist in SBML\n"
		"Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setBoundaryCondition", _wrap_Species_setBoundaryCondition, METH_VARARGS, (char *)"\n"
		"Species_setBoundaryCondition(Species self, bool value) -> int\n"
		"\n"
		"Sets the 'boundaryCondition' attribute of this Species object.\n"
		"\n"
		"@param value boolean value for the 'boundaryCondition' attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setCharge", _wrap_Species_setCharge, METH_VARARGS, (char *)"\n"
		"Species_setCharge(Species self, int value) -> int\n"
		"\n"
		"Sets the 'charge' attribute of this Species object.\n"
		"\n"
		"@param value an integer to which to set the 'charge' to.\n"
		"\n"
		"@note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'\n"
		"attribute on Species in SBML is deprecated and its use strongly\n"
		"discouraged, and it does not exist in SBML Level&nbsp;3 at all.  Its\n"
		"presence is considered a misfeature in earlier definitions of SBML\n"
		"because its implications for the mathematics of a model were never\n"
		"defined, and in any case, no known modeling system ever used it.\n"
		"Instead, models take account of charge values directly in their\n"
		"definitions of species by (for example) having separate species\n"
		"identities for the charged and uncharged versions of the same species.\n"
		"This allows the condition to affect model mathematics directly.\n"
		"LibSBML retains this method for easier compatibility with SBML\n"
		"Level&nbsp;1.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setConstant", _wrap_Species_setConstant, METH_VARARGS, (char *)"\n"
		"Species_setConstant(Species self, bool value) -> int\n"
		"\n"
		"Sets the 'constant' attribute of this Species object.\n"
		"\n"
		"@param value a boolean value for the 'constant' attribute\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attribute 'constant' is only available in SBML Levels&nbsp;2\n"
		"and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_setConversionFactor", _wrap_Species_setConversionFactor, METH_VARARGS, (char *)"\n"
		"Species_setConversionFactor(Species self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'conversionFactor' attribute of this Species object.\n"
		"\n"
		"The string in @p sid is copied.\n"
		"\n"
		"@param sid the new conversionFactor for the Species\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'conversionFactor' attribute was introduced in SBML\n"
		"Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1\n"
		"and&nbsp;2.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetName", _wrap_Species_unsetName, METH_VARARGS, (char *)"\n"
		"Species_unsetName(Species self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this Species object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetSpeciesType", _wrap_Species_unsetSpeciesType, METH_VARARGS, (char *)"\n"
		"Species_unsetSpeciesType(Species self) -> int\n"
		"\n"
		"Unsets the 'speciesType' attribute value of this Species object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The attribute 'speciesType' is only available in SBML\n"
		"Level&nbsp;2 Versions&nbsp;2&ndash;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetInitialAmount", _wrap_Species_unsetInitialAmount, METH_VARARGS, (char *)"\n"
		"Species_unsetInitialAmount(Species self) -> int\n"
		"\n"
		"Unsets the 'initialAmount' attribute value of this Species object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetInitialConcentration", _wrap_Species_unsetInitialConcentration, METH_VARARGS, (char *)"\n"
		"Species_unsetInitialConcentration(Species self) -> int\n"
		"\n"
		"Unsets the 'initialConcentration' attribute value of this Species object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The attribute 'initialConcentration' is only available in SBML\n"
		"Level&nbsp;2 and&nbsp;3.  It does not exist on Species in Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetSubstanceUnits", _wrap_Species_unsetSubstanceUnits, METH_VARARGS, (char *)"\n"
		"Species_unsetSubstanceUnits(Species self) -> int\n"
		"\n"
		"Unsets the 'substanceUnits' attribute value of this Species object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetSpatialSizeUnits", _wrap_Species_unsetSpatialSizeUnits, METH_VARARGS, (char *)"\n"
		"Species_unsetSpatialSizeUnits(Species self) -> int\n"
		"\n"
		"Unsets the 'spatialSizeUnits' attribute value of this Species object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@warning In versions of SBML Level~2 before Version&nbsp;3, the class\n"
		"Species included an attribute called 'spatialSizeUnits', which allowed\n"
		"explicitly setting the units of size for initial concentration.  This\n"
		"attribute was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML\n"
		"retains this attribute for compatibility with older definitions of\n"
		"Level&nbsp;2, but its use is strongly discouraged because it is\n"
		"incompatible with Level&nbsp;2 Version&nbsp;3 and Level&nbsp;2 Version&nbsp;4.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetUnits", _wrap_Species_unsetUnits, METH_VARARGS, (char *)"\n"
		"Species_unsetUnits(Species self) -> int\n"
		"\n"
		"Unsets the 'units' attribute value of this Species object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetCharge", _wrap_Species_unsetCharge, METH_VARARGS, (char *)"\n"
		"Species_unsetCharge(Species self) -> int\n"
		"\n"
		"Unsets the 'charge' attribute\n"
		"value of this Species object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note Beginning in SBML Level&nbsp;2 Version&nbsp;2, the 'charge'\n"
		"attribute on Species in SBML is deprecated and its use strongly\n"
		"discouraged, and it does not exist in SBML Level&nbsp;3 at all.  Its\n"
		"presence is considered a misfeature in earlier definitions of SBML\n"
		"because its implications for the mathematics of a model were never\n"
		"defined, and in any case, no known modeling system ever used it.\n"
		"Instead, models take account of charge values directly in their\n"
		"definitions of species by (for example) having separate species\n"
		"identities for the charged and uncharged versions of the same species.\n"
		"This allows the condition to affect model mathematics directly.\n"
		"LibSBML retains this method for easier compatibility with SBML\n"
		"Level&nbsp;1.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_unsetConversionFactor", _wrap_Species_unsetConversionFactor, METH_VARARGS, (char *)"\n"
		"Species_unsetConversionFactor(Species self) -> int\n"
		"\n"
		"Unsets the 'conversionFactor' attribute value of this Species object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'conversionFactor' attribute was introduced in SBML\n"
		"Level&nbsp;3.  It does not exist on Species in SBML Levels&nbsp;1\n"
		"and&nbsp;2.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getDerivedUnitDefinition", _wrap_Species_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"Species_getDerivedUnitDefinition(Species self) -> UnitDefinition\n"
		"\n"
		"Constructs and returns a UnitDefinition that corresponds to the units\n"
		"of this Species' amount or concentration.\n"
		"\n"
		"Species in SBML have an attribute ('substanceUnits') for declaring the\n"
		"units of measurement intended for the species' amount or concentration\n"
		"(depending on which one applies).  In the absence of a value given for\n"
		"'substanceUnits', the units are taken from the enclosing Model's\n"
		"definition of @c 'substance' or @c 'substance'/<em>(size of the\n"
		"compartment)</em> in which the species is located, or finally, if\n"
		"these are not redefined by the Model, the relevant SBML default units\n"
		"for those quantities.  Following that procedure, the method\n"
		"@if java Species.getDerivedUnitDefinition()@else getDerivedUnitDefinition()@endif\n"
		"returns a UnitDefinition based on the\n"
		"interpreted units of this species's amount or concentration.\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c None.\n"
		"\n"
		"Note also that unit declarations for Species are in terms of the @em\n"
		"identifier of a unit, but this method returns a UnitDefinition object,\n"
		"not a unit identifier.  It does this by constructing an appropriate\n"
		"UnitDefinition.  Callers may find this particularly useful when used\n"
		"in conjunction with the helper methods on UnitDefinition for comparing\n"
		"different UnitDefinition objects.\n"
		"\n"
		"In SBML Level&nbsp;2 specifications prior to Version&nbsp;3, Species\n"
		"includes an additional attribute named 'spatialSizeUnits', which\n"
		"allows explicitly setting the units of size for initial concentration.\n"
		"The @if java Species.getDerivedUnitDefinition()@else getDerivedUnitDefinition()@endif\n"
		"takes this into account for models\n"
		"expressed in SBML Level&nbsp;2 Versions&nbsp;1 and&nbsp;2.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of this \n"
		"Species, or @c None if one cannot be constructed.\n"
		"\n"
		"@see getSubstanceUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getTypeCode", _wrap_Species_getTypeCode, METH_VARARGS, (char *)"\n"
		"Species_getTypeCode(Species self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_getElementName", _wrap_Species_getElementName, METH_VARARGS, (char *)"\n"
		"Species_getElementName(Species self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Species, is\n"
		"always @c 'species'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'species'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_hasRequiredAttributes", _wrap_Species_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Species_hasRequiredAttributes(Species self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this Species object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a Species object are:\n"
		"@li 'id' (or 'name' in SBML Level&nbsp;1)\n"
		"@li 'compartment'\n"
		"@li 'initialAmount' (required in SBML Level&nbsp;1 only; optional otherwise)\n"
		"@li 'hasOnlySubstanceUnits' (required in SBML Level&nbsp;3; optional in SBML Level&nbsp;2)\n"
		"@li 'boundaryCondition' (required in SBML Level&nbsp;3; optional in Levels&nbsp;1 and&nbsp;2)\n"
		"@li 'constant' (required in SBML Level&nbsp;3; optional in SBML Level&nbsp;2)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Species_swigregister", Species_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfSpecies_clone", _wrap_ListOfSpecies_clone, METH_VARARGS, (char *)"\n"
		"ListOfSpecies_clone(ListOfSpecies self) -> ListOfSpecies\n"
		"\n"
		"Creates and returns a deep copy of this ListOfSpeciess instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfSpeciess.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpecies_getTypeCode", _wrap_ListOfSpecies_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfSpecies_getTypeCode(ListOfSpecies self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpecies_getItemTypeCode", _wrap_ListOfSpecies_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfSpecies_getItemTypeCode(ListOfSpecies self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Species objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpecies_getElementName", _wrap_ListOfSpecies_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfSpecies_getElementName(ListOfSpecies self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfSpeciess, the XML element name is @c 'listOfSpeciess'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfSpeciess'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpecies_get", _wrap_ListOfSpecies_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Species\n"
		"get(unsigned int n) -> Species\n"
		"get(string sid) -> Species\n"
		"ListOfSpecies_get(ListOfSpecies self, string sid) -> Species\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a Species from the ListOfSpecies.\n"
		"\n"
		"@param n the index number of the Species to get.\n"
		"\n"
		"@return the nth Species in this ListOfSpecies.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a Species from the ListOfSpecies.\n"
		"\n"
		"@param n the index number of the Species to get.\n"
		"\n"
		"@return the nth Species in this ListOfSpecies.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a Species from the ListOfSpecies\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Species to get.\n"
		"\n"
		"@return Species in this ListOfSpecies\n"
		"with the given id or @c None if no such\n"
		"Species exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a Species from the ListOfSpecies\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Species to get.\n"
		"\n"
		"@return Species in this ListOfSpecies\n"
		"with the given id or @c None if no such\n"
		"Species exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpecies_remove", _wrap_ListOfSpecies_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> Species\n"
		"ListOfSpecies_remove(ListOfSpecies self, string sid) -> Species\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfSpeciess items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes item in this ListOfSpeciess items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"None is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfSpecies", _wrap_new_ListOfSpecies, METH_VARARGS, (char *)"new_ListOfSpecies() -> ListOfSpecies"},
	 { (char *)"delete_ListOfSpecies", _wrap_delete_ListOfSpecies, METH_VARARGS, (char *)"delete_ListOfSpecies(ListOfSpecies self)"},
	 { (char *)"ListOfSpecies_swigregister", ListOfSpecies_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Parameter", _wrap_delete_Parameter, METH_VARARGS, (char *)"delete_Parameter(Parameter self)"},
	 { (char *)"new_Parameter", _wrap_new_Parameter, METH_VARARGS, (char *)"\n"
		"Parameter(unsigned int level, unsigned int version)\n"
		"Parameter(SBMLNamespaces sbmlns)\n"
		"new_Parameter(Parameter orig) -> Parameter\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Parameter(long level, long version)</pre>\n"
		"\n"
		"Creates a new Parameter using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this Parameter\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"Parameter\n"
		"\n"
		"@note Upon the addition of a Parameter object to an SBMLDocument\n"
		"(e.g., using Model.addParameter()), the SBML Level, SBML Version\n"
		"and XML namespace of the document @em override the values used\n"
		"when creating the Parameter object via this constructor.  This is\n"
		"necessary to ensure that an SBML document is a consistent structure.\n"
		"Nevertheless, the ability to supply the values at the time of creation\n"
		"of a Parameter is an important aid to producing valid SBML.  Knowledge\n"
		"of the intented SBML Level and Version determine whether it is valid\n"
		"to assign a particular value to an attribute, or whether it is valid\n"
		"to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Parameter(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new Parameter using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"It is worth emphasizing that although this constructor does not take\n"
		"an identifier argument, in SBML Level&nbsp;2 and beyond, the 'id'\n"
		"(identifier) attribute of a Parameter is required to have a value.\n"
		"Thus, callers are cautioned to assign a value after calling this\n"
		"constructor if no identifier is provided as an argument.  Setting the\n"
		"identifier can be accomplished using the method\n"
		"@if java setId(String id)@else setId()@endif.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a Parameter object to an SBMLDocument\n"
		"(e.g., using Model.addParameter()), the SBML XML namespace of the\n"
		"document @em overrides the value used when creating the Parameter\n"
		"object via this constructor.  This is necessary to ensure that an SBML\n"
		"document is a consistent structure.  Nevertheless, the ability to\n"
		"supply the values at the time of creation of a Parameter is an\n"
		"important aid to producing valid SBML.  Knowledge of the intented SBML\n"
		"Level and Version determine whether it is valid to assign a particular\n"
		"value to an attribute, or whether it is valid to add an object to an\n"
		"existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Parameter(Parameter orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of a Parameter.\n"
		"\n"
		"@param orig the Parameter instance to copy.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_clone", _wrap_Parameter_clone, METH_VARARGS, (char *)"\n"
		"Parameter_clone(Parameter self) -> Parameter\n"
		"\n"
		"Creates and returns a deep copy of this Parameter.\n"
		"\n"
		"@return a (deep) copy of this Parameter.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_initDefaults", _wrap_Parameter_initDefaults, METH_VARARGS, (char *)"\n"
		"Parameter_initDefaults(Parameter self)\n"
		"\n"
		"Initializes the fields of this Parameter object to 'typical' defaults\n"
		"values.\n"
		"\n"
		"The SBML Parameter component has slightly different aspects and\n"
		"default attribute values in different SBML Levels and Versions.  Many\n"
		"SBML object classes defined by libSBML have an initDefaults() method\n"
		"to set the values to certain common defaults, based mostly on what\n"
		"they are in SBML Level&nbsp;2.  In the case of Parameter, this method\n"
		"only sets the value of the 'constant' attribute to @c true.\n"
		"\n"
		"@see getConstant()\n"
		"@see isSetConstant()\n"
		"@see setConstant()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getId", _wrap_Parameter_getId, METH_VARARGS, (char *)"\n"
		"Parameter_getId(Parameter self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this Parameter.\n"
		"\n"
		"@return the id of this Parameter.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getName", _wrap_Parameter_getName, METH_VARARGS, (char *)"\n"
		"Parameter_getName(Parameter self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this Parameter.\n"
		"\n"
		"@return the name of this Parameter.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getValue", _wrap_Parameter_getValue, METH_VARARGS, (char *)"\n"
		"Parameter_getValue(Parameter self) -> double\n"
		"\n"
		"Gets the numerical value of this Parameter.\n"
		"\n"
		"@return the value of the 'value' attribute of this Parameter, as a\n"
		"number of type @c double.\n"
		"\n"
		"@note <b>It is crucial</b> that callers not blindly call\n"
		"Parameter.getValue() without first using Parameter.isSetValue() to\n"
		"determine whether a value has ever been set.  Otherwise, the value\n"
		"return by Parameter.getValue() may not actually represent a value\n"
		"assigned to the parameter.  The reason is simply that the data type\n"
		"@c double in a program always has @em some value.  A separate test is\n"
		"needed to determine whether the value is a true model value, or\n"
		"uninitialized data in a computer's memory location.\n"
		"\n"
		"@see isSetValue()\n"
		"@see setValue()\n"
		"@see getUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getUnits", _wrap_Parameter_getUnits, METH_VARARGS, (char *)"\n"
		"Parameter_getUnits(Parameter self) -> string\n"
		"\n"
		"Gets the units defined for this Parameter.\n"
		"\n"
		"The value of an SBML parameter's 'units' attribute establishes the\n"
		"unit of measurement associated with the parameter's value.\n"
		"\n"
		"@return the value of the 'units' attribute of this Parameter, as a\n"
		"string.  An empty string indicates that no units have been assigned.\n"
		"\n"
		"@note @htmlinclude unassigned-units-are-not-a-default.html\n"
		"\n"
		"@see isSetUnits()\n"
		"@see setUnits()\n"
		"@see getValue()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getConstant", _wrap_Parameter_getConstant, METH_VARARGS, (char *)"\n"
		"Parameter_getConstant(Parameter self) -> bool\n"
		"\n"
		"Gets the value of the 'constant' attribute of this Parameter instance.\n"
		"\n"
		"@return @c true if this Parameter is declared as being constant,\n"
		"@c false otherwise.\n"
		"\n"
		"@note Readers who view the documentation for LocalParameter may be\n"
		"confused about the presence of this method.  LibSBML derives\n"
		"LocalParameter from Parameter; however, this does not precisely match\n"
		"the object hierarchy defined by SBML Level&nbsp;3, where\n"
		"LocalParameter is derived directly from SBase and not Parameter.  We\n"
		"believe this arrangement makes it easier for libSBML users to program\n"
		"applications that work with both SBML Level&nbsp;2 and SBML\n"
		"Level&nbsp;3, but programmers should also keep in mind this difference\n"
		"exists.  A side-effect of libSBML's scheme is that certain methods on\n"
		"LocalParameter that are inherited from Parameter do not actually have\n"
		"relevance to LocalParameter objects.  An example of this is the\n"
		"methods pertaining to Parameter's attribute 'constant' (i.e.,\n"
		"isSetConstant(), setConstant(), and getConstant()).\n"
		"\n"
		"@see isSetConstant()\n"
		"@see setConstant()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_isSetId", _wrap_Parameter_isSetId, METH_VARARGS, (char *)"\n"
		"Parameter_isSetId(Parameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Parameter's 'id' attribute is set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this Parameter is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_isSetName", _wrap_Parameter_isSetName, METH_VARARGS, (char *)"\n"
		"Parameter_isSetName(Parameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Parameter's 'name' attribute is set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this Parameter is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_isSetValue", _wrap_Parameter_isSetValue, METH_VARARGS, (char *)"\n"
		"Parameter_isSetValue(Parameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if the\n"
		"'value' attribute of this Parameter is set.\n"
		"\n"
		"In SBML definitions after SBML Level&nbsp;1 Version&nbsp;1,\n"
		"parameter values are optional and have no defaults.  If a model read\n"
		"from a file does not contain a setting for the 'value' attribute of a\n"
		"parameter, its value is considered unset; it does not default to any\n"
		"particular value.  Similarly, when a Parameter object is created in\n"
		"libSBML, it has no value until given a value.  The\n"
		"Parameter.isSetValue() method allows calling applications to\n"
		"determine whether a given parameter's value has ever been set.\n"
		"\n"
		"In SBML Level&nbsp;1 Version&nbsp;1, parameters are required to have\n"
		"values and therefore, the value of a Parameter <b>should always be\n"
		"set</b>.  In Level&nbsp;1 Version&nbsp;2 and beyond, the value is\n"
		"optional and as such, the 'value' attribute may or may not be set.\n"
		"\n"
		"@return @c true if the value of this Parameter is set,\n"
		"@c false otherwise.\n"
		"\n"
		"@see getValue()\n"
		"@see setValue()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_isSetUnits", _wrap_Parameter_isSetUnits, METH_VARARGS, (char *)"\n"
		"Parameter_isSetUnits(Parameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if the\n"
		"'units' attribute of this Parameter is set.\n"
		"\n"
		"@return @c true if the 'units' attribute of this Parameter is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note @htmlinclude unassigned-units-are-not-a-default.html\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_isSetConstant", _wrap_Parameter_isSetConstant, METH_VARARGS, (char *)"\n"
		"Parameter_isSetConstant(Parameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if the\n"
		"'constant' attribute of this Parameter is set.\n"
		"\n"
		"@return @c true if the 'constant' attribute of this Parameter is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note Readers who view the documentation for LocalParameter may be\n"
		"confused about the presence of this method.  LibSBML derives\n"
		"LocalParameter from Parameter; however, this does not precisely match\n"
		"the object hierarchy defined by SBML Level&nbsp;3, where\n"
		"LocalParameter is derived directly from SBase and not Parameter.  We\n"
		"believe this arrangement makes it easier for libSBML users to program\n"
		"applications that work with both SBML Level&nbsp;2 and SBML\n"
		"Level&nbsp;3, but programmers should also keep in mind this difference\n"
		"exists.  A side-effect of libSBML's scheme is that certain methods on\n"
		"LocalParameter that are inherited from Parameter do not actually have\n"
		"relevance to LocalParameter objects.  An example of this is the\n"
		"methods pertaining to Parameter's attribute 'constant' (i.e.,\n"
		"isSetConstant(), setConstant(), and getConstant()).\n"
		"\n"
		"@see getConstant()\n"
		"@see setConstant()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_setId", _wrap_Parameter_setId, METH_VARARGS, (char *)"\n"
		"Parameter_setId(Parameter self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this Parameter.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this Parameter\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_setName", _wrap_Parameter_setName, METH_VARARGS, (char *)"\n"
		"Parameter_setName(Parameter self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this Parameter.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the Parameter\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_setValue", _wrap_Parameter_setValue, METH_VARARGS, (char *)"\n"
		"Parameter_setValue(Parameter self, double value) -> int\n"
		"\n"
		"Sets the 'value' attribute of this Parameter to the given @c double\n"
		"value and marks the attribute as set.\n"
		"\n"
		"@param value a @c double, the value to assign\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_setUnits", _wrap_Parameter_setUnits, METH_VARARGS, (char *)"\n"
		"Parameter_setUnits(Parameter self, string units) -> int\n"
		"\n"
		"Sets the 'units' attribute of this Parameter to a copy of the given\n"
		"units identifier @p units.\n"
		"\n"
		"@param units a string, the identifier of the units to assign to this\n"
		"Parameter instance\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_setConstant", _wrap_Parameter_setConstant, METH_VARARGS, (char *)"\n"
		"Parameter_setConstant(Parameter self, bool flag) -> int\n"
		"\n"
		"Sets the 'constant' attribute of this Parameter to the given boolean\n"
		"@p flag.\n"
		"\n"
		"@param flag a boolean, the value for the 'constant' attribute of this\n"
		"Parameter instance\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note Readers who view the documentation for LocalParameter may be\n"
		"confused about the presence of this method.  LibSBML derives\n"
		"LocalParameter from Parameter; however, this does not precisely match\n"
		"the object hierarchy defined by SBML Level&nbsp;3, where\n"
		"LocalParameter is derived directly from SBase and not Parameter.  We\n"
		"believe this arrangement makes it easier for libSBML users to program\n"
		"applications that work with both SBML Level&nbsp;2 and SBML\n"
		"Level&nbsp;3, but programmers should also keep in mind this difference\n"
		"exists.  A side-effect of libSBML's scheme is that certain methods on\n"
		"LocalParameter that are inherited from Parameter do not actually have\n"
		"relevance to LocalParameter objects.  An example of this is the\n"
		"methods pertaining to Parameter's attribute 'constant' (i.e.,\n"
		"isSetConstant(), setConstant(), and getConstant()).\n"
		"\n"
		"@see getConstant()\n"
		"@see isSetConstant()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_unsetName", _wrap_Parameter_unsetName, METH_VARARGS, (char *)"\n"
		"Parameter_unsetName(Parameter self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this Parameter.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_unsetValue", _wrap_Parameter_unsetValue, METH_VARARGS, (char *)"\n"
		"Parameter_unsetValue(Parameter self) -> int\n"
		"\n"
		"Unsets the 'value' attribute of this Parameter instance.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"In SBML Level&nbsp;1 Version&nbsp;1, parameters are required to have\n"
		"values and therefore, the value of a Parameter <b>should always be\n"
		"set</b>.  In SBML Level&nbsp;1 Version&nbsp;2 and beyond, the value\n"
		"is optional and as such, the 'value' attribute may or may not be set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_unsetUnits", _wrap_Parameter_unsetUnits, METH_VARARGS, (char *)"\n"
		"Parameter_unsetUnits(Parameter self) -> int\n"
		"\n"
		"Unsets the 'units' attribute of this Parameter instance.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getDerivedUnitDefinition", _wrap_Parameter_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"Parameter_getDerivedUnitDefinition(Parameter self) -> UnitDefinition\n"
		"\n"
		"Constructs and returns a UnitDefinition that corresponds to the units\n"
		"of this Parameter's value.\n"
		"\n"
		"Parameters in SBML have an attribute ('units') for declaring the units\n"
		"of measurement intended for the parameter's value.  <b>No defaults are\n"
		"defined</b> by SBML in the absence of a definition for 'units'.  This\n"
		"method returns a UnitDefinition object based on the units declared for\n"
		"this Parameter using its 'units' attribute, or it returns @c None if\n"
		"no units have been declared.\n"
		"\n"
		"Note that unit declarations for Parameter objects are specified in\n"
		"terms of the @em identifier of a unit (e.g., using setUnits()), but\n"
		"@em this method returns a UnitDefinition object, not a unit\n"
		"identifier.  It does this by constructing an appropriate\n"
		"UnitDefinition.For SBML Level&nbsp;2 models, it will do this even when\n"
		"the value of the 'units' attribute is one of the special SBML\n"
		"Level&nbsp;2 unit identifiers @c 'substance', @c 'volume', @c 'area',\n"
		"@c 'length' or @c 'time'.  Callers may find this useful in conjunction\n"
		"with the helper methods provided by the UnitDefinition class for\n"
		"comparing different UnitDefinition objects.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of this \n"
		"Parameter, or @c None if one cannot be constructed.\n"
		"\n"
		"@note The libSBML system for unit analysis depends on the model as a\n"
		"whole.  In cases where the Parameter object has not yet been added to\n"
		"a model, or the model itself is incomplete, unit analysis is not\n"
		"possible, and consequently this method will return @c None.\n"
		"\n"
		"@see isSetUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getTypeCode", _wrap_Parameter_getTypeCode, METH_VARARGS, (char *)"\n"
		"Parameter_getTypeCode(Parameter self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or\n"
		"@link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_getElementName", _wrap_Parameter_getElementName, METH_VARARGS, (char *)"\n"
		"Parameter_getElementName(Parameter self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Parameter, is\n"
		"always @c 'parameter'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'parameter'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_hasRequiredAttributes", _wrap_Parameter_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Parameter_hasRequiredAttributes(Parameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this Parameter object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a Parameter object are:\n"
		"@li 'id' (or 'name' in SBML Level&nbsp;1)\n"
		"@li 'value' (required in Level&nbsp;1, optional otherwise)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Parameter_swigregister", Parameter_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfParameters_clone", _wrap_ListOfParameters_clone, METH_VARARGS, (char *)"\n"
		"ListOfParameters_clone(ListOfParameters self) -> ListOfParameters\n"
		"\n"
		"Creates and returns a deep copy of this ListOfParameters instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfParameters.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfParameters_getTypeCode", _wrap_ListOfParameters_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfParameters_getTypeCode(ListOfParameters self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link\n"
		"libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfParameters_getItemTypeCode", _wrap_ListOfParameters_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfParameters_getItemTypeCode(ListOfParameters self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Parameter objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink\n"
		"(default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfParameters_getElementName", _wrap_ListOfParameters_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfParameters_getElementName(ListOfParameters self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfParameters, the XML element name is @c 'listOfParameters'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfParameters'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfParameters_get", _wrap_ListOfParameters_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Parameter\n"
		"get(unsigned int n) -> Parameter\n"
		"get(string sid) -> Parameter\n"
		"ListOfParameters_get(ListOfParameters self, string sid) -> Parameter\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Returns the Parameter object located at position @p n within this\n"
		"ListOfParameters instance.\n"
		"\n"
		"@param n the index number of the Parameter to get.\n"
		"\n"
		"@return the nth Parameter in this ListOfParameters.  If the index @p n\n"
		"is out of bounds for the length of the list, then @c None is returned.\n"
		"\n"
		"@see size()\n"
		"@see get()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Returns the Parameter object located at position @p n within this\n"
		"ListOfParameters instance.\n"
		"\n"
		"@param n the index number of the Parameter to get.\n"
		"\n"
		"@return the nth Parameter in this ListOfParameters.  If the index @p n\n"
		"is out of bounds for the length of the list, then @c None is returned.\n"
		"\n"
		"@see size()\n"
		"@see get()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Returns the first Parameter object matching the given identifier.\n"
		"\n"
		"@param sid a string, the identifier of the Parameter to get.\n"
		"\n"
		"@return the Parameter object found.  The caller owns the returned\n"
		"object and is responsible for deleting it.  If none of the items have\n"
		"an identifier matching @p sid, then @c None is returned.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Returns the first Parameter object matching the given identifier.\n"
		"\n"
		"@param sid a string representing the identifier of the Parameter to\n"
		"get.\n"
		"\n"
		"@return the Parameter object found.  The caller owns the returned\n"
		"object and is responsible for deleting it.  If none of the items have\n"
		"an identifier matching @p sid, then @c None is returned.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfParameters_remove", _wrap_ListOfParameters_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> Parameter\n"
		"ListOfParameters_remove(ListOfParameters self, string sid) -> Parameter\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfParameters, and returns a pointer\n"
		"to it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@return the item removed.  The caller owns the returned object and is\n"
		"responsible for deleting it.  If the index number @p n is out of\n"
		"bounds for the length of the list, then @c None is returned.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes the first Parameter object in this ListOfParameters\n"
		"matching the given identifier, and returns a pointer to it.\n"
		"\n"
		"@param sid the identifier of the item to remove.\n"
		"\n"
		"@return the item removed.  The caller owns the returned object and is\n"
		"responsible for deleting it.  If none of the items have an identifier\n"
		"matching @p sid, then @c None is returned.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfParameters", _wrap_new_ListOfParameters, METH_VARARGS, (char *)"new_ListOfParameters() -> ListOfParameters"},
	 { (char *)"delete_ListOfParameters", _wrap_delete_ListOfParameters, METH_VARARGS, (char *)"delete_ListOfParameters(ListOfParameters self)"},
	 { (char *)"ListOfParameters_swigregister", ListOfParameters_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_LocalParameter", _wrap_delete_LocalParameter, METH_VARARGS, (char *)"delete_LocalParameter(LocalParameter self)"},
	 { (char *)"new_LocalParameter", _wrap_new_LocalParameter, METH_VARARGS, (char *)"\n"
		"LocalParameter(unsigned int level, unsigned int version)\n"
		"LocalParameter(SBMLNamespaces sbmlns)\n"
		"LocalParameter(LocalParameter orig)\n"
		"new_LocalParameter(Parameter orig) -> LocalParameter\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>LocalParameter(long level, long version)</pre>\n"
		"\n"
		"Creates a new LocalParameter object with the given SBML @p level and\n"
		"@p version values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this\n"
		"LocalParameter.\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"LocalParameter.\n"
		"\n"
		"@note Upon the addition of a LocalParameter object to an SBMLDocument\n"
		"(e.g., using KineticLaw.addLocalParameter()), the SBML Level, SBML\n"
		"Version and XML namespace of the document @em override the\n"
		"values used when creating the LocalParameter object via this\n"
		"constructor.  This is necessary to ensure that an SBML document is a\n"
		"consistent structure.  Nevertheless, the ability to supply the values\n"
		"at the time of creation of a LocalParameter is an important aid to\n"
		"producing valid SBML.  Knowledge of the intented SBML Level and\n"
		"Version determine whether it is valid to assign a particular value to\n"
		"an attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>LocalParameter(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new LocalParameter object with the given SBMLNamespaces\n"
		"object @p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"It is worth emphasizing that although this constructor does not take\n"
		"an identifier argument, in SBML Level&nbsp;2 and beyond, the 'id'\n"
		"(identifier) attribute of a LocalParameter is required to have a value.\n"
		"Thus, callers are cautioned to assign a value after calling this\n"
		"constructor if no identifier is provided as an argument.  Setting the\n"
		"identifier can be accomplished using the method\n"
		"@if java setId(String id)@else setId()@endif.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a LocalParameter object to an SBMLDocument\n"
		"(e.g., using KineticLaw.addLocalParameter()), the SBML XML namespace of\n"
		"the document @em overrides the value used when creating the\n"
		"LocalParameter object via this constructor.  This is necessary to\n"
		"ensure that an SBML document is a consistent structure.  Nevertheless,\n"
		"the ability to supply the values at the time of creation of a\n"
		"LocalParameter is an important aid to producing valid SBML.  Knowledge\n"
		"of the intented SBML Level and Version determine whether it is valid\n"
		"to assign a particular value to an attribute, or whether it is valid\n"
		"to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>LocalParameter(LocalParameter orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of a given LocalParameter object.\n"
		"\n"
		"@param orig the LocalParameter instance to copy.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>LocalParameter(Parameter orig)</pre>\n"
		"\n"
		"Copy constructor; creates a LocalParameter object by copying\n"
		"the attributes of a given Parameter object.\n"
		"\n"
		"@param orig the Parameter instance to copy.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"LocalParameter_clone", _wrap_LocalParameter_clone, METH_VARARGS, (char *)"\n"
		"LocalParameter_clone(LocalParameter self) -> LocalParameter\n"
		"\n"
		"Creates and returns a deep copy of this LocalParameter.\n"
		"\n"
		"@return a (deep) copy of this LocalParameter.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"LocalParameter_getDerivedUnitDefinition", _wrap_LocalParameter_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"LocalParameter_getDerivedUnitDefinition(LocalParameter self) -> UnitDefinition\n"
		"\n"
		"Constructs and returns a UnitDefinition that corresponds to the units\n"
		"of this LocalParameter's value.\n"
		"\n"
		"LocalParameters in SBML have an attribute ('units') for declaring the\n"
		"units of measurement intended for the parameter's value.  <b>No\n"
		"defaults are defined</b> by SBML in the absence of a definition for\n"
		"'units'.  This method returns a UnitDefinition object based on the\n"
		"units declared for this LocalParameter using its 'units' attribute, or\n"
		"it returns @c None if no units have been declared.\n"
		"\n"
		"Note that unit declarations for LocalParameter objects are specified\n"
		"in terms of the @em identifier of a unit (e.g., using setUnits()), but\n"
		"@em this method returns a UnitDefinition object, not a unit\n"
		"identifier.  It does this by constructing an appropriate\n"
		"UnitDefinition.  For SBML Level&nbsp;2 models, it will do this even\n"
		"when the value of the 'units' attribute is one of the predefined SBML\n"
		"units @c 'substance', @c 'volume', @c 'area', @c 'length' or @c\n"
		"'time'.  Callers may find this useful in conjunction with the helper\n"
		"methods provided by the UnitDefinition class for comparing different\n"
		"UnitDefinition objects.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of this \n"
		"LocalParameter, or @c None if one cannot be constructed.\n"
		"\n"
		"@note The libSBML system for unit analysis depends on the model as a\n"
		"whole.  In cases where the LocalParameter object has not yet been\n"
		"added to a model, or the model itself is incomplete, unit analysis is\n"
		"not possible, and consequently this method will return @c None.\n"
		"\n"
		"@see isSetUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"LocalParameter_getTypeCode", _wrap_LocalParameter_getTypeCode, METH_VARARGS, (char *)"\n"
		"LocalParameter_getTypeCode(LocalParameter self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link\n"
		"libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"LocalParameter_getElementName", _wrap_LocalParameter_getElementName, METH_VARARGS, (char *)"\n"
		"LocalParameter_getElementName(LocalParameter self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for LocalParameter,\n"
		"is always @c 'localParameter'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'localParameter'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"LocalParameter_hasRequiredAttributes", _wrap_LocalParameter_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"LocalParameter_hasRequiredAttributes(LocalParameter self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this LocalParameter object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a LocalParameter object are:\n"
		"@li 'id'\n"
		"@li 'value'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"LocalParameter_swigregister", LocalParameter_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfLocalParameters_clone", _wrap_ListOfLocalParameters_clone, METH_VARARGS, (char *)"\n"
		"ListOfLocalParameters_clone(ListOfLocalParameters self) -> ListOfLocalParameters\n"
		"\n"
		"Creates and returns a deep copy of this ListOfLocalParameters object.\n"
		"\n"
		"@return a (deep) copy of this ListOfLocalParameters.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfLocalParameters_getTypeCode", _wrap_ListOfLocalParameters_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfLocalParameters_getTypeCode(ListOfLocalParameters self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link\n"
		"libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfLocalParameters_getItemTypeCode", _wrap_ListOfLocalParameters_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfLocalParameters_getItemTypeCode(ListOfLocalParameters self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., LocalParameter objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink\n"
		"(default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfLocalParameters_getElementName", _wrap_ListOfLocalParameters_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfLocalParameters_getElementName(ListOfLocalParameters self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfLocalParameters, the XML element name is @c 'listOfLocalParameters'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfLocalParameters'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfLocalParameters_get", _wrap_ListOfLocalParameters_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> LocalParameter\n"
		"get(unsigned int n) -> LocalParameter\n"
		"get(string sid) -> LocalParameter\n"
		"ListOfLocalParameters_get(ListOfLocalParameters self, string sid) -> LocalParameter\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Returns the LocalParameter object located at position @p n within this\n"
		"ListOfLocalParameters instance.\n"
		"\n"
		"@param n the index number of the LocalParameter to get.\n"
		"\n"
		"@return the nth LocalParameter in this ListOfLocalParameters.  If the\n"
		"index @p n is out of bounds for the length of the list, then @c None\n"
		"is returned.\n"
		"\n"
		"@see size()\n"
		"@see get()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Returns the LocalParameter object located at position @p n within this\n"
		"ListOfLocalParameters instance.\n"
		"\n"
		"@param n the index number of the LocalParameter to get.\n"
		"\n"
		"@return the item at position @p n.  The caller owns the returned\n"
		"object and is responsible for deleting it.  If the index number @p n\n"
		"is out of bounds for the length of the list, then @c None is returned.\n"
		"\n"
		"@see size()\n"
		"@see get()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Returns the first LocalParameter object matching the given identifier.\n"
		"\n"
		"@param sid a string, the identifier of the LocalParameter to get.\n"
		"\n"
		"@return the LocalParameter object found.  The caller owns the returned\n"
		"object and is responsible for deleting it.  If none of the items have\n"
		"an identifier matching @p sid, then @c None is returned.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Returns the first LocalParameter object matching the given identifier.\n"
		"\n"
		"@param sid a string representing the identifier of the LocalParameter\n"
		"to get.\n"
		"\n"
		"@return the LocalParameter object found.  The caller owns the returned\n"
		"object and is responsible for deleting it.  If none of the items have\n"
		"an identifier matching @p sid, then @c None is returned.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfLocalParameters_remove", _wrap_ListOfLocalParameters_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> LocalParameter\n"
		"ListOfLocalParameters_remove(ListOfLocalParameters self, string sid) -> LocalParameter\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfLocalParameters, and returns a\n"
		"pointer to it.\n"
		"\n"
		"@param n the index of the item to remove.  \n"
		"\n"
		"@return the item removed.  The caller owns the returned object and is\n"
		"responsible for deleting it.  If the index number @p n is out of\n"
		"bounds for the length of the list, then @c None is returned.\n"
		"\n"
		"@see size()\n"
		"@see remove()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes the first LocalParameter object in this ListOfLocalParameters\n"
		"matching the given identifier, and returns a pointer to it.\n"
		"\n"
		"@param sid the identifier of the item to remove.\n"
		"\n"
		"@return the item removed.  The caller owns the returned object and is\n"
		"responsible for deleting it.  If none of the items have an identifier\n"
		"matching @p sid, then @c None is returned.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfLocalParameters", _wrap_new_ListOfLocalParameters, METH_VARARGS, (char *)"new_ListOfLocalParameters() -> ListOfLocalParameters"},
	 { (char *)"delete_ListOfLocalParameters", _wrap_delete_ListOfLocalParameters, METH_VARARGS, (char *)"delete_ListOfLocalParameters(ListOfLocalParameters self)"},
	 { (char *)"ListOfLocalParameters_swigregister", ListOfLocalParameters_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_InitialAssignment", _wrap_delete_InitialAssignment, METH_VARARGS, (char *)"delete_InitialAssignment(InitialAssignment self)"},
	 { (char *)"new_InitialAssignment", _wrap_new_InitialAssignment, METH_VARARGS, (char *)"\n"
		"InitialAssignment(unsigned int level, unsigned int version)\n"
		"InitialAssignment(SBMLNamespaces sbmlns)\n"
		"new_InitialAssignment(InitialAssignment orig) -> InitialAssignment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>InitialAssignment(long level, long version)</pre>\n"
		"\n"
		"Creates a new InitialAssignment using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this InitialAssignment\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"InitialAssignment\n"
		"\n"
		"@note Upon the addition of a InitialAssignment object to an\n"
		"SBMLDocument (e.g., using Model.addInitialAssignment()), the SBML\n"
		"Level, SBML Version and XML namespace of the document @em\n"
		"override the values used when creating the InitialAssignment object\n"
		"via this constructor.  This is necessary to ensure that an SBML\n"
		"document is a consistent structure.  Nevertheless, the ability to\n"
		"supply the values at the time of creation of a InitialAssignment is an\n"
		"important aid to producing valid SBML.  Knowledge of the intented SBML\n"
		"Level and Version determine whether it is valid to assign a particular\n"
		"value to an attribute, or whether it is valid to add an object to an\n"
		"existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>InitialAssignment(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new InitialAssignment using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a InitialAssignment object to an\n"
		"SBMLDocument (e.g., using Model.addInitialAssignment()), the SBML XML\n"
		"namespace of the document @em overrides the value used when creating\n"
		"the InitialAssignment object via this constructor.  This is necessary\n"
		"to ensure that an SBML document is a consistent structure.\n"
		"Nevertheless, the ability to supply the values at the time of creation\n"
		"of a InitialAssignment is an important aid to producing valid SBML.\n"
		"Knowledge of the intented SBML Level and Version determine whether it\n"
		"is valid to assign a particular value to an attribute, or whether it\n"
		"is valid to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>InitialAssignment(InitialAssignment orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this InitialAssignment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_clone", _wrap_InitialAssignment_clone, METH_VARARGS, (char *)"\n"
		"InitialAssignment_clone(InitialAssignment self) -> InitialAssignment\n"
		"\n"
		"Creates and returns a deep copy of this InitialAssignment.\n"
		"\n"
		"@return a (deep) copy of this InitialAssignment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_getSymbol", _wrap_InitialAssignment_getSymbol, METH_VARARGS, (char *)"\n"
		"InitialAssignment_getSymbol(InitialAssignment self) -> string\n"
		"\n"
		"Get the value of the 'symbol' attribute of this InitialAssignment.\n"
		"\n"
		"@return the identifier string stored as the 'symbol' attribute value\n"
		"in this InitialAssignment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_getMath", _wrap_InitialAssignment_getMath, METH_VARARGS, (char *)"\n"
		"InitialAssignment_getMath(InitialAssignment self) -> ASTNode\n"
		"\n"
		"Get the mathematical formula of this InitialAssignment.\n"
		"\n"
		"@return an ASTNode, the value of the 'math' subelement of this\n"
		"InitialAssignment\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_isSetSymbol", _wrap_InitialAssignment_isSetSymbol, METH_VARARGS, (char *)"\n"
		"InitialAssignment_isSetSymbol(InitialAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"InitialAssignment's 'symbol' attribute is set.\n"
		"\n"
		"@return @c true if the 'symbol' attribute of this InitialAssignment\n"
		"is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_isSetMath", _wrap_InitialAssignment_isSetMath, METH_VARARGS, (char *)"\n"
		"InitialAssignment_isSetMath(InitialAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"InitialAssignment's 'math' subelement contains a value.\n"
		"\n"
		"@return @c true if the 'math' for this InitialAssignment is set,\n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_setSymbol", _wrap_InitialAssignment_setSymbol, METH_VARARGS, (char *)"\n"
		"InitialAssignment_setSymbol(InitialAssignment self, string sid) -> int\n"
		"\n"
		"Sets the 'symbol' attribute value of this InitialAssignment.\n"
		"\n"
		"@param sid the identifier of a Species, Compartment or Parameter\n"
		"object defined elsewhere in this Model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_setMath", _wrap_InitialAssignment_setMath, METH_VARARGS, (char *)"\n"
		"InitialAssignment_setMath(InitialAssignment self, ASTNode math) -> int\n"
		"\n"
		"Sets the 'math' subelement of this InitialAssignment.\n"
		"\n"
		"The AST passed in @p math is copied.\n"
		"\n"
		"@param math an AST containing the mathematical expression to\n"
		"be used as the formula for this InitialAssignment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_getDerivedUnitDefinition", _wrap_InitialAssignment_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"InitialAssignment_getDerivedUnitDefinition(InitialAssignment self) -> UnitDefinition\n"
		"\n"
		"Calculates and returns a UnitDefinition that expresses the units\n"
		"of measurement assumed for the 'math' expression of this\n"
		"InitialAssignment.\n"
		"\n"
		"The units are calculated based on the mathematical expression in the\n"
		"InitialAssignment and the model quantities referenced by\n"
		"<code>&lt;ci&gt;</code> elements used within that expression.  The\n"
		"@if java InitialAssignment.getDerivedUnitDefinition()@else getDerivedUnitDefinition()@endif\n"
		"method returns the calculated units.\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c None.\n"
		"\n"
		"@warning Note that it is possible the 'math' expression in the\n"
		"InitialAssignment contains pure numbers or parameters with undeclared\n"
		"units.  In those cases, it is not possible to calculate the units of\n"
		"the overall expression without making assumptions.  LibSBML does not\n"
		"make assumptions about the units, and\n"
		"@if java InitialAssignment.getDerivedUnitDefinition()@else getDerivedUnitDefinition()@endif\n"
		"only returns the units as far as it is able to determine them.  For\n"
		"example, in an expression <em>X + Y</em>, if <em>X</em> has\n"
		"unambiguously-defined units and <em>Y</em> does not, it will return\n"
		"the units of <em>X</em>.  <strong>It is important that callers also\n"
		"invoke the method</strong>\n"
		"@if java InitialAssignment.containsUndeclaredUnits()@else containsUndeclaredUnits()@endif\n"
		"<strong>to determine whether this situation holds</strong>.  Callers\n"
		"may wish to take suitable actions in those scenarios.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of the math \n"
		"expression of this InitialAssignment, or @c None if one cannot be constructed.\n"
		"\n"
		"@see containsUndeclaredUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_containsUndeclaredUnits", _wrap_InitialAssignment_containsUndeclaredUnits, METH_VARARGS, (char *)"\n"
		"containsUndeclaredUnits() -> bool\n"
		"InitialAssignment_containsUndeclaredUnits(InitialAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if \n"
		"the math expression of this InitialAssignment contains\n"
		"parameters/numbers with undeclared units.\n"
		"\n"
		"@return @c true if the math expression of this InitialAssignment\n"
		"includes parameters/numbers \n"
		"with undeclared units, @c false otherwise.\n"
		"\n"
		"@note A return value of @c true indicates that the UnitDefinition\n"
		"returned by\n"
		"@if java InitialAssignment.getDerivedUnitDefinition()@else getDerivedUnitDefinition()@endif\n"
		"may not accurately represent the units of the expression.\n"
		"\n"
		"@see getDerivedUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_getTypeCode", _wrap_InitialAssignment_getTypeCode, METH_VARARGS, (char *)"\n"
		"InitialAssignment_getTypeCode(InitialAssignment self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_getElementName", _wrap_InitialAssignment_getElementName, METH_VARARGS, (char *)"\n"
		"InitialAssignment_getElementName(InitialAssignment self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for\n"
		"InitialAssignment, is always @c 'initialAssignment'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'initialAssignment'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_hasRequiredAttributes", _wrap_InitialAssignment_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"InitialAssignment_hasRequiredAttributes(InitialAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this InitialAssignment object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for an InitialAssignment object are:\n"
		"@li 'symbol'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_hasRequiredElements", _wrap_InitialAssignment_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"InitialAssignment_hasRequiredElements(InitialAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this InitialAssignment object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a InitialAssignment object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_getId", _wrap_InitialAssignment_getId, METH_VARARGS, (char *)"\n"
		"InitialAssignment_getId(InitialAssignment self) -> string\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if\n"
		"ll the required elements for this InitialAssignment object\n"
		"ave been set.\n"
		"\n"
		"note The required elements for a InitialAssignment object are:\n"
		"li 'math'\n"
		"\n"
		"return a boolean value indicating whether all the required\n"
		"lements for this object have been defined.\n"
		" \n"
		"\n"
		""},
	 { (char *)"InitialAssignment_swigregister", InitialAssignment_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfInitialAssignments_clone", _wrap_ListOfInitialAssignments_clone, METH_VARARGS, (char *)"\n"
		"ListOfInitialAssignments_clone(ListOfInitialAssignments self) -> ListOfInitialAssignments\n"
		"\n"
		"Creates and returns a deep copy of this ListOfInitialAssignments instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfInitialAssignments.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfInitialAssignments_getTypeCode", _wrap_ListOfInitialAssignments_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfInitialAssignments_getTypeCode(ListOfInitialAssignments self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfInitialAssignments_getItemTypeCode", _wrap_ListOfInitialAssignments_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfInitialAssignments_getItemTypeCode(ListOfInitialAssignments self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., InitialAssignment objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfInitialAssignments_getElementName", _wrap_ListOfInitialAssignments_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfInitialAssignments_getElementName(ListOfInitialAssignments self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfInitialAssignments, the XML element name is @c\n"
		"'listOfInitialAssignments'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfInitialAssignments'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfInitialAssignments_get", _wrap_ListOfInitialAssignments_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> InitialAssignment\n"
		"get(unsigned int n) -> InitialAssignment\n"
		"get(string sid) -> InitialAssignment\n"
		"ListOfInitialAssignments_get(ListOfInitialAssignments self, string sid) -> InitialAssignment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a InitialAssignment from the ListOfInitialAssignments.\n"
		"\n"
		"@param n the index number of the InitialAssignment to get.\n"
		"\n"
		"@return the nth InitialAssignment in this ListOfInitialAssignments.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a InitialAssignment from the ListOfInitialAssignments.\n"
		"\n"
		"@param n the index number of the InitialAssignment to get.\n"
		"\n"
		"@return the nth InitialAssignment in this ListOfInitialAssignments.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a InitialAssignment from the ListOfInitialAssignments\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the InitialAssignment to get.\n"
		"\n"
		"@return InitialAssignment in this ListOfInitialAssignments\n"
		"with the given id or @c None if no such\n"
		"InitialAssignment exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a InitialAssignment from the ListOfInitialAssignments\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the InitialAssignment to get.\n"
		"\n"
		"@return InitialAssignment in this ListOfInitialAssignments\n"
		"with the given id or @c None if no such\n"
		"InitialAssignment exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfInitialAssignments_remove", _wrap_ListOfInitialAssignments_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> InitialAssignment\n"
		"ListOfInitialAssignments_remove(ListOfInitialAssignments self, string sid) -> InitialAssignment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfInitialAssignments items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes item in this ListOfInitialAssignments items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"None is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfInitialAssignments", _wrap_new_ListOfInitialAssignments, METH_VARARGS, (char *)"new_ListOfInitialAssignments() -> ListOfInitialAssignments"},
	 { (char *)"delete_ListOfInitialAssignments", _wrap_delete_ListOfInitialAssignments, METH_VARARGS, (char *)"delete_ListOfInitialAssignments(ListOfInitialAssignments self)"},
	 { (char *)"ListOfInitialAssignments_swigregister", ListOfInitialAssignments_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Rule", _wrap_delete_Rule, METH_VARARGS, (char *)"delete_Rule(Rule self)"},
	 { (char *)"new_Rule", _wrap_new_Rule, METH_VARARGS, (char *)"\n"
		"new_Rule(Rule orig) -> Rule\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Rule(Rule orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this Rule.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_clone", _wrap_Rule_clone, METH_VARARGS, (char *)"\n"
		"Rule_clone(Rule self) -> Rule\n"
		"\n"
		"Creates and returns a deep copy of this Rule.\n"
		"\n"
		"@return a (deep) copy of this Rule.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getFormula", _wrap_Rule_getFormula, METH_VARARGS, (char *)"\n"
		"Rule_getFormula(Rule self) -> string\n"
		"\n"
		"Returns the mathematical expression of this Rule in text-string form.\n"
		"\n"
		"The text string is produced by\n"
		"@if java <code><a href='libsbml.html#formulaToString(org.sbml.libsbml.ASTNode)'>libsbml.formulaToString()</a></code>@else SBML_formulaToString()@endif; please consult\n"
		"the documentation for that function to find out more about the format\n"
		"of the text-string formula.\n"
		"\n"
		"@return the formula text string for this Rule.\n"
		"\n"
		"@note The attribute 'formula' is specific to SBML Level&nbsp;1; in\n"
		"higher Levels of SBML, it has been replaced with a subelement named\n"
		"'math'.  However, libSBML provides a unified interface to the\n"
		"underlying math expression and this method can be used for models\n"
		"of all Levels of SBML.\n"
		"\n"
		"@see getMath()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getMath", _wrap_Rule_getMath, METH_VARARGS, (char *)"\n"
		"Rule_getMath(Rule self) -> ASTNode\n"
		"\n"
		"Get the mathematical formula of this Rule as an ASTNode tree.\n"
		"\n"
		"@return an ASTNode, the value of the 'math' subelement of this Rule.\n"
		"\n"
		"@note The subelement 'math' is present in SBML Levels&nbsp;2\n"
		"and&nbsp;3.  In SBML Level&nbsp;1, the equivalent construct is the\n"
		"attribute named 'formula'.  LibSBML provides a unified interface to\n"
		"the underlying math expression and this method can be used for models\n"
		"of all Levels of SBML.\n"
		"\n"
		"@see getFormula()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getVariable", _wrap_Rule_getVariable, METH_VARARGS, (char *)"\n"
		"Rule_getVariable(Rule self) -> string\n"
		"\n"
		"Get the value of the 'variable' attribute of this Rule object.\n"
		"\n"
		"In SBML Level&nbsp;1, the different rule types each have a different\n"
		"name for the attribute holding the reference to the object\n"
		"constituting the left-hand side of the rule.  (E.g., for\n"
		"SBML Level&nbsp;1's SpeciesConcentrationRule the attribute is 'species', for\n"
		"CompartmentVolumeRule it is 'compartment', etc.)  In SBML\n"
		"Levels&nbsp;2 and&nbsp;3, the only two types of Rule objects with a\n"
		"left-hand side object reference are AssignmentRule and RateRule, and\n"
		"both of them use the same name for attribute: 'variable'.  In order to\n"
		"make it easier for application developers to work with all Levels of\n"
		"SBML, libSBML uses a uniform name for all of such attributes, and it\n"
		"is 'variable', regardless of whether Level&nbsp;1 rules or\n"
		"Level&nbsp;2&ndash;3 rules are being used.\n"
		"\n"
		"@return the identifier string stored as the 'variable' attribute value\n"
		"in this Rule, or @c None if this object is an AlgebraicRule object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getUnits", _wrap_Rule_getUnits, METH_VARARGS, (char *)"\n"
		"Rule_getUnits(Rule self) -> string\n"
		"\n"
		"Returns the units for the\n"
		"mathematical formula of this Rule.\n"
		"\n"
		"@return the identifier of the units for the expression of this Rule.\n"
		"\n"
		"@note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule\n"
		"objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isSetFormula", _wrap_Rule_isSetFormula, METH_VARARGS, (char *)"\n"
		"Rule_isSetFormula(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Rule's mathematical expression is set.\n"
		"\n"
		"This method is equivalent to isSetMath().  This version is present for\n"
		"easier compatibility with SBML Level&nbsp;1, in which mathematical\n"
		"formulas were written in text-string form.\n"
		"\n"
		"@return @c true if the mathematical formula for this Rule is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The attribute 'formula' is specific to SBML Level&nbsp;1; in\n"
		"higher Levels of SBML, it has been replaced with a subelement named\n"
		"'math'.  However, libSBML provides a unified interface to the\n"
		"underlying math expression and this method can be used for models\n"
		"of all Levels of SBML.\n"
		"\n"
		"@see isSetMath()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isSetMath", _wrap_Rule_isSetMath, METH_VARARGS, (char *)"\n"
		"Rule_isSetMath(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Rule's mathematical expression is set.\n"
		"\n"
		"This method is equivalent to isSetFormula().\n"
		"\n"
		"@return @c true if the formula (or equivalently the math) for this\n"
		"Rule is set, @c false otherwise.\n"
		"\n"
		"@note The subelement 'math' is present in SBML Levels&nbsp;2\n"
		"and&nbsp;3.  In SBML Level&nbsp;1, the equivalent construct is the\n"
		"attribute named 'formula'.  LibSBML provides a unified interface to\n"
		"the underlying math expression and this method can be used for models\n"
		"of all Levels of SBML.\n"
		"\n"
		"@see isSetFormula()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isSetVariable", _wrap_Rule_isSetVariable, METH_VARARGS, (char *)"\n"
		"Rule_isSetVariable(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Rule's 'variable' attribute is set.\n"
		"\n"
		"In SBML Level&nbsp;1, the different rule types each have a different\n"
		"name for the attribute holding the reference to the object\n"
		"constituting the left-hand side of the rule.  (E.g., for\n"
		"SBML Level&nbsp;1's SpeciesConcentrationRule the attribute is 'species', for\n"
		"CompartmentVolumeRule it is 'compartment', etc.)  In SBML\n"
		"Levels&nbsp;2 and&nbsp;3, the only two types of Rule objects with a\n"
		"left-hand side object reference are AssignmentRule and RateRule, and\n"
		"both of them use the same name for attribute: 'variable'.  In order to\n"
		"make it easier for application developers to work with all Levels of\n"
		"SBML, libSBML uses a uniform name for all such attributes, and it is\n"
		"'variable', regardless of whether Level&nbsp;1 rules or\n"
		"Level&nbsp;2&ndash;3 rules are being used.\n"
		"\n"
		"@return @c true if the 'variable' attribute value of this Rule is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isSetUnits", _wrap_Rule_isSetUnits, METH_VARARGS, (char *)"\n"
		"Rule_isSetUnits(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true\n"
		"if this Rule's 'units' attribute is set.\n"
		"\n"
		"@return @c true if the units for this Rule is set, @c false\n"
		"otherwise\n"
		"\n"
		"@note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule\n"
		"objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_setFormula", _wrap_Rule_setFormula, METH_VARARGS, (char *)"\n"
		"Rule_setFormula(Rule self, string formula) -> int\n"
		"\n"
		"Sets the 'math' subelement of this Rule to an expression in\n"
		"text-string form.\n"
		"\n"
		"This is equivalent to setMath(ASTNode math).  The provision of\n"
		"using text-string formulas is retained for easier SBML Level&nbsp;1\n"
		"compatibility.  The formula is converted to an ASTNode internally.\n"
		"\n"
		"@param formula a mathematical formula in text-string form.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note The attribute 'formula' is specific to SBML Level&nbsp;1; in\n"
		"higher Levels of SBML, it has been replaced with a subelement named\n"
		"'math'.  However, libSBML provides a unified interface to the\n"
		"underlying math expression and this method can be used for models\n"
		"of all Levels of SBML.\n"
		"\n"
		"@see setMath()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_setMath", _wrap_Rule_setMath, METH_VARARGS, (char *)"\n"
		"Rule_setMath(Rule self, ASTNode math) -> int\n"
		"\n"
		"Sets the 'math' subelement of this Rule to a copy of the given\n"
		"ASTNode.\n"
		"\n"
		"@param math the ASTNode structure of the mathematical formula.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note The subelement 'math' is present in SBML Levels&nbsp;2\n"
		"and&nbsp;3.  In SBML Level&nbsp;1, the equivalent construct is the\n"
		"attribute named 'formula'.  LibSBML provides a unified interface to\n"
		"the underlying math expression and this method can be used for models\n"
		"of all Levels of SBML.\n"
		"\n"
		"@see setFormula()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_setVariable", _wrap_Rule_setVariable, METH_VARARGS, (char *)"\n"
		"Rule_setVariable(Rule self, string sid) -> int\n"
		"\n"
		"Sets the 'variable' attribute value of this Rule object.\n"
		"\n"
		"In SBML Level&nbsp;1, the different rule types each have a different\n"
		"name for the attribute holding the reference to the object\n"
		"constituting the left-hand side of the rule.  (E.g., for\n"
		"SBML Level&nbsp;1's SpeciesConcentrationRule the attribute is 'species', for\n"
		"CompartmentVolumeRule it is 'compartment', etc.)  In SBML\n"
		"Levels&nbsp;2 and&nbsp;3, the only two types of Rule objects with a\n"
		"left-hand side object reference are AssignmentRule and RateRule, and\n"
		"both of them use the same name for attribute: 'variable'.  In order to\n"
		"make it easier for application developers to work with all Levels of\n"
		"SBML, libSBML uses a uniform name for all such attributes, and it is\n"
		"'variable', regardless of whether Level&nbsp;1 rules or\n"
		"Level&nbsp;2&ndash;3 rules are being used.\n"
		"\n"
		"@param sid the identifier of a Compartment, Species or Parameter\n"
		"elsewhere in the enclosing Model object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_setUnits", _wrap_Rule_setUnits, METH_VARARGS, (char *)"\n"
		"Rule_setUnits(Rule self, string sname) -> int\n"
		"\n"
		"Sets the units for this Rule.\n"
		"\n"
		"@param sname the identifier of the units\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule\n"
		"objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_unsetUnits", _wrap_Rule_unsetUnits, METH_VARARGS, (char *)"\n"
		"Rule_unsetUnits(Rule self) -> int\n"
		"\n"
		"Unsets the 'units' for this Rule.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attribute 'units' exists on SBML Level&nbsp;1 ParameterRule\n"
		"objects only.  It is not present in SBML Levels&nbsp;2 and&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getDerivedUnitDefinition", _wrap_Rule_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"Rule_getDerivedUnitDefinition(Rule self) -> UnitDefinition\n"
		"\n"
		"Calculates and returns a UnitDefinition that expresses the units of\n"
		"measurement assumed for the 'math' expression of this Rule.\n"
		"\n"
		"The units are calculated based on the mathematical expression in the\n"
		"Rule and the model quantities referenced by <code>&lt;ci&gt;</code>\n"
		"elements used within that expression.  The getDerivedUnitDefinition()\n"
		"method returns the calculated units.\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c None.\n"
		"\n"
		"@warning Note that it is possible the 'math' expression in the Rule\n"
		"contains pure numbers or parameters with undeclared units.  In those\n"
		"cases, it is not possible to calculate the units of the overall\n"
		"expression without making assumptions.  LibSBML does not make\n"
		"assumptions about the units, and getDerivedUnitDefinition() only\n"
		"returns the units as far as it is able to determine them.  For\n"
		"example, in an expression <em>X + Y</em>, if <em>X</em> has\n"
		"unambiguously-defined units and <em>Y</em> does not, it will return\n"
		"the units of <em>X</em>.  <strong>It is important that callers also\n"
		"invoke the method</strong>\n"
		"@if java Rule.containsUndeclaredUnits()@else containsUndeclaredUnits()@endif\n"
		"<strong>to determine whether this situation holds</strong>.  Callers may\n"
		"wish to take suitable actions in those scenarios.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of the math \n"
		"expression of this Rule, or @c None if one cannot be constructed.\n"
		"\n"
		"@see containsUndeclaredUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_containsUndeclaredUnits", _wrap_Rule_containsUndeclaredUnits, METH_VARARGS, (char *)"\n"
		"containsUndeclaredUnits() -> bool\n"
		"Rule_containsUndeclaredUnits(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if \n"
		"the math expression of this Rule contains\n"
		"parameters/numbers with undeclared units.\n"
		"\n"
		"@return @c true if the math expression of this Rule\n"
		"includes parameters/numbers \n"
		"with undeclared units, @c false otherwise.\n"
		"\n"
		"@note A return value of @c true indicates that the UnitDefinition\n"
		"returned by getDerivedUnitDefinition() may not accurately represent\n"
		"the units of the expression.\n"
		"\n"
		"@see getDerivedUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getType", _wrap_Rule_getType, METH_VARARGS, (char *)"\n"
		"Rule_getType(Rule self) -> RuleType_t\n"
		"\n"
		"Get the type of rule this is.\n"
		"\n"
		"@return the rule type (a value drawn from the enumeration <a\n"
		"class='el' href='#RuleType_t'>RuleType_t</a>) of this Rule.  The value\n"
		"will be either @link libsbml.RULE_TYPE_RATE RULE_TYPE_RATE@endlink\n"
		"or @link libsbml.RULE_TYPE_SCALAR RULE_TYPE_SCALAR@endlink.\n"
		"\n"
		"@note The attribute 'type' on Rule objects is present only in SBML\n"
		"Level&nbsp;1.  In SBML Level&nbsp;2 and later, the type has been\n"
		"replaced by subclassing the Rule object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isAlgebraic", _wrap_Rule_isAlgebraic, METH_VARARGS, (char *)"\n"
		"Rule_isAlgebraic(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Rule is an AlgebraicRule.\n"
		"\n"
		"@return @c true if this Rule is an AlgebraicRule, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isAssignment", _wrap_Rule_isAssignment, METH_VARARGS, (char *)"\n"
		"Rule_isAssignment(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Rule is an AssignmentRule.\n"
		"\n"
		"@return @c true if this Rule is an AssignmentRule, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isCompartmentVolume", _wrap_Rule_isCompartmentVolume, METH_VARARGS, (char *)"\n"
		"Rule_isCompartmentVolume(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this Rule is an CompartmentVolumeRule\n"
		"or equivalent.\n"
		"\n"
		"This libSBML method works for SBML Level&nbsp;1 models (where there is\n"
		"such a thing as an explicit CompartmentVolumeRule), as well as other Levels of\n"
		"SBML.  For Levels above Level&nbsp;1, this method checks the symbol\n"
		"being affected by the rule, and returns @c true if the symbol is the\n"
		"identifier of a Compartment object defined in the model.\n"
		"\n"
		"@return @c true if this Rule is a CompartmentVolumeRule, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isParameter", _wrap_Rule_isParameter, METH_VARARGS, (char *)"\n"
		"Rule_isParameter(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this Rule is an ParameterRule or\n"
		"equivalent.\n"
		"\n"
		"This libSBML method works for SBML Level&nbsp;1 models (where there is\n"
		"such a thing as an explicit ParameterRule), as well as other Levels of\n"
		"SBML.  For Levels above Level&nbsp;1, this method checks the symbol\n"
		"being affected by the rule, and returns @c true if the symbol is the\n"
		"identifier of a Parameter object defined in the model.\n"
		"\n"
		"@return @c true if this Rule is a ParameterRule, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isRate", _wrap_Rule_isRate, METH_VARARGS, (char *)"\n"
		"Rule_isRate(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this Rule\n"
		"is a RateRule (SBML Levels&nbsp;2&ndash;3) or has a 'type' attribute\n"
		"value of @c 'rate' (SBML Level&nbsp;1).\n"
		"\n"
		"@return @c true if this Rule is a RateRule (Level&nbsp;2) or has\n"
		"type 'rate' (Level&nbsp;1), @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isScalar", _wrap_Rule_isScalar, METH_VARARGS, (char *)"\n"
		"Rule_isScalar(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this Rule\n"
		"is an AssignmentRule (SBML Levels&nbsp;2&ndash;3) or has a 'type'\n"
		"attribute value of @c 'scalar' (SBML Level&nbsp;1).\n"
		"\n"
		"@return @c true if this Rule is an AssignmentRule (Level&nbsp;2) or has\n"
		"type 'scalar' (Level&nbsp;1), @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_isSpeciesConcentration", _wrap_Rule_isSpeciesConcentration, METH_VARARGS, (char *)"\n"
		"Rule_isSpeciesConcentration(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if this Rule is a\n"
		"SpeciesConcentrationRule or equivalent.\n"
		"\n"
		"This libSBML method works for SBML Level&nbsp;1 models (where there is\n"
		"such a thing as an explicit SpeciesConcentrationRule), as well as\n"
		"other Levels of SBML.  For Levels above Level&nbsp;1, this method\n"
		"checks the symbol being affected by the rule, and returns @c true if\n"
		"the symbol is the identifier of a Species object defined in the model.\n"
		"\n"
		"@return @c true if this Rule is a SpeciesConcentrationRule, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getTypeCode", _wrap_Rule_getTypeCode, METH_VARARGS, (char *)"\n"
		"Rule_getTypeCode(Rule self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link\n"
		"libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getL1TypeCode", _wrap_Rule_getL1TypeCode, METH_VARARGS, (char *)"\n"
		"Rule_getL1TypeCode(Rule self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the SBML Level&nbsp;1 type code for this Rule object.\n"
		"\n"
		"This method only applies to SBML Level&nbsp;1 model objects.  If this\n"
		"is not an SBML Level&nbsp;1 rule object, this method will return @link\n"
		"libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink.\n"
		"\n"
		"@return the SBML Level&nbsp;1 type code for this Rule (namely, @link\n"
		"libsbml.SBML_COMPARTMENT_VOLUME_RULE\n"
		"SBML_COMPARTMENT_VOLUME_RULE@endlink, @link\n"
		"libsbml.SBML_PARAMETER_RULE SBML_PARAMETER_RULE@endlink, @link\n"
		"libsbml.SBML_SPECIES_CONCENTRATION_RULE\n"
		"SBML_SPECIES_CONCENTRATION_RULE@endlink, or @link\n"
		"libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getElementName", _wrap_Rule_getElementName, METH_VARARGS, (char *)"\n"
		"Rule_getElementName(Rule self) -> string\n"
		"\n"
		"Returns the XML element name of this object\n"
		"\n"
		"The returned value can be any of a number of different strings,\n"
		"depending on the SBML Level in use and the kind of Rule object this\n"
		"is.  The rules as of libSBML version @htmlinclude libsbml-version.html\n"
		"are the following:\n"
		"<ul>\n"
		"<li> (Level&nbsp;2 and&nbsp;3) RateRule: returns @c 'rateRule'\n"
		"<li> (Level&nbsp;2 and&nbsp;3) AssignmentRule: returns @c 'assignmentRule' \n"
		"<li> (Level&nbsp;2 and&nbsp;3) AlgebraicRule: returns @c 'algebraicRule'\n"
		"<li> (Level&nbsp;1 Version&nbsp;1) SpecieConcentrationRule: returns @c 'specieConcentrationRule'\n"
		"<li> (Level&nbsp;1 Version&nbsp;2) SpeciesConcentrationRule: returns @c 'speciesConcentrationRule'\n"
		"<li> (Level&nbsp;1) CompartmentVolumeRule: returns @c 'compartmentVolumeRule'\n"
		"<li> (Level&nbsp;1) ParameterRule: returns @c 'parameterRule'\n"
		"<li> Unknown rule type: returns @c 'unknownRule'\n"
		"</ul>\n"
		"\n"
		"Beware that the last (@c 'unknownRule') is not a valid SBML element\n"
		"name.\n"
		"\n"
		"@return the name of this element\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_setL1TypeCode", _wrap_Rule_setL1TypeCode, METH_VARARGS, (char *)"\n"
		"Rule_setL1TypeCode(Rule self, SBMLTypeCode_t type) -> int\n"
		"\n"
		"Sets the SBML Level&nbsp;1 type code for this Rule.\n"
		"\n"
		"@param type the SBML Level&nbsp;1 type code for this Rule. The\n"
		"allowable values are @link libsbml.SBML_COMPARTMENT_VOLUME_RULE\n"
		"SBML_COMPARTMENT_VOLUME_RULE@endlink, @link\n"
		"libsbml.SBML_PARAMETER_RULE SBML_PARAMETER_RULE@endlink, and\n"
		"@link libsbml.SBML_SPECIES_CONCENTRATION_RULE\n"
		"SBML_SPECIES_CONCENTRATION_RULE@endlink.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink\n"
		"if given @p type value is not one of the above.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_hasRequiredElements", _wrap_Rule_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"Rule_hasRequiredElements(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if all the\n"
		"required elements for this Rule object have been set.\n"
		"\n"
		"The only required element for a Rule object is the 'math' subelement.\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_hasRequiredAttributes", _wrap_Rule_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Rule_hasRequiredAttributes(Rule self) -> bool\n"
		"\n"
		"Predicate returning @c true if all the\n"
		"required attributes for this Rule object have been set.\n"
		"\n"
		"The required attributes for a Rule object depend on the type of Rule\n"
		"it is.  For AssignmentRule and RateRule objects (and SBML\n"
		"Level&nbsp1's SpeciesConcentrationRule, CompartmentVolumeRule, and\n"
		"ParameterRule objects), the required attribute is 'variable'; for\n"
		"AlgebraicRule objects, there is no required attribute.\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Rule_getId", _wrap_Rule_getId, METH_VARARGS, (char *)"\n"
		"Rule_getId(Rule self) -> string\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if all the\n"
		"equired attributes for this Rule object have been set.\n"
		"\n"
		"he required attributes for a Rule object depend on the type of Rule\n"
		"t is.  For AssignmentRule and RateRule objects (and SBML\n"
		"evel&nbsp1's SpeciesConcentrationRule, CompartmentVolumeRule, and\n"
		"arameterRule objects), the required attribute is 'variable'; for\n"
		"lgebraicRule objects, there is no required attribute.\n"
		"\n"
		"return a boolean value indicating whether all the required\n"
		"lements for this object have been defined.\n"
		" \n"
		"\n"
		""},
	 { (char *)"Rule_swigregister", Rule_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_AlgebraicRule", _wrap_new_AlgebraicRule, METH_VARARGS, (char *)"\n"
		"AlgebraicRule(unsigned int level, unsigned int version)\n"
		"new_AlgebraicRule(SBMLNamespaces sbmlns) -> AlgebraicRule\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>AlgebraicRule(long level, long version)</pre>\n"
		"\n"
		"Creates a new AlgebraicRule using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this AlgebraicRule\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"AlgebraicRule\n"
		"\n"
		"@note Upon the addition of an AlgebraicRule object to an SBMLDocument\n"
		"(e.g., using&nbsp; @if java Model.addRule()@else Model.addRule()@endif), the SBML Level, SBML Version\n"
		"and XML namespace of the document @em override the values used\n"
		"when creating the AlgebraicRule object via this constructor.  This is\n"
		"necessary to ensure that an SBML document is a consistent structure.\n"
		"Nevertheless, the ability to supply the values at the time of creation\n"
		"of a AlgebraicRule is an important aid to producing valid SBML.\n"
		"Knowledge of the intented SBML Level and Version determine whether it\n"
		"is valid to assign a particular value to an attribute, or whether it\n"
		"is valid to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>AlgebraicRule(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new AlgebraicRule using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a AlgebraicRule object to an SBMLDocument\n"
		"(e.g., using&nbsp; @if java Model.addRule()@else Model.addRule()@endif, the SBML XML namespace of the\n"
		"document @em overrides the value used when creating the AlgebraicRule\n"
		"object via this constructor.  This is necessary to ensure that an SBML\n"
		"document is a consistent structure.  Nevertheless, the ability to\n"
		"supply the values at the time of creation of a AlgebraicRule is an\n"
		"important aid to producing valid SBML.  Knowledge of the intented SBML\n"
		"Level and Version determine whether it is valid to assign a particular\n"
		"value to an attribute, or whether it is valid to add an object to an\n"
		"existing SBMLDocument.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_AlgebraicRule", _wrap_delete_AlgebraicRule, METH_VARARGS, (char *)"delete_AlgebraicRule(AlgebraicRule self)"},
	 { (char *)"AlgebraicRule_clone", _wrap_AlgebraicRule_clone, METH_VARARGS, (char *)"\n"
		"AlgebraicRule_clone(AlgebraicRule self) -> AlgebraicRule\n"
		"\n"
		"Creates and returns a deep copy of this Rule.\n"
		"\n"
		"@return a (deep) copy of this Rule.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"AlgebraicRule_hasRequiredAttributes", _wrap_AlgebraicRule_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"AlgebraicRule_hasRequiredAttributes(AlgebraicRule self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this AlgebraicRule object\n"
		"have been set.\n"
		"\n"
		"@note In SBML Levels&nbsp;2&ndash;3, there is no required attribute\n"
		"for an AlgebraicRule object.  For Level&nbsp;1, the only required\n"
		"attribute is 'formula'.\n"
		"\n"
		"@return @c true if the required attributes have been set, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"AlgebraicRule_swigregister", AlgebraicRule_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_AssignmentRule", _wrap_new_AssignmentRule, METH_VARARGS, (char *)"\n"
		"AssignmentRule(unsigned int level, unsigned int version)\n"
		"new_AssignmentRule(SBMLNamespaces sbmlns) -> AssignmentRule\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>AssignmentRule(long level, long version)</pre>\n"
		"\n"
		"Creates a new AssignmentRule using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this AssignmentRule\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"AssignmentRule\n"
		"\n"
		"@note Upon the addition of an AssignmentRule object to an SBMLDocument\n"
		"(e.g., using&nbsp; @if java Model.addRule()@else Model.addRule()@endif, the SBML Level, SBML Version\n"
		"and XML namespace of the document @em override the values used\n"
		"when creating the AssignmentRule object via this constructor.  This is\n"
		"necessary to ensure that an SBML document is a consistent structure.\n"
		"Nevertheless, the ability to supply the values at the time of creation\n"
		"of a AssignmentRule is an important aid to producing valid SBML.\n"
		"Knowledge of the intented SBML Level and Version determine whether it\n"
		"is valid to assign a particular value to an attribute, or whether it\n"
		"is valid to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>AssignmentRule(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new AssignmentRule using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a AssignmentRule object to an SBMLDocument\n"
		"(e.g., using&nbsp; @if java Model.addRule()@else Model.addRule()@endif, the SBML XML namespace of\n"
		"the document @em overrides the value used when creating the\n"
		"AssignmentRule object via this constructor.  This is necessary to\n"
		"ensure that an SBML document is a consistent structure.  Nevertheless,\n"
		"the ability to supply the values at the time of creation of a\n"
		"AssignmentRule is an important aid to producing valid SBML.  Knowledge\n"
		"of the intented SBML Level and Version determine whether it is valid\n"
		"to assign a particular value to an attribute, or whether it is valid\n"
		"to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_AssignmentRule", _wrap_delete_AssignmentRule, METH_VARARGS, (char *)"delete_AssignmentRule(AssignmentRule self)"},
	 { (char *)"AssignmentRule_clone", _wrap_AssignmentRule_clone, METH_VARARGS, (char *)"\n"
		"AssignmentRule_clone(AssignmentRule self) -> AssignmentRule\n"
		"\n"
		"Creates and returns a deep copy of this Rule.\n"
		"\n"
		"@return a (deep) copy of this Rule.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"AssignmentRule_hasRequiredAttributes", _wrap_AssignmentRule_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"AssignmentRule_hasRequiredAttributes(AssignmentRule self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this AssignmentRule object\n"
		"have been set.\n"
		"\n"
		"@note In SBML Levels&nbsp;2&ndash;3, the only required attribute for\n"
		"an AssignmentRule object is 'variable'.  For Level&nbsp;1, where the\n"
		"equivalent attribute is known by different names ('compartment',\n"
		"'species', or 'name', depending on the type of object), there is an\n"
		"additional required attribute called 'formula'.\n"
		"\n"
		"@return @c true if the required attributes have been set, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"AssignmentRule_swigregister", AssignmentRule_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_RateRule", _wrap_new_RateRule, METH_VARARGS, (char *)"\n"
		"RateRule(unsigned int level, unsigned int version)\n"
		"new_RateRule(SBMLNamespaces sbmlns) -> RateRule\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>RateRule(long level, long version)</pre>\n"
		"\n"
		"Creates a new RateRule using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this RateRule\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"RateRule\n"
		"\n"
		"@note Upon the addition of a RateRule object to an SBMLDocument\n"
		"(e.g., using&nbsp; @if java Model.addRule()@else Model.addRule()@endif, the SBML Level, SBML Version\n"
		"and XML namespace of the document @em override the values used\n"
		"when creating the RateRule object via this constructor.  This is\n"
		"necessary to ensure that an SBML document is a consistent structure.\n"
		"Nevertheless, the ability to supply the values at the time of creation\n"
		"of a RateRule is an important aid to producing valid SBML.  Knowledge\n"
		"of the intented SBML Level and Version determine whether it is valid\n"
		"to assign a particular value to an attribute, or whether it is valid\n"
		"to add an object to an existing SBMLDocument.\n"
		" \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>RateRule(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new RateRule using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a RateRule object to an SBMLDocument (e.g.,\n"
		"using @if java Model.addRule()@else Model.addRule()@endif, the SBML XML namespace of the document\n"
		"@em overrides the value used when creating the RateRule object via\n"
		"this constructor.  This is necessary to ensure that an SBML document\n"
		"is a consistent structure.  Nevertheless, the ability to supply the\n"
		"values at the time of creation of a RateRule is an important aid to\n"
		"producing valid SBML.  Knowledge of the intented SBML Level and\n"
		"Version determine whether it is valid to assign a particular value to\n"
		"an attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_RateRule", _wrap_delete_RateRule, METH_VARARGS, (char *)"delete_RateRule(RateRule self)"},
	 { (char *)"RateRule_clone", _wrap_RateRule_clone, METH_VARARGS, (char *)"\n"
		"RateRule_clone(RateRule self) -> RateRule\n"
		"\n"
		"Creates and returns a deep copy of this Rule.\n"
		"\n"
		"@return a (deep) copy of this Rule.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RateRule_hasRequiredAttributes", _wrap_RateRule_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"RateRule_hasRequiredAttributes(RateRule self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this RateRule object\n"
		"have been set.\n"
		"\n"
		"@note In SBML Levels&nbsp;2&ndash;3, the only required attribute for a\n"
		"RateRule object is 'variable'.  For Level&nbsp;1, where the equivalent\n"
		"attribute is known by different names ('compartment', 'species', or\n"
		"'name', depending on the type of object), there is an additional\n"
		"required attribute called 'formula'.\n"
		"\n"
		"@return @c true if the required attributes have been set, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RateRule_swigregister", RateRule_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfRules_clone", _wrap_ListOfRules_clone, METH_VARARGS, (char *)"\n"
		"ListOfRules_clone(ListOfRules self) -> ListOfRules\n"
		"\n"
		"Creates and returns a deep copy of this ListOfRules instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfRules.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfRules_getTypeCode", _wrap_ListOfRules_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfRules_getTypeCode(ListOfRules self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfRules_getItemTypeCode", _wrap_ListOfRules_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfRules_getItemTypeCode(ListOfRules self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Rule objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfRules_getElementName", _wrap_ListOfRules_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfRules_getElementName(ListOfRules self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfRules, the XML element name is @c 'listOfRules'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfRules'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfRules_get", _wrap_ListOfRules_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Rule\n"
		"get(unsigned int n) -> Rule\n"
		"get(string sid) -> Rule\n"
		"ListOfRules_get(ListOfRules self, string sid) -> Rule\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a Rule from the ListOfRules.\n"
		"\n"
		"@param n the index number of the Rule to get.\n"
		"\n"
		"@return the nth Rule in this ListOfRules.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a Rule from the ListOfRules.\n"
		"\n"
		"@param n the index number of the Rule to get.\n"
		"\n"
		"@return the nth Rule in this ListOfRules.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a Rule from the ListOfRules\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Rule to get.\n"
		"\n"
		"@return Rule in this ListOfRules\n"
		"with the given id or @c None if no such\n"
		"Rule exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a Rule from the ListOfRules\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Rule to get.\n"
		"\n"
		"@return Rule in this ListOfRules\n"
		"with the given id or @c None if no such\n"
		"Rule exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfRules_remove", _wrap_ListOfRules_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> Rule\n"
		"ListOfRules_remove(ListOfRules self, string sid) -> Rule\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfRules items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes item in this ListOfRules items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"None is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfRules", _wrap_new_ListOfRules, METH_VARARGS, (char *)"new_ListOfRules() -> ListOfRules"},
	 { (char *)"delete_ListOfRules", _wrap_delete_ListOfRules, METH_VARARGS, (char *)"delete_ListOfRules(ListOfRules self)"},
	 { (char *)"ListOfRules_swigregister", ListOfRules_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Constraint", _wrap_delete_Constraint, METH_VARARGS, (char *)"delete_Constraint(Constraint self)"},
	 { (char *)"new_Constraint", _wrap_new_Constraint, METH_VARARGS, (char *)"\n"
		"Constraint(unsigned int level, unsigned int version)\n"
		"Constraint(SBMLNamespaces sbmlns)\n"
		"new_Constraint(Constraint orig) -> Constraint\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Constraint(long level, long version)</pre>\n"
		"\n"
		"Creates a new Constraint using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this Constraint\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"Constraint\n"
		"\n"
		"@note Upon the addition of a Constraint object to an SBMLDocument\n"
		"(e.g., using Model.addConstraint()), the\n"
		"SBML Level, SBML Version and XML namespace of the document @em\n"
		"override the values used when creating the Constraint object via this\n"
		"constructor.  This is necessary to ensure that an SBML document is a\n"
		"consistent structure.  Nevertheless, the ability to supply the values\n"
		"at the time of creation of a Constraint is an important aid to\n"
		"producing valid SBML.  Knowledge of the intented SBML Level and\n"
		"Version determine whether it is valid to assign a particular value to\n"
		"an attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Constraint(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new Constraint using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a Constraint object to an SBMLDocument\n"
		"(e.g., using Model.addConstraint()), the\n"
		"SBML XML namespace of the document @em overrides the value used when\n"
		"creating the Constraint object via this constructor.  This is\n"
		"necessary to ensure that an SBML document is a consistent structure.\n"
		"Nevertheless, the ability to supply the values at the time of creation\n"
		"of a Constraint is an important aid to producing valid SBML.\n"
		"Knowledge of the intented SBML Level and Version determine whether it\n"
		"is valid to assign a particular value to an attribute, or whether it\n"
		"is valid to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Constraint(Constraint orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this Constraint.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_clone", _wrap_Constraint_clone, METH_VARARGS, (char *)"\n"
		"Constraint_clone(Constraint self) -> Constraint\n"
		"\n"
		"Creates and returns a deep copy of this Constraint.\n"
		"\n"
		"@return a (deep) copy of this Constraint.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_getMessage", _wrap_Constraint_getMessage, METH_VARARGS, (char *)"\n"
		"Constraint_getMessage(Constraint self) -> XMLNode\n"
		"\n"
		"Get the message, if any, associated with this Constraint\n"
		"\n"
		"@return the message for this Constraint, as an XMLNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_getMessageString", _wrap_Constraint_getMessageString, METH_VARARGS, (char *)"\n"
		"Constraint_getMessageString(Constraint self) -> string\n"
		"\n"
		"Get the message string, if any, associated with this Constraint\n"
		"\n"
		"@return the message for this Constraint, as a string.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_getMath", _wrap_Constraint_getMath, METH_VARARGS, (char *)"\n"
		"Constraint_getMath(Constraint self) -> ASTNode\n"
		"\n"
		"Get the mathematical expression of this Constraint\n"
		"\n"
		"@return the math for this Constraint, as an ASTNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_isSetMessage", _wrap_Constraint_isSetMessage, METH_VARARGS, (char *)"\n"
		"Constraint_isSetMessage(Constraint self) -> bool\n"
		"\n"
		"Predicate returning @c true if a\n"
		"message is defined for this Constraint.\n"
		"\n"
		"@return @c true if the message of this Constraint is set,\n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_isSetMath", _wrap_Constraint_isSetMath, METH_VARARGS, (char *)"\n"
		"Constraint_isSetMath(Constraint self) -> bool\n"
		"\n"
		"Predicate returning @c true if a\n"
		"mathematical formula is defined for this Constraint.\n"
		"\n"
		"@return @c true if the 'math' subelement for this Constraint is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_setMessage", _wrap_Constraint_setMessage, METH_VARARGS, (char *)"\n"
		"Constraint_setMessage(Constraint self, XMLNode xhtml) -> int\n"
		"\n"
		"Sets the message of this Constraint.\n"
		"\n"
		"The XMLNode tree passed in @p xhtml is copied.\n"
		"\n"
		"@param xhtml an XML tree containing XHTML content.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_setMath", _wrap_Constraint_setMath, METH_VARARGS, (char *)"\n"
		"Constraint_setMath(Constraint self, ASTNode math) -> int\n"
		"\n"
		"Sets the mathematical expression of this Constraint to a copy of the\n"
		"AST given as @p math.\n"
		"\n"
		"@param math an ASTNode expression to be assigned as the 'math'\n"
		"subelement of this Constraint\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_unsetMessage", _wrap_Constraint_unsetMessage, METH_VARARGS, (char *)"\n"
		"Constraint_unsetMessage(Constraint self) -> int\n"
		"\n"
		"Unsets the 'message' subelement of this Constraint.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_getTypeCode", _wrap_Constraint_getTypeCode, METH_VARARGS, (char *)"\n"
		"Constraint_getTypeCode(Constraint self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_getElementName", _wrap_Constraint_getElementName, METH_VARARGS, (char *)"\n"
		"Constraint_getElementName(Constraint self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Constraint, is\n"
		"always @c 'constraint'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'constraint'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_hasRequiredElements", _wrap_Constraint_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"Constraint_hasRequiredElements(Constraint self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Constraint object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Constraint object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Constraint_swigregister", Constraint_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfConstraints_clone", _wrap_ListOfConstraints_clone, METH_VARARGS, (char *)"\n"
		"ListOfConstraints_clone(ListOfConstraints self) -> ListOfConstraints\n"
		"\n"
		"Creates and returns a deep copy of this ListOfConstraints instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfConstraints.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfConstraints_getTypeCode", _wrap_ListOfConstraints_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfConstraints_getTypeCode(ListOfConstraints self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfConstraints_getItemTypeCode", _wrap_ListOfConstraints_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfConstraints_getItemTypeCode(ListOfConstraints self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Constraint objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfConstraints_getElementName", _wrap_ListOfConstraints_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfConstraints_getElementName(ListOfConstraints self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfConstraints, the XML element name is @c 'listOfConstraints'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfConstraints'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfConstraints_get", _wrap_ListOfConstraints_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Constraint\n"
		"ListOfConstraints_get(ListOfConstraints self, unsigned int n) -> Constraint\n"
		"\n"
		"Get a Constraint from the ListOfConstraints.\n"
		"\n"
		"@param n the index number of the Constraint to get.\n"
		"\n"
		"@return the nth Constraint in this ListOfConstraints.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfConstraints_remove", _wrap_ListOfConstraints_remove, METH_VARARGS, (char *)"\n"
		"ListOfConstraints_remove(ListOfConstraints self, unsigned int n) -> Constraint\n"
		"\n"
		"Removes the nth item from this ListOfConstraints items and returns a\n"
		"pointer to it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfConstraints", _wrap_new_ListOfConstraints, METH_VARARGS, (char *)"new_ListOfConstraints() -> ListOfConstraints"},
	 { (char *)"delete_ListOfConstraints", _wrap_delete_ListOfConstraints, METH_VARARGS, (char *)"delete_ListOfConstraints(ListOfConstraints self)"},
	 { (char *)"ListOfConstraints_swigregister", ListOfConstraints_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Reaction", _wrap_delete_Reaction, METH_VARARGS, (char *)"delete_Reaction(Reaction self)"},
	 { (char *)"new_Reaction", _wrap_new_Reaction, METH_VARARGS, (char *)"\n"
		"Reaction(unsigned int level, unsigned int version)\n"
		"Reaction(SBMLNamespaces sbmlns)\n"
		"new_Reaction(Reaction orig) -> Reaction\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Reaction(long level, long version)</pre>\n"
		"\n"
		"Creates a new Reaction using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this Reaction\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"Reaction\n"
		"\n"
		"@note Upon the addition of a Reaction object to an SBMLDocument (e.g.,\n"
		"using Model.addReaction()), the SBML Level, SBML Version and\n"
		"XML namespace of the document @em override the values used when\n"
		"creating the Reaction object via this constructor.  This is necessary\n"
		"to ensure that an SBML document is a consistent structure.\n"
		"Nevertheless, the ability to supply the values at the time of creation\n"
		"of a Reaction is an important aid to producing valid SBML.  Knowledge\n"
		"of the intented SBML Level and Version determine whether it is valid\n"
		"to assign a particular value to an attribute, or whether it is valid\n"
		"to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Reaction(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new Reaction using the given SBMLNamespaces object\n"
		"@p  sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a Reaction object to an SBMLDocument (e.g.,\n"
		"using Model.addReaction()), the SBML XML namespace of the document\n"
		"@em overrides the value used when creating the Reaction object via\n"
		"this constructor.  This is necessary to ensure that an SBML document\n"
		"is a consistent structure.  Nevertheless, the ability to supply the\n"
		"values at the time of creation of a Reaction is an important aid to\n"
		"producing valid SBML.  Knowledge of the intented SBML Level and\n"
		"Version determine whether it is valid to assign a particular value to\n"
		"an attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Reaction(Reaction orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_clone", _wrap_Reaction_clone, METH_VARARGS, (char *)"\n"
		"Reaction_clone(Reaction self) -> Reaction\n"
		"\n"
		"Creates and returns a deep copy of this Reaction.\n"
		"\n"
		"@return a (deep) copy of this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_initDefaults", _wrap_Reaction_initDefaults, METH_VARARGS, (char *)"\n"
		"Reaction_initDefaults(Reaction self)\n"
		"\n"
		"Initializes the fields of this Reaction object to 'typical' default\n"
		"values.\n"
		"\n"
		"The SBML Reaction component has slightly different aspects and\n"
		"default attribute values in different SBML Levels and Versions.\n"
		"This method sets the values to certain common defaults, based\n"
		"mostly on what they are in SBML Level&nbsp;2.  Specifically:\n"
		"<ul>\n"
		"<li> Sets the 'reversible' attribute to @c true\n"
		"<li> Sets the 'fast' attribute to @c false\n"
		"<li> Marks the 'fast' attribute as @em not having been set\n"
		"</ul>\n"
		"\n"
		"@warning The 'fast' attribute must be used with care.  SBML\n"
		"definitions before SBML Level&nbsp;2 Version&nbsp;2 incorrectly\n"
		"indicated that software tools could ignore this attribute if they did\n"
		"not implement support for the corresponding concept; however, further\n"
		"research in SBML has revealed that this is not true, and 'fast'\n"
		"<em>cannot be ignored</em> if it is set to @c true.  Beginning with\n"
		"SBML Level&nbsp;2 Versions&nbsp;2, the SBML specifications therefore\n"
		"stipulate that if a model has any reactions with 'fast' set to @c\n"
		"true, a software tool must be able to respect the attribute or else\n"
		"indicate to the user that it does not have the capacity to do so.\n"
		"Readers are directed to the SBML specifications, which provides more\n"
		"detail about the conditions under which a reaction can be considered\n"
		"to be fast in this sense.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getId", _wrap_Reaction_getId, METH_VARARGS, (char *)"\n"
		"Reaction_getId(Reaction self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this Reaction.\n"
		"\n"
		"@return the id of this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getName", _wrap_Reaction_getName, METH_VARARGS, (char *)"\n"
		"Reaction_getName(Reaction self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this Reaction.\n"
		"\n"
		"@return the name of this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getKineticLaw", _wrap_Reaction_getKineticLaw, METH_VARARGS, (char *)"\n"
		"getKineticLaw() -> KineticLaw\n"
		"Reaction_getKineticLaw(Reaction self) -> KineticLaw\n"
		"\n"
		"Returns the KineticLaw object contained in this Reaction.\n"
		"\n"
		"@return the KineticLaw instance.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getReversible", _wrap_Reaction_getReversible, METH_VARARGS, (char *)"\n"
		"Reaction_getReversible(Reaction self) -> bool\n"
		"\n"
		"Returns the value of the 'reversible' attribute on the Reaction as a\n"
		"boolean value.\n"
		"\n"
		"@return the reversibility status of this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getFast", _wrap_Reaction_getFast, METH_VARARGS, (char *)"\n"
		"Reaction_getFast(Reaction self) -> bool\n"
		"\n"
		"Returns the value of the 'fast' attribute of this Reaction.\n"
		"\n"
		"@return the 'fast' status of this Reaction.\n"
		"\n"
		"@warning SBML definitions before SBML Level&nbsp;2 Version&nbsp;2 incorrectly\n"
		"indicated that software tools could ignore this attribute if they did\n"
		"not implement support for the corresponding concept; however, further\n"
		"research in SBML has revealed that this is not true, and 'fast'\n"
		"<em>cannot be ignored</em> if it is set to @c true.  SBML Level&nbsp;2\n"
		"Versions 2, 3 and 4 therefore stipulate that if a model has any reactions\n"
		"with 'fast' set to @c true, a software tool must be able to respect\n"
		"the attribute or else indicate to the user that it does not have the\n"
		"capacity to do so.  Readers are directed to the SBML Level&nbsp;2 Version\n"
		"4 specification, which provides more detail about the conditions under\n"
		"which a reaction can be considered to be fast in this sense.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getCompartment", _wrap_Reaction_getCompartment, METH_VARARGS, (char *)"\n"
		"Reaction_getCompartment(Reaction self) -> string\n"
		"\n"
		"(SBML Level&nbsp;3 only) Returns the value of the 'compartment'\n"
		"attribute on the Reaction.\n"
		"\n"
		"@return the compartment of this Reaction.\n"
		"\n"
		"@note The 'compartment' attribute is available in SBML Level&nbsp;3\n"
		"Version&nbsp;1 Core, but is not present on Reaction in lower Levels of\n"
		"SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_isSetId", _wrap_Reaction_isSetId, METH_VARARGS, (char *)"\n"
		"Reaction_isSetId(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Reaction's 'id' attribute is set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this Reaction is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_isSetName", _wrap_Reaction_isSetName, METH_VARARGS, (char *)"\n"
		"Reaction_isSetName(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Reaction's 'name' attribute is set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this Reaction is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_isSetKineticLaw", _wrap_Reaction_isSetKineticLaw, METH_VARARGS, (char *)"\n"
		"Reaction_isSetKineticLaw(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Reaction contains a kinetic law object.\n"
		"\n"
		"@return @c true if a KineticLaw is present in this Reaction,, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_isSetFast", _wrap_Reaction_isSetFast, METH_VARARGS, (char *)"\n"
		"Reaction_isSetFast(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if the value of\n"
		"the 'fast' attribute on this Reaction.\n"
		"\n"
		"@return @c true if the 'fast' attribute is true, @c false otherwise.\n"
		"\n"
		"@warning SBML definitions before SBML Level&nbsp;2 Version&nbsp;2 incorrectly\n"
		"indicated that software tools could ignore this attribute if they did\n"
		"not implement support for the corresponding concept; however, further\n"
		"research in SBML has revealed that this is not true, and 'fast'\n"
		"<em>cannot be ignored</em> if it is set to @c true.  SBML Level&nbsp;2\n"
		"Versions 2, 3 and 4 therefore stipulate that if a model has any reactions\n"
		"with 'fast' set to @c true, a software tool must be able to respect\n"
		"the attribute or else indicate to the user that it does not have the\n"
		"capacity to do so.  Readers are directed to the SBML Level&nbsp;2 Version\n"
		"4 specification, which provides more detail about the conditions under\n"
		"which a reaction can be considered to be fast in this sense.  Note\n"
		"also that in SBML Level&nbsp;1, 'fast' is defined as optional with a\n"
		"default of @c false, which means it is effectively always set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_isSetCompartment", _wrap_Reaction_isSetCompartment, METH_VARARGS, (char *)"\n"
		"Reaction_isSetCompartment(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Reaction's 'compartment' attribute is set.\n"
		"\n"
		"@return @c true if the 'compartment' attribute of this Reaction is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note The 'compartment' attribute is available in SBML\n"
		"Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in\n"
		"lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_isSetReversible", _wrap_Reaction_isSetReversible, METH_VARARGS, (char *)"\n"
		"Reaction_isSetReversible(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Reaction's 'reversible' attribute is set.\n"
		"\n"
		"@return @c true if the 'reversible' attribute of this Reaction is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_setId", _wrap_Reaction_setId, METH_VARARGS, (char *)"\n"
		"Reaction_setId(Reaction self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this Reaction.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this Reaction\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_setName", _wrap_Reaction_setName, METH_VARARGS, (char *)"\n"
		"Reaction_setName(Reaction self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this Reaction.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the Reaction\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_setKineticLaw", _wrap_Reaction_setKineticLaw, METH_VARARGS, (char *)"\n"
		"Reaction_setKineticLaw(Reaction self, KineticLaw kl) -> int\n"
		"\n"
		"Sets the 'kineticLaw' subelement of this Reaction to a copy of the\n"
		"given KineticLaw object.\n"
		"\n"
		"@param kl the KineticLaw object to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		" \n"
		"\n"
		""},
	 { (char *)"Reaction_setReversible", _wrap_Reaction_setReversible, METH_VARARGS, (char *)"\n"
		"Reaction_setReversible(Reaction self, bool value) -> int\n"
		"\n"
		"Sets the value of the 'reversible' attribute of this Reaction.\n"
		"\n"
		"@param value the value of the 'reversible' attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_setFast", _wrap_Reaction_setFast, METH_VARARGS, (char *)"\n"
		"Reaction_setFast(Reaction self, bool value) -> int\n"
		"\n"
		"Sets the value of the 'fast' attribute of this Reaction.\n"
		"\n"
		"@param value the value of the 'fast' attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@warning SBML definitions before SBML Level&nbsp;2 Version&nbsp;2 incorrectly\n"
		"indicated that software tools could ignore this attribute if they did\n"
		"not implement support for the corresponding concept; however, further\n"
		"research in SBML has revealed that this is not true, and 'fast'\n"
		"<em>cannot be ignored</em> if it is set to @c true.  SBML Level&nbsp;2\n"
		"Versions 2, 3 and 4 therefore stipulate that if a model has any reactions\n"
		"with 'fast' set to @c true, a software tool must be able to respect\n"
		"the attribute or else indicate to the user that it does not have the\n"
		"capacity to do so.  Readers are directed to the SBML Level&nbsp;2 Version\n"
		"4 specification, which provides more detail about the conditions under\n"
		"which a reaction can be considered to be fast in this sense.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_setCompartment", _wrap_Reaction_setCompartment, METH_VARARGS, (char *)"\n"
		"Reaction_setCompartment(Reaction self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'compartment' attribute of this Reaction.\n"
		"\n"
		"The string @p sid is copied.  \n"
		"\n"
		"@param sid the string to use as the compartment of this Reaction\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The 'compartment' attribute is available in SBML\n"
		"Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in\n"
		"lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_unsetName", _wrap_Reaction_unsetName, METH_VARARGS, (char *)"\n"
		"Reaction_unsetName(Reaction self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this Reaction.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_unsetKineticLaw", _wrap_Reaction_unsetKineticLaw, METH_VARARGS, (char *)"\n"
		"Reaction_unsetKineticLaw(Reaction self) -> int\n"
		"\n"
		"Unsets the 'kineticLaw' subelement of this Reaction.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_unsetFast", _wrap_Reaction_unsetFast, METH_VARARGS, (char *)"\n"
		"Reaction_unsetFast(Reaction self) -> int\n"
		"\n"
		"Unsets the value of the 'fast' attribute of this Reaction.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@warning In SBML Level&nbsp;1, 'fast' is optional with a default of @c\n"
		"false, which means it is effectively always set (and reset to @c false\n"
		"if this method is called).  Further, SBML definitions before SBML\n"
		"Level&nbsp;2 Version&nbsp;2 incorrectly indicated that software tools could\n"
		"ignore this attribute if they did not implement support for the\n"
		"corresponding concept; however, further research in SBML has revealed\n"
		"that this is not true, and 'fast' <em>cannot be ignored</em> if it is\n"
		"set to @c true.  SBML Level&nbsp;2 Versions 2, 3 and 4 therefore stipulate\n"
		"that if a model has any reactions with 'fast' set to @c true, a\n"
		"software tool must be able to respect the attribute or else indicate\n"
		"to the user that it does not have the capacity to do so.  Readers are\n"
		"directed to the SBML Level&nbsp;2 Version&nbsp;4 specification, which provides\n"
		"more detail about the conditions under which a reaction can be\n"
		"considered to be fast in this sense.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_unsetCompartment", _wrap_Reaction_unsetCompartment, METH_VARARGS, (char *)"\n"
		"Reaction_unsetCompartment(Reaction self) -> int\n"
		"\n"
		"Unsets the value of the 'compartment' attribute of this Reaction.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The 'compartment' attribute is available in SBML\n"
		"Level&nbsp;3 Version&nbsp;1 Core, but is not present on Reaction in\n"
		"lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_addReactant", _wrap_Reaction_addReactant, METH_VARARGS, (char *)"\n"
		"Reaction_addReactant(Reaction self, SpeciesReference sr) -> int\n"
		"\n"
		"Adds a given SpeciesReference object as a reactant in this Reaction.\n"
		"\n"
		"The SpeciesReference instance in @p sr is copied.\n"
		"\n"
		"@param sr a SpeciesReference object referring to a Species in the\n"
		"enclosing Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Reaction.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Reaction</em>.  In addition, the caller should make\n"
		"sure to free the original object if it is no longer being used, or\n"
		"else a memory leak will result.  Please see Reaction.createReactant()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createReactant()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_addProduct", _wrap_Reaction_addProduct, METH_VARARGS, (char *)"\n"
		"Reaction_addProduct(Reaction self, SpeciesReference sr) -> int\n"
		"\n"
		"Adds a given SpeciesReference object as a product in this Reaction.\n"
		"\n"
		"The SpeciesReference instance in @p sr is copied.\n"
		"\n"
		"@param sr a SpeciesReference object referring to a Species in the\n"
		"enclosing Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Reaction.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Reaction</em>.  In addition, the caller should make\n"
		"sure to free the original object if it is no longer being used, or\n"
		"else a memory leak will result.  Please see Reaction.createProduct()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createProduct()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_addModifier", _wrap_Reaction_addModifier, METH_VARARGS, (char *)"\n"
		"Reaction_addModifier(Reaction self, ModifierSpeciesReference msr) -> int\n"
		"\n"
		"Adds a given ModifierSpeciesReference object as a product in this\n"
		"Reaction.\n"
		"\n"
		"The ModifierSpeciesReference instance in @p msr is copied.\n"
		"\n"
		"@param msr a ModifierSpeciesReference object referring to a Species in\n"
		"the enclosing Model\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Reaction.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Reaction</em>.  In addition, the caller should make\n"
		"sure to free the original object if it is no longer being used, or\n"
		"else a memory leak will result.  Please see Reaction.createModifier()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createModifier()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_createReactant", _wrap_Reaction_createReactant, METH_VARARGS, (char *)"\n"
		"Reaction_createReactant(Reaction self) -> SpeciesReference\n"
		"\n"
		"Creates a new SpeciesReference, adds it to this Reaction's list of\n"
		"reactants, and returns it.\n"
		"\n"
		"@return a new SpeciesReference object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_createProduct", _wrap_Reaction_createProduct, METH_VARARGS, (char *)"\n"
		"Reaction_createProduct(Reaction self) -> SpeciesReference\n"
		"\n"
		"Creates a new SpeciesReference, adds it to this Reaction's list of\n"
		"products, and returns it.\n"
		"\n"
		"@return a new SpeciesReference object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_createModifier", _wrap_Reaction_createModifier, METH_VARARGS, (char *)"\n"
		"Reaction_createModifier(Reaction self) -> ModifierSpeciesReference\n"
		"\n"
		"Creates a new ModifierSpeciesReference, adds it to this Reaction's\n"
		"list of modifiers and returns it.\n"
		"\n"
		"@return a new ModifierSpeciesReference object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_createKineticLaw", _wrap_Reaction_createKineticLaw, METH_VARARGS, (char *)"\n"
		"Reaction_createKineticLaw(Reaction self) -> KineticLaw\n"
		"\n"
		"Creates a new KineticLaw object, installs it as this Reaction's\n"
		"'kineticLaw' subelement, and returns it.\n"
		"\n"
		"If this Reaction had a previous KineticLaw, it will be destroyed.\n"
		"\n"
		"@return the new KineticLaw object\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getListOfReactants", _wrap_Reaction_getListOfReactants, METH_VARARGS, (char *)"\n"
		"getListOfReactants() -> ListOfSpeciesReferences\n"
		"Reaction_getListOfReactants(Reaction self) -> ListOfSpeciesReferences\n"
		"\n"
		"Returns the list of reactants in this Reaction object.\n"
		"\n"
		"@return the ListOfSpeciesReferences containing the references to the\n"
		"species acting as reactants in this reaction\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getListOfProducts", _wrap_Reaction_getListOfProducts, METH_VARARGS, (char *)"\n"
		"getListOfProducts() -> ListOfSpeciesReferences\n"
		"Reaction_getListOfProducts(Reaction self) -> ListOfSpeciesReferences\n"
		"\n"
		"Returns the list of products in this Reaction object.\n"
		"\n"
		"@return the ListOfSpeciesReferences containing the references to the\n"
		"species acting as products in this reaction\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getListOfModifiers", _wrap_Reaction_getListOfModifiers, METH_VARARGS, (char *)"\n"
		"getListOfModifiers() -> ListOfSpeciesReferences\n"
		"Reaction_getListOfModifiers(Reaction self) -> ListOfSpeciesReferences\n"
		"\n"
		"Returns the list of modifiers in this Reaction object.\n"
		"\n"
		"@return the ListOfSpeciesReferences containing the references to the\n"
		"species acting as modifiers in this reaction\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getReactant", _wrap_Reaction_getReactant, METH_VARARGS, (char *)"\n"
		"getReactant(unsigned int n) -> SpeciesReference\n"
		"getReactant(unsigned int n) -> SpeciesReference\n"
		"getReactant(string species) -> SpeciesReference\n"
		"Reaction_getReactant(Reaction self, string species) -> SpeciesReference\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getReactant(long n)</pre>\n"
		"\n"
		"Returns the nth reactant species (as a SpeciesReference object) in \n"
		"the list of reactants in this Reaction.\n"
		"\n"
		"Callers should first call getNumReactants() to find out how many\n"
		"reactants there are, to avoid using an invalid index number.\n"
		"\n"
		"@param n the index of the reactant sought.\n"
		"\n"
		"@return the nth reactant (as a SpeciesReference object) of this\n"
		"Reaction.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getReactant(long n)</pre>\n"
		"\n"
		"Returns the nth reactant species (as a SpeciesReference object) \n"
		"in the list of reactants in this Reaction.\n"
		"\n"
		"Callers should first call getNumReactants() to find out how many\n"
		"reactants there are, to avoid using an invalid index number.\n"
		"\n"
		"@param n the index of the reactant sought.\n"
		"\n"
		"@return the nth reactant (as a SpeciesReference object) of this\n"
		"Reaction.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getReactant(string species)</pre>\n"
		"\n"
		"Returns the reactant species (as a SpeciesReference object) having \n"
		"a specific identifier in this Reaction.\n"
		"\n"
		"@param species the identifier of the reactant Species ('species' \n"
		"attribute of the reactant SpeciesReference object)\n"
		"\n"
		"@return a SpeciesReference object, or @c None if no species with the\n"
		"given identifier @p species appears as a reactant in this Reaction.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getReactant(string species)</pre>\n"
		"\n"
		"Returns the reactant species (as a SpeciesReference object) having \n"
		"a specific identifier in this Reaction.\n"
		"\n"
		"@param species the identifier of the reactant Species ('species' \n"
		"attribute of the reactant SpeciesReference object)\n"
		"\n"
		"@return a SpeciesReference object, or @c None if no species with the\n"
		"given identifier @p species appears as a reactant in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getProduct", _wrap_Reaction_getProduct, METH_VARARGS, (char *)"\n"
		"getProduct(unsigned int n) -> SpeciesReference\n"
		"getProduct(unsigned int n) -> SpeciesReference\n"
		"getProduct(string species) -> SpeciesReference\n"
		"Reaction_getProduct(Reaction self, string species) -> SpeciesReference\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getProduct(long n)</pre>\n"
		"\n"
		"Returns the nth product species (as a SpeciesReference object) in \n"
		"the list of products in this Reaction.\n"
		"\n"
		"Callers should first call getNumProducts() to find out how many\n"
		"products there are, to avoid using an invalid index number.\n"
		"\n"
		"@param n the index of the product sought.\n"
		"\n"
		"@return the nth product (as a SpeciesReference object) of this\n"
		"Reaction.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getProduct(long n)</pre>\n"
		"\n"
		"Returns the nth product species (as a SpeciesReference object) \n"
		"in the list of products in this Reaction.\n"
		"\n"
		"Callers should first call getNumProducts() to find out how many\n"
		"products there are, to avoid using an invalid index number.\n"
		"\n"
		"@param n the index of the product sought.\n"
		"\n"
		"@return the nth product (as a SpeciesReference object) of this\n"
		"Reaction.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getProduct(string species)</pre>\n"
		"\n"
		"Returns the product species (as a SpeciesReference object) having \n"
		"a specific identifier in this Reaction.\n"
		"\n"
		"@param species the identifier of the product Species ('species'\n"
		"attribute of the product SpeciesReference object)\n"
		"\n"
		"@return a SpeciesReference object, or @c None if no species with the\n"
		"given identifier @p species appears as a product in this Reaction.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getProduct(string species)</pre>\n"
		"\n"
		"Returns the product species (as a SpeciesReference object) having \n"
		"a specific identifier in this Reaction.\n"
		"\n"
		"@param species the identifier of the product Species ('species'\n"
		"attribute of the product SpeciesReference object)\n"
		"\n"
		"@return a SpeciesReference object, or @c None if no species with the\n"
		"given identifier @p species appears as a product in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getModifier", _wrap_Reaction_getModifier, METH_VARARGS, (char *)"\n"
		"getModifier(unsigned int n) -> ModifierSpeciesReference\n"
		"getModifier(unsigned int n) -> ModifierSpeciesReference\n"
		"getModifier(string species) -> ModifierSpeciesReference\n"
		"Reaction_getModifier(Reaction self, string species) -> ModifierSpeciesReference\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getModifier(long n)</pre>\n"
		"\n"
		"Returns the nth modifier species (as a ModifierSpeciesReference object) \n"
		"in the list of modifiers of this Reaction.\n"
		"\n"
		"Callers should first call getNumModifiers() to find out how many\n"
		"modifiers there are, to avoid using an invalid index number.\n"
		"\n"
		"@param n the index of the modifier species sought\n"
		"\n"
		"@return the nth modifier (as a ModifierSpeciesReference object) of\n"
		"this Reaction.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getModifier(long n)</pre>\n"
		"\n"
		"Returns the nth modifier species (as a ModifierSpeciesReference object) \n"
		"in the list of modifiers of this Reaction.\n"
		"\n"
		"Callers should first call getNumModifiers() to find out how many\n"
		"modifiers there are, to avoid using an invalid index number.\n"
		"\n"
		"@param n the index of the modifier species sought\n"
		"\n"
		"@return the nth modifier (as a ModifierSpeciesReference object) of\n"
		"this Reaction.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getModifier(string species)</pre>\n"
		"\n"
		"Returns the modifier species (as a ModifierSpeciesReference object) \n"
		"having a specific identifier in this Reaction.\n"
		"\n"
		"@param species the identifier of the modifier Species ('species' \n"
		"attribute of the ModifierSpeciesReference object)\n"
		"\n"
		"@return a ModifierSpeciesReference object, or @c None if no species with\n"
		"the given identifier @p species appears as a modifier in this\n"
		"Reaction.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getModifier(string species)</pre>\n"
		"\n"
		"Returns the modifier species (as a ModifierSpeciesReference object) \n"
		"having a specific identifier in this Reaction.\n"
		"\n"
		"@param species the identifier of the modifier Species ('species' \n"
		"attribute of the ModifierSpeciesReference object)\n"
		"\n"
		"@return a ModifierSpeciesReference object, or @c None if no species with\n"
		"the given identifier @p species appears as a modifier in this\n"
		"Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getNumReactants", _wrap_Reaction_getNumReactants, METH_VARARGS, (char *)"\n"
		"Reaction_getNumReactants(Reaction self) -> unsigned int\n"
		"\n"
		"Returns the number of reactant species in this Reaction.\n"
		"\n"
		"@return the number of reactants in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getNumProducts", _wrap_Reaction_getNumProducts, METH_VARARGS, (char *)"\n"
		"Reaction_getNumProducts(Reaction self) -> unsigned int\n"
		"\n"
		"Returns the number of product species in this Reaction.\n"
		"\n"
		"@return the number of products in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getNumModifiers", _wrap_Reaction_getNumModifiers, METH_VARARGS, (char *)"\n"
		"Reaction_getNumModifiers(Reaction self) -> unsigned int\n"
		"\n"
		"Returns the number of modifier species in this Reaction.\n"
		"\n"
		"@return the number of modifiers in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_removeReactant", _wrap_Reaction_removeReactant, METH_VARARGS, (char *)"\n"
		"removeReactant(unsigned int n) -> SpeciesReference\n"
		"Reaction_removeReactant(Reaction self, string species) -> SpeciesReference\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeReactant(long n)</pre>\n"
		"\n"
		"Removes the nth reactant species (SpeciesReference object) in the list of \n"
		"reactants in this Reaction and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"The caller should first call getNumReactants() to find out how many\n"
		"reactants there are, to avoid using an invalid index number.\n"
		"\n"
		"@param n the index of the reactant SpeciesReference object to remove\n"
		"\n"
		"@return the removed reactant SpeciesReference object, or @c None if the \n"
		"given index is out of range.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeReactant(string species)</pre>\n"
		"\n"
		"Removes the reactant species (SpeciesReference object) having the given  \n"
		"'species' attribute in this Reaction and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param species the 'species' attribute of the reactant SpeciesReference \n"
		"object\n"
		"\n"
		"@return the removed reactant SpeciesReference object, or @c None if no \n"
		"reactant SpeciesReference object with the given 'species' attribute \n"
		"@p species exists in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_removeProduct", _wrap_Reaction_removeProduct, METH_VARARGS, (char *)"\n"
		"removeProduct(unsigned int n) -> SpeciesReference\n"
		"Reaction_removeProduct(Reaction self, string species) -> SpeciesReference\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeProduct(long n)</pre>\n"
		"\n"
		"Removes the nth product species (SpeciesReference object) in the list of \n"
		"products in this Reaction and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"The caller should first call getNumProducts() to find out how many\n"
		"products there are, to avoid using an invalid index number.\n"
		"\n"
		"@param n the index of the product SpeciesReference object to remove\n"
		"\n"
		"@return the removed product SpeciesReference object, or @c None if the \n"
		"given index is out of range.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeProduct(string species)</pre>\n"
		"\n"
		"Removes the product species (SpeciesReference object) having the given  \n"
		"'species' attribute in this Reaction and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param species the 'species' attribute of the product SpeciesReference \n"
		"object\n"
		"\n"
		"@return the removed product SpeciesReference object, or @c None if no \n"
		"product SpeciesReference object with the given 'species' attribute \n"
		"@p species exists in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_removeModifier", _wrap_Reaction_removeModifier, METH_VARARGS, (char *)"\n"
		"removeModifier(unsigned int n) -> ModifierSpeciesReference\n"
		"Reaction_removeModifier(Reaction self, string species) -> ModifierSpeciesReference\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeModifier(long n)</pre>\n"
		"\n"
		"Removes the nth modifier species (ModifierSpeciesReference object) in \n"
		"the list of  modifiers in this Reaction and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"The caller should first call getNumModifiers() to find out how many\n"
		"modifiers there are, to avoid using an invalid index number.\n"
		"\n"
		"@param n the index of the ModifierSpeciesReference object to remove\n"
		"\n"
		"@return the removed ModifierSpeciesReference object, or @c None if the \n"
		"given index is out of range.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeModifier(string species)</pre>\n"
		"\n"
		"Removes the modifier species (ModifierSpeciesReference object) having \n"
		"the given 'species' attribute in this Reaction and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param species the 'species' attribute of the ModifierSpeciesReference \n"
		"object\n"
		"\n"
		"@return the removed ModifierSpeciesReference object, or @c None if no \n"
		"ModifierSpeciesReference object with the given 'species' attribute @p \n"
		"species exists in this Reaction.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getTypeCode", _wrap_Reaction_getTypeCode, METH_VARARGS, (char *)"\n"
		"Reaction_getTypeCode(Reaction self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_getElementName", _wrap_Reaction_getElementName, METH_VARARGS, (char *)"\n"
		"Reaction_getElementName(Reaction self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Reaction, is\n"
		"always @c 'reaction'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'reaction'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_hasRequiredAttributes", _wrap_Reaction_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Reaction_hasRequiredAttributes(Reaction self) -> bool\n"
		"\n"
		"Predicate returning @c true if all the required attributes for this\n"
		"Reaction object have been set.\n"
		"\n"
		"@note The required attributes for a Reaction object are:\n"
		"@li 'id' (or 'name' in SBML Level&nbsp;1)\n"
		"@li 'fast' (in Level&nbsp;3 only, where it is defined as a required attribute)\n"
		"@li 'reversible' (in Level&nbsp;3 only, where it is defined as a required attribute)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Reaction_swigregister", Reaction_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfReactions_clone", _wrap_ListOfReactions_clone, METH_VARARGS, (char *)"\n"
		"ListOfReactions_clone(ListOfReactions self) -> ListOfReactions\n"
		"\n"
		"Creates and returns a deep copy of this ListOfReactions instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfReactions.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfReactions_getTypeCode", _wrap_ListOfReactions_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfReactions_getTypeCode(ListOfReactions self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link\n"
		"libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfReactions_getItemTypeCode", _wrap_ListOfReactions_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfReactions_getItemTypeCode(ListOfReactions self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Reaction objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfReactions_getElementName", _wrap_ListOfReactions_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfReactions_getElementName(ListOfReactions self) -> string\n"
		"\n"
		"Returns the XML element name of this object\n"
		"\n"
		"For ListOfReactions, the XML element name is @c 'listOfReactions'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfReactions'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfReactions_get", _wrap_ListOfReactions_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Reaction\n"
		"get(unsigned int n) -> Reaction\n"
		"get(string sid) -> Reaction\n"
		"ListOfReactions_get(ListOfReactions self, string sid) -> Reaction\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a Reaction from the ListOfReactions.\n"
		"\n"
		"@param n the index number of the Reaction to get.\n"
		"\n"
		"@return the nth Reaction in this ListOfReactions.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a Reaction from the ListOfReactions.\n"
		"\n"
		"@param n the index number of the Reaction to get.\n"
		"\n"
		"@return the nth Reaction in this ListOfReactions.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a Reaction from the ListOfReactions\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Reaction to get.\n"
		"\n"
		"@return Reaction in this ListOfReactions\n"
		"with the given id or @c None if no such\n"
		"Reaction exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a Reaction from the ListOfReactions\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Reaction to get.\n"
		"\n"
		"@return Reaction in this ListOfReactions\n"
		"with the given id or @c None if no such\n"
		"Reaction exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfReactions_remove", _wrap_ListOfReactions_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> Reaction\n"
		"ListOfReactions_remove(ListOfReactions self, string sid) -> Reaction\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfReactions items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes item in this ListOfReactions items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then\n"
		"@c None is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfReactions", _wrap_new_ListOfReactions, METH_VARARGS, (char *)"new_ListOfReactions() -> ListOfReactions"},
	 { (char *)"delete_ListOfReactions", _wrap_delete_ListOfReactions, METH_VARARGS, (char *)"delete_ListOfReactions(ListOfReactions self)"},
	 { (char *)"ListOfReactions_swigregister", ListOfReactions_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_KineticLaw", _wrap_delete_KineticLaw, METH_VARARGS, (char *)"delete_KineticLaw(KineticLaw self)"},
	 { (char *)"new_KineticLaw", _wrap_new_KineticLaw, METH_VARARGS, (char *)"\n"
		"KineticLaw(unsigned int level, unsigned int version)\n"
		"KineticLaw(SBMLNamespaces sbmlns)\n"
		"new_KineticLaw(KineticLaw orig) -> KineticLaw\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>KineticLaw(long level, long version)</pre>\n"
		"\n"
		"Creates a new KineticLaw using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this KineticLaw\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"KineticLaw\n"
		"\n"
		"@note Upon the addition of a KineticLaw object to an SBMLDocument\n"
		"(e.g., using Reaction.setKineticLaw()), the SBML Level, SBML Version\n"
		"and XML namespace of the document @em override the values used\n"
		"when creating the KineticLaw object via this constructor.  This is\n"
		"necessary to ensure that an SBML document is a consistent structure.\n"
		"Nevertheless, the ability to supply the values at the time of creation\n"
		"of a KineticLaw is an important aid to producing valid SBML.  Knowledge\n"
		"of the intented SBML Level and Version determine whether it is valid\n"
		"to assign a particular value to an attribute, or whether it is valid\n"
		"to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>KineticLaw(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new KineticLaw using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a KineticLaw object to an SBMLDocument\n"
		"(e.g., using Reaction.setKineticLaw()), the SBML XML namespace of the\n"
		"document @em overrides the value used when creating the KineticLaw\n"
		"object via this constructor.  This is necessary to ensure that an SBML\n"
		"document is a consistent structure.  Nevertheless, the ability to\n"
		"supply the values at the time of creation of a KineticLaw is an\n"
		"important aid to producing valid SBML.  Knowledge of the intented SBML\n"
		"Level and Version determine whether it is valid to assign a particular\n"
		"value to an attribute, or whether it is valid to add an object to an\n"
		"existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>KineticLaw(KineticLaw orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this KineticLaw.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_clone", _wrap_KineticLaw_clone, METH_VARARGS, (char *)"\n"
		"KineticLaw_clone(KineticLaw self) -> KineticLaw\n"
		"\n"
		"Creates and returns a deep copy of this KineticLaw object.\n"
		"\n"
		"@return a (deep) copy of this KineticLaw.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getFormula", _wrap_KineticLaw_getFormula, METH_VARARGS, (char *)"\n"
		"KineticLaw_getFormula(KineticLaw self) -> string\n"
		"\n"
		"Returns the mathematical formula for this KineticLaw object and return\n"
		"it as as a text string.\n"
		"\n"
		"This is fundamentally equivalent to\n"
		"@if java KineticLaw.getMath()@else getMath()@endif.\n"
		"This variant is provided principally for compatibility compatibility\n"
		"with SBML Level&nbsp;1.\n"
		"\n"
		"@return a string representing the formula of this KineticLaw.\n"
		"\n"
		"@note @htmlinclude level-1-uses-text-string-math.html\n"
		"\n"
		"@see getMath()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getMath", _wrap_KineticLaw_getMath, METH_VARARGS, (char *)"\n"
		"KineticLaw_getMath(KineticLaw self) -> ASTNode\n"
		"\n"
		"Returns the mathematical formula for this KineticLaw object and return\n"
		"it as as an AST.\n"
		"\n"
		"This is fundamentally equivalent to\n"
		"@if java KineticLaw.getFormula()@else getFormula()@endif.\n"
		"The latter is provided principally for compatibility compatibility\n"
		"with SBML Level&nbsp;1, which represented mathematical formulas in\n"
		"text-string form.\n"
		"\n"
		"@return the ASTNode representation of the mathematical formula.\n"
		"\n"
		"@see getFormula()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getTimeUnits", _wrap_KineticLaw_getTimeUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_getTimeUnits(KineticLaw self) -> string\n"
		"\n"
		"(SBML Level&nbsp;2 Version&nbsp;1 only) Returns the value of the\n"
		"'timeUnits' attribute of this KineticLaw object.\n"
		"\n"
		"@return the 'timeUnits' attribute value.\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getSubstanceUnits", _wrap_KineticLaw_getSubstanceUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_getSubstanceUnits(KineticLaw self) -> string\n"
		"\n"
		"(SBML Level&nbsp;2 Version&nbsp;1 only) Returns the value of the\n"
		"'substanceUnits' attribute of this KineticLaw object.\n"
		"\n"
		"@return the 'substanceUnits' attribute value.\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_isSetFormula", _wrap_KineticLaw_isSetFormula, METH_VARARGS, (char *)"\n"
		"KineticLaw_isSetFormula(KineticLaw self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"KineticLaw's 'formula' attribute is set.\n"
		"\n"
		"This is functionally identical to the method\n"
		"@if java KineticLaw.isSetMath()@else isSetMath()@endif.  It is\n"
		"provided in order to mirror the parallel between\n"
		"@if java KineticLaw.getFormula()@else getFormula()@endif and\n"
		"@if java KineticLaw.getMath()@else getMath()@endif.\n"
		"\n"
		"@return @c true if the formula (meaning the @c math subelement) of\n"
		"this KineticLaw is set, @c false otherwise.\n"
		"\n"
		"@note @htmlinclude level-1-uses-text-string-math.html\n"
		"\n"
		"@see isSetMath()\n"
		"    \n"
		"\n"
		""},
	 { (char *)"KineticLaw_isSetMath", _wrap_KineticLaw_isSetMath, METH_VARARGS, (char *)"\n"
		"KineticLaw_isSetMath(KineticLaw self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Kinetic's 'math' subelement is set.\n"
		"\n"
		"This is identical to the method\n"
		"@if java KineticLaw.isSetFormula()@else isSetFormula()@endif.\n"
		"It is provided in order to mirror the parallel between\n"
		"@if java KineticLaw.getFormula()@else getFormula()@endif and\n"
		"@if java KineticLaw.getMath()@else getMath()@endif.\n"
		"\n"
		"@return @c true if the formula (meaning the @c math subelement) of\n"
		"this KineticLaw is set, @c false otherwise.\n"
		"\n"
		"@see isSetFormula()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_isSetTimeUnits", _wrap_KineticLaw_isSetTimeUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_isSetTimeUnits(KineticLaw self) -> bool\n"
		"\n"
		"(SBML Level&nbsp;2 Version&nbsp;1 only) Predicate returning @c true if\n"
		"this SpeciesReference's 'timeUnits' attribute is set.\n"
		"\n"
		"@return @c true if the 'timeUnits' attribute of this KineticLaw object\n"
		"is set, @c false otherwise.\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_isSetSubstanceUnits", _wrap_KineticLaw_isSetSubstanceUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_isSetSubstanceUnits(KineticLaw self) -> bool\n"
		"\n"
		"(SBML Level&nbsp;2 Version&nbsp;1 only) Predicate returning @c true if\n"
		"this SpeciesReference's 'substanceUnits' attribute is set.\n"
		"\n"
		"@return @c true if the 'substanceUnits' attribute of this KineticLaw\n"
		"object is set, @c false otherwise.\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_setFormula", _wrap_KineticLaw_setFormula, METH_VARARGS, (char *)"\n"
		"KineticLaw_setFormula(KineticLaw self, string formula) -> int\n"
		"\n"
		"Sets the mathematical expression of this KineticLaw instance to the\n"
		"given @p formula.\n"
		"\n"
		"The given @p formula string is copied.  Internally, libSBML stores the\n"
		"mathematical expression as an ASTNode.\n"
		"\n"
		"@param formula the mathematical expression to use, represented in\n"
		"text-string form.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note @htmlinclude level-1-uses-text-string-math.html\n"
		"\n"
		"@see setMath()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_setMath", _wrap_KineticLaw_setMath, METH_VARARGS, (char *)"\n"
		"KineticLaw_setMath(KineticLaw self, ASTNode math) -> int\n"
		"\n"
		"Sets the mathematical expression of this KineticLaw instance to a copy\n"
		"of the given ASTNode.\n"
		"\n"
		"This is fundamentally identical to\n"
		"@if java KineticLaw.setFormula()@else getFormula()@endif.\n"
		"The latter is provided principally for compatibility compatibility with\n"
		"SBML Level&nbsp;1, which represented mathematical formulas in text-string\n"
		"form.\n"
		"\n"
		"@param math an ASTNode representing a formula tree.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@see setFormula()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_setTimeUnits", _wrap_KineticLaw_setTimeUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_setTimeUnits(KineticLaw self, string sid) -> int\n"
		"\n"
		"(SBML Level&nbsp;2 Version&nbsp;1 only) Sets the 'timeUnits' attribute\n"
		"of this KineticLaw object to a copy of the identifier in @p sid.\n"
		"\n"
		"@param sid the identifier of the units to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_setSubstanceUnits", _wrap_KineticLaw_setSubstanceUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_setSubstanceUnits(KineticLaw self, string sid) -> int\n"
		"\n"
		"(SBML Level&nbsp;2 Version&nbsp;1 only) Sets the 'substanceUnits'\n"
		"attribute of this KineticLaw object to a copy of the identifier given\n"
		"in @p sid.\n"
		"\n"
		"@param sid the identifier of the units to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_unsetTimeUnits", _wrap_KineticLaw_unsetTimeUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_unsetTimeUnits(KineticLaw self) -> int\n"
		"\n"
		"(SBML Level&nbsp;2 Version&nbsp;1 only) Unsets the 'timeUnits'\n"
		"attribugte of this KineticLaw object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_unsetSubstanceUnits", _wrap_KineticLaw_unsetSubstanceUnits, METH_VARARGS, (char *)"\n"
		"KineticLaw_unsetSubstanceUnits(KineticLaw self) -> int\n"
		"\n"
		"(SBML Level&nbsp;2 Version&nbsp;1 only) Unsets the 'substanceUnits'\n"
		"attribute of this KineticLaw object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attributes 'timeUnits' and 'substanceUnits' are present only\n"
		"in SBML Level&nbsp;2 Version&nbsp;1.  In SBML Level&nbsp;2\n"
		"Version&nbsp;2, the 'timeUnits' and 'substanceUnits' attributes were\n"
		"removed.  For compatibility with new versions of SBML, users are\n"
		"cautioned to avoid these attributes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_addParameter", _wrap_KineticLaw_addParameter, METH_VARARGS, (char *)"\n"
		"KineticLaw_addParameter(KineticLaw self, Parameter p) -> int\n"
		"\n"
		"Adds a copy of the given Parameter object to the list of local\n"
		"parameters in this KineticLaw.\n"
		"\n"
		"@param p the Parameter to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this KineticLaw.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the KineticLaw</em>.  In addition, the caller should make\n"
		"sure to free the original object if it is no longer being used, or\n"
		"else a memory leak will result.  Please see\n"
		"@if java KineticLaw.createParameter()@else createParameter()@endif\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createParameter()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_addLocalParameter", _wrap_KineticLaw_addLocalParameter, METH_VARARGS, (char *)"\n"
		"KineticLaw_addLocalParameter(KineticLaw self, LocalParameter p) -> int\n"
		"\n"
		"Adds a copy of the given LocalParameter object to the list of local\n"
		"parameters in this KineticLaw.\n"
		"\n"
		"@param p the LocalParameter to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this KineticLaw.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the KineticLaw</em>.  In addition, the caller should make\n"
		"sure to free the original object if it is no longer being used, or\n"
		"else a memory leak will result.  Please see\n"
		"@if java KineticLaw.createParameter()@else createParameter()@endif\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createLocalParameter()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_createParameter", _wrap_KineticLaw_createParameter, METH_VARARGS, (char *)"\n"
		"KineticLaw_createParameter(KineticLaw self) -> Parameter\n"
		"\n"
		"Creates a new Parameter object, adds it to this KineticLaw's list of\n"
		"local parameters, and returns the Parameter object created.\n"
		"\n"
		"@return a new Parameter object instance\n"
		"\n"
		"@see addParameter()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_createLocalParameter", _wrap_KineticLaw_createLocalParameter, METH_VARARGS, (char *)"\n"
		"KineticLaw_createLocalParameter(KineticLaw self) -> LocalParameter\n"
		"\n"
		"Creates a new LocalParameter object, adds it to this KineticLaw's list\n"
		"of local parameters, and returns the LocalParameter object created.\n"
		"\n"
		"@return a new LocalParameter object instance\n"
		"\n"
		"@see addLocalParameter()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getListOfParameters", _wrap_KineticLaw_getListOfParameters, METH_VARARGS, (char *)"\n"
		"getListOfParameters() -> ListOfParameters\n"
		"KineticLaw_getListOfParameters(KineticLaw self) -> ListOfParameters\n"
		"\n"
		"Returns the list of local parameters in this KineticLaw object.\n"
		"\n"
		"@return the list of Parameters for this KineticLaw.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getListOfLocalParameters", _wrap_KineticLaw_getListOfLocalParameters, METH_VARARGS, (char *)"\n"
		"getListOfLocalParameters() -> ListOfLocalParameters\n"
		"KineticLaw_getListOfLocalParameters(KineticLaw self) -> ListOfLocalParameters\n"
		"\n"
		"Returns the list of local parameters in this KineticLaw object.\n"
		"\n"
		"@return the list of LocalParameters for this KineticLaw.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getParameter", _wrap_KineticLaw_getParameter, METH_VARARGS, (char *)"\n"
		"getParameter(unsigned int n) -> Parameter\n"
		"getParameter(unsigned int n) -> Parameter\n"
		"getParameter(string sid) -> Parameter\n"
		"KineticLaw_getParameter(KineticLaw self, string sid) -> Parameter\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getParameter(long n)</pre>\n"
		"\n"
		"Returns the nth Parameter object in the list of local parameters in\n"
		"this KineticLaw instance.\n"
		"\n"
		"@param n the index of the Parameter object sought\n"
		"\n"
		"@return the nth Parameter of this KineticLaw.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getParameter(long n)</pre>\n"
		"\n"
		"Returns the nth Parameter object in the list of local parameters in\n"
		"this KineticLaw instance.\n"
		"\n"
		"@param n the index of the Parameter object sought\n"
		"\n"
		"@return the nth Parameter of this KineticLaw.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getParameter(string sid)</pre>\n"
		"\n"
		"Returns a local parameter based on its identifier.\n"
		"\n"
		"@param sid the identifier of the Parameter being sought.\n"
		"\n"
		"@return the Parameter object in this KineticLaw instace having the\n"
		"given 'id', or @c None if no such Parameter exists.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getParameter(string sid)</pre>\n"
		"\n"
		"Returns a local parameter based on its identifier.\n"
		"\n"
		"@param sid the identifier of the Parameter being sought.\n"
		"\n"
		"@return the Parameter object in this KineticLaw instace having the\n"
		"given 'id', or @c None if no such Parameter exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getLocalParameter", _wrap_KineticLaw_getLocalParameter, METH_VARARGS, (char *)"\n"
		"getLocalParameter(unsigned int n) -> LocalParameter\n"
		"getLocalParameter(unsigned int n) -> LocalParameter\n"
		"getLocalParameter(string sid) -> LocalParameter\n"
		"KineticLaw_getLocalParameter(KineticLaw self, string sid) -> LocalParameter\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getLocalParameter(long n)</pre>\n"
		"\n"
		"Returns the nth LocalParameter object in the list of local parameters in\n"
		"this KineticLaw instance.\n"
		"\n"
		"@param n the index of the LocalParameter object sought\n"
		"\n"
		"@return the nth LocalParameter of this KineticLaw.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getLocalParameter(long n)</pre>\n"
		"\n"
		"Returns the nth LocalParameter object in the list of local parameters in\n"
		"this KineticLaw instance.\n"
		"\n"
		"@param n the index of the LocalParameter object sought\n"
		"\n"
		"@return the nth LocalParameter of this KineticLaw.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getLocalParameter(string sid)</pre>\n"
		"\n"
		"Returns a local parameter based on its identifier.\n"
		"\n"
		"@param sid the identifier of the LocalParameter being sought.\n"
		"\n"
		"@return the LocalParameter object in this KineticLaw instace having the\n"
		"given 'id', or @c None if no such LocalParameter exists.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getLocalParameter(string sid)</pre>\n"
		"\n"
		"Returns a local parameter based on its identifier.\n"
		"\n"
		"@param sid the identifier of the LocalParameter being sought.\n"
		"\n"
		"@return the LocalParameter object in this KineticLaw instace having the\n"
		"given 'id', or @c None if no such LocalParameter exists.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getNumParameters", _wrap_KineticLaw_getNumParameters, METH_VARARGS, (char *)"\n"
		"KineticLaw_getNumParameters(KineticLaw self) -> unsigned int\n"
		"\n"
		"Returns the number of local parameters in this KineticLaw instance.\n"
		"\n"
		"@return the number of Parameters in this KineticLaw.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getNumLocalParameters", _wrap_KineticLaw_getNumLocalParameters, METH_VARARGS, (char *)"\n"
		"KineticLaw_getNumLocalParameters(KineticLaw self) -> unsigned int\n"
		"\n"
		"Returns the number of local parameters in this KineticLaw instance.\n"
		"\n"
		"@return the number of LocalParameters in this KineticLaw.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getDerivedUnitDefinition", _wrap_KineticLaw_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"KineticLaw_getDerivedUnitDefinition(KineticLaw self) -> UnitDefinition\n"
		"\n"
		"Calculates and returns a UnitDefinition that expresses the units\n"
		"of measurement assumed for the 'math' expression of this\n"
		"KineticLaw.\n"
		"\n"
		"The units are calculated based on the mathematical expression in the\n"
		"KineticLaw and the model quantities referenced by\n"
		"<code>&lt;ci&gt;</code> elements used within that expression.  The\n"
		"@if java KineticLaw.getDerivedUnitDefinition()@else getDerivedUnitDefinition()@endif\n"
		"method returns the calculated units.\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c None.\n"
		"\n"
		"@warning Note that it is possible the 'math' expression in the\n"
		"KineticLaw contains pure numbers or parameters with undeclared\n"
		"units.  In those cases, it is not possible to calculate the units of\n"
		"the overall expression without making assumptions.  LibSBML does not\n"
		"make assumptions about the units, and\n"
		"@if java KineticLaw.getDerivedUnitDefinition()@else getDerivedUnitDefinition()@endif\n"
		"only returns the units as far as it is able to determine them.  For\n"
		"example, in an expression <em>X + Y</em>, if <em>X</em> has\n"
		"unambiguously-defined units and <em>Y</em> does not, it will return\n"
		"the units of <em>X</em>.  <strong>It is important that callers also\n"
		"invoke the method</strong>\n"
		"@if java KineticLaw.containsUndeclaredUnits()@else containsUndeclaredUnits()@endif\n"
		"<strong>to determine whether this situation holds</strong>.  Callers may\n"
		"wish to take suitable actions in those scenarios.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of the math \n"
		"expression of this KineticLaw, or @c None if one cannot be constructed.\n"
		"\n"
		"@see containsUndeclaredUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_containsUndeclaredUnits", _wrap_KineticLaw_containsUndeclaredUnits, METH_VARARGS, (char *)"\n"
		"containsUndeclaredUnits() -> bool\n"
		"KineticLaw_containsUndeclaredUnits(KineticLaw self) -> bool\n"
		"\n"
		"Predicate returning @c true if \n"
		"the math expression of this KineticLaw contains\n"
		"parameters/numbers with undeclared units.\n"
		"\n"
		"@return @c true if the math expression of this KineticLaw\n"
		"includes parameters/numbers \n"
		"with undeclared units, @c false otherwise.\n"
		"\n"
		"@note A return value of @c true indicates that the UnitDefinition\n"
		"returned by\n"
		"@if java KineticLaw.getDerivedUnitDefinition()@else getDerivedUnitDefinition()@endif\n"
		"may not accurately represent the units of the expression.\n"
		"\n"
		"@see getDerivedUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_removeParameter", _wrap_KineticLaw_removeParameter, METH_VARARGS, (char *)"\n"
		"removeParameter(unsigned int n) -> Parameter\n"
		"KineticLaw_removeParameter(KineticLaw self, string sid) -> Parameter\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeParameter(long n)</pre>\n"
		"\n"
		"Removes the nth Parameter object in the list of local parameters \n"
		"in this KineticLaw instance and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the Parameter object to remove\n"
		"\n"
		"@return the Parameter object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeParameter(string sid)</pre>\n"
		"\n"
		"Removes a Parameter object with the given identifier in the list of\n"
		"local parameters in this KineticLaw instance and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param sid the identifier of the Parameter to remove\n"
		"\n"
		"@return the Parameter object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no Parameter\n"
		"object with the identifier exists in this KineticLaw instance.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_removeLocalParameter", _wrap_KineticLaw_removeLocalParameter, METH_VARARGS, (char *)"\n"
		"removeLocalParameter(unsigned int n) -> LocalParameter\n"
		"KineticLaw_removeLocalParameter(KineticLaw self, string sid) -> LocalParameter\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeLocalParameter(long n)</pre>\n"
		"\n"
		"Removes the nth LocalParameter object in the list of local parameters \n"
		"in this KineticLaw instance and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the LocalParameter object to remove\n"
		"\n"
		"@return the LocalParameter object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeLocalParameter(string sid)</pre>\n"
		"\n"
		"Removes a LocalParameter object with the given identifier in the list of\n"
		"local parameters in this KineticLaw instance and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param sid the identifier of the LocalParameter to remove\n"
		"\n"
		"@return the LocalParameter object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no LocalParameter\n"
		"object with the identifier exists in this KineticLaw instance.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getTypeCode", _wrap_KineticLaw_getTypeCode, METH_VARARGS, (char *)"\n"
		"KineticLaw_getTypeCode(KineticLaw self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link\n"
		"libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_getElementName", _wrap_KineticLaw_getElementName, METH_VARARGS, (char *)"\n"
		"KineticLaw_getElementName(KineticLaw self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Species, is\n"
		"always @c 'kineticLaw'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'kineticLaw'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_hasRequiredAttributes", _wrap_KineticLaw_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"KineticLaw_hasRequiredAttributes(KineticLaw self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this KineticLaw object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a KineticLaw object are:\n"
		"@li 'formula' (SBML Level&nbsp;1 only)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_hasRequiredElements", _wrap_KineticLaw_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"KineticLaw_hasRequiredElements(KineticLaw self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this KineticLaw object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a KineticLaw object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"KineticLaw_swigregister", KineticLaw_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_SimpleSpeciesReference", _wrap_delete_SimpleSpeciesReference, METH_VARARGS, (char *)"delete_SimpleSpeciesReference(SimpleSpeciesReference self)"},
	 { (char *)"SimpleSpeciesReference_getId", _wrap_SimpleSpeciesReference_getId, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_getId(SimpleSpeciesReference self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"@return the id of this SimpleSpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_getName", _wrap_SimpleSpeciesReference_getName, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_getName(SimpleSpeciesReference self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"@return the name of this SimpleSpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_getSpecies", _wrap_SimpleSpeciesReference_getSpecies, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_getSpecies(SimpleSpeciesReference self) -> string\n"
		"\n"
		"Get the value of the 'species' attribute.\n"
		"\n"
		"@return the value of the attribute 'species' for this\n"
		"SimpleSpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_isSetId", _wrap_SimpleSpeciesReference_isSetId, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_isSetId(SimpleSpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SimpleSpeciesReference's 'id' attribute is set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this SimpleSpeciesReference is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_isSetName", _wrap_SimpleSpeciesReference_isSetName, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_isSetName(SimpleSpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SimpleSpeciesReference's 'name' attribute is set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this SimpleSpeciesReference is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_isSetSpecies", _wrap_SimpleSpeciesReference_isSetSpecies, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_isSetSpecies(SimpleSpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SimpleSpeciesReference's 'species' attribute is set.\n"
		"\n"
		"@return @c true if the 'species' attribute of this\n"
		"SimpleSpeciesReference is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_setSpecies", _wrap_SimpleSpeciesReference_setSpecies, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_setSpecies(SimpleSpeciesReference self, string sid) -> int\n"
		"\n"
		"Sets the 'species' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"The identifier string passed in @p sid is copied.\n"
		"\n"
		"@param sid the identifier of a species defined in the enclosing\n"
		"Model's ListOfSpecies.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_setId", _wrap_SimpleSpeciesReference_setId, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_setId(SimpleSpeciesReference self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this SimpleSpeciesReference\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_setName", _wrap_SimpleSpeciesReference_setName, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_setName(SimpleSpeciesReference self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the SimpleSpeciesReference\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_unsetId", _wrap_SimpleSpeciesReference_unsetId, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_unsetId(SimpleSpeciesReference self) -> int\n"
		"\n"
		"Unsets the value of the 'id' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_unsetName", _wrap_SimpleSpeciesReference_unsetName, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_unsetName(SimpleSpeciesReference self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this SimpleSpeciesReference.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_isModifier", _wrap_SimpleSpeciesReference_isModifier, METH_VARARGS, (char *)"\n"
		"SimpleSpeciesReference_isModifier(SimpleSpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"is a ModifierSpeciesReference.\n"
		"\n"
		"@return @c true if this SimpleSpeciesReference's subclass is\n"
		"ModiferSpeciesReference, @c false if it is a plain SpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SimpleSpeciesReference_swigregister", SimpleSpeciesReference_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_SpeciesReference", _wrap_delete_SpeciesReference, METH_VARARGS, (char *)"delete_SpeciesReference(SpeciesReference self)"},
	 { (char *)"new_SpeciesReference", _wrap_new_SpeciesReference, METH_VARARGS, (char *)"\n"
		"SpeciesReference(unsigned int level, unsigned int version)\n"
		"SpeciesReference(SBMLNamespaces sbmlns)\n"
		"new_SpeciesReference(SpeciesReference orig) -> SpeciesReference\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>SpeciesReference(long level, long version)</pre>\n"
		"\n"
		"Creates a new SpeciesReference using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this SpeciesReference\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"SpeciesReference\n"
		"\n"
		"@note Upon the addition of a SpeciesReference object to a Model (e.g.,\n"
		"using Reaction.addReactant() or\n"
		"Reaction.addProduct()), the SBML Level,\n"
		"SBML Version and XML namespace of the document @em override the values\n"
		"used when creating the SpeciesReference object via this constructor.\n"
		"This is necessary to ensure that an SBML document is a consistent\n"
		"structure.  Nevertheless, the ability to supply the values at the time\n"
		"of creation of a SpeciesReference is an important aid to producing\n"
		"valid SBML.  Knowledge of the intented SBML Level and Version\n"
		"determine whether it is valid to assign a particular value to an\n"
		"attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>SpeciesReference(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new SpeciesReference using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a SpeciesReference object to a Model (e.g.,\n"
		"using Reaction.addReactant() or\n"
		"Reaction.addProduct()), the SBML Level,\n"
		"SBML Version and XML namespace of the document @em override the values\n"
		"used when creating the SpeciesReference object via this constructor.\n"
		"This is necessary to ensure that an SBML document is a consistent\n"
		"structure.  Nevertheless, the ability to supply the values at the time\n"
		"of creation of a SpeciesReference is an important aid to producing\n"
		"valid SBML.  Knowledge of the intented SBML Level and Version\n"
		"determine whether it is valid to assign a particular value to an\n"
		"attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>SpeciesReference(SpeciesReference orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this SpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_clone", _wrap_SpeciesReference_clone, METH_VARARGS, (char *)"\n"
		"SpeciesReference_clone(SpeciesReference self) -> SpeciesReference\n"
		"\n"
		"Creates and returns a deep copy of this SpeciesReference instance.\n"
		"\n"
		"@return a (deep) copy of this SpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_initDefaults", _wrap_SpeciesReference_initDefaults, METH_VARARGS, (char *)"\n"
		"SpeciesReference_initDefaults(SpeciesReference self)\n"
		"\n"
		"Initializes the fields of this SpeciesReference object to 'typical'\n"
		"default values.\n"
		"\n"
		"The SBML SpeciesReference component has slightly different aspects and\n"
		"default attribute values in different SBML Levels and Versions.\n"
		"This method sets the values to certain common defaults, based\n"
		"mostly on what they are in SBML Level&nbsp;2.  Specifically:\n"
		"<ul>\n"
		"<li> Sets attribute 'stoichiometry' to @c 1.0\n"
		"<li> (Applies to Level&nbsp;1 models only) Sets attribute 'denominator' to @c 1\n"
		"</ul>\n"
		"\n"
		"@see getDenominator()\n"
		"@see setDenominator()\n"
		"@see getStoichiometry()\n"
		"@see setStoichiometry()\n"
		"@see getStoichiometryMath()\n"
		"@see setStoichiometryMath()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_getStoichiometry", _wrap_SpeciesReference_getStoichiometry, METH_VARARGS, (char *)"\n"
		"SpeciesReference_getStoichiometry(SpeciesReference self) -> double\n"
		"\n"
		"Get the value of the 'stoichiometry' attribute.\n"
		"\n"
		"In SBML Level 2, product and reactant stoichiometries can be specified\n"
		"using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a\n"
		"SpeciesReference object.  The former is to be used when a\n"
		"stoichiometry is simply a scalar number, while the latter is for\n"
		"occasions when it needs to be a rational number or it needs to\n"
		"reference other mathematical expressions.  The 'stoichiometry'\n"
		"attribute is of type @c double and should contain values greater than\n"
		"zero (@c 0).  The 'stoichiometryMath' element is implemented as an\n"
		"element containing a MathML expression.  These two are mutually\n"
		"exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should\n"
		"be defined in a given SpeciesReference instance.  When neither the\n"
		"attribute nor the element is present, the value of 'stoichiometry' in\n"
		"the SpeciesReference instance defaults to @c 1.  For maximum\n"
		"interoperability between different software tools, the 'stoichiometry'\n"
		"attribute should be used in preference to 'stoichiometryMath' when a\n"
		"species' stoichiometry is a simple scalar number (integer or\n"
		"decimal).\n"
		"\n"
		"In SBML Level 3, there is no StoichiometryMath, and SpeciesReference\n"
		"objects have only the 'stoichiometry' attribute.\n"
		"\n"
		"@return the value of the (scalar) 'stoichiometry' attribute of this\n"
		"SpeciesReference.\n"
		"\n"
		"@see getStoichiometryMath()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_getStoichiometryMath", _wrap_SpeciesReference_getStoichiometryMath, METH_VARARGS, (char *)"\n"
		"getStoichiometryMath() -> StoichiometryMath\n"
		"SpeciesReference_getStoichiometryMath(SpeciesReference self) -> StoichiometryMath\n"
		"\n"
		"Get the content of the 'stoichiometryMath' subelement as an ASTNode\n"
		"tree.\n"
		"\n"
		"The 'stoichiometryMath' element exists only in SBML Level 2.  There,\n"
		"product and reactant stoichiometries can be specified using\n"
		"<em>either</em> 'stoichiometry' or 'stoichiometryMath' in a\n"
		"SpeciesReference object.  The former is to be used when a\n"
		"stoichiometry is simply a scalar number, while the latter is for\n"
		"occasions when it needs to be a rational number or it needs to\n"
		"reference other mathematical expressions.  The 'stoichiometry'\n"
		"attribute is of type @c double and should contain values greater than\n"
		"zero (@c 0).  The 'stoichiometryMath' element is implemented as an\n"
		"element containing a MathML expression.  These two are mutually\n"
		"exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should\n"
		"be defined in a given SpeciesReference instance.  When neither the\n"
		"attribute nor the element is present, the value of 'stoichiometry' in\n"
		"the SpeciesReference instance defaults to @c 1.  For maximum\n"
		"interoperability between different software tools, the 'stoichiometry'\n"
		"attribute should be used in preference to 'stoichiometryMath' when a\n"
		"species' stoichiometry is a simple scalar number (integer or decimal).\n"
		"\n"
		"@return the content of the 'stoichiometryMath' subelement of this\n"
		"SpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_getDenominator", _wrap_SpeciesReference_getDenominator, METH_VARARGS, (char *)"\n"
		"SpeciesReference_getDenominator(SpeciesReference self) -> int\n"
		"\n"
		"Get the value of the 'denominator' attribute, for the case of a\n"
		"rational-numbered stoichiometry or a model in SBML Level&nbsp;1.\n"
		"\n"
		"The 'denominator' attribute is only actually written out in the case\n"
		"of an SBML Level&nbsp;1 model.  In SBML Level&nbsp;2, rational-number\n"
		"stoichiometries are written as MathML elements in the\n"
		"'stoichiometryMath' subelement.  However, as a convenience to users,\n"
		"libSBML allows the creation and manipulation of rational-number\n"
		"stoichiometries by supplying the numerator and denominator directly\n"
		"rather than having to manually create an ASTNode structure.  LibSBML\n"
		"will write out the appropriate constructs (either a combination of\n"
		"'stoichiometry' and 'denominator' in the case of SBML Level&nbsp;1, or a\n"
		"'stoichiometryMath' subelement in the case of SBML Level&nbsp;2).\n"
		"\n"
		"@return the value of the 'denominator' attribute of this\n"
		"SpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_getConstant", _wrap_SpeciesReference_getConstant, METH_VARARGS, (char *)"\n"
		"SpeciesReference_getConstant(SpeciesReference self) -> bool\n"
		"\n"
		"Get the value of the 'constant' attribute.\n"
		"\n"
		"@return the value of the 'constant' attribute of this\n"
		"SpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_isSetStoichiometryMath", _wrap_SpeciesReference_isSetStoichiometryMath, METH_VARARGS, (char *)"\n"
		"SpeciesReference_isSetStoichiometryMath(SpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SpeciesReference's 'stoichiometryMath' subelement is set\n"
		"\n"
		"@return @c true if the 'stoichiometryMath' subelement of this\n"
		"SpeciesReference is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_isSetConstant", _wrap_SpeciesReference_isSetConstant, METH_VARARGS, (char *)"\n"
		"SpeciesReference_isSetConstant(SpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SpeciesReference's 'constant' attribute is set\n"
		"\n"
		"@return @c true if the 'constant' attribute of this\n"
		"SpeciesReference is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_isSetStoichiometry", _wrap_SpeciesReference_isSetStoichiometry, METH_VARARGS, (char *)"\n"
		"SpeciesReference_isSetStoichiometry(SpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"SpeciesReference's 'stoichiometry' attribute is set.\n"
		"\n"
		"@return @c true if the 'stoichiometry' attribute of this\n"
		"SpeciesReference is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_setStoichiometry", _wrap_SpeciesReference_setStoichiometry, METH_VARARGS, (char *)"\n"
		"SpeciesReference_setStoichiometry(SpeciesReference self, double value) -> int\n"
		"\n"
		"Sets the value of the 'stoichiometry' attribute of this\n"
		"SpeciesReference.\n"
		"\n"
		"In SBML Level 2, product and reactant stoichiometries can be specified\n"
		"using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a\n"
		"SpeciesReference object.  The former is to be used when a\n"
		"stoichiometry is simply a scalar number, while the latter is for\n"
		"occasions when it needs to be a rational number or it needs to\n"
		"reference other mathematical expressions.  The 'stoichiometry'\n"
		"attribute is of type @c double and should contain values greater than\n"
		"zero (@c 0).  The 'stoichiometryMath' element is implemented as an\n"
		"element containing a MathML expression.  These two are mutually\n"
		"exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should\n"
		"be defined in a given SpeciesReference instance.  When neither the\n"
		"attribute nor the element is present, the value of 'stoichiometry' in\n"
		"the SpeciesReference instance defaults to @c 1.  For maximum\n"
		"interoperability between different software tools, the 'stoichiometry'\n"
		"attribute should be used in preference to 'stoichiometryMath' when a\n"
		"species' stoichiometry is a simple scalar number (integer or\n"
		"decimal).\n"
		"\n"
		"In SBML Level 3, there is no StoichiometryMath, and SpeciesReference\n"
		"objects have only the 'stoichiometry' attribute.\n"
		"\n"
		"@param value the new value of the 'stoichiometry' attribute\n"
		"\n"
		"@note In SBML Level&nbsp;2, the 'stoichiometryMath' subelement of this\n"
		"SpeciesReference object will be unset because the 'stoichiometry'\n"
		"attribute and the stoichiometryMath' subelement are mutually\n"
		"exclusive.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_setStoichiometryMath", _wrap_SpeciesReference_setStoichiometryMath, METH_VARARGS, (char *)"\n"
		"SpeciesReference_setStoichiometryMath(SpeciesReference self, StoichiometryMath math) -> int\n"
		"\n"
		"Sets the 'stoichiometryMath' subelement of this SpeciesReference.\n"
		"\n"
		"The Abstract Syntax Tree in @p math is copied.\n"
		"\n"
		"In SBML Level 2, product and reactant stoichiometries can be specified\n"
		"using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a\n"
		"SpeciesReference object.  The former is to be used when a\n"
		"stoichiometry is simply a scalar number, while the latter is for\n"
		"occasions when it needs to be a rational number or it needs to\n"
		"reference other mathematical expressions.  The 'stoichiometry'\n"
		"attribute is of type @c double and should contain values greater than\n"
		"zero (@c 0).  The 'stoichiometryMath' element is implemented as an\n"
		"element containing a MathML expression.  These two are mutually\n"
		"exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should\n"
		"be defined in a given SpeciesReference instance.  When neither the\n"
		"attribute nor the element is present, the value of 'stoichiometry' in\n"
		"the SpeciesReference instance defaults to @c 1.  For maximum\n"
		"interoperability between different software tools, the 'stoichiometry'\n"
		"attribute should be used in preference to 'stoichiometryMath' when a\n"
		"species' stoichiometry is a simple scalar number (integer or\n"
		"decimal).\n"
		"\n"
		"In SBML Level 3, there is no StoichiometryMath, and SpeciesReference\n"
		"objects have only the 'stoichiometry' attribute.\n"
		"\n"
		"@param math the StoichiometryMath expression that is to be copied as the\n"
		"content of the 'stoichiometryMath' subelement.\n"
		"\n"
		"@note In SBML Level&nbsp;2, the 'stoichiometry' attribute of this\n"
		"SpeciesReference object will be unset (isSetStoichiometry() will\n"
		"return @c false although getStoichiometry() will return @c 1.0) if the\n"
		"given math is not null because the 'stoichiometry' attribute and the\n"
		"stoichiometryMath' subelement are mutually exclusive.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_setDenominator", _wrap_SpeciesReference_setDenominator, METH_VARARGS, (char *)"\n"
		"SpeciesReference_setDenominator(SpeciesReference self, int value) -> int\n"
		"\n"
		"Set the value of the 'denominator' attribute, for the case of a\n"
		"rational-numbered stoichiometry or a model in SBML Level&nbsp;1.\n"
		"\n"
		"The 'denominator' attribute is only actually written out in the case\n"
		"of an SBML Level&nbsp;1 model.  In SBML Level&nbsp;2, rational-number\n"
		"stoichiometries are written as MathML elements in the\n"
		"'stoichiometryMath' subelement.  However, as a convenience to users,\n"
		"libSBML allows the creation and manipulation of rational-number\n"
		"stoichiometries by supplying the numerator and denominator directly\n"
		"rather than having to manually create an ASTNode structure.  LibSBML\n"
		"will write out the appropriate constructs (either a combination of\n"
		"'stoichiometry' and 'denominator' in the case of SBML Level&nbsp;1, or\n"
		"a 'stoichiometryMath' subelement in the case of SBML Level&nbsp;2).\n"
		"\n"
		"@param value the scalar value \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_setConstant", _wrap_SpeciesReference_setConstant, METH_VARARGS, (char *)"\n"
		"SpeciesReference_setConstant(SpeciesReference self, bool flag) -> int\n"
		"\n"
		"Sets the 'constant' attribute of this SpeciesReference to the given boolean\n"
		"@p flag.\n"
		"\n"
		"@param flag a boolean, the value for the 'constant' attribute of this\n"
		"SpeciesReference instance\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_unsetStoichiometryMath", _wrap_SpeciesReference_unsetStoichiometryMath, METH_VARARGS, (char *)"\n"
		"SpeciesReference_unsetStoichiometryMath(SpeciesReference self) -> int\n"
		"\n"
		"Unsets the 'stoichiometryMath' subelement of this SpeciesReference.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"In SBML Level 2, product and reactant stoichiometries can be specified\n"
		"using <em>either</em> 'stoichiometry' or 'stoichiometryMath' in a\n"
		"SpeciesReference object.  The former is to be used when a\n"
		"stoichiometry is simply a scalar number, while the latter is for\n"
		"occasions when it needs to be a rational number or it needs to\n"
		"reference other mathematical expressions.  The 'stoichiometry'\n"
		"attribute is of type @c double and should contain values greater than\n"
		"zero (@c 0).  The 'stoichiometryMath' element is implemented as an\n"
		"element containing a MathML expression.  These two are mutually\n"
		"exclusive; only one of 'stoichiometry' or 'stoichiometryMath' should\n"
		"be defined in a given SpeciesReference instance.  When neither the\n"
		"attribute nor the element is present, the value of 'stoichiometry' in\n"
		"the SpeciesReference instance defaults to @c 1.  For maximum\n"
		"interoperability between different software tools, the 'stoichiometry'\n"
		"attribute should be used in preference to 'stoichiometryMath' when a\n"
		"species' stoichiometry is a simple scalar number (integer or\n"
		"decimal).\n"
		"\n"
		"In SBML Level 3, there is no StoichiometryMath, and SpeciesReference\n"
		"objects have only the 'stoichiometry' attribute.\n"
		"\n"
		"@note In SBML Level&nbsp;2, the 'stoichiometry' attribute of this\n"
		"SpeciesReference object will be reset to a default value (@c 1.0) if\n"
		"the 'stoichiometry' attribute has not been set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_unsetStoichiometry", _wrap_SpeciesReference_unsetStoichiometry, METH_VARARGS, (char *)"\n"
		"SpeciesReference_unsetStoichiometry(SpeciesReference self) -> int\n"
		"\n"
		"Unsets the 'stoichiometry' attribute of this SpeciesReference.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note In SBML Level&nbsp;1, the 'stoichiometry' attribute of this\n"
		"SpeciesReference object will be just reset to a default value (@c 1.0)\n"
		"and isSetStoichiometry() will still return @c true.  In SBML\n"
		"Level&nbsp;2, the 'stoichiometry' attribute of this object will be\n"
		"unset (which will result in isSetStoichiometry() returning @c false,\n"
		"although getStoichiometry() will return @c 1.0) if the\n"
		"'stoichiometryMath' subelement is set, otherwise the attribute\n"
		"will be just reset to the default value (@c 1.0) (and\n"
		"isSetStoichiometry() will still return @c true).  In SBML\n"
		"Level&nbsp;3, the 'stoichiometry' attribute of this object will be set\n"
		"to @c NaN and isSetStoichiometry() will return @c false.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_createStoichiometryMath", _wrap_SpeciesReference_createStoichiometryMath, METH_VARARGS, (char *)"\n"
		"SpeciesReference_createStoichiometryMath(SpeciesReference self) -> StoichiometryMath\n"
		"\n"
		"Creates a new, empty StoichiometryMath object, adds it to this\n"
		"SpeciesReference, and returns it.\n"
		"\n"
		"@return the newly created StoichiometryMath object instance\n"
		"\n"
		"@see Reaction.addReactant()\n"
		"@see Reaction.addProduct()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_setAnnotation", _wrap_SpeciesReference_setAnnotation, METH_VARARGS, (char *)"\n"
		"setAnnotation(XMLNode annotation) -> int\n"
		"SpeciesReference_setAnnotation(SpeciesReference self, string annotation) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setAnnotation(XMLNode annotation)</pre>\n"
		"\n"
		"Sets the value of the 'annotation' subelement of this SBML object to a\n"
		"copy of @p annotation.\n"
		"\n"
		"Any existing content of the 'annotation' subelement is discarded.\n"
		"Unless you have taken steps to first copy and reconstitute any\n"
		"existing annotations into the @p annotation that is about to be\n"
		"assigned, it is likely that performing such wholesale replacement is\n"
		"unfriendly towards other software applications whose annotations are\n"
		"discarded.  An alternative may be to use appendAnnotation().\n"
		"\n"
		"@param annotation an XML structure that is to be used as the content\n"
		"of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see appendAnnotation()\n"
		"@see appendAnnotation()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setAnnotation(string annotation)</pre>\n"
		"\n"
		"Sets the value of the 'annotation' subelement of this SBML object to a\n"
		"copy of @p annotation.\n"
		"\n"
		"Any existing content of the 'annotation' subelement is discarded.\n"
		"Unless you have taken steps to first copy and reconstitute any\n"
		"existing annotations into the @p annotation that is about to be\n"
		"assigned, it is likely that performing such wholesale replacement is\n"
		"unfriendly towards other software applications whose annotations are\n"
		"discarded.  An alternative may be to use appendAnnotation().\n"
		"\n"
		"@param annotation an XML string that is to be used as the content\n"
		"of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see appendAnnotation()\n"
		"@see appendAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_appendAnnotation", _wrap_SpeciesReference_appendAnnotation, METH_VARARGS, (char *)"\n"
		"appendAnnotation(XMLNode annotation) -> int\n"
		"SpeciesReference_appendAnnotation(SpeciesReference self, string annotation) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>appendAnnotation(XMLNode annotation)</pre>\n"
		"\n"
		"Appends annotation content to any existing content in the 'annotation'\n"
		"subelement of this object.\n"
		"\n"
		"The content in @p annotation is copied.  Unlike\n"
		"SpeciesReference.setAnnotation(),\n"
		"this method allows other annotations to be preserved when an application\n"
		"adds its own data.\n"
		"\n"
		"@param annotation an XML structure that is to be copied and appended\n"
		"to the content of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see setAnnotation()\n"
		"@see setAnnotation()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>appendAnnotation(string annotation)</pre>\n"
		"\n"
		"Appends annotation content to any existing content in the 'annotation'\n"
		"subelement of this object.\n"
		"\n"
		"The content in @p annotation is copied.  Unlike\n"
		"SpeciesReference.setAnnotation(), this\n"
		"method allows other annotations to be preserved when an application\n"
		"adds its own data.\n"
		"\n"
		"@param annotation an XML string that is to be copied and appended\n"
		"to the content of the 'annotation' subelement of this object\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see setAnnotation()\n"
		"@see setAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_getTypeCode", _wrap_SpeciesReference_getTypeCode, METH_VARARGS, (char *)"\n"
		"SpeciesReference_getTypeCode(SpeciesReference self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_getElementName", _wrap_SpeciesReference_getElementName, METH_VARARGS, (char *)"\n"
		"SpeciesReference_getElementName(SpeciesReference self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for\n"
		"SpeciesReference, is always @c 'speciesReference'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'speciesReference'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_initL2Stoichiometry", _wrap_SpeciesReference_initL2Stoichiometry, METH_VARARGS, (char *)"\n"
		"SpeciesReference_initL2Stoichiometry(SpeciesReference self)\n"
		"\n"
		"@internal\n"
		"ubclasses should override this method to write out their contained\n"
		"BML objects as XML elements.  Be sure to call your parents\n"
		"mplementation of this method as well.\n"
		" \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_hasRequiredAttributes", _wrap_SpeciesReference_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"SpeciesReference_hasRequiredAttributes(SpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this SpeciesReference object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a SpeciesReference object are:\n"
		"@li 'species'\n"
		"@li 'constant' (only available SBML Level&nbsp;3)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SpeciesReference_swigregister", SpeciesReference_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_ModifierSpeciesReference", _wrap_new_ModifierSpeciesReference, METH_VARARGS, (char *)"\n"
		"ModifierSpeciesReference(unsigned int level, unsigned int version)\n"
		"new_ModifierSpeciesReference(SBMLNamespaces sbmlns) -> ModifierSpeciesReference\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>ModifierSpeciesReference(long level, long version)</pre>\n"
		"\n"
		"Creates a new ModifierSpeciesReference using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this ModifierSpeciesReference\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"ModifierSpeciesReference\n"
		"\n"
		"@note Upon the addition of a ModifierSpeciesReference object to an\n"
		"SBMLDocument (e.g., using Reaction.addModifier()), the\n"
		"SBML Level, SBML Version and XML namespace of the document @em\n"
		"override the values used when creating the ModifierSpeciesReference\n"
		"object via this constructor.  This is necessary to ensure that an SBML\n"
		"document is a consistent structure.  Nevertheless, the ability to\n"
		"supply the values at the time of creation of a\n"
		"ModifierSpeciesReference is an important aid to producing valid SBML.\n"
		"Knowledge of the intented SBML Level and Version determine whether it\n"
		"is valid to assign a particular value to an attribute, or whether it\n"
		"is valid to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>ModifierSpeciesReference(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new ModifierSpeciesReference using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a ModifierSpeciesReference object to an\n"
		"SBMLDocument (e.g., using Reaction.addModifier()), the\n"
		"SBML XML namespace of the document @em overrides the value used when\n"
		"creating the ModifierSpeciesReference object via this constructor.\n"
		"This is necessary to ensure that an SBML document is a consistent\n"
		"structure.  Nevertheless, the ability to supply the values at the time\n"
		"of creation of a ModifierSpeciesReference is an important aid to\n"
		"producing valid SBML.  Knowledge of the intented SBML Level and\n"
		"Version determine whether it is valid to assign a particular value to\n"
		"an attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_ModifierSpeciesReference", _wrap_delete_ModifierSpeciesReference, METH_VARARGS, (char *)"delete_ModifierSpeciesReference(ModifierSpeciesReference self)"},
	 { (char *)"ModifierSpeciesReference_clone", _wrap_ModifierSpeciesReference_clone, METH_VARARGS, (char *)"\n"
		"ModifierSpeciesReference_clone(ModifierSpeciesReference self) -> ModifierSpeciesReference\n"
		"\n"
		"Creates and returns a deep copy of this ModifierSpeciesReference\n"
		"instance.\n"
		"\n"
		"@return a (deep) copy of this ModifierSpeciesReference.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModifierSpeciesReference_getTypeCode", _wrap_ModifierSpeciesReference_getTypeCode, METH_VARARGS, (char *)"\n"
		"ModifierSpeciesReference_getTypeCode(ModifierSpeciesReference self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModifierSpeciesReference_getElementName", _wrap_ModifierSpeciesReference_getElementName, METH_VARARGS, (char *)"\n"
		"ModifierSpeciesReference_getElementName(ModifierSpeciesReference self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Species, is\n"
		"always @c 'modifierSpeciesReference'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'modifierSpeciesReference'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModifierSpeciesReference_hasRequiredAttributes", _wrap_ModifierSpeciesReference_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"ModifierSpeciesReference_hasRequiredAttributes(ModifierSpeciesReference self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this ModifierSpeciesReference object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a ModifierSpeciesReference object are:\n"
		"species\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModifierSpeciesReference_swigregister", ModifierSpeciesReference_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_ListOfSpeciesReferences", _wrap_new_ListOfSpeciesReferences, METH_VARARGS, (char *)"\n"
		"new_ListOfSpeciesReferences() -> ListOfSpeciesReferences\n"
		"\n"
		"Creates a new, empty ListOfSpeciesReferences.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesReferences_clone", _wrap_ListOfSpeciesReferences_clone, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesReferences_clone(ListOfSpeciesReferences self) -> ListOfSpeciesReferences\n"
		"\n"
		"Creates and returns a deep copy of this ListOfSpeciesReferences\n"
		"instance.\n"
		"\n"
		"@return a (deep) copy of this ListOfSpeciesReferences.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesReferences_getTypeCode", _wrap_ListOfSpeciesReferences_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesReferences_getTypeCode(ListOfSpeciesReferences self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesReferences_getItemTypeCode", _wrap_ListOfSpeciesReferences_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesReferences_getItemTypeCode(ListOfSpeciesReferences self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., SpeciesReference objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesReferences_getElementName", _wrap_ListOfSpeciesReferences_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfSpeciesReferences_getElementName(ListOfSpeciesReferences self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfSpeciesReferences, the XML element name is @c\n"
		"'listOfSpeciesReferences'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfSpeciesReferences'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesReferences_get", _wrap_ListOfSpeciesReferences_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> SimpleSpeciesReference\n"
		"get(unsigned int n) -> SimpleSpeciesReference\n"
		"get(string sid) -> SimpleSpeciesReference\n"
		"ListOfSpeciesReferences_get(ListOfSpeciesReferences self, string sid) -> SimpleSpeciesReference\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a SpeciesReference from the ListOfSpeciesReferences.\n"
		"\n"
		"@param n the index number of the SpeciesReference to get.\n"
		"\n"
		"@return the nth SpeciesReference in this ListOfSpeciesReferences.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a SpeciesReference from the ListOfSpeciesReferences.\n"
		"\n"
		"@param n the index number of the SpeciesReference to get.\n"
		"\n"
		"@return the nth SpeciesReference in this ListOfSpeciesReferences.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a SpeciesReference from the ListOfSpeciesReferences\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the SpeciesReference to get.\n"
		"\n"
		"@return SpeciesReference in this ListOfSpeciesReferences\n"
		"with the given id or @c None if no such\n"
		"SpeciesReference exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a SpeciesReference from the ListOfSpeciesReferences\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the SpeciesReference to get.\n"
		"\n"
		"@return SpeciesReference in this ListOfSpeciesReferences\n"
		"with the given id or @c None if no such\n"
		"SpeciesReference exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfSpeciesReferences_remove", _wrap_ListOfSpeciesReferences_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> SimpleSpeciesReference\n"
		"ListOfSpeciesReferences_remove(ListOfSpeciesReferences self, string sid) -> SimpleSpeciesReference\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfSpeciesReferences items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes item in this ListOfSpeciesReferences items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"None is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_ListOfSpeciesReferences", _wrap_delete_ListOfSpeciesReferences, METH_VARARGS, (char *)"delete_ListOfSpeciesReferences(ListOfSpeciesReferences self)"},
	 { (char *)"ListOfSpeciesReferences_swigregister", ListOfSpeciesReferences_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Event", _wrap_delete_Event, METH_VARARGS, (char *)"delete_Event(Event self)"},
	 { (char *)"new_Event", _wrap_new_Event, METH_VARARGS, (char *)"\n"
		"Event(unsigned int level, unsigned int version)\n"
		"Event(SBMLNamespaces sbmlns)\n"
		"new_Event(Event orig) -> Event\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Event(long level, long version)</pre>\n"
		"\n"
		"Creates a new Event using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this Event\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"Event\n"
		"\n"
		"@note Upon the addition of an Event object to an SBMLDocument (e.g.,\n"
		"using Model.addEvent()), the SBML Level, SBML Version and XML\n"
		"namespace of the document @em override the values used when creating\n"
		"the Event object via this constructor.  This is necessary to ensure\n"
		"that an SBML document is a consistent structure.  Nevertheless, the\n"
		"ability to supply the values at the time of creation of an Event is an\n"
		"important aid to producing valid SBML.  Knowledge of the intented SBML\n"
		"Level and Version determine whether it is valid to assign a particular\n"
		"value to an attribute, or whether it is valid to add an object to an\n"
		"existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Event(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new Event using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of an Event object to an SBMLDocument (e.g.,\n"
		"using Model.addEvent()), the SBML XML namespace of the document @em\n"
		"overrides the value used when creating the Event object via this\n"
		"constructor.  This is necessary to ensure that an SBML document is a\n"
		"consistent structure.  Nevertheless, the ability to supply the values\n"
		"at the time of creation of a Event is an important aid to producing\n"
		"valid SBML.  Knowledge of the intented SBML Level and Version\n"
		"determine whether it is valid to assign a particular value to an\n"
		"attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Event(Event orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this Event.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_clone", _wrap_Event_clone, METH_VARARGS, (char *)"\n"
		"Event_clone(Event self) -> Event\n"
		"\n"
		"Creates and returns a deep copy of this Event.\n"
		"\n"
		"@return a (deep) copy of this Event.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getId", _wrap_Event_getId, METH_VARARGS, (char *)"\n"
		"Event_getId(Event self) -> string\n"
		"\n"
		"Returns the value of the 'id' attribute of this Event.\n"
		"\n"
		"@return the id of this Event.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getName", _wrap_Event_getName, METH_VARARGS, (char *)"\n"
		"Event_getName(Event self) -> string\n"
		"\n"
		"Returns the value of the 'name' attribute of this Event.\n"
		"\n"
		"@return the name of this Event.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getTrigger", _wrap_Event_getTrigger, METH_VARARGS, (char *)"\n"
		"getTrigger() -> Trigger\n"
		"Event_getTrigger(Event self) -> Trigger\n"
		"\n"
		"Get the event trigger portion of this Event.\n"
		"\n"
		"@return the Trigger object of this Event.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getDelay", _wrap_Event_getDelay, METH_VARARGS, (char *)"\n"
		"getDelay() -> Delay\n"
		"Event_getDelay(Event self) -> Delay\n"
		"\n"
		"Get the assignment delay portion of this Event, if there is one.\n"
		"\n"
		"@return the delay of this Event if one is defined, or @c None if none\n"
		"is defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getPriority", _wrap_Event_getPriority, METH_VARARGS, (char *)"\n"
		"getPriority() -> Priority\n"
		"Event_getPriority(Event self) -> Priority\n"
		"\n"
		"(SBML Level&nbsp;3 only) Get the event priority portion of this\n"
		"Event.\n"
		"\n"
		"@return the Priority object of this Event.\n"
		"\n"
		"@note The element 'priority' is available in SBML Level&nbsp;3\n"
		"Version&nbsp;1 Core, but is not present in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getTimeUnits", _wrap_Event_getTimeUnits, METH_VARARGS, (char *)"\n"
		"Event_getTimeUnits(Event self) -> string\n"
		"\n"
		"Get the value of the 'timeUnits' attribute of this Event, if it has one.\n"
		"\n"
		"@return the value of the attribute 'timeUnits' as a string.\n"
		"\n"
		"@warning Definitions of Event in SBML Level 2 Versions&nbsp;1\n"
		"and&nbsp;2 included the additional attribute called 'timeUnits', but\n"
		"it was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML supports\n"
		"this attribute for compatibility with previous versions of SBML\n"
		"Level&nbsp;2, but its use is discouraged since models in Level 2\n"
		"Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a Version&nbsp;3\n"
		"or&nbsp;4 model sets the attribute, the consistency-checking method\n"
		"SBMLDocument.checkConsistency() will report an error.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getUseValuesFromTriggerTime", _wrap_Event_getUseValuesFromTriggerTime, METH_VARARGS, (char *)"\n"
		"Event_getUseValuesFromTriggerTime(Event self) -> bool\n"
		"\n"
		"Get the value of the 'useValuesFromTriggerTime' attribute of this Event.\n"
		"\n"
		"The optional Delay on Event means there are two times to consider when\n"
		"computing the results of an event: the time at which the event is\n"
		"<em>triggered</em>, and the time at which assignments are\n"
		"<em>executed</em>.  It is also possible to distinguish between the\n"
		"time at which the EventAssignment's expression is calculated, and the\n"
		"time at which the assignment is made: the expression could be\n"
		"evaluated at the same time the assignments are performed, i.e., when\n"
		"the event is <em>executed</em>, but it could also be defined to be\n"
		"evaluated at the time the event is <em>triggered</em>.\n"
		"\n"
		"In SBML Level&nbsp;2 versions prior to Version&nbsp;4, the semantics\n"
		"of Event time delays were defined such that the expressions in the\n"
		"event's assignments were always evaluated at the time the event was\n"
		"<em>triggered</em>.  This definition made it difficult to define an\n"
		"event whose assignment formulas were meant to be evaluated at the time\n"
		"the event was <em>executed</em> (i.e., after the time period defined\n"
		"by the value of the Delay element).  In SBML Level&nbsp;2\n"
		"Version&nbsp;4, the attribute 'useValuesFromTriggerTime' on Event\n"
		"allows a model to indicate the time at which the event's assignments\n"
		"are intended to be evaluated.  In SBML Level&nbsp;2, the attribute has\n"
		"a default value of @c true, which corresponds to the interpretation of\n"
		"event assignments prior to Version&nbsp;4: the values of the\n"
		"assignment formulas are computed at the moment the event is triggered,\n"
		"not after the delay.  If 'useValuesFromTriggerTime'=@c false, it means\n"
		"that the formulas in the event's assignments are to be computed after\n"
		"the delay, at the time the event is executed.  In SBML Level&nbsp;3,\n"
		"the attribute is mandatory, not optional, and all events must specify\n"
		"a value for it.\n"
		"\n"
		"@return the value of the attribute 'useValuesFromTriggerTime' as a boolean.\n"
		"\n"
		"@warning The attribute 'useValuesFromTriggerTime' was introduced in\n"
		"SBML Level&nbsp;2 Version&nbsp;4.  It is not valid in models defined\n"
		"using SBML Level&nbsp;2 versions prior to Version&nbsp;4.  If a\n"
		"Level&nbsp;2 Version&nbsp;1&ndash;3 model sets the attribute, the\n"
		"consistency-checking method SBMLDocument.checkConsistency() will\n"
		"report an error.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_isSetId", _wrap_Event_isSetId, METH_VARARGS, (char *)"\n"
		"Event_isSetId(Event self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Event's 'id' attribute is set.\n"
		"\n"
		"@return @c true if the 'id' attribute of this Event is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_isSetName", _wrap_Event_isSetName, METH_VARARGS, (char *)"\n"
		"Event_isSetName(Event self) -> bool\n"
		"\n"
		"Predicate returning @c true if this\n"
		"Event's 'name' attribute is set.\n"
		"\n"
		"@return @c true if the 'name' attribute of this Event is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_isSetTrigger", _wrap_Event_isSetTrigger, METH_VARARGS, (char *)"\n"
		"Event_isSetTrigger(Event self) -> bool\n"
		"\n"
		"Predicate for testing whether the trigger for this Event is set.\n"
		"\n"
		"@return @c true if the trigger of this Event is set, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_isSetDelay", _wrap_Event_isSetDelay, METH_VARARGS, (char *)"\n"
		"Event_isSetDelay(Event self) -> bool\n"
		"\n"
		"Predicate for testing whether the delay for this Event is set.\n"
		"\n"
		"@return @c true if the delay of this Event is set, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_isSetPriority", _wrap_Event_isSetPriority, METH_VARARGS, (char *)"\n"
		"Event_isSetPriority(Event self) -> bool\n"
		"\n"
		"(SBML Level&nbsp;3 only) Predicate for testing whether the priority\n"
		"for this Event is set.\n"
		"\n"
		"@return @c true if the priority of this Event is set, @c false\n"
		"otherwise.\n"
		"\n"
		"@note The element 'priority' is available in SBML Level&nbsp;3\n"
		"Version&nbsp;1 Core, but is not present in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_isSetTimeUnits", _wrap_Event_isSetTimeUnits, METH_VARARGS, (char *)"\n"
		"Event_isSetTimeUnits(Event self) -> bool\n"
		"\n"
		"Predicate for testing whether the 'timeUnits' attribute of this Event\n"
		"is set.\n"
		"\n"
		"@return @c true if the 'timeUnits' attribute of this Event is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@warning Definitions of Event in SBML Level 2 Versions&nbsp;1\n"
		"and&nbsp;2 included the additional attribute called 'timeUnits', but\n"
		"it was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML supports\n"
		"this attribute for compatibility with previous versions of SBML\n"
		"Level&nbsp;2, but its use is discouraged since models in Level 2\n"
		"Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a Version&nbsp;3\n"
		"or&nbsp;4 model sets the attribute, the consistency-checking method\n"
		"SBMLDocument.checkConsistency() will report an error.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_isSetUseValuesFromTriggerTime", _wrap_Event_isSetUseValuesFromTriggerTime, METH_VARARGS, (char *)"\n"
		"Event_isSetUseValuesFromTriggerTime(Event self) -> bool\n"
		"\n"
		"Predicate for testing whether the 'useValuesFromTriggerTime' attribute of this Event\n"
		"is set.\n"
		"\n"
		"@return @c true if the 'useValuesFromTriggerTime' attribute of this Event is\n"
		"set, @c false otherwise.\n"
		"\n"
		"@note In SBML Level&nbsp;2, this attribute is optional and has a default value of\n"
		"@c true, whereas in Level&nbsp;3 Version&nbsp;1, this optional is mandatory and\n"
		"has no default value.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_setId", _wrap_Event_setId, METH_VARARGS, (char *)"\n"
		"Event_setId(Event self, string sid) -> int\n"
		"\n"
		"Sets the value of the 'id' attribute of this Event.\n"
		"\n"
		"The string @p sid is copied.  Note that SBML has strict requirements\n"
		"for the syntax of identifiers.  @htmlinclude id-syntax.html\n"
		"\n"
		"@param sid the string to use as the identifier of this Event\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_setName", _wrap_Event_setName, METH_VARARGS, (char *)"\n"
		"Event_setName(Event self, string name) -> int\n"
		"\n"
		"Sets the value of the 'name' attribute of this Event.\n"
		"\n"
		"The string in @p name is copied.\n"
		"\n"
		"@param name the new name for the Event\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_setTrigger", _wrap_Event_setTrigger, METH_VARARGS, (char *)"\n"
		"Event_setTrigger(Event self, Trigger trigger) -> int\n"
		"\n"
		"Sets the trigger definition of this Event to a copy of the given\n"
		"Trigger object instance.\n"
		"\n"
		"@param trigger the Trigger object instance to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_setDelay", _wrap_Event_setDelay, METH_VARARGS, (char *)"\n"
		"Event_setDelay(Event self, Delay delay) -> int\n"
		"\n"
		"Sets the delay definition of this Event to a copy of the given Delay\n"
		"object instance.\n"
		"\n"
		"@param delay the Delay object instance to use\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_setPriority", _wrap_Event_setPriority, METH_VARARGS, (char *)"\n"
		"Event_setPriority(Event self, Priority priority) -> int\n"
		"\n"
		"(SBML Level&nbsp;3 only) Sets the priority definition of this Event\n"
		"to a copy of the given Priority object instance.\n"
		"\n"
		"@param priority the Priority object instance to use\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The element 'priority' is available in SBML Level&nbsp;3\n"
		"Version&nbsp;1 Core, but is not present in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_setTimeUnits", _wrap_Event_setTimeUnits, METH_VARARGS, (char *)"\n"
		"Event_setTimeUnits(Event self, string sid) -> int\n"
		"\n"
		"Sets the 'timeUnits' attribute of this Event to a copy of @p sid.\n"
		"\n"
		"@param sid the identifier of the time units to use.\n"
		"\n"
		"@warning Definitions of Event in SBML Level 2 Versions&nbsp;1\n"
		"and&nbsp;2 included the additional attribute called 'timeUnits', but\n"
		"it was removed in SBML Level&nbsp;2 Version&nbsp;3.  LibSBML supports\n"
		"this attribute for compatibility with previous versions of SBML\n"
		"Level&nbsp;2, but its use is discouraged since models in Level 2\n"
		"Versions&nbsp;3 and&nbsp;4 cannot contain it.  If a Version&nbsp;3\n"
		"or&nbsp;4 model sets the attribute, the consistency-checking method\n"
		"SBMLDocument.checkConsistency() will report an error.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_setUseValuesFromTriggerTime", _wrap_Event_setUseValuesFromTriggerTime, METH_VARARGS, (char *)"\n"
		"Event_setUseValuesFromTriggerTime(Event self, bool value) -> int\n"
		"\n"
		"Sets the 'useValuesFromTriggerTime' attribute of this Event to a @p value.\n"
		"\n"
		"The optional Delay on Event means there are two times to consider when\n"
		"computing the results of an event: the time at which the event is\n"
		"<em>triggered</em>, and the time at which assignments are\n"
		"<em>executed</em>.  It is also possible to distinguish between the\n"
		"time at which the EventAssignment's expression is calculated, and the\n"
		"time at which the assignment is made: the expression could be\n"
		"evaluated at the same time the assignments are performed, i.e., when\n"
		"the event is <em>executed</em>, but it could also be defined to be\n"
		"evaluated at the time the event is <em>triggered</em>.\n"
		"\n"
		"In SBML Level&nbsp;2 versions prior to Version&nbsp;4, the semantics\n"
		"of Event time delays were defined such that the expressions in the\n"
		"event's assignments were always evaluated at the time the event was\n"
		"<em>triggered</em>.  This definition made it difficult to define an\n"
		"event whose assignment formulas were meant to be evaluated at the time\n"
		"the event was <em>executed</em> (i.e., after the time period defined\n"
		"by the value of the Delay element).  In SBML Level&nbsp;2\n"
		"Version&nbsp;4, the attribute 'useValuesFromTriggerTime' on Event\n"
		"allows a model to indicate the time at which the event's assignments\n"
		"are intended to be evaluated.  In SBML Level&nbsp;2, the attribute has\n"
		"a default value of @c true, which corresponds to the interpretation of\n"
		"event assignments prior to Version&nbsp;4: the values of the\n"
		"assignment formulas are computed at the moment the event is triggered,\n"
		"not after the delay.  If 'useValuesFromTriggerTime'=@c false, it means\n"
		"that the formulas in the event's assignments are to be computed after\n"
		"the delay, at the time the event is executed.  In SBML Level&nbsp;3,\n"
		"the attribute is mandatory, not optional, and all events must specify\n"
		"a value for it.\n"
		"\n"
		"@param value the value of useValuesFromTriggerTime to use.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@warning The attribute 'useValuesFromTriggerTime' was introduced in\n"
		"SBML Level&nbsp;2 Version&nbsp;4.  It is not valid in models defined\n"
		"using SBML Level&nbsp;2 versions prior to Version&nbsp;4.  If a\n"
		"Version&nbsp;1&ndash;&nbsp;3 model sets the attribute, the\n"
		"consistency-checking method SBMLDocument.checkConsistency() will\n"
		"report an error.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_unsetId", _wrap_Event_unsetId, METH_VARARGS, (char *)"\n"
		"Event_unsetId(Event self) -> int\n"
		"\n"
		"Unsets the value of the 'id' attribute of this Event.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_unsetName", _wrap_Event_unsetName, METH_VARARGS, (char *)"\n"
		"Event_unsetName(Event self) -> int\n"
		"\n"
		"Unsets the value of the 'name' attribute of this Event.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_unsetDelay", _wrap_Event_unsetDelay, METH_VARARGS, (char *)"\n"
		"Event_unsetDelay(Event self) -> int\n"
		"\n"
		"Unsets the Delay of this Event.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_unsetPriority", _wrap_Event_unsetPriority, METH_VARARGS, (char *)"\n"
		"Event_unsetPriority(Event self) -> int\n"
		"\n"
		"(SBML Level&nbsp;3 only) Unsets the Priority of this Event.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note The element 'priority' is available in SBML Level&nbsp;3\n"
		"Version&nbsp;1 Core, but is not present in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_unsetTimeUnits", _wrap_Event_unsetTimeUnits, METH_VARARGS, (char *)"\n"
		"Event_unsetTimeUnits(Event self) -> int\n"
		"\n"
		"Unsets the 'timeUnits' attribute of this Event.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@warning Definitions of Event in SBML Level&nbsp;2 Versions 1 and 2\n"
		"included the attribute called 'timeUnits', but it was removed in SBML\n"
		"Level&nbsp;2 Version&nbsp;3.  LibSBML supports this attribute for\n"
		"compatibility with previous versions of SBML Level&nbsp;2, but its use\n"
		"is discouraged since models in Level&nbsp;2 Version&nbsp;3 and\n"
		"Version&nbsp;4 cannot contain it.  If a Version&nbsp;3 or&nbsp;4 model\n"
		"sets this attribute, the consistency-checking method\n"
		"SBMLDocument.checkConsistency() will report an error.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_addEventAssignment", _wrap_Event_addEventAssignment, METH_VARARGS, (char *)"\n"
		"Event_addEventAssignment(Event self, EventAssignment ea) -> int\n"
		"\n"
		"Appends a copy of the given EventAssignment to this Event.\n"
		"\n"
		"@param ea the EventAssignment object to add.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_LEVEL_MISMATCH LIBSBML_LEVEL_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_VERSION_MISMATCH LIBSBML_VERSION_MISMATCH @endlink\n"
		"@li @link libsbml.LIBSBML_DUPLICATE_OBJECT_ID LIBSBML_DUPLICATE_OBJECT_ID @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note This method should be used with some caution.  The fact that\n"
		"this method @em copies the object passed to it means that the caller\n"
		"will be left holding a physically different object instance than the\n"
		"one contained in this Event.  Changes made to the original object\n"
		"instance (such as resetting attribute values) will <em>not affect the\n"
		"instance in the Event</em>.  In addition, the caller should make sure\n"
		"to free the original object if it is no longer being used, or else a\n"
		"memory leak will result.  Please see Event.createEventAssignment()\n"
		"for a method that does not lead to these issues.\n"
		"\n"
		"@see createEventAssignment()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_createEventAssignment", _wrap_Event_createEventAssignment, METH_VARARGS, (char *)"\n"
		"Event_createEventAssignment(Event self) -> EventAssignment\n"
		"\n"
		"Creates a new, empty EventAssignment, adds it to this Event's list of\n"
		"event assignments and returns the EventAssignment.\n"
		"\n"
		"@return the newly created EventAssignment object instance\n"
		"\n"
		"@see addEventAssignment()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_createTrigger", _wrap_Event_createTrigger, METH_VARARGS, (char *)"\n"
		"Event_createTrigger(Event self) -> Trigger\n"
		"\n"
		"Creates a new, empty Trigger, adds it to this Event and \n"
		"returns the Trigger.\n"
		"\n"
		"@return the newly created Trigger object instance\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_createDelay", _wrap_Event_createDelay, METH_VARARGS, (char *)"\n"
		"Event_createDelay(Event self) -> Delay\n"
		"\n"
		"Creates a new, empty Delay, adds it to this Event and \n"
		"returns the Delay.\n"
		"\n"
		"@return the newly created Delay object instance\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_createPriority", _wrap_Event_createPriority, METH_VARARGS, (char *)"\n"
		"Event_createPriority(Event self) -> Priority\n"
		"\n"
		"(SBML Level&nbsp;3 only) Creates a new, empty Priority, adds it to this\n"
		"Event and returns the Priority.\n"
		"\n"
		"@return the newly created Priority object instance\n"
		"\n"
		"@note The element 'priority' is available in SBML Level&nbsp;3\n"
		"Version&nbsp;1 Core, but is not present in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getListOfEventAssignments", _wrap_Event_getListOfEventAssignments, METH_VARARGS, (char *)"\n"
		"getListOfEventAssignments() -> ListOfEventAssignments\n"
		"Event_getListOfEventAssignments(Event self) -> ListOfEventAssignments\n"
		"\n"
		"Returns the list of event assignments for this Event.\n"
		"\n"
		"@return the list of EventAssignments for this Event.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getEventAssignment", _wrap_Event_getEventAssignment, METH_VARARGS, (char *)"\n"
		"getEventAssignment(unsigned int n) -> EventAssignment\n"
		"getEventAssignment(unsigned int n) -> EventAssignment\n"
		"getEventAssignment(string variable) -> EventAssignment\n"
		"Event_getEventAssignment(Event self, string variable) -> EventAssignment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getEventAssignment(long n)</pre>\n"
		"\n"
		"Return a specific EventAssignment object of this Event.\n"
		"\n"
		"@param n an integer, the index of the EventAssignment object to return\n"
		"\n"
		"@return the <code>n</code>th EventAssignment of this Event.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getEventAssignment(long n)</pre>\n"
		"\n"
		"Return a specific EventAssignment object of this Event.\n"
		"\n"
		"@param n an integer, the index of the EventAssignment object to return\n"
		"\n"
		"@return the <code>n</code>th EventAssignment of this Event.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getEventAssignment(string variable)</pre>\n"
		"\n"
		"Return the event assignment indicated by the given @p variable.\n"
		"\n"
		"@param variable a string, the identifier of the variable whose\n"
		"EventAssignment is being sought.\n"
		"\n"
		"@return the EventAssignment for the given @p variable, or @c None if\n"
		"no such EventAssignment exits.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getEventAssignment(string variable)</pre>\n"
		"\n"
		"Return the event assignment indicated by the given @p variable.\n"
		"\n"
		"@param variable a string, the identifier of the variable whose\n"
		"EventAssignment is being sought.\n"
		"\n"
		"@return the EventAssignment for the given @p variable, or @c None if\n"
		"no such EventAssignment exits.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getNumEventAssignments", _wrap_Event_getNumEventAssignments, METH_VARARGS, (char *)"\n"
		"Event_getNumEventAssignments(Event self) -> unsigned int\n"
		"\n"
		"Returns the number of EventAssignment objects attached to this\n"
		"Event.\n"
		"\n"
		"@return the number of EventAssignments in this Event.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_removeEventAssignment", _wrap_Event_removeEventAssignment, METH_VARARGS, (char *)"\n"
		"removeEventAssignment(unsigned int n) -> EventAssignment\n"
		"Event_removeEventAssignment(Event self, string variable) -> EventAssignment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeEventAssignment(long n)</pre>\n"
		"\n"
		"Removes the nth EventAssignment object from this Event object and\n"
		"returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the EventAssignment object to remove\n"
		"\n"
		"@return the EventAssignment object removed.  As mentioned above, \n"
		"the caller owns the returned item. @c None is returned if the given index \n"
		"is out of range.\n"
		"\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeEventAssignment(string variable)</pre>\n"
		"\n"
		"Removes the EventAssignment object with the given 'variable' attribute \n"
		"from this Event object and returns a pointer to it.\n"
		"\n"
		"The caller owns the returned object and is responsible for deleting it.\n"
		"If none of the EventAssignment objects in this Event object have the \n"
		"'variable' attribute @p variable, then @c None is returned.\n"
		"\n"
		"@param variable the 'variable' attribute of the EventAssignment object \n"
		"to remove\n"
		"\n"
		"@return the EventAssignment object removed.  As mentioned above, the \n"
		"caller owns the returned object. @c None is returned if no EventAssignment\n"
		"object with the 'variable' attribute exists in this Event object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getTypeCode", _wrap_Event_getTypeCode, METH_VARARGS, (char *)"\n"
		"Event_getTypeCode(Event self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code of this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_getElementName", _wrap_Event_getElementName, METH_VARARGS, (char *)"\n"
		"Event_getElementName(Event self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Event, is\n"
		"always @c 'event'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'event'. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_hasRequiredAttributes", _wrap_Event_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Event_hasRequiredAttributes(Event self) -> bool\n"
		"\n"
		"Predicate returning @c true if all the required attributes for this\n"
		"Event object have been set.\n"
		"\n"
		"@note The required attributes for a Event object are:\n"
		"@li 'useValuesfromTriggerTime' (required in SBML Level&nbsp;3)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_hasRequiredElements", _wrap_Event_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"Event_hasRequiredElements(Event self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Event object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Event object are:\n"
		"@li 'trigger'\n"
		"@li 'listOfEventAssignments' (required in SBML Level&nbsp;2, optional in Level&nbsp;3)\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Event_swigregister", Event_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfEvents_clone", _wrap_ListOfEvents_clone, METH_VARARGS, (char *)"\n"
		"ListOfEvents_clone(ListOfEvents self) -> ListOfEvents\n"
		"\n"
		"Creates and returns a deep copy of this ListOfEvents.\n"
		"\n"
		"@return a (deep) copy of this ListOfEvents.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEvents_getTypeCode", _wrap_ListOfEvents_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfEvents_getTypeCode(ListOfEvents self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEvents_getItemTypeCode", _wrap_ListOfEvents_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfEvents_getItemTypeCode(ListOfEvents self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., Event objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEvents_getElementName", _wrap_ListOfEvents_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfEvents_getElementName(ListOfEvents self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfEvents, the XML element name is @c 'listOfEvents'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfEvents'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEvents_get", _wrap_ListOfEvents_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> Event\n"
		"get(unsigned int n) -> Event\n"
		"get(string sid) -> Event\n"
		"ListOfEvents_get(ListOfEvents self, string sid) -> Event\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a Event from the ListOfEvents.\n"
		"\n"
		"@param n the index number of the Event to get.\n"
		"\n"
		"@return the <code>n</code>th Event in this ListOfEvents.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a Event from the ListOfEvents.\n"
		"\n"
		"@param n the index number of the Event to get.\n"
		"\n"
		"@return the <code>n</code>th Event in this ListOfEvents.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a Event from the ListOfEvents\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Event to get.\n"
		"\n"
		"@return Event in this ListOfEvents\n"
		"with the given id or @c None if no such\n"
		"Event exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a Event from the ListOfEvents\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the Event to get.\n"
		"\n"
		"@return Event in this ListOfEvents\n"
		"with the given id or @c None if no such\n"
		"Event exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEvents_remove", _wrap_ListOfEvents_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> Event\n"
		"ListOfEvents_remove(ListOfEvents self, string sid) -> Event\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfEvents items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes item in this ListOfEvents items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"None is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfEvents", _wrap_new_ListOfEvents, METH_VARARGS, (char *)"new_ListOfEvents() -> ListOfEvents"},
	 { (char *)"delete_ListOfEvents", _wrap_delete_ListOfEvents, METH_VARARGS, (char *)"delete_ListOfEvents(ListOfEvents self)"},
	 { (char *)"ListOfEvents_swigregister", ListOfEvents_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_EventAssignment", _wrap_delete_EventAssignment, METH_VARARGS, (char *)"delete_EventAssignment(EventAssignment self)"},
	 { (char *)"new_EventAssignment", _wrap_new_EventAssignment, METH_VARARGS, (char *)"\n"
		"EventAssignment(unsigned int level, unsigned int version)\n"
		"EventAssignment(SBMLNamespaces sbmlns)\n"
		"new_EventAssignment(EventAssignment orig) -> EventAssignment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>EventAssignment(long level, long version)</pre>\n"
		"\n"
		"Creates a new EventAssignment using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this EventAssignment\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"EventAssignment\n"
		"\n"
		"@note Upon the addition of a EventAssignment object to an SBMLDocument\n"
		"(e.g., using Event.addEventAssignment()), \n"
		"the SBML Level, SBML Version and XML namespace of the document @em\n"
		"override the values used when creating the EventAssignment object via\n"
		"this constructor.  This is necessary to ensure that an SBML document\n"
		"is a consistent structure.  Nevertheless, the ability to supply the\n"
		"values at the time of creation of a EventAssignment is an important\n"
		"aid to producing valid SBML.  Knowledge of the intented SBML Level and\n"
		"Version determine whether it is valid to assign a particular value to\n"
		"an attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>EventAssignment(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new EventAssignment using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a EventAssignment object to an SBMLDocument\n"
		"(e.g., using Event.addEventAssignment()),\n"
		"the SBML XML namespace of the document @em overrides the value used\n"
		"when creating the EventAssignment object via this constructor.  This\n"
		"is necessary to ensure that an SBML document is a consistent\n"
		"structure.  Nevertheless, the ability to supply the values at the time\n"
		"of creation of a EventAssignment is an important aid to producing\n"
		"valid SBML.  Knowledge of the intented SBML Level and Version\n"
		"determine whether it is valid to assign a particular value to an\n"
		"attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>EventAssignment(EventAssignment orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this EventAssignment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_clone", _wrap_EventAssignment_clone, METH_VARARGS, (char *)"\n"
		"EventAssignment_clone(EventAssignment self) -> EventAssignment\n"
		"\n"
		"Creates and returns a deep copy of this EventAssignment.\n"
		"\n"
		"@return a (deep) copy of this EventAssignment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_getVariable", _wrap_EventAssignment_getVariable, METH_VARARGS, (char *)"\n"
		"EventAssignment_getVariable(EventAssignment self) -> string\n"
		"\n"
		"Get the value of this EventAssignment's 'variable' attribute.\n"
		"\n"
		"@return the identifier stored in the 'variable' attribute of this\n"
		"EventAssignment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_getMath", _wrap_EventAssignment_getMath, METH_VARARGS, (char *)"\n"
		"EventAssignment_getMath(EventAssignment self) -> ASTNode\n"
		"\n"
		"Get the mathematical expression in this EventAssignment's 'math'\n"
		"subelement.\n"
		"\n"
		"@return the top ASTNode of an abstract syntax tree representing the\n"
		"mathematical formula in this EventAssignment.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_isSetVariable", _wrap_EventAssignment_isSetVariable, METH_VARARGS, (char *)"\n"
		"EventAssignment_isSetVariable(EventAssignment self) -> bool\n"
		"\n"
		"Predicate for testing whether the attribute 'variable' of this\n"
		"EventAssignment is set.\n"
		"\n"
		"@return @c true if the 'variable' attribute of this EventAssignment\n"
		"is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_isSetMath", _wrap_EventAssignment_isSetMath, METH_VARARGS, (char *)"\n"
		"EventAssignment_isSetMath(EventAssignment self) -> bool\n"
		"\n"
		"Predicate for testing whether the 'math' subelement of this\n"
		"EventAssignment is set.\n"
		"\n"
		"@return @c true if this EventAssignment has a 'math' subelement,\n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_setVariable", _wrap_EventAssignment_setVariable, METH_VARARGS, (char *)"\n"
		"EventAssignment_setVariable(EventAssignment self, string sid) -> int\n"
		"\n"
		"Sets the attribute 'variable' of this EventAssignment to a copy of\n"
		"the given identifier string.\n"
		"\n"
		"@param sid the identifier of a Compartment, Species or (global)\n"
		"Parameter defined in this model.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_setMath", _wrap_EventAssignment_setMath, METH_VARARGS, (char *)"\n"
		"EventAssignment_setMath(EventAssignment self, ASTNode math) -> int\n"
		"\n"
		"Sets the 'math' subelement of this EventAssignment to a copy of the\n"
		"given ASTNode.\n"
		"\n"
		"@param math an ASTNode that will be copied and stored as the\n"
		"mathematical formula for this EventAssignment.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_getDerivedUnitDefinition", _wrap_EventAssignment_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"EventAssignment_getDerivedUnitDefinition(EventAssignment self) -> UnitDefinition\n"
		"\n"
		"Calculates and returns a UnitDefinition that expresses the units\n"
		"of measurement assumed for the 'math' expression of this\n"
		"EventAssignment.\n"
		"\n"
		"The units are calculated based on the mathematical expression in the\n"
		"EventAssignment and the model quantities referenced by\n"
		"<code>&lt;ci&gt;</code> elements used within that expression.  The\n"
		"EventAssignment.getDerivedUnitDefinition() method returns the\n"
		"calculated units.\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c None.\n"
		"\n"
		"@warning Note that it is possible the 'math' expression in the\n"
		"EventAssignment contains literal numbers or parameters with undeclared\n"
		"units.  In those cases, it is not possible to calculate the units of\n"
		"the overall expression without making assumptions.  LibSBML does not\n"
		"make assumptions about the units, and\n"
		"EventAssignment.getDerivedUnitDefinition() only returns the units as\n"
		"far as it is able to determine them.  For example, in an expression\n"
		"<em>X + Y</em>, if <em>X</em> has unambiguously-defined units and\n"
		"<em>Y</em> does not, it will return the units of <em>X</em>.  When\n"
		"using this method, <strong>it is critical that callers also invoke the\n"
		"method</strong> EventAssignment.containsUndeclaredUnits() <strong>to\n"
		"determine whether this situation holds</strong>.  Callers should take\n"
		"suitable action in those situations.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of the math \n"
		"expression of this EventAssignment, or @c None if one cannot be constructed.\n"
		"\n"
		"@see containsUndeclaredUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_containsUndeclaredUnits", _wrap_EventAssignment_containsUndeclaredUnits, METH_VARARGS, (char *)"\n"
		"containsUndeclaredUnits() -> bool\n"
		"EventAssignment_containsUndeclaredUnits(EventAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if the math\n"
		"expression of this EventAssignment contains literal numbers or\n"
		"parameters with undeclared units.\n"
		"\n"
		"The EventAssignment.getDerivedUnitDefinition() method returns what\n"
		"libSBML computes to be the units of the 'math', to the extent that\n"
		"libSBML can compute them.  However, if the expression contains literal\n"
		"numbers or parameters with undeclared units, libSBML may not be able\n"
		"to compute the full units of the expression and will only return what\n"
		"it can compute.  Callers should always use\n"
		"EventAssignment.containsUndeclaredUnits() when using\n"
		"EventAssignment.getDerivedUnitDefinition() to decide whether the\n"
		"returned units may be incomplete.\n"
		"\n"
		"@return @c true if the math expression of this EventAssignment\n"
		"includes parameters/numbers \n"
		"with undeclared units, @c false otherwise.\n"
		"\n"
		"@note A return value of @c true indicates that the UnitDefinition\n"
		"returned by EventAssignment.getDerivedUnitDefinition() may not\n"
		"accurately represent the units of the expression.\n"
		"\n"
		"@see getDerivedUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_getTypeCode", _wrap_EventAssignment_getTypeCode, METH_VARARGS, (char *)"\n"
		"EventAssignment_getTypeCode(EventAssignment self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code of this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_getElementName", _wrap_EventAssignment_getElementName, METH_VARARGS, (char *)"\n"
		"EventAssignment_getElementName(EventAssignment self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for\n"
		"EventAssignment, is always @c 'eventAssignment'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'eventAssignment'. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_hasRequiredAttributes", _wrap_EventAssignment_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"EventAssignment_hasRequiredAttributes(EventAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this EventAssignment object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a EventAssignment object are:\n"
		"@li 'variable'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_hasRequiredElements", _wrap_EventAssignment_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"EventAssignment_hasRequiredElements(EventAssignment self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this EventAssignment object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a EventAssignment object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"EventAssignment_getId", _wrap_EventAssignment_getId, METH_VARARGS, (char *)"\n"
		"EventAssignment_getId(EventAssignment self) -> string\n"
		"\n"
		"@internal\n"
		"redicate returning @c true if\n"
		"ll the required elements for this EventAssignment object\n"
		"ave been set.\n"
		"\n"
		"note The required elements for a EventAssignment object are:\n"
		"li 'math'\n"
		"\n"
		"return a boolean value indicating whether all the required\n"
		"lements for this object have been defined.\n"
		" \n"
		"\n"
		""},
	 { (char *)"EventAssignment_swigregister", EventAssignment_swigregister, METH_VARARGS, NULL},
	 { (char *)"ListOfEventAssignments_clone", _wrap_ListOfEventAssignments_clone, METH_VARARGS, (char *)"\n"
		"ListOfEventAssignments_clone(ListOfEventAssignments self) -> ListOfEventAssignments\n"
		"\n"
		"Creates and returns a deep copy of this ListOfEventAssignments.\n"
		"\n"
		"@return a (deep) copy of this ListOfEventAssignments.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEventAssignments_getTypeCode", _wrap_ListOfEventAssignments_getTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfEventAssignments_getTypeCode(ListOfEventAssignments self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for this %SBML object.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEventAssignments_getItemTypeCode", _wrap_ListOfEventAssignments_getItemTypeCode, METH_VARARGS, (char *)"\n"
		"ListOfEventAssignments_getItemTypeCode(ListOfEventAssignments self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code for the objects contained in this ListOf\n"
		"(i.e., EventAssignment objects, if the list is non-empty).\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for the objects contained in this ListOf\n"
		"instance, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEventAssignments_getElementName", _wrap_ListOfEventAssignments_getElementName, METH_VARARGS, (char *)"\n"
		"ListOfEventAssignments_getElementName(ListOfEventAssignments self) -> string\n"
		"\n"
		"Returns the XML element name of this object.\n"
		"\n"
		"For ListOfEventAssignments, the XML element name is @c\n"
		"'listOfEventAssignments'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'listOfEventAssignments'.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEventAssignments_get", _wrap_ListOfEventAssignments_get, METH_VARARGS, (char *)"\n"
		"get(unsigned int n) -> EventAssignment\n"
		"get(unsigned int n) -> EventAssignment\n"
		"get(string sid) -> EventAssignment\n"
		"ListOfEventAssignments_get(ListOfEventAssignments self, string sid) -> EventAssignment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a EventAssignment from the ListOfEventAssignments.\n"
		"\n"
		"@param n the index number of the EventAssignment to get.\n"
		"\n"
		"@return the nth EventAssignment in this ListOfEventAssignments.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(long n)</pre>\n"
		"\n"
		"Get a EventAssignment from the ListOfEventAssignments.\n"
		"\n"
		"@param n the index number of the EventAssignment to get.\n"
		"\n"
		"@return the nth EventAssignment in this ListOfEventAssignments.\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a EventAssignment from the ListOfEventAssignments\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the EventAssignment to get.\n"
		"\n"
		"@return EventAssignment in this ListOfEventAssignments\n"
		"with the given id or @c None if no such\n"
		"EventAssignment exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>get(string sid)</pre>\n"
		"\n"
		"Get a EventAssignment from the ListOfEventAssignments\n"
		"based on its identifier.\n"
		"\n"
		"@param sid a string representing the identifier \n"
		"of the EventAssignment to get.\n"
		"\n"
		"@return EventAssignment in this ListOfEventAssignments\n"
		"with the given id or @c None if no such\n"
		"EventAssignment exists.\n"
		"\n"
		"@see get()\n"
		"@see size()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ListOfEventAssignments_remove", _wrap_ListOfEventAssignments_remove, METH_VARARGS, (char *)"\n"
		"remove(unsigned int n) -> EventAssignment\n"
		"ListOfEventAssignments_remove(ListOfEventAssignments self, string sid) -> EventAssignment\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(long n)</pre>\n"
		"\n"
		"Removes the nth item from this ListOfEventAssignments items and returns a pointer to\n"
		"it.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"\n"
		"@param n the index of the item to remove\n"
		"\n"
		"@see size()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string sid)</pre>\n"
		"\n"
		"Removes item in this ListOfEventAssignments items with the given identifier.\n"
		"\n"
		"The caller owns the returned item and is responsible for deleting it.\n"
		"If none of the items in this list have the identifier @p sid, then @c\n"
		"None is returned.\n"
		"\n"
		"@param sid the identifier of the item to remove\n"
		"\n"
		"@return the item removed.  As mentioned above, the caller owns the\n"
		"returned item.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_ListOfEventAssignments", _wrap_new_ListOfEventAssignments, METH_VARARGS, (char *)"new_ListOfEventAssignments() -> ListOfEventAssignments"},
	 { (char *)"delete_ListOfEventAssignments", _wrap_delete_ListOfEventAssignments, METH_VARARGS, (char *)"delete_ListOfEventAssignments(ListOfEventAssignments self)"},
	 { (char *)"ListOfEventAssignments_swigregister", ListOfEventAssignments_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Trigger", _wrap_delete_Trigger, METH_VARARGS, (char *)"delete_Trigger(Trigger self)"},
	 { (char *)"new_Trigger", _wrap_new_Trigger, METH_VARARGS, (char *)"\n"
		"Trigger(unsigned int level, unsigned int version)\n"
		"Trigger(SBMLNamespaces sbmlns)\n"
		"new_Trigger(Trigger orig) -> Trigger\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Trigger(long level, long version)</pre>\n"
		"\n"
		"Creates a new Trigger using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this Trigger\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"Trigger\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Trigger(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new Trigger using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Trigger(Trigger orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this Trigger.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_clone", _wrap_Trigger_clone, METH_VARARGS, (char *)"\n"
		"Trigger_clone(Trigger self) -> Trigger\n"
		"\n"
		"Creates and returns a deep copy of this Trigger.\n"
		"\n"
		"@return a (deep) copy of this Trigger.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_getMath", _wrap_Trigger_getMath, METH_VARARGS, (char *)"\n"
		"Trigger_getMath(Trigger self) -> ASTNode\n"
		"\n"
		"Get the mathematical formula for the trigger and return it\n"
		"as an AST.\n"
		"\n"
		"@return the math of this Trigger.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_getInitialValue", _wrap_Trigger_getInitialValue, METH_VARARGS, (char *)"\n"
		"Trigger_getInitialValue(Trigger self) -> bool\n"
		"\n"
		"(SBML Level&nbsp;3 only) Get the value of the 'initialValue' attribute\n"
		"of this Trigger.\n"
		"\n"
		"@return the boolean value stored as the 'initialValue' attribute value\n"
		"in this Trigger.\n"
		"\n"
		"@note The attribute 'initialValue' is available in SBML Level&nbsp;3\n"
		"Version&nbsp;1 Core, but is not present in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_getPersistent", _wrap_Trigger_getPersistent, METH_VARARGS, (char *)"\n"
		"Trigger_getPersistent(Trigger self) -> bool\n"
		"\n"
		"(SBML Level&nbsp;3 only) Get the value of the 'persistent' attribute\n"
		"of this Trigger.\n"
		"\n"
		"@return the boolean value stored as the 'persistent' attribute value\n"
		"in this Trigger.\n"
		"\n"
		"@note The attribute 'persistent' is available in SBML Level&nbsp;3\n"
		"Version&nbsp;1 Core, but is not present in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_isSetMath", _wrap_Trigger_isSetMath, METH_VARARGS, (char *)"\n"
		"Trigger_isSetMath(Trigger self) -> bool\n"
		"\n"
		"Predicate to test whether the math for this trigger is set.\n"
		"\n"
		"@return @c true if the formula (meaning the 'math' subelement) of\n"
		"this Trigger is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_isSetInitialValue", _wrap_Trigger_isSetInitialValue, METH_VARARGS, (char *)"\n"
		"Trigger_isSetInitialValue(Trigger self) -> bool\n"
		"\n"
		"(SBML Level&nbsp;3 only) Predicate to test whether the 'initialValue'\n"
		"attribute for this trigger is set.\n"
		"\n"
		"@return @c true if the initialValue attribute of\n"
		"this Trigger is set, @c false otherwise.\n"
		"\n"
		"@note The attribute 'initialValue' is available in SBML Level&nbsp;3\n"
		"Version&nbsp;1 Core, but is not present in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_isSetPersistent", _wrap_Trigger_isSetPersistent, METH_VARARGS, (char *)"\n"
		"Trigger_isSetPersistent(Trigger self) -> bool\n"
		"\n"
		"(SBML Level&nbsp;3 only) Predicate to test whether the 'persistent'\n"
		"attribute for this trigger is set.\n"
		"\n"
		"@return @c true if the persistent attribute of\n"
		"this Trigger is set, @c false otherwise.\n"
		"\n"
		"@note The attribute 'persistent' is available in SBML Level&nbsp;3\n"
		"Version&nbsp;1 Core, but is not present in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_setMath", _wrap_Trigger_setMath, METH_VARARGS, (char *)"\n"
		"Trigger_setMath(Trigger self, ASTNode math) -> int\n"
		"\n"
		"Sets the trigger expression of this Trigger instance to a copy of the given\n"
		"ASTNode.\n"
		"\n"
		"@param math an ASTNode representing a formula tree.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_setInitialValue", _wrap_Trigger_setInitialValue, METH_VARARGS, (char *)"\n"
		"Trigger_setInitialValue(Trigger self, bool initialValue) -> int\n"
		"\n"
		"(SBML Level&nbsp;3 only) Sets the 'initialValue' attribute of this Trigger instance.\n"
		"\n"
		"@param initialValue a boolean representing the initialValue to be set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attribute 'initialValue' is available in SBML Level&nbsp;3\n"
		"Version&nbsp;1 Core, but is not present in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_setPersistent", _wrap_Trigger_setPersistent, METH_VARARGS, (char *)"\n"
		"Trigger_setPersistent(Trigger self, bool persistent) -> int\n"
		"\n"
		"(SBML Level&nbsp;3 only) Sets the 'persistent' attribute of this Trigger instance.\n"
		"\n"
		"@param persistent a boolean representing the persistent value to be set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"\n"
		"@note The attribute 'persistent' is available in SBML Level&nbsp;3\n"
		"Version&nbsp;1 Core, but is not present in lower Levels of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_getTypeCode", _wrap_Trigger_getTypeCode, METH_VARARGS, (char *)"\n"
		"Trigger_getTypeCode(Trigger self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code of this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_getElementName", _wrap_Trigger_getElementName, METH_VARARGS, (char *)"\n"
		"Trigger_getElementName(Trigger self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Trigger, is\n"
		"always @c 'trigger'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'trigger'. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_hasRequiredElements", _wrap_Trigger_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"Trigger_hasRequiredElements(Trigger self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Trigger object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Trigger object are:\n"
		"math\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_hasRequiredAttributes", _wrap_Trigger_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"Trigger_hasRequiredAttributes(Trigger self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required attributes for this Trigger object\n"
		"have been set.\n"
		"\n"
		"@note The required attributes for a Trigger object are:\n"
		"@li 'persistent' (required in SBML Level&nbsp;3)\n"
		"@li 'initialValue' (required in SBML Level&nbsp;3)\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"attributes for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Trigger_swigregister", Trigger_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Delay", _wrap_delete_Delay, METH_VARARGS, (char *)"delete_Delay(Delay self)"},
	 { (char *)"new_Delay", _wrap_new_Delay, METH_VARARGS, (char *)"\n"
		"Delay(unsigned int level, unsigned int version)\n"
		"Delay(SBMLNamespaces sbmlns)\n"
		"new_Delay(Delay orig) -> Delay\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Delay(long level, long version)</pre>\n"
		"\n"
		"Creates a new Delay using the given SBML @p level and @p version\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this Delay\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"Delay\n"
		"\n"
		"@note Upon the addition of a Delay object to an Event (e.g., using\n"
		"Event.setDelay()), the SBML Level, SBML Version\n"
		"and XML namespace of the document @em override the values used when\n"
		"creating the Delay object via this constructor.  This is necessary to\n"
		"ensure that an SBML document is a consistent structure.  Nevertheless,\n"
		"the ability to supply the values at the time of creation of a Delay is\n"
		"an important aid to producing valid SBML.  Knowledge of the intented\n"
		"SBML Level and Version determine whether it is valid to assign a\n"
		"particular value to an attribute, or whether it is valid to add a\n"
		"particular Delay object to an existing Event.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Delay(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new Delay using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a Delay object to an Event (e.g., using\n"
		"Event.setDelay()), the SBML XML namespace of\n"
		"the document @em overrides the value used when creating the Delay\n"
		"object via this constructor.  This is necessary to ensure that an SBML\n"
		"document is a consistent structure.  Nevertheless, the ability to\n"
		"supply the values at the time of creation of a Delay is an important\n"
		"aid to producing valid SBML.  Knowledge of the intented SBML Level and\n"
		"Version determine whether it is valid to assign a particular value to\n"
		"an attribute, or whether it is valid to add a particular Delay object\n"
		"to an existing Event.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Delay(Delay orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this Delay.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_clone", _wrap_Delay_clone, METH_VARARGS, (char *)"\n"
		"Delay_clone(Delay self) -> Delay\n"
		"\n"
		"Creates and returns a deep copy of this Delay.\n"
		"\n"
		"@return a (deep) copy of this Delay.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_getMath", _wrap_Delay_getMath, METH_VARARGS, (char *)"\n"
		"Delay_getMath(Delay self) -> ASTNode\n"
		"\n"
		"Get the mathematical formula for the delay and return it\n"
		"as an AST.\n"
		"\n"
		"@return the math of this Delay.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_isSetMath", _wrap_Delay_isSetMath, METH_VARARGS, (char *)"\n"
		"Delay_isSetMath(Delay self) -> bool\n"
		"\n"
		"Predicate to test whether the formula for this delay is set.\n"
		"\n"
		"@return @c true if the formula (meaning the @c math subelement) of\n"
		"this Delay is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_setMath", _wrap_Delay_setMath, METH_VARARGS, (char *)"\n"
		"Delay_setMath(Delay self, ASTNode math) -> int\n"
		"\n"
		"Sets the delay expression of this Delay instance to a copy of the given\n"
		"ASTNode.\n"
		"\n"
		"@param math an ASTNode representing a formula tree.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t.  @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_getDerivedUnitDefinition", _wrap_Delay_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"Delay_getDerivedUnitDefinition(Delay self) -> UnitDefinition\n"
		"\n"
		"Calculates and returns a UnitDefinition that expresses the units\n"
		"of measurement assumed for the 'math' expression of this Delay.\n"
		"\n"
		"Delay elements in SBML express a time delay for an Event.  Beginning\n"
		"with SBML Level&nbsp;2 Version&nbsp;2, the units of that time are\n"
		"calculated based on the mathematical expression and the model\n"
		"quantities referenced by <code>&lt;ci&gt;</code> elements used within\n"
		"that expression.  The Delay.getDerivedUnitDefinition() method returns\n"
		"what libSBML computes the units to be, to the extent that libSBML can\n"
		"compute them.\n"
		"\n"
		"(Prior to SBML Level&nbsp;2 Version&nbsp;2, there existed an attribute\n"
		"on Event called 'timeUnits'.  This attribute could be used to set the\n"
		"intended units of the delay expression.  For such models, this will\n"
		"return a UnitDefinition object that corresponds to the declared\n"
		"'timeUnits' units.)\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c None.\n"
		"\n"
		"@warning Note that it is possible the 'math' expression in the Delay\n"
		"contains literal numbers or parameters with undeclared units.  In\n"
		"those cases, it is not possible to calculate the units of the overall\n"
		"expression without making assumptions.  LibSBML does not make\n"
		"assumptions about the units, and Delay.getDerivedUnitDefinition()\n"
		"only returns the units as far as it is able to determine them.  For\n"
		"example, in an expression <em>X + Y</em>, if <em>X</em> has\n"
		"unambiguously-defined units and <em>Y</em> does not, it will return\n"
		"the units of <em>X</em>.  When using this method, <strong>it is\n"
		"critical that callers also invoke the method</strong>\n"
		"Delay.containsUndeclaredUnits() <strong>to determine whether this\n"
		"situation holds</strong>.  Callers should take suitable action in\n"
		"those situations.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of the math \n"
		"expression of this Delay, or @c None if one cannot be constructed.\n"
		"\n"
		"@see containsUndeclaredUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_containsUndeclaredUnits", _wrap_Delay_containsUndeclaredUnits, METH_VARARGS, (char *)"\n"
		"containsUndeclaredUnits() -> bool\n"
		"Delay_containsUndeclaredUnits(Delay self) -> bool\n"
		"\n"
		"Predicate returning @c true if \n"
		"the 'math' expression in this Delay instance contains\n"
		"parameters with undeclared units or literal numbers.\n"
		"\n"
		"Delay elements in SBML express a time delay for an Event.  Beginning\n"
		"with SBML Level&nbsp;2 Version&nbsp;2, the units of that time are\n"
		"calculated based on the mathematical expression and the model\n"
		"quantities referenced by <code>&lt;ci&gt;</code> elements used within\n"
		"that expression.  The Delay.getDerivedUnitDefinition() method returns\n"
		"what libSBML computes the units to be, to the extent that libSBML can\n"
		"compute them.  However, if the expression contains literal numbers or\n"
		"parameters with undeclared units, libSBML may not be able to compute\n"
		"the full units of the expression and will only return what it can\n"
		"compute.  Callers should always use Delay.containsUndeclaredUnits()\n"
		"when using Delay.getDerivedUnitDefinition() to decide whether the\n"
		"returned units may be incomplete.\n"
		"\n"
		"@return @c true if the math expression of this Delay includes\n"
		"numbers/parameters with undeclared units, @c false otherwise.\n"
		"\n"
		"@note A return value of @c true indicates that the UnitDefinition\n"
		"returned by Delay.getDerivedUnitDefinition() may not accurately\n"
		"represent the units of the expression.\n"
		"\n"
		"@see getDerivedUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_getTypeCode", _wrap_Delay_getTypeCode, METH_VARARGS, (char *)"\n"
		"Delay_getTypeCode(Delay self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code of this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_getElementName", _wrap_Delay_getElementName, METH_VARARGS, (char *)"\n"
		"Delay_getElementName(Delay self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Delay, is\n"
		"always @c 'delay'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'delay'.\n"
		"\n"
		"@see getTypeCode()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_hasRequiredElements", _wrap_Delay_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"Delay_hasRequiredElements(Delay self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Delay object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Delay object are:\n"
		"math\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Delay_swigregister", Delay_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Priority", _wrap_delete_Priority, METH_VARARGS, (char *)"delete_Priority(Priority self)"},
	 { (char *)"new_Priority", _wrap_new_Priority, METH_VARARGS, (char *)"\n"
		"Priority(unsigned int level, unsigned int version)\n"
		"Priority(SBMLNamespaces sbmlns)\n"
		"new_Priority(Priority orig) -> Priority\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Priority(long level, long version)</pre>\n"
		"\n"
		"Creates a new Priority object using the given SBML @p level and @p\n"
		"version values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this Priority\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"Priority\n"
		"\n"
		"@note Upon the addition of a Priority object to an Event (e.g., using\n"
		"Event.setPriority()), the SBML Level, SBML Version\n"
		"and XML namespace of the document @em override the values used when\n"
		"creating the Priority object via this constructor.  This is necessary to\n"
		"ensure that an SBML document is a consistent structure.  Nevertheless,\n"
		"the ability to supply the values at the time of creation of a Priority is\n"
		"an important aid to producing valid SBML.  Knowledge of the intented\n"
		"SBML Level and Version determine whether it is valid to assign a\n"
		"particular value to an attribute, or whether it is valid to add a\n"
		"particular Priority object to an existing Event.<br><br>\n"
		"\n"
		"@note The Priority construct exists only in SBML Level&nbsp;3; it\n"
		"cannot be used in SBML Level&nbsp;2 or Level&nbsp;1 models.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Priority(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new Priority object using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"@note Upon the addition of a Priority object to an Event (e.g., using\n"
		"Event.setPriority()), the SBML XML namespace of\n"
		"the document @em overrides the value used when creating the Priority\n"
		"object via this constructor.  This is necessary to ensure that an SBML\n"
		"document is a consistent structure.  Nevertheless, the ability to\n"
		"supply the values at the time of creation of a Priority is an important\n"
		"aid to producing valid SBML.  Knowledge of the intented SBML Level and\n"
		"Version determine whether it is valid to assign a particular value to\n"
		"an attribute, or whether it is valid to add a particular Priority object\n"
		"to an existing Event.<br><br>\n"
		"\n"
		"@note The Priority construct exists only in SBML Level&nbsp;3; it\n"
		"cannot be used in SBML Level&nbsp;2 or Level&nbsp;1 models.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Priority(const Priority& orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this Priority.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Priority_clone", _wrap_Priority_clone, METH_VARARGS, (char *)"\n"
		"Priority_clone(Priority self) -> Priority\n"
		"\n"
		"Creates and returns a deep copy of this Priority.\n"
		"\n"
		"@return a (deep) copy of this Priority.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Priority_getMath", _wrap_Priority_getMath, METH_VARARGS, (char *)"\n"
		"Priority_getMath(Priority self) -> ASTNode\n"
		"\n"
		"Get the mathematical formula for the priority and return it\n"
		"as an AST.\n"
		"\n"
		"@return the math of this Priority.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Priority_isSetMath", _wrap_Priority_isSetMath, METH_VARARGS, (char *)"\n"
		"Priority_isSetMath(Priority self) -> bool\n"
		"\n"
		"Predicate to test whether the formula for this delay is set.\n"
		"\n"
		"@return @c true if the formula (meaning the @c math subelement) of\n"
		"this Priority is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Priority_setMath", _wrap_Priority_setMath, METH_VARARGS, (char *)"\n"
		"Priority_setMath(Priority self, ASTNode math) -> int\n"
		"\n"
		"Sets the math expression of this Priority instance to a copy of the given\n"
		"ASTNode.\n"
		"\n"
		"@param math an ASTNode representing a formula tree.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t.  @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Priority_getTypeCode", _wrap_Priority_getTypeCode, METH_VARARGS, (char *)"\n"
		"Priority_getTypeCode(Priority self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code of this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Priority_getElementName", _wrap_Priority_getElementName, METH_VARARGS, (char *)"\n"
		"Priority_getElementName(Priority self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for Priority, is\n"
		"always @c 'priority'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'priority'.\n"
		"\n"
		"@see getTypeCode()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Priority_hasRequiredElements", _wrap_Priority_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"Priority_hasRequiredElements(Priority self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this Priority object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a Priority object are:\n"
		"math\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Priority_swigregister", Priority_swigregister, METH_VARARGS, NULL},
	 { (char *)"SBO_isQuantitativeParameter", _wrap_SBO_isQuantitativeParameter, METH_VARARGS, (char *)"\n"
		"SBO_isQuantitativeParameter(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'quantiative parameter'</em>, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isParticipantRole", _wrap_SBO_isParticipantRole, METH_VARARGS, (char *)"\n"
		"SBO_isParticipantRole(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'participant role'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isModellingFramework", _wrap_SBO_isModellingFramework, METH_VARARGS, (char *)"\n"
		"SBO_isModellingFramework(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'modeling framework'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isMathematicalExpression", _wrap_SBO_isMathematicalExpression, METH_VARARGS, (char *)"\n"
		"SBO_isMathematicalExpression(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'mathematical expression'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isKineticConstant", _wrap_SBO_isKineticConstant, METH_VARARGS, (char *)"\n"
		"SBO_isKineticConstant(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'kinetic constant'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isReactant", _wrap_SBO_isReactant, METH_VARARGS, (char *)"\n"
		"SBO_isReactant(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'reactant'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isProduct", _wrap_SBO_isProduct, METH_VARARGS, (char *)"\n"
		"SBO_isProduct(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'product'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isModifier", _wrap_SBO_isModifier, METH_VARARGS, (char *)"\n"
		"SBO_isModifier(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'modifier'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isRateLaw", _wrap_SBO_isRateLaw, METH_VARARGS, (char *)"\n"
		"SBO_isRateLaw(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'rate law'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isEvent", _wrap_SBO_isEvent, METH_VARARGS, (char *)"\n"
		"SBO_isEvent(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'event'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isPhysicalParticipant", _wrap_SBO_isPhysicalParticipant, METH_VARARGS, (char *)"\n"
		"SBO_isPhysicalParticipant(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'physical participant</em>, @c false otherwise.\n"
		"   \n"
		"\n"
		""},
	 { (char *)"SBO_isParticipant", _wrap_SBO_isParticipant, METH_VARARGS, (char *)"\n"
		"SBO_isParticipant(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'participant'</em>, @c false otherwise.\n"
		"   \n"
		"\n"
		""},
	 { (char *)"SBO_isInteraction", _wrap_SBO_isInteraction, METH_VARARGS, (char *)"\n"
		"SBO_isInteraction(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'interaction'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isEntity", _wrap_SBO_isEntity, METH_VARARGS, (char *)"\n"
		"SBO_isEntity(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'entity'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isFunctionalEntity", _wrap_SBO_isFunctionalEntity, METH_VARARGS, (char *)"\n"
		"SBO_isFunctionalEntity(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'functional entity'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isMaterialEntity", _wrap_SBO_isMaterialEntity, METH_VARARGS, (char *)"\n"
		"SBO_isMaterialEntity(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'material entity'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isConservationLaw", _wrap_SBO_isConservationLaw, METH_VARARGS, (char *)"\n"
		"SBO_isConservationLaw(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'conservation law'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isSteadyStateExpression", _wrap_SBO_isSteadyStateExpression, METH_VARARGS, (char *)"\n"
		"SBO_isSteadyStateExpression(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'steady state expression'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isFunctionalCompartment", _wrap_SBO_isFunctionalCompartment, METH_VARARGS, (char *)"\n"
		"SBO_isFunctionalCompartment(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'functional compartment'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isContinuousFramework", _wrap_SBO_isContinuousFramework, METH_VARARGS, (char *)"\n"
		"SBO_isContinuousFramework(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'continuous framework'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isDiscreteFramework", _wrap_SBO_isDiscreteFramework, METH_VARARGS, (char *)"\n"
		"SBO_isDiscreteFramework(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'discrete framework'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isLogicalFramework", _wrap_SBO_isLogicalFramework, METH_VARARGS, (char *)"\n"
		"SBO_isLogicalFramework(unsigned int term) -> bool\n"
		"\n"
		"Returns @c true if the given term identifier comes from the stated branch of %SBO.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'logical framework'</em>, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_isObselete", _wrap_SBO_isObselete, METH_VARARGS, (char *)"\n"
		"SBO_isObselete(unsigned int term) -> bool\n"
		"\n"
		"Predicate for checking whether the given term is obsolete.\n"
		"\n"
		"@return @c true if @p term is-a %SBO <em>'obsolete'</em> term, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_intToString", _wrap_SBO_intToString, METH_VARARGS, (char *)"\n"
		"SBO_intToString(int sboTerm) -> string\n"
		"\n"
		"Returns the integer as a correctly formatted %SBO identifier string.\n"
		"\n"
		"@return the given integer sboTerm as a zero-padded seven digit string.\n"
		"\n"
		"@note If the sboTerm is not in the correct range\n"
		"(0000000&ndash;9999999), an empty string is returned.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_stringToInt", _wrap_SBO_stringToInt, METH_VARARGS, (char *)"\n"
		"SBO_stringToInt(string sboTerm) -> int\n"
		"\n"
		"Returns the string as a correctly formatted %SBO integer portion.\n"
		"\n"
		"@return the given string sboTerm as an integer.  If the sboTerm is not\n"
		"in the correct format (a zero-padded, seven digit string), <code>-1</code> is\n"
		"returned.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBO_checkTerm", _wrap_SBO_checkTerm, METH_VARARGS, (char *)"\n"
		"checkTerm(string sboTerm) -> bool\n"
		"SBO_checkTerm(int sboTerm) -> bool\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>checkTerm(string sboTerm)</pre>\n"
		"\n"
		"Checks the format of the given %SBO identifier string.\n"
		"\n"
		"@return @c true if sboTerm is in the correct format (a zero-padded, seven\n"
		"digit string), @c false otherwise.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>checkTerm(int sboTerm)</pre>\n"
		"\n"
		"Checks the format of the given %SBO identifier, given in the form of\n"
		"the integer portion alone.\n"
		"\n"
		"@return @c true if sboTerm is in the range (0000000&ndash;9999999), @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_SBO", _wrap_new_SBO, METH_VARARGS, (char *)"new_SBO() -> SBO"},
	 { (char *)"delete_SBO", _wrap_delete_SBO, METH_VARARGS, (char *)"delete_SBO(SBO self)"},
	 { (char *)"SBO_swigregister", SBO_swigregister, METH_VARARGS, NULL},
	 { (char *)"SyntaxChecker_isValidSBMLSId", _wrap_SyntaxChecker_isValidSBMLSId, METH_VARARGS, (char *)"\n"
		"SyntaxChecker_isValidSBMLSId(string sid) -> bool\n"
		"\n"
		"Returns true @c true or @c false depending on whether the argument\n"
		"string conforms to the syntax of SBML identifiers.\n"
		"\n"
		"In SBML, identifiers that are the values of 'id' attributes on objects\n"
		"must conform to a data type called <code>SId</code> in the SBML\n"
		"specifications.  LibSBML does not provide an explicit <code>SId</code>\n"
		"data type; it uses ordinary character strings, which is easier for\n"
		"applications to support.  LibSBML does, however, test for identifier\n"
		"validity at various times, such as when reading in models from files\n"
		"and data streams.\n"
		"\n"
		"This method provides programs with the ability to test explicitly that\n"
		"the identifier strings they create conform to the SBML identifier\n"
		"syntax.\n"
		"\n"
		"@param sid string to be checked for conformance to SBML identifier\n"
		"syntax.\n"
		"\n"
		"@return @c true if the string conforms to type SBML data type\n"
		"<code>SId</code>, @c false otherwise.\n"
		"\n"
		"@note @htmlinclude id-syntax.html\n"
		"\n"
		"@see isValidUnitSId()\n"
		"@see isValidXMLID()\n"
		"    \n"
		"\n"
		""},
	 { (char *)"SyntaxChecker_isValidXMLID", _wrap_SyntaxChecker_isValidXMLID, METH_VARARGS, (char *)"\n"
		"SyntaxChecker_isValidXMLID(string id) -> bool\n"
		"\n"
		"Returns @c true or @c false depending on whether the argument string\n"
		"conforms to the XML data type <code>ID</code>.\n"
		"\n"
		"In SBML, identifiers that are the values of 'metaid' attributes on\n"
		"objects must conform to the <a target='_blank'\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a> data type.  LibSBML\n"
		"does not provide an explicit XML <code>ID</code> data type; it uses\n"
		"ordinary character strings, which is easier for applications to\n"
		"support.  LibSBML does, however, test for identifier validity at\n"
		"various times, such as when reading in models from files and data\n"
		"streams.\n"
		"\n"
		"This method provides programs with the ability to test explicitly that\n"
		"the identifier strings they create conform to the SBML identifier\n"
		"syntax.\n"
		"\n"
		"@param id string to be checked for conformance to the syntax of\n"
		"<a target='_blank' href='http://www.w3.org/TR/REC-xml/#id'>XML ID</a>.\n"
		"\n"
		"@return @c true if the string is a syntactically-valid value for the\n"
		"XML type <a target='_blank'\n"
		"href='http://www.w3.org/TR/REC-xml/#id'>ID</a>, @c false otherwise.\n"
		"\n"
		"@note @htmlinclude xmlid-syntax.html\n"
		"\n"
		"@see isValidSBMLSId()\n"
		"@see isValidUnitSId()\n"
		"    \n"
		"\n"
		""},
	 { (char *)"SyntaxChecker_isValidUnitSId", _wrap_SyntaxChecker_isValidUnitSId, METH_VARARGS, (char *)"\n"
		"SyntaxChecker_isValidUnitSId(string units) -> bool\n"
		"\n"
		"Returns @c true or @c false depending on whether the argument string\n"
		"conforms to the syntax of SBML unit identifiers.\n"
		"\n"
		"In SBML, the identifiers of units (of both the predefined units and\n"
		"user-defined units) must conform to a data type called\n"
		"<code>UnitSId</code> in the SBML specifications.  LibSBML does not\n"
		"provide an explicit <code>UnitSId</code> data type; it uses ordinary\n"
		"character strings, which is easier for applications to support.\n"
		"LibSBML does, however, test for identifier validity at various times,\n"
		"such as when reading in models from files and data streams.\n"
		"\n"
		"This method provides programs with the ability to test explicitly that\n"
		"the identifier strings they create conform to the SBML identifier\n"
		"syntax.\n"
		"\n"
		"@param units string to be checked for conformance to SBML unit\n"
		"identifier syntax.\n"
		"\n"
		"@return @c true if the string conforms to type SBML data type\n"
		"<code>UnitSId</code>, @c false otherwise.\n"
		"\n"
		"@note @htmlinclude unitid-syntax.html\n"
		"\n"
		"@see isValidSBMLSId()\n"
		"@see isValidXMLID()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SyntaxChecker_hasExpectedXHTMLSyntax", _wrap_SyntaxChecker_hasExpectedXHTMLSyntax, METH_VARARGS, (char *)"\n"
		"hasExpectedXHTMLSyntax(XMLNode xhtml, SBMLNamespaces sbmlns = None) -> bool\n"
		"SyntaxChecker_hasExpectedXHTMLSyntax(XMLNode xhtml) -> bool\n"
		"\n"
		"Returns @c true or @c false depending on whether the given XMLNode\n"
		"object contains valid XHTML content.\n"
		"\n"
		"In SBML, the content of the 'notes' subelement available on SBase, as\n"
		"well as the 'message' subelement available on Constraint, must conform\n"
		"to <a target='_blank'\n"
		"href='http://www.w3.org/TR/xhtml1/'>XHTML&nbsp;1.0</a> (which is\n"
		"simply an XML-ized version of HTML).  However, the content cannot be\n"
		"@em entirely free-form; it must satisfy certain requirements defined in\n"
		"the <a target='_blank'\n"
		"href='http://sbml.org/Documents/Specifications'>SBML\n"
		"specifications</a> for specific SBML Levels.  This method implements a\n"
		"verification process that lets callers check whether the content of a\n"
		"given XMLNode object conforms to the SBML requirements for 'notes' and\n"
		"'message' structure.\n"
		"\n"
		"An aspect of XHTML validity is that the content is declared to be in\n"
		"the XML namespace for XHTML&nbsp;1.0.  There is more than one way in\n"
		"which this can be done in XML.  In particular, a model might not\n"
		"contain the declaration within the 'notes' or 'message' subelement\n"
		"itself, but might instead place the declaration on an enclosing\n"
		"element and use an XML namespace prefix within the 'notes' element to\n"
		"refer to it.  In other words, the following is valid:\n"
		"  @verbatim\n"
		" <sbml xmlns='http://www.sbml.org/sbml/level2/version3' level='2' version='3'\n"
		"       xmlns:xhtml='http://www.w3.org/1999/xhtml'>\n"
		"   <model>\n"
		"     <notes>\n"
		"       <xhtml:body>\n"
		"         <xhtml:center><xhtml:h2>A Simple Mitotic Oscillator</xhtml:h2></xhtml:center>\n"
		"         <xhtml:p>A minimal cascade model for the mitotic oscillator.</xhtml:p>\n"
		"       </xhtml:body>\n"
		"     </notes>\n"
		"   ... rest of model ...\n"
		" </sbml>\n"
		" @endverbatim\n"
		"Contrast the above with the following, self-contained version, which\n"
		"places the XML namespace declaration within the <code>&lt;notes&gt;</code>\n"
		"element itself:\n"
		"  @verbatim\n"
		" <sbml xmlns='http://www.sbml.org/sbml/level2/version3' level='2' version='3'>\n"
		"   <model>\n"
		"     <notes>\n"
		"       <html xmlns='http://www.w3.org/1999/xhtml'>\n"
		"         <head>\n"
		"           <title/>\n"
		"         </head>\n"
		"         <body>\n"
		"           <center><h2>A Simple Mitotic Oscillator</h2></center>\n"
		"           <p>A minimal cascade model for the mitotic oscillator.</p>\n"
		"         </body>\n"
		"       </html>\n"
		"     </notes>\n"
		"   ... rest of model ...\n"
		" </sbml>\n"
		" @endverbatim\n"
		"\n"
		"Both of the above are valid XML.  The purpose of the @p sbmlns\n"
		"argument to this method is to allow callers to check the validity of\n"
		"'notes' and 'message' subelements whose XML namespace declarations\n"
		"have been put elsewhere in the manner illustrated above.  Callers can\n"
		"can pass in the SBMLNamespaces object of a higher-level model\n"
		"component if the XMLNode object does not itself have the XML namespace\n"
		"declaration for XHTML&nbsp;1.0.\n"
		"\n"
		"@param xhtml the XMLNode to be checked for conformance.\n"
		"@param sbmlns the SBMLNamespaces associated with the object.\n"
		"\n"
		"@return @c true if the XMLNode content conforms, @c false otherwise.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SyntaxChecker_isValidInternalSId", _wrap_SyntaxChecker_isValidInternalSId, METH_VARARGS, (char *)"\n"
		"SyntaxChecker_isValidInternalSId(string sid) -> bool\n"
		"\n"
		"@internal\n"
		"eturns true @c true or @c false depending on whether the argument\n"
		"tring conforms to the syntax of SBML identifiers or is empty.\n"
		"   \n"
		"\n"
		""},
	 { (char *)"SyntaxChecker_isValidInternalUnitSId", _wrap_SyntaxChecker_isValidInternalUnitSId, METH_VARARGS, (char *)"\n"
		"SyntaxChecker_isValidInternalUnitSId(string sid) -> bool\n"
		"\n"
		"@internal\n"
		"eturns true @c true or @c false depending on whether the argument\n"
		"tring conforms to the syntax of SBML identifiers or is empty.\n"
		"   \n"
		"\n"
		""},
	 { (char *)"new_SyntaxChecker", _wrap_new_SyntaxChecker, METH_VARARGS, (char *)"new_SyntaxChecker() -> SyntaxChecker"},
	 { (char *)"delete_SyntaxChecker", _wrap_delete_SyntaxChecker, METH_VARARGS, (char *)"delete_SyntaxChecker(SyntaxChecker self)"},
	 { (char *)"SyntaxChecker_swigregister", SyntaxChecker_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_StoichiometryMath", _wrap_delete_StoichiometryMath, METH_VARARGS, (char *)"delete_StoichiometryMath(StoichiometryMath self)"},
	 { (char *)"new_StoichiometryMath", _wrap_new_StoichiometryMath, METH_VARARGS, (char *)"\n"
		"StoichiometryMath(unsigned int level, unsigned int version)\n"
		"StoichiometryMath(SBMLNamespaces sbmlns)\n"
		"new_StoichiometryMath(StoichiometryMath orig) -> StoichiometryMath\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>StoichiometryMath(long level, long version)</pre>\n"
		"\n"
		"Creates a new StoichiometryMath object using the given SBML @p level\n"
		"values.\n"
		"\n"
		"@param level a long integer, the SBML Level to assign to this StoichiometryMath\n"
		"\n"
		"@param version a long integer, the SBML Version to assign to this\n"
		"StoichiometryMath\n"
		"\n"
		"The StoichiometryMath construct exists only in SBML Level&nbsp;2.  It\n"
		"is an optional construct available for defining the stoichiometries of\n"
		"reactants and products in Reaction objects.  Note that a different\n"
		"mechanism is used in SBML Level&nbsp;3, where StoichiometryMath is not\n"
		"available.  Please consult the top of this libSBML StoichiometryMath\n"
		"documentation for more information about the differences between SBML\n"
		"Level&nbsp;2 and&nbsp;3 with respect to stoichiometries.\n"
		"\n"
		"@note Upon the addition of a StoichiometryMath object to an\n"
		"SBMLDocument (e.g., using\n"
		"SpeciesReference.createStoichiometryMath()), the SBML Level, SBML\n"
		"Version and XML namespace of the document @em override the values used\n"
		"when creating the StoichiometryMath object via this constructor.  This\n"
		"is necessary to ensure that an SBML document is a consistent\n"
		"structure.  Nevertheless, the ability to supply the values at the time\n"
		"of creation of a StoichiometryMath is an important aid to producing\n"
		"valid SBML.  Knowledge of the intented SBML Level and Version\n"
		"determine whether it is valid to assign a particular value to an\n"
		"attribute, or whether it is valid to add an object to an existing\n"
		"SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>StoichiometryMath(SBMLNamespaces sbmlns)</pre>\n"
		"\n"
		"Creates a new StoichiometryMath object using the given SBMLNamespaces object\n"
		"@p sbmlns.\n"
		"\n"
		"The SBMLNamespaces object encapsulates SBML Level/Version/namespaces\n"
		"information.  It is used to communicate the SBML Level, Version, and\n"
		"(in Level&nbsp;3) packages used in addition to SBML Level&nbsp;3 Core.\n"
		"A common approach to using this class constructor is to create an\n"
		"SBMLNamespaces object somewhere in a program, once, then pass it to\n"
		"object constructors such as this one when needed.\n"
		"\n"
		"@param sbmlns an SBMLNamespaces object.\n"
		"\n"
		"The StoichiometryMath construct exists only in SBML Level&nbsp;2.  It\n"
		"is an optional construct available for defining the stoichiometries of\n"
		"reactants and products in Reaction objects.  Note that a different\n"
		"mechanism is used in SBML Level&nbsp;3, where StoichiometryMath is not\n"
		"available.  Please consult the top of this libSBML StoichiometryMath\n"
		"documentation for more information about the differences between SBML\n"
		"Level&nbsp;2 and&nbsp;3 with respect to stoichiometries.\n"
		"\n"
		"@note Upon the addition of a StoichiometryMath object to an\n"
		"SBMLDocument (e.g., using\n"
		"SpeciesReference.createStoichiometryMath()), the SBML XML namespace\n"
		"of the document @em overrides the value used when creating the\n"
		"StoichiometryMath object via this constructor.  This is necessary to\n"
		"ensure that an SBML document is a consistent structure.  Nevertheless,\n"
		"the ability to supply the values at the time of creation of a\n"
		"StoichiometryMath is an important aid to producing valid SBML.\n"
		"Knowledge of the intented SBML Level and Version determine whether it\n"
		"is valid to assign a particular value to an attribute, or whether it\n"
		"is valid to add an object to an existing SBMLDocument.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>StoichiometryMath(StoichiometryMath orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this StoichiometryMath.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_clone", _wrap_StoichiometryMath_clone, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_clone(StoichiometryMath self) -> StoichiometryMath\n"
		"\n"
		"Creates and returns a deep copy of this StoichiometryMath object.\n"
		"\n"
		"@return a (deep) copy of this StoichiometryMath.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_getMath", _wrap_StoichiometryMath_getMath, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_getMath(StoichiometryMath self) -> ASTNode\n"
		"\n"
		"Retrieves the mathematical formula within this StoichiometryMath and\n"
		"return it as an AST.\n"
		"\n"
		"@return the math of this StoichiometryMath.\n"
		"\n"
		"The StoichiometryMath construct exists only in SBML Level&nbsp;2.  It\n"
		"is an optional construct available for defining the stoichiometries of\n"
		"reactants and products in Reaction objects.  Note that a different\n"
		"mechanism is used in SBML Level&nbsp;3, where StoichiometryMath is not\n"
		"available.  Please consult the top of this libSBML StoichiometryMath\n"
		"documentation for more information about the differences between SBML\n"
		"Level&nbsp;2 and&nbsp;3 with respect to stoichiometries.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_isSetMath", _wrap_StoichiometryMath_isSetMath, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_isSetMath(StoichiometryMath self) -> bool\n"
		"\n"
		"Predicate to test whether the math for this StoichiometryMath object\n"
		"is set.\n"
		"\n"
		"@return @c true if the formula (meaning the @c math subelement) of\n"
		"this StoichiometryMath is set, @c false otherwise.\n"
		"\n"
		"The StoichiometryMath construct exists only in SBML Level&nbsp;2.  It\n"
		"is an optional construct available for defining the stoichiometries of\n"
		"reactants and products in Reaction objects.  Note that a different\n"
		"mechanism is used in SBML Level&nbsp;3, where StoichiometryMath is not\n"
		"available.  Please consult the top of this libSBML StoichiometryMath\n"
		"documentation for more information about the differences between SBML\n"
		"Level&nbsp;2 and&nbsp;3 with respect to stoichiometries.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_setMath", _wrap_StoichiometryMath_setMath, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_setMath(StoichiometryMath self, ASTNode math) -> int\n"
		"\n"
		"Sets the 'math' expression of this StoichiometryMath instance to a\n"
		"copy of the given ASTNode.\n"
		"\n"
		"@param math an ASTNode representing a formula tree.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"The StoichiometryMath construct exists only in SBML Level&nbsp;2.  It\n"
		"is an optional construct available for defining the stoichiometries of\n"
		"reactants and products in Reaction objects.  Note that a different\n"
		"mechanism is used in SBML Level&nbsp;3, where StoichiometryMath is not\n"
		"available.  Please consult the top of this libSBML StoichiometryMath\n"
		"documentation for more information about the differences between SBML\n"
		"Level&nbsp;2 and&nbsp;3 with respect to stoichiometries.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_getDerivedUnitDefinition", _wrap_StoichiometryMath_getDerivedUnitDefinition, METH_VARARGS, (char *)"\n"
		"getDerivedUnitDefinition() -> UnitDefinition\n"
		"StoichiometryMath_getDerivedUnitDefinition(StoichiometryMath self) -> UnitDefinition\n"
		"\n"
		"Calculates and returns a UnitDefinition object that expresses the\n"
		"units returned by the math expression in this StoichiometryMath\n"
		"object.\n"
		"\n"
		"The units are calculated based on the mathematical expression in the\n"
		"StoichiometryMath and the model quantities referenced by\n"
		"<code>&lt;ci&gt;</code> elements used within that expression.  The\n"
		"StoichiometryMath.getDerivedUnitDefinition() method returns the\n"
		"calculated units.\n"
		"\n"
		"Note that the functionality that facilitates unit analysis depends \n"
		"on the model as a whole.  Thus, in cases where the object has not \n"
		"been added to a model or the model itself is incomplete,\n"
		"unit analysis is not possible and this method will return @c None.\n"
		"\n"
		"@warning Note that it is possible the 'math' expression in the\n"
		"StoichiometryMath instance contains literal numbers or parameters with\n"
		"undeclared units.  In those cases, it is not possible to calculate the\n"
		"units of the overall expression without making assumptions.  LibSBML\n"
		"does not make assumptions about the units, and\n"
		"StoichiometryMath.getDerivedUnitDefinition() only returns the units\n"
		"as far as it is able to determine them.  For example, in an expression\n"
		"<em>X + Y</em>, if <em>X</em> has unambiguously-defined units and\n"
		"<em>Y</em> does not, it will return the units of <em>X</em>.  When\n"
		"using this method, <strong>it is critical that callers also invoke the\n"
		"method</strong> StoichiometryMath.containsUndeclaredUnits()\n"
		"<strong>to determine whether this situation holds</strong>.  Callers\n"
		"should take suitable action in those situations.\n"
		"\n"
		"@return a UnitDefinition that expresses the units of the math, \n"
		"or @c None if one cannot be constructed.\n"
		"\n"
		"@see containsUndeclaredUnits()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_containsUndeclaredUnits", _wrap_StoichiometryMath_containsUndeclaredUnits, METH_VARARGS, (char *)"\n"
		"containsUndeclaredUnits() -> bool\n"
		"StoichiometryMath_containsUndeclaredUnits(StoichiometryMath self) -> bool\n"
		"\n"
		"Predicate returning @c true if the math\n"
		"expression of this StoichiometryMath object contains literal numbers\n"
		"or parameters with undeclared units.\n"
		"\n"
		"The StoichiometryMath.getDerivedUnitDefinition() method returns what\n"
		"libSBML computes the units of the Stoichiometry to be, to the extent\n"
		"that libSBML can compute them.  However, if the expression contains\n"
		"literal numbers or parameters with undeclared units, libSBML may not\n"
		"be able to compute the full units of the expression and will only\n"
		"return what it can compute.  Callers should always use\n"
		"StoichiometryMath.containsUndeclaredUnits() when using\n"
		"StoichiometryMath.getDerivedUnitDefinition() to decide whether the\n"
		"returned units may be incomplete.\n"
		"\n"
		"@return @c true if the math expression of this StoichiometryMath\n"
		"includes numbers/parameters with undeclared units, @c false otherwise.\n"
		"\n"
		"@note A return value of @c true indicates that the UnitDefinition\n"
		"returned by StoichiometryMath.getDerivedUnitDefinition() may not\n"
		"accurately represent the units of the expression.\n"
		"\n"
		"@see getDerivedUnitDefinition()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_getTypeCode", _wrap_StoichiometryMath_getTypeCode, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_getTypeCode(StoichiometryMath self) -> SBMLTypeCode_t\n"
		"\n"
		"Returns the libSBML type code of this object instance.\n"
		"\n"
		"@if clike LibSBML attaches an identifying code to every kind of SBML\n"
		"object.  These are known as <em>SBML type codes</em>.  The set of\n"
		"possible type codes is defined in the enumeration #SBMLTypeCode_t.\n"
		"The names of the type codes all begin with the characters @c\n"
		"SBML_. @endif@if java LibSBML attaches an identifying code to every\n"
		"kind of SBML object.  These are known as <em>SBML type codes</em>.  In\n"
		"other languages, the set of type codes is stored in an enumeration; in\n"
		"the Java language interface for libSBML, the type codes are defined as\n"
		"static integer constants in the interface class {@link\n"
		"libsbmlConstants}.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if python LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the Python language interface for libSBML, the type\n"
		"codes are defined as static integer constants in the interface class\n"
		"@link libsbml@endlink.  The names of the type codes all begin with the\n"
		"characters @c SBML_. @endif@if csharp LibSBML attaches an identifying\n"
		"code to every kind of SBML object.  These are known as <em>SBML type\n"
		"codes</em>.  In the C# language interface for libSBML, the type codes\n"
		"are defined as static integer constants in the interface class @link\n"
		"libsbml.libsbml@endlink.  The names of the type codes all begin with\n"
		"the characters @c SBML_. @endif\n"
		"\n"
		"@return the SBML type code for this object, or @link libsbml.SBML_UNKNOWN SBML_UNKNOWN@endlink (default).\n"
		"\n"
		"@see getElementName()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_getElementName", _wrap_StoichiometryMath_getElementName, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_getElementName(StoichiometryMath self) -> string\n"
		"\n"
		"Returns the XML element name of this object, which for StoichiometryMath, is\n"
		"always @c 'stoichiometryMath'.\n"
		"\n"
		"@return the name of this element, i.e., @c 'stoichiometryMath'. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_hasRequiredElements", _wrap_StoichiometryMath_hasRequiredElements, METH_VARARGS, (char *)"\n"
		"StoichiometryMath_hasRequiredElements(StoichiometryMath self) -> bool\n"
		"\n"
		"Predicate returning @c true if\n"
		"all the required elements for this StoichiometryMath object\n"
		"have been set.\n"
		"\n"
		"@note The required elements for a StoichiometryMath object are:\n"
		"@li 'math'\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"StoichiometryMath_swigregister", StoichiometryMath_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_SBMLNamespaces", _wrap_delete_SBMLNamespaces, METH_VARARGS, (char *)"delete_SBMLNamespaces(SBMLNamespaces self)"},
	 { (char *)"new_SBMLNamespaces", _wrap_new_SBMLNamespaces, METH_VARARGS, (char *)"\n"
		"SBMLNamespaces(unsigned int level = 3, unsigned int version = 1)\n"
		"SBMLNamespaces(unsigned int level = 3)\n"
		"SBMLNamespaces()\n"
		"new_SBMLNamespaces(SBMLNamespaces orig) -> SBMLNamespaces\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>SBMLNamespaces(long level = SBML_DEFAULT_LEVEL, long version = SBML_DEFAULT_VERSION)</pre>\n"
		"\n"
		"Creates a new SBMLNamespaces object corresponding to the given SBML\n"
		"@p level and @p version.\n"
		"\n"
		"SBMLNamespaces objects are used in libSBML to communicate SBML Level\n"
		"and Version data between constructors and other methods.  The\n"
		"SBMLNamespaces object class tracks 3-tuples (triples) consisting of\n"
		"SBML Level, Version, and the corresponding SBML XML namespace.  Most\n"
		"constructors for SBML objects in libSBML take a SBMLNamespaces object\n"
		"as an argument, thereby allowing the constructor to produce the proper\n"
		"combination of attributes and other internal data structures for the\n"
		"given SBML Level and Version.\n"
		"\n"
		"The plural name (SBMLNamespaces) is not a mistake, because in SBML\n"
		"Level&nbsp;3, objects may have extensions added by Level&nbsp;3\n"
		"packages used by a given model and therefore may have multiple\n"
		"namespaces associated with them; however, until the introduction of\n"
		"SBML Level&nbsp;3, the SBMLNamespaces object only records one SBML\n"
		"Level/Version/namespace combination at a time.  Most constructors for\n"
		"SBML objects in libSBML take a SBMLNamespaces object as an argument,\n"
		"thereby allowing the constructor to produce the proper combination of\n"
		"attributes and other internal data structures for the given SBML Level\n"
		"and Version.\n"
		"\n"
		"@param level the SBML level\n"
		"@param version the SBML version\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>SBMLNamespaces(SBMLNamespaces orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of a SBMLNamespaces.\n"
		"\n"
		"@param orig the SBMLNamespaces instance to copy.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_clone", _wrap_SBMLNamespaces_clone, METH_VARARGS, (char *)"\n"
		"SBMLNamespaces_clone(SBMLNamespaces self) -> SBMLNamespaces\n"
		"\n"
		"Creates and returns a deep copy of this SBMLNamespaces.\n"
		"\n"
		"@return a (deep) copy of this SBMLNamespaces.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_getSBMLNamespaceURI", _wrap_SBMLNamespaces_getSBMLNamespaceURI, METH_VARARGS, (char *)"\n"
		"SBMLNamespaces_getSBMLNamespaceURI(unsigned int level, unsigned int version) -> string\n"
		"\n"
		"Returns a string representing the SBML XML namespace for the \n"
		"given @p level and @p version of SBML.\n"
		"\n"
		"@param level the SBML level\n"
		"@param version the SBML version\n"
		"\n"
		"@return a string representing the SBML namespace that reflects the\n"
		"SBML Level and Version specified.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_getSupportedNamespaces", _wrap_SBMLNamespaces_getSupportedNamespaces, METH_VARARGS, (char *)"\n"
		"SBMLNamespaces_getSupportedNamespaces() -> List\n"
		"\n"
		"Returns a list of all supported SBMLNamespaces in this version of \n"
		"libsbml. \n"
		"\n"
		"@return a list with supported SBML namespaces. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_getLevel", _wrap_SBMLNamespaces_getLevel, METH_VARARGS, (char *)"\n"
		"getLevel() -> unsigned int\n"
		"SBMLNamespaces_getLevel(SBMLNamespaces self) -> unsigned int\n"
		"\n"
		"Get the SBML Level of this SBMLNamespaces object.\n"
		"\n"
		"@return the SBML Level of this SBMLNamespaces object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_getVersion", _wrap_SBMLNamespaces_getVersion, METH_VARARGS, (char *)"\n"
		"getVersion() -> unsigned int\n"
		"SBMLNamespaces_getVersion(SBMLNamespaces self) -> unsigned int\n"
		"\n"
		"Get the SBML Version of this SBMLNamespaces object.\n"
		"\n"
		"@return the SBML Version of this SBMLNamespaces object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_getNamespaces", _wrap_SBMLNamespaces_getNamespaces, METH_VARARGS, (char *)"\n"
		"getNamespaces() -> XMLNamespaces\n"
		"SBMLNamespaces_getNamespaces(SBMLNamespaces self) -> XMLNamespaces\n"
		"\n"
		"Get the XML namespaces list for this SBMLNamespaces object.\n"
		"\n"
		"@return the XML namespaces of this SBMLNamespaces object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_addNamespaces", _wrap_SBMLNamespaces_addNamespaces, METH_VARARGS, (char *)"\n"
		"SBMLNamespaces_addNamespaces(SBMLNamespaces self, XMLNamespaces xmlns)\n"
		"\n"
		"Add the given XML namespaces list to the set of namespaces within this\n"
		"SBMLNamespaces object.\n"
		"\n"
		"The following code gives an example of how one could add the XHTML\n"
		"namespace to the list of namespaces recorded by the top-level\n"
		"<code>&lt;sbml&gt;</code> element of a model.  It gives the new\n"
		"namespace a prefix of <code>html</code>.  @if clike\n"
		"  @verbatim\n"
		" SBMLDocumentsd;\n"
		" try \n"
		" {\n"
		"     sd = new SBMLDocument(3, 1);\n"
		" } \n"
		" catch (SBMLConstructorException e)\n"
		" {\n"
		"     // Here, have code to handle a truly exceptional situation. Candidate\n"
		"     // causes include invalid combinations of SBML Level and Version\n"
		"     // (impossible if hardwired as given here), running out of memory, and\n"
		"     // unknown system exceptions.\n"
		" }\n"
		"\n"
		" SBMLNamespaces sn = sd->getNamespaces();\n"
		" if (sn != None)\n"
		" {\n"
		"     sn->add('http://www.w3.org/1999/xhtml', 'html');\n"
		" }\n"
		" else\n"
		" {\n"
		"     // Handle another truly exceptional situation.\n"
		" }\n"
		" @endverbatim\n"
		"@endif@if java\n"
		" @verbatim\n"
		" SBMLDocument sd;\n"
		" try \n"
		" {\n"
		"     sd = new SBMLDocument(3, 1);\n"
		" } \n"
		" catch (SBMLConstructorException e)\n"
		" {\n"
		"     // Here, have code to handle a truly exceptional situation. Candidate\n"
		"     // causes include invalid combinations of SBML Level and Version\n"
		"     // (impossible if hardwired as given here), running out of memory, and\n"
		"     // unknown system exceptions.\n"
		" }\n"
		"\n"
		" SBMLNamespaces sn = sd.getNamespaces();\n"
		" if (sn != null)\n"
		" {\n"
		"     sn.add('http://www.w3.org/1999/xhtml', 'html');\n"
		" }\n"
		" else\n"
		" {\n"
		"     // Handle another truly exceptional situation.\n"
		"  }\n"
		" @endverbatim\n"
		"@endif@if python\n"
		" @verbatim\n"
		" sbmlDoc = SBMLDocument(3, 1)\n"
		" if sbmlDoc == None:\n"
		"   # Do something to handle exceptional situation.  Candidate\n"
		"   # causes include invalid combinations of SBML Level and Version\n"
		"   # (impossible if hardwired as given here), running out of memory, and\n"
		"   # unknown system exceptions.\n"
		"\n"
		" namespaces = sbmlDoc.getNamespaces()\n"
		" if namespaces == None:\n"
		"   # Do something to handle exceptional situation.\n"
		"\n"
		" status = namespaces.add('http://www.w3.org/1999/xhtml', 'html')\n"
		" if status != LIBSBML_OPERATION_SUCCESS:\n"
		"   # Do something to handle exceptional situation.\n"
		" @endverbatim\n"
		"@endif@if csharp\n"
		" @verbatim\n"
		" SBMLDocument sd = null;\n"
		" try\n"
		" {\n"
		"     sd = new SBMLDocument(3, 1);\n"
		" }\n"
		" catch (SBMLConstructorException e)\n"
		" {\n"
		"     // Here, have code to handle a truly exceptional situation.\n"
		"     // Candidate causes include invalid combinations of SBML\n"
		"     // Level and Version (impossible if hardwired as given here),\n"
		"     // running out of memory, and unknown system exceptions.\n"
		" }\n"
		"\n"
		" XMLNamespaces sn = sd.getNamespaces();\n"
		" if (sn != null)\n"
		" {\n"
		"     sn.add('http://www.w3.org/1999/xhtml', 'html');            \n"
		" }\n"
		" else\n"
		" {\n"
		"     // Handle another truly exceptional situation.\n"
		" }\n"
		" @endverbatim\n"
		"@endif\n"
		"\n"
		"@param xmlns the XML namespaces to be added.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_addPackagePrefix", _wrap_SBMLNamespaces_addPackagePrefix, METH_VARARGS, (char *)"\n"
		"SBMLNamespaces_addPackagePrefix(SBMLNamespaces self, string package_prefix)\n"
		"\n"
		"@internal\n"
		"dd the given XML namespaces list to the set of namespaces within this\n"
		"BMLNamespaces object.\n"
		"\n"
		"he following code gives an example of how one could add the XHTML\n"
		"amespace to the list of namespaces recorded by the top-level\n"
		"code>&lt;sbml&gt;</code> element of a model.  It gives the new\n"
		"amespace a prefix of <code>html</code>.  @if clike\n"
		" @verbatim\n"
		"SBMLDocumentsd;\n"
		"try \n"
		"{\n"
		"    sd = new SBMLDocument(3, 1);\n"
		"} \n"
		"catch (SBMLConstructorException e)\n"
		"{\n"
		"    // Here, have code to handle a truly exceptional situation. Candidate\n"
		"    // causes include invalid combinations of SBML Level and Version\n"
		"    // (impossible if hardwired as given here), running out of memory, and\n"
		"    // unknown system exceptions.\n"
		"}\n"
		"\n"
		"SBMLNamespaces sn = sd->getNamespaces();\n"
		"if (sn != None)\n"
		"{\n"
		"    sn->add('http://www.w3.org/1999/xhtml', 'html');\n"
		"}\n"
		"else\n"
		"{\n"
		"    // Handle another truly exceptional situation.\n"
		"}\n"
		"@endverbatim\n"
		"endif@if java\n"
		"@verbatim\n"
		"SBMLDocument sd;\n"
		"try \n"
		"{\n"
		"    sd = new SBMLDocument(3, 1);\n"
		"} \n"
		"catch (SBMLConstructorException e)\n"
		"{\n"
		"    // Here, have code to handle a truly exceptional situation. Candidate\n"
		"    // causes include invalid combinations of SBML Level and Version\n"
		"    // (impossible if hardwired as given here), running out of memory, and\n"
		"    // unknown system exceptions.\n"
		"}\n"
		"\n"
		"SBMLNamespaces sn = sd.getNamespaces();\n"
		"if (sn != null)\n"
		"{\n"
		"    sn.add('http://www.w3.org/1999/xhtml', 'html');\n"
		"}\n"
		"else\n"
		"{\n"
		"    // Handle another truly exceptional situation.\n"
		" }\n"
		"@endverbatim\n"
		"endif@if python\n"
		"@verbatim\n"
		"sbmlDoc = SBMLDocument(3, 1)\n"
		"if sbmlDoc == None:\n"
		"  # Do something to handle exceptional situation.  Candidate\n"
		"  # causes include invalid combinations of SBML Level and Version\n"
		"  # (impossible if hardwired as given here), running out of memory, and\n"
		"  # unknown system exceptions.\n"
		"\n"
		"namespaces = sbmlDoc.getNamespaces()\n"
		"if namespaces == None:\n"
		"  # Do something to handle exceptional situation.\n"
		"\n"
		"status = namespaces.add('http://www.w3.org/1999/xhtml', 'html')\n"
		"if status != LIBSBML_OPERATION_SUCCESS:\n"
		"  # Do something to handle exceptional situation.\n"
		"@endverbatim\n"
		"endif@if csharp\n"
		"@verbatim\n"
		"SBMLDocument sd = null;\n"
		"try\n"
		"{\n"
		"    sd = new SBMLDocument(3, 1);\n"
		"}\n"
		"catch (SBMLConstructorException e)\n"
		"{\n"
		"    // Here, have code to handle a truly exceptional situation.\n"
		"    // Candidate causes include invalid combinations of SBML\n"
		"    // Level and Version (impossible if hardwired as given here),\n"
		"    // running out of memory, and unknown system exceptions.\n"
		"}\n"
		"\n"
		"XMLNamespaces sn = sd.getNamespaces();\n"
		"if (sn != null)\n"
		"{\n"
		"    sn.add('http://www.w3.org/1999/xhtml', 'html');            \n"
		"}\n"
		"else\n"
		"{\n"
		"    // Handle another truly exceptional situation.\n"
		"}\n"
		"@endverbatim\n"
		"endif\n"
		"\n"
		"param xmlns the XML namespaces to be added.\n"
		" \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_getPackagePrefix", _wrap_SBMLNamespaces_getPackagePrefix, METH_VARARGS, (char *)"\n"
		"SBMLNamespaces_getPackagePrefix(SBMLNamespaces self, unsigned int index) -> string\n"
		"\n"
		"@internal\n"
		"dd the given XML namespaces list to the set of namespaces within this\n"
		"BMLNamespaces object.\n"
		"\n"
		"he following code gives an example of how one could add the XHTML\n"
		"amespace to the list of namespaces recorded by the top-level\n"
		"code>&lt;sbml&gt;</code> element of a model.  It gives the new\n"
		"amespace a prefix of <code>html</code>.  @if clike\n"
		" @verbatim\n"
		"SBMLDocumentsd;\n"
		"try \n"
		"{\n"
		"    sd = new SBMLDocument(3, 1);\n"
		"} \n"
		"catch (SBMLConstructorException e)\n"
		"{\n"
		"    // Here, have code to handle a truly exceptional situation. Candidate\n"
		"    // causes include invalid combinations of SBML Level and Version\n"
		"    // (impossible if hardwired as given here), running out of memory, and\n"
		"    // unknown system exceptions.\n"
		"}\n"
		"\n"
		"SBMLNamespaces sn = sd->getNamespaces();\n"
		"if (sn != None)\n"
		"{\n"
		"    sn->add('http://www.w3.org/1999/xhtml', 'html');\n"
		"}\n"
		"else\n"
		"{\n"
		"    // Handle another truly exceptional situation.\n"
		"}\n"
		"@endverbatim\n"
		"endif@if java\n"
		"@verbatim\n"
		"SBMLDocument sd;\n"
		"try \n"
		"{\n"
		"    sd = new SBMLDocument(3, 1);\n"
		"} \n"
		"catch (SBMLConstructorException e)\n"
		"{\n"
		"    // Here, have code to handle a truly exceptional situation. Candidate\n"
		"    // causes include invalid combinations of SBML Level and Version\n"
		"    // (impossible if hardwired as given here), running out of memory, and\n"
		"    // unknown system exceptions.\n"
		"}\n"
		"\n"
		"SBMLNamespaces sn = sd.getNamespaces();\n"
		"if (sn != null)\n"
		"{\n"
		"    sn.add('http://www.w3.org/1999/xhtml', 'html');\n"
		"}\n"
		"else\n"
		"{\n"
		"    // Handle another truly exceptional situation.\n"
		" }\n"
		"@endverbatim\n"
		"endif@if python\n"
		"@verbatim\n"
		"sbmlDoc = SBMLDocument(3, 1)\n"
		"if sbmlDoc == None:\n"
		"  # Do something to handle exceptional situation.  Candidate\n"
		"  # causes include invalid combinations of SBML Level and Version\n"
		"  # (impossible if hardwired as given here), running out of memory, and\n"
		"  # unknown system exceptions.\n"
		"\n"
		"namespaces = sbmlDoc.getNamespaces()\n"
		"if namespaces == None:\n"
		"  # Do something to handle exceptional situation.\n"
		"\n"
		"status = namespaces.add('http://www.w3.org/1999/xhtml', 'html')\n"
		"if status != LIBSBML_OPERATION_SUCCESS:\n"
		"  # Do something to handle exceptional situation.\n"
		"@endverbatim\n"
		"endif@if csharp\n"
		"@verbatim\n"
		"SBMLDocument sd = null;\n"
		"try\n"
		"{\n"
		"    sd = new SBMLDocument(3, 1);\n"
		"}\n"
		"catch (SBMLConstructorException e)\n"
		"{\n"
		"    // Here, have code to handle a truly exceptional situation.\n"
		"    // Candidate causes include invalid combinations of SBML\n"
		"    // Level and Version (impossible if hardwired as given here),\n"
		"    // running out of memory, and unknown system exceptions.\n"
		"}\n"
		"\n"
		"XMLNamespaces sn = sd.getNamespaces();\n"
		"if (sn != null)\n"
		"{\n"
		"    sn.add('http://www.w3.org/1999/xhtml', 'html');            \n"
		"}\n"
		"else\n"
		"{\n"
		"    // Handle another truly exceptional situation.\n"
		"}\n"
		"@endverbatim\n"
		"endif\n"
		"\n"
		"param xmlns the XML namespaces to be added.\n"
		" \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_containsPackagePrefix", _wrap_SBMLNamespaces_containsPackagePrefix, METH_VARARGS, (char *)"\n"
		"SBMLNamespaces_containsPackagePrefix(SBMLNamespaces self, string package_prefix) -> bool\n"
		"\n"
		"@internal\n"
		"dd the given XML namespaces list to the set of namespaces within this\n"
		"BMLNamespaces object.\n"
		"\n"
		"he following code gives an example of how one could add the XHTML\n"
		"amespace to the list of namespaces recorded by the top-level\n"
		"code>&lt;sbml&gt;</code> element of a model.  It gives the new\n"
		"amespace a prefix of <code>html</code>.  @if clike\n"
		" @verbatim\n"
		"SBMLDocumentsd;\n"
		"try \n"
		"{\n"
		"    sd = new SBMLDocument(3, 1);\n"
		"} \n"
		"catch (SBMLConstructorException e)\n"
		"{\n"
		"    // Here, have code to handle a truly exceptional situation. Candidate\n"
		"    // causes include invalid combinations of SBML Level and Version\n"
		"    // (impossible if hardwired as given here), running out of memory, and\n"
		"    // unknown system exceptions.\n"
		"}\n"
		"\n"
		"SBMLNamespaces sn = sd->getNamespaces();\n"
		"if (sn != None)\n"
		"{\n"
		"    sn->add('http://www.w3.org/1999/xhtml', 'html');\n"
		"}\n"
		"else\n"
		"{\n"
		"    // Handle another truly exceptional situation.\n"
		"}\n"
		"@endverbatim\n"
		"endif@if java\n"
		"@verbatim\n"
		"SBMLDocument sd;\n"
		"try \n"
		"{\n"
		"    sd = new SBMLDocument(3, 1);\n"
		"} \n"
		"catch (SBMLConstructorException e)\n"
		"{\n"
		"    // Here, have code to handle a truly exceptional situation. Candidate\n"
		"    // causes include invalid combinations of SBML Level and Version\n"
		"    // (impossible if hardwired as given here), running out of memory, and\n"
		"    // unknown system exceptions.\n"
		"}\n"
		"\n"
		"SBMLNamespaces sn = sd.getNamespaces();\n"
		"if (sn != null)\n"
		"{\n"
		"    sn.add('http://www.w3.org/1999/xhtml', 'html');\n"
		"}\n"
		"else\n"
		"{\n"
		"    // Handle another truly exceptional situation.\n"
		" }\n"
		"@endverbatim\n"
		"endif@if python\n"
		"@verbatim\n"
		"sbmlDoc = SBMLDocument(3, 1)\n"
		"if sbmlDoc == None:\n"
		"  # Do something to handle exceptional situation.  Candidate\n"
		"  # causes include invalid combinations of SBML Level and Version\n"
		"  # (impossible if hardwired as given here), running out of memory, and\n"
		"  # unknown system exceptions.\n"
		"\n"
		"namespaces = sbmlDoc.getNamespaces()\n"
		"if namespaces == None:\n"
		"  # Do something to handle exceptional situation.\n"
		"\n"
		"status = namespaces.add('http://www.w3.org/1999/xhtml', 'html')\n"
		"if status != LIBSBML_OPERATION_SUCCESS:\n"
		"  # Do something to handle exceptional situation.\n"
		"@endverbatim\n"
		"endif@if csharp\n"
		"@verbatim\n"
		"SBMLDocument sd = null;\n"
		"try\n"
		"{\n"
		"    sd = new SBMLDocument(3, 1);\n"
		"}\n"
		"catch (SBMLConstructorException e)\n"
		"{\n"
		"    // Here, have code to handle a truly exceptional situation.\n"
		"    // Candidate causes include invalid combinations of SBML\n"
		"    // Level and Version (impossible if hardwired as given here),\n"
		"    // running out of memory, and unknown system exceptions.\n"
		"}\n"
		"\n"
		"XMLNamespaces sn = sd.getNamespaces();\n"
		"if (sn != null)\n"
		"{\n"
		"    sn.add('http://www.w3.org/1999/xhtml', 'html');            \n"
		"}\n"
		"else\n"
		"{\n"
		"    // Handle another truly exceptional situation.\n"
		"}\n"
		"@endverbatim\n"
		"endif\n"
		"\n"
		"param xmlns the XML namespaces to be added.\n"
		" \n"
		"\n"
		""},
	 { (char *)"SBMLNamespaces_swigregister", SBMLNamespaces_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_SBMLTransforms", _wrap_new_SBMLTransforms, METH_VARARGS, (char *)"new_SBMLTransforms() -> SBMLTransforms"},
	 { (char *)"delete_SBMLTransforms", _wrap_delete_SBMLTransforms, METH_VARARGS, (char *)"delete_SBMLTransforms(SBMLTransforms self)"},
	 { (char *)"SBMLTransforms_swigregister", SBMLTransforms_swigregister, METH_VARARGS, NULL},
	 { (char *)"readMathMLFromString", _wrap_readMathMLFromString, METH_VARARGS, (char *)"\n"
		"readMathMLFromString(char xml) -> ASTNode_t\n"
		"\n"
		"Reads the MathML from the given XML string, constructs a corresponding\n"
		"abstract syntax tree, and returns a pointer to the root of the tree.\n"
		"\n"
		"@param xml a string containing a full MathML expression\n"
		"\n"
		"@return the root of an AST corresponding to the given mathematical\n"
		"expression, otherwise @c None is returned if the given string is @c None\n"
		"or invalid.\n"
		"\n"
		"\n"
		""},
	 { (char *)"writeMathMLToString", _wrap_writeMathMLToString, METH_VARARGS, (char *)"\n"
		"writeMathMLToString(ASTNode_t node) -> char\n"
		"\n"
		"Writes the given ASTNode (and its children) to a string as MathML, and\n"
		"returns the string.\n"
		"\n"
		"@param node the root of an AST to write out to the stream.\n"
		"\n"
		"@return a string containing the written-out MathML representation\n"
		"of the given AST.\n"
		"\n"
		"@note The string is owned by the caller and should be freed (with\n"
		"free()) when no longer needed.  @c None is returned if the given\n"
		"argument is @c None.\n"
		"\n"
		"\n"
		""},
	 { (char *)"new_ASTNode", _wrap_new_ASTNode, METH_VARARGS, (char *)"\n"
		"ASTNode(ASTNodeType_t type = AST_UNKNOWN)\n"
		"ASTNode()\n"
		"new_ASTNode(ASTNode orig) -> ASTNode\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>ASTNode(ASTNodeType_t type = AST_UNKNOWN)</pre>\n"
		"\n"
		"Creates and returns a new ASTNode.\n"
		"\n"
		"Unless the argument @p type is given, the returned node will by\n"
		"default have a type of @link libsbml.AST_UNKNOWN\n"
		"AST_UNKNOWN@endlink.  If the type isn't supplied when caling this\n"
		"constructor, the caller should set the node type to something else as\n"
		"soon as possible using\n"
		"@if clike setType()@else ASTNode.setType()@endif.\n"
		"\n"
		"@param type an optional\n"
		"@if clike @link #ASTNodeType_t ASTNodeType_t@endlink@else type@endif\n"
		"code indicating the type of node to create.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>ASTNode(Token_t *token)</pre>\n"
		"\n"
		"Creates a new ASTNode from the given Token.  The resulting ASTNode\n"
		"will contain the same data as the Token.\n"
		"\n"
		"@param token the Token to add.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>ASTNode(ASTNode orig)</pre>\n"
		"\n"
		"Copy constructor; creates a deep copy of the given ASTNode.\n"
		"\n"
		"@param orig the ASTNode to be copied.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_ASTNode", _wrap_delete_ASTNode, METH_VARARGS, (char *)"delete_ASTNode(ASTNode self)"},
	 { (char *)"ASTNode_freeName", _wrap_ASTNode_freeName, METH_VARARGS, (char *)"\n"
		"ASTNode_freeName(ASTNode self) -> int\n"
		"\n"
		"Frees the name of this ASTNode and sets it to @c None.\n"
		"\n"
		"This operation is only applicable to ASTNode objects corresponding to\n"
		"operators, numbers, or @link libsbml.AST_UNKNOWN\n"
		"AST_UNKNOWN@endlink.  This method has no effect on other types of\n"
		"nodes.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_canonicalize", _wrap_ASTNode_canonicalize, METH_VARARGS, (char *)"\n"
		"ASTNode_canonicalize(ASTNode self) -> bool\n"
		"\n"
		"Converts this ASTNode to a canonical form and returns @c true if\n"
		"successful, @c false otherwise.\n"
		"\n"
		"The rules determining the canonical form conversion are as follows:\n"
		"<ul>\n"
		"\n"
		"<li> If the node type is @link libsbml.AST_NAME AST_NAME@endlink\n"
		"and the node name matches @c 'ExponentialE', @c 'Pi', @c 'True' or @c\n"
		"'False' the node type is converted to the corresponding \n"
		"<code>AST_CONSTANT_</code><em><span class='placeholder'>X</span></em> type.\n"
		"\n"
		"<li> If the node type is an @link libsbml.AST_FUNCTION\n"
		"AST_FUNCTION@endlink and the node name matches an SBML (MathML) function name, logical operator name, or\n"
		"relational operator name, the node is converted to the corresponding\n"
		"<code>AST_FUNCTION_</code><em><span class='placeholder'>X</span></em> or\n"
		"<code>AST_LOGICAL_</code><em><span class='placeholder'>X</span></em> type.\n"
		"\n"
		"</ul>\n"
		"\n"
		"SBML Level&nbsp;1 function names are searched first; thus, for\n"
		"example, canonicalizing @c log will result in a node type of @link\n"
		"libsbml.AST_FUNCTION_LN AST_FUNCTION_LN@endlink.  (See the SBML\n"
		"Level&nbsp;1 Version&nbsp;2 Specification, Appendix C.)\n"
		"\n"
		"Sometimes, canonicalization of a node results in a structural\n"
		"conversion of the node as a result of adding a child.  For example, a\n"
		"node with the SBML Level&nbsp;1 function name @c sqr and a single\n"
		"child node (the argument) will be transformed to a node of type\n"
		"@link libsbml.AST_FUNCTION_POWER AST_FUNCTION_POWER@endlink with\n"
		"two children.  The first child will remain unchanged, but the second\n"
		"child will be an ASTNode of type @link libsbml.AST_INTEGER\n"
		"AST_INTEGER@endlink and a value of 2.  The function names that result\n"
		"in structural changes are: @c log10, @c sqr, and @c sqrt.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_addChild", _wrap_ASTNode_addChild, METH_VARARGS, (char *)"\n"
		"ASTNode_addChild(ASTNode self, ASTNode child) -> int\n"
		"\n"
		"Adds the given node as a child of this ASTNode.  Child nodes are added\n"
		"in-order, from left to right.\n"
		"\n"
		"@param child the ASTNode instance to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note Adding a child to an ASTNode may change the structure of the\n"
		"mathematical formula being represented by the tree structure, and may\n"
		"render the representation invalid.  Callers need to be careful to use\n"
		"this method in the context of other operations to create complete and\n"
		"correct formulas.  The method\n"
		"@if clike isWellFormedASTNode()@else ASTNode.isWellFormedASTNode()@endif\n"
		"may also be useful for checking the results of node modifications.\n"
		"\n"
		"@see prependChild()\n"
		"@see replaceChild()\n"
		"@see insertChild()\n"
		"@see removeChild()\n"
		"@see isWellFormedASTNode()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_prependChild", _wrap_ASTNode_prependChild, METH_VARARGS, (char *)"\n"
		"ASTNode_prependChild(ASTNode self, ASTNode child) -> int\n"
		"\n"
		"Adds the given node as a child of this ASTNode.  This method adds\n"
		"child nodes from right to left.\n"
		"\n"
		"@param child the ASTNode instance to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note Prepending a child to an ASTNode may change the structure of the\n"
		"mathematical formula being represented by the tree structure, and may\n"
		"render the representation invalid.\n"
		"\n"
		"@see addChild()\n"
		"@see replaceChild()\n"
		"@see insertChild()\n"
		"@see removeChild()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_removeChild", _wrap_ASTNode_removeChild, METH_VARARGS, (char *)"\n"
		"ASTNode_removeChild(ASTNode self, unsigned int n) -> int\n"
		"\n"
		"Removes the nth child of this ASTNode object.\n"
		"\n"
		"@param n long the index of the child to remove\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"\n"
		"@note Removing a child from an ASTNode may change the structure of the\n"
		"mathematical formula being represented by the tree structure, and may\n"
		"render the representation invalid.\n"
		"\n"
		"@see addChild()\n"
		"@see prependChild()\n"
		"@see replaceChild()\n"
		"@see insertChild()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_replaceChild", _wrap_ASTNode_replaceChild, METH_VARARGS, (char *)"\n"
		"ASTNode_replaceChild(ASTNode self, unsigned int n, ASTNode newChild) -> int\n"
		"\n"
		"Replaces the nth child of this ASTNode with the given ASTNode.\n"
		"\n"
		"@param n long the index of the child to replace\n"
		"@param newChild ASTNode to replace the nth child\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note Replacing a child from an ASTNode may change the structure of the\n"
		"mathematical formula being represented by the tree structure, and may\n"
		"render the representation invalid.\n"
		"\n"
		"@see addChild()\n"
		"@see prependChild()\n"
		"@see insertChild()\n"
		"@see removeChild()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_insertChild", _wrap_ASTNode_insertChild, METH_VARARGS, (char *)"\n"
		"ASTNode_insertChild(ASTNode self, unsigned int n, ASTNode newChild) -> int\n"
		"\n"
		"Insert the given ASTNode at point n in the list of children\n"
		"of this ASTNode.\n"
		"\n"
		"@param n long the index of the ASTNode being added\n"
		"@param newChild ASTNode to insert as the nth child\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note Inserting a child into an ASTNode may change the structure of the\n"
		"mathematical formula being represented by the tree structure, and may\n"
		"render the representation invalid.\n"
		"\n"
		"@see addChild()\n"
		"@see prependChild()\n"
		"@see replaceChild()\n"
		"@see removeChild()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_deepCopy", _wrap_ASTNode_deepCopy, METH_VARARGS, (char *)"\n"
		"ASTNode_deepCopy(ASTNode self) -> ASTNode\n"
		"\n"
		"Creates a recursive copy of this node and all its children.\n"
		"\n"
		"@return a copy of this ASTNode and all its children.  The caller owns\n"
		"the returned ASTNode and is reponsible for deleting it.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getChild", _wrap_ASTNode_getChild, METH_VARARGS, (char *)"\n"
		"ASTNode_getChild(ASTNode self, unsigned int n) -> ASTNode\n"
		"\n"
		"Get a child of this node according to its index number.\n"
		"\n"
		"@param n the index of the child to get\n"
		"\n"
		"@return the nth child of this ASTNode or @c None if this node has no nth\n"
		"child (<code>n &gt; </code>\n"
		"@if clike getNumChildren()@else ASTNode.getNumChildren()@endif\n"
		"<code>- 1</code>).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getLeftChild", _wrap_ASTNode_getLeftChild, METH_VARARGS, (char *)"\n"
		"ASTNode_getLeftChild(ASTNode self) -> ASTNode\n"
		"\n"
		"Get the left child of this node.\n"
		"\n"
		"@return the left child of this ASTNode.  This is equivalent to calling\n"
		"@if clike getChild()@else ASTNode.getChild()@endif\n"
		"with an argument of @c 0.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getRightChild", _wrap_ASTNode_getRightChild, METH_VARARGS, (char *)"\n"
		"ASTNode_getRightChild(ASTNode self) -> ASTNode\n"
		"\n"
		"Get the right child of this node.\n"
		"\n"
		"@return the right child of this ASTNode, or @c None if this node has no\n"
		"right child.  If\n"
		"@if clike getNumChildren()@else ASTNode.getNumChildren()@endif\n"
		"<code>&gt; 1</code>, then this is equivalent to:\n"
		"@code\n"
		"getChild( getNumChildren() - 1 );\n"
		"@endcode\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getNumChildren", _wrap_ASTNode_getNumChildren, METH_VARARGS, (char *)"\n"
		"ASTNode_getNumChildren(ASTNode self) -> unsigned int\n"
		"\n"
		"Get the number of children that this node has.\n"
		"\n"
		"@return the number of children of this ASTNode, or 0 is this node has\n"
		"no children.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_addSemanticsAnnotation", _wrap_ASTNode_addSemanticsAnnotation, METH_VARARGS, (char *)"\n"
		"ASTNode_addSemanticsAnnotation(ASTNode self, XMLNode sAnnotation) -> int\n"
		"\n"
		"Adds the given XMLNode as a <em>semantic annotation</em> of this ASTNode.\n"
		"\n"
		"@htmlinclude about-semantic-annotations.html\n"
		"\n"
		"@param sAnnotation the annotation to add.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@note Although SBML permits the semantic annotation construct in\n"
		"MathML expressions, the truth is that this construct has so far (at\n"
		"this time of this writing, which is early 2011) seen very little use\n"
		"in SBML software.  The full implications of using semantic annotations\n"
		"are still poorly understood.  If you wish to use this construct, we\n"
		"urge you to discuss possible uses and applications on the SBML\n"
		"discussion lists, particularly <a target='_blank'\n"
		"href='http://sbml.org/Forums'>sbml-discuss&#64;caltech.edu</a> and/or <a\n"
		"target='_blank'\n"
		"href='http://sbml.org/Forums'>sbml-interoperability&#64;caltech.edu</a>.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getNumSemanticsAnnotations", _wrap_ASTNode_getNumSemanticsAnnotations, METH_VARARGS, (char *)"\n"
		"ASTNode_getNumSemanticsAnnotations(ASTNode self) -> unsigned int\n"
		"\n"
		"Get the number of <em>semantic annotation</em> elements inside this node.\n"
		"\n"
		"@htmlinclude about-semantic-annotations.html\n"
		"\n"
		"@return the number of annotations of this ASTNode.\n"
		"\n"
		"@see ASTNode.addSemanticsAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getSemanticsAnnotation", _wrap_ASTNode_getSemanticsAnnotation, METH_VARARGS, (char *)"\n"
		"ASTNode_getSemanticsAnnotation(ASTNode self, unsigned int n) -> XMLNode\n"
		"\n"
		"Get the nth semantic annotation of this node.\n"
		"\n"
		"@htmlinclude about-semantic-annotations.html\n"
		"\n"
		"@return the nth annotation of this ASTNode, or @c None if this node has\n"
		"no nth annotation (<code>n &gt;</code>\n"
		"@if clike getNumChildren()@else ASTNode.getNumChildren()@endif\n"
		"<code>- 1</code>).\n"
		"\n"
		"@see ASTNode.addSemanticsAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getCharacter", _wrap_ASTNode_getCharacter, METH_VARARGS, (char *)"\n"
		"ASTNode_getCharacter(ASTNode self) -> char\n"
		"\n"
		"Get the value of this node as a single character.  This function\n"
		"should be called only when\n"
		"@if clike getType()@else ASTNode.getType()@endif returns\n"
		"@link libsbml.AST_PLUS AST_PLUS@endlink,\n"
		"@link libsbml.AST_MINUS AST_MINUS@endlink,\n"
		"@link libsbml.AST_TIMES AST_TIMES@endlink,\n"
		"@link libsbml.AST_DIVIDE AST_DIVIDE@endlink or\n"
		"@link libsbml.AST_POWER AST_POWER@endlink.\n"
		"\n"
		"@return the value of this ASTNode as a single character\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getInteger", _wrap_ASTNode_getInteger, METH_VARARGS, (char *)"\n"
		"ASTNode_getInteger(ASTNode self) -> long\n"
		"\n"
		"Get the value of this node as an integer. This function should be\n"
		"called only when\n"
		"@if clike getType()@else ASTNode.getType()@endif\n"
		"<code>== @link libsbml.AST_INTEGER AST_INTEGER@endlink</code>.\n"
		"\n"
		"@return the value of this ASTNode as a (<code>long</code>) integer. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getName", _wrap_ASTNode_getName, METH_VARARGS, (char *)"\n"
		"ASTNode_getName(ASTNode self) -> char\n"
		"\n"
		"Get the value of this node as a string.  This function may be called\n"
		"on nodes that (1) are not operators, i.e., nodes for which\n"
		"@if clike isOperator()@else ASTNode.isOperator()@endif\n"
		"returns @c false, and (2) are not numbers, i.e.,\n"
		"@if clike isNumber()@else ASTNode.isNumber()@endif returns @c false.\n"
		"\n"
		"@return the value of this ASTNode as a string.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getNumerator", _wrap_ASTNode_getNumerator, METH_VARARGS, (char *)"\n"
		"ASTNode_getNumerator(ASTNode self) -> long\n"
		"\n"
		"Get the value of the numerator of this node.  This function should be\n"
		"called only when\n"
		"@if clike getType()@else ASTNode.getType()@endif\n"
		"<code>== @link libsbml.AST_RATIONAL AST_RATIONAL@endlink</code>.\n"
		"\n"
		"@return the value of the numerator of this ASTNode.  \n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getDenominator", _wrap_ASTNode_getDenominator, METH_VARARGS, (char *)"\n"
		"ASTNode_getDenominator(ASTNode self) -> long\n"
		"\n"
		"Get the value of the denominator of this node.  This function should\n"
		"be called only when\n"
		"@if clike getType()@else ASTNode.getType()@endif\n"
		"<code>== @link libsbml.AST_RATIONAL AST_RATIONAL@endlink</code>.\n"
		"\n"
		"@return the value of the denominator of this ASTNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getReal", _wrap_ASTNode_getReal, METH_VARARGS, (char *)"\n"
		"ASTNode_getReal(ASTNode self) -> double\n"
		"\n"
		"Get the real-numbered value of this node.  This function\n"
		"should be called only when\n"
		"@if clike isReal()@else ASTNode.isReal()@endif\n"
		"<code>== true</code>.\n"
		"\n"
		"This function performs the necessary arithmetic if the node type is\n"
		"@link libsbml.AST_REAL_E AST_REAL_E@endlink (<em>mantissa *\n"
		"10<sup> exponent</sup></em>) or @link libsbml.AST_RATIONAL\n"
		"AST_RATIONAL@endlink (<em>numerator / denominator</em>).\n"
		"\n"
		"@return the value of this ASTNode as a real (double).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getMantissa", _wrap_ASTNode_getMantissa, METH_VARARGS, (char *)"\n"
		"ASTNode_getMantissa(ASTNode self) -> double\n"
		"\n"
		"Get the mantissa value of this node.  This function should be called\n"
		"only when @if clike getType()@else ASTNode.getType()@endif\n"
		"returns @link libsbml.AST_REAL_E AST_REAL_E@endlink\n"
		"or @link libsbml.AST_REAL AST_REAL@endlink.\n"
		"If @if clike getType()@else ASTNode.getType()@endif\n"
		"returns @link libsbml.AST_REAL AST_REAL@endlink,\n"
		"this method is identical to\n"
		"@if clike getReal()@else ASTNode.getReal()@endif.\n"
		"\n"
		"@return the value of the mantissa of this ASTNode. \n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getExponent", _wrap_ASTNode_getExponent, METH_VARARGS, (char *)"\n"
		"ASTNode_getExponent(ASTNode self) -> long\n"
		"\n"
		"Get the exponent value of this ASTNode.  This function should be\n"
		"called only when\n"
		"@if clike getType()@else ASTNode.getType()@endif\n"
		"returns @link libsbml.AST_REAL_E AST_REAL_E@endlink\n"
		"or @link libsbml.AST_REAL AST_REAL@endlink.\n"
		"\n"
		"@return the value of the exponent of this ASTNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getPrecedence", _wrap_ASTNode_getPrecedence, METH_VARARGS, (char *)"\n"
		"ASTNode_getPrecedence(ASTNode self) -> int\n"
		"\n"
		"Get the precedence of this node in the infix math syntax of SBML\n"
		"Level&nbsp;1.  For more information about the infix syntax, see the\n"
		"discussion about <a href='#math-convert'>text string formulas</a> at\n"
		"the top of the documentation for ASTNode.\n"
		"\n"
		"@return an integer indicating the precedence of this ASTNode\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getType", _wrap_ASTNode_getType, METH_VARARGS, (char *)"\n"
		"ASTNode_getType(ASTNode self) -> ASTNodeType_t\n"
		"\n"
		"Get the type of this ASTNode.  The value returned is one of the\n"
		"enumeration values such as @link libsbml.AST_LAMBDA\n"
		"AST_LAMBDA@endlink, @link libsbml.AST_PLUS AST_PLUS@endlink,\n"
		"etc.\n"
		"\n"
		"@return the type of this ASTNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getUnits", _wrap_ASTNode_getUnits, METH_VARARGS, (char *)"\n"
		"ASTNode_getUnits(ASTNode self) -> string\n"
		"\n"
		"Get the units of this ASTNode.  \n"
		"\n"
		"@htmlinclude about-sbml-units-attrib.html\n"
		"\n"
		"@return the units of this ASTNode.\n"
		"\n"
		"@note The <code>sbml:units</code> attribute is only available in SBML\n"
		"Level&nbsp;3.  It may not be used in Levels 1&ndash;2 of SBML.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isBoolean", _wrap_ASTNode_isBoolean, METH_VARARGS, (char *)"\n"
		"ASTNode_isBoolean(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node has a boolean type\n"
		"(a logical operator, a relational operator, or the constants @c true\n"
		"or @c false).\n"
		"\n"
		"@return true if this ASTNode is a boolean, false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isConstant", _wrap_ASTNode_isConstant, METH_VARARGS, (char *)"\n"
		"ASTNode_isConstant(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents a MathML\n"
		"constant (e.g., @c true, @c Pi).\n"
		"\n"
		"@return @c true if this ASTNode is a MathML constant, @c false otherwise.\n"
		"\n"
		"@note this function will also return @c true for @link\n"
		"libsbml.AST_NAME_AVOGADRO AST_NAME_AVOGADRO@endlink in SBML Level&nbsp;3.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isFunction", _wrap_ASTNode_isFunction, METH_VARARGS, (char *)"\n"
		"ASTNode_isFunction(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents a\n"
		"MathML function (e.g., <code>abs()</code>), or an SBML Level&nbsp;1\n"
		"function, or a user-defined function.\n"
		"\n"
		"@return @c true if this ASTNode is a function, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isInfinity", _wrap_ASTNode_isInfinity, METH_VARARGS, (char *)"\n"
		"ASTNode_isInfinity(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents\n"
		"the special IEEE 754 value infinity, @c false (zero) otherwise.\n"
		"\n"
		"@return @c true if this ASTNode is the special IEEE 754 value infinity,\n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isInteger", _wrap_ASTNode_isInteger, METH_VARARGS, (char *)"\n"
		"ASTNode_isInteger(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node contains an\n"
		"integer value, @c false (zero) otherwise.\n"
		"\n"
		"@return @c true if this ASTNode is of type @link\n"
		"libsbml.AST_INTEGER AST_INTEGER@endlink, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isLambda", _wrap_ASTNode_isLambda, METH_VARARGS, (char *)"\n"
		"ASTNode_isLambda(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is a MathML\n"
		"<code>&lt;lambda&gt;</code>, @c false (zero) otherwise.\n"
		"\n"
		"@return @c true if this ASTNode is of type @link libsbml.AST_LAMBDA\n"
		"AST_LAMBDA@endlink, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isLog10", _wrap_ASTNode_isLog10, METH_VARARGS, (char *)"\n"
		"ASTNode_isLog10(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents a \n"
		"@c log10 function, @c false (zero) otherwise.  More precisely, this\n"
		"predicate returns @c true if the node type is @link\n"
		"libsbml.AST_FUNCTION_LOG AST_FUNCTION_LOG@endlink with two\n"
		"children, the first of which is an @link libsbml.AST_INTEGER\n"
		"AST_INTEGER@endlink equal to 10.\n"
		"\n"
		"@return @c true if the given ASTNode represents a log10() function, @c\n"
		"false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isLogical", _wrap_ASTNode_isLogical, METH_VARARGS, (char *)"\n"
		"ASTNode_isLogical(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is a MathML\n"
		"logical operator (i.e., @c and, @c or, @c not, @c xor).\n"
		"\n"
		"@return @c true if this ASTNode is a MathML logical operator\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isName", _wrap_ASTNode_isName, METH_VARARGS, (char *)"\n"
		"ASTNode_isName(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is a user-defined\n"
		"variable name in SBML L1, L2 (MathML), or the special symbols @c delay\n"
		"or @c time.  The predicate returns @c false (zero) otherwise.\n"
		"\n"
		"@return @c true if this ASTNode is a user-defined variable name in SBML\n"
		"L1, L2 (MathML) or the special symbols delay or time.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isNaN", _wrap_ASTNode_isNaN, METH_VARARGS, (char *)"\n"
		"ASTNode_isNaN(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents the\n"
		"special IEEE 754 value 'not a number' (NaN), @c false (zero)\n"
		"otherwise.\n"
		"\n"
		"@return @c true if this ASTNode is the special IEEE 754 NaN.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isNegInfinity", _wrap_ASTNode_isNegInfinity, METH_VARARGS, (char *)"\n"
		"ASTNode_isNegInfinity(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents the\n"
		"special IEEE 754 value 'negative infinity', @c false (zero) otherwise.\n"
		"\n"
		"@return @c true if this ASTNode is the special IEEE 754 value negative\n"
		"infinity, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isNumber", _wrap_ASTNode_isNumber, METH_VARARGS, (char *)"\n"
		"ASTNode_isNumber(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node contains a number,\n"
		"@c false (zero) otherwise.  This is functionally equivalent to the\n"
		"following code:\n"
		"@code\n"
		"  isInteger() || isReal()\n"
		"@endcode\n"
		"\n"
		"@return @c true if this ASTNode is a number, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isOperator", _wrap_ASTNode_isOperator, METH_VARARGS, (char *)"\n"
		"ASTNode_isOperator(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is a mathematical\n"
		"operator, meaning, <code>+</code>, <code>-</code>, <code>*</code>, \n"
		"<code>/</code> or <code>^</code> (power).\n"
		"\n"
		"@return @c true if this ASTNode is an operator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isPiecewise", _wrap_ASTNode_isPiecewise, METH_VARARGS, (char *)"\n"
		"ASTNode_isPiecewise(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is the MathML\n"
		"<code>&lt;piecewise&gt;</code> construct, @c false (zero) otherwise.\n"
		"\n"
		"@return @c true if this ASTNode is a MathML @c piecewise function\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isRational", _wrap_ASTNode_isRational, METH_VARARGS, (char *)"\n"
		"ASTNode_isRational(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents a rational\n"
		"number, @c false (zero) otherwise.\n"
		"\n"
		"@return @c true if this ASTNode is of type @link\n"
		"libsbml.AST_RATIONAL AST_RATIONAL@endlink.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isReal", _wrap_ASTNode_isReal, METH_VARARGS, (char *)"\n"
		"ASTNode_isReal(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node can represent a\n"
		"real number, @c false (zero) otherwise.  More precisely, this node\n"
		"must be of one of the following types: @link libsbml.AST_REAL\n"
		"AST_REAL@endlink, @link libsbml.AST_REAL_E AST_REAL_E@endlink or\n"
		"@link libsbml.AST_RATIONAL AST_RATIONAL@endlink.\n"
		"\n"
		"@return @c true if the value of this ASTNode can represented as a real\n"
		"number, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isRelational", _wrap_ASTNode_isRelational, METH_VARARGS, (char *)"\n"
		"ASTNode_isRelational(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is a MathML\n"
		"relational operator, meaning <code>==</code>, <code>&gt;=</code>, \n"
		"<code>&gt;</code>, <code>&lt;</code>, and <code>!=</code>.\n"
		"\n"
		"@return @c true if this ASTNode is a MathML relational operator, @c\n"
		"false otherwise\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isSqrt", _wrap_ASTNode_isSqrt, METH_VARARGS, (char *)"\n"
		"ASTNode_isSqrt(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node represents a\n"
		"square root function, @c false (zero) otherwise.  More precisely, the\n"
		"node type must be @link libsbml.AST_FUNCTION_ROOT\n"
		"AST_FUNCTION_ROOT@endlink with two children, the first of which is an\n"
		"@link libsbml.AST_INTEGER AST_INTEGER@endlink node having value\n"
		"equal to 2.\n"
		"\n"
		"@return @c true if the given ASTNode represents a sqrt() function,\n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isUMinus", _wrap_ASTNode_isUMinus, METH_VARARGS, (char *)"\n"
		"ASTNode_isUMinus(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node is a unary minus\n"
		"operator, @c false (zero) otherwise.  A node is defined as a unary\n"
		"minus node if it is of type @link libsbml.AST_MINUS\n"
		"AST_MINUS@endlink and has exactly one child.\n"
		"\n"
		"For numbers, unary minus nodes can be 'collapsed' by negating the\n"
		"number.  In fact, \n"
		"@if clike SBML_parseFormula() @endif@if csharp SBML_parseFormula() @else <code><a href='libsbml.html#parseFormula(java.lang.String)'>libsbml.parseFormula()</a></code>@endif does this during its parsing process.\n"
		"However, unary minus nodes for symbols\n"
		"(@link libsbml.AST_NAME AST_NAME@endlink) cannot\n"
		"be 'collapsed', so this predicate function is necessary.\n"
		"\n"
		"@return @c true if this ASTNode is a unary minus, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isUnknown", _wrap_ASTNode_isUnknown, METH_VARARGS, (char *)"\n"
		"ASTNode_isUnknown(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node has an unknown type.\n"
		"\n"
		"'Unknown' nodes have the type @link libsbml.AST_UNKNOWN\n"
		"AST_UNKNOWN@endlink.  Nodes with unknown types will not appear in an\n"
		"ASTNode tree returned by libSBML based upon valid SBML input; the only\n"
		"situation in which a node with type @link libsbml.AST_UNKNOWN\n"
		"AST_UNKNOWN@endlink may appear is immediately after having create a\n"
		"new, untyped node using the ASTNode constructor.  Callers creating\n"
		"nodes should endeavor to set the type to a valid node type as soon as\n"
		"possible after creating new nodes.\n"
		"\n"
		"@return @c true if this ASTNode is of type @link\n"
		"libsbml.AST_UNKNOWN AST_UNKNOWN@endlink, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isSetUnits", _wrap_ASTNode_isSetUnits, METH_VARARGS, (char *)"\n"
		"ASTNode_isSetUnits(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node has the attribute\n"
		"<code>sbml:units</code>.\n"
		"\n"
		"@htmlinclude about-sbml-units-attrib.html\n"
		"\n"
		"@return @c true if this ASTNode has units associated with it, @c false otherwise.\n"
		"\n"
		"@note The <code>sbml:units</code> attribute is only available in SBML\n"
		"Level&nbsp;3.  It may not be used in Levels 1&ndash;2 of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_hasUnits", _wrap_ASTNode_hasUnits, METH_VARARGS, (char *)"\n"
		"ASTNode_hasUnits(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true (non-zero) if this node or any of its\n"
		"children nodes have the attribute <code>sbml:units</code>.\n"
		"\n"
		"@htmlinclude about-sbml-units-attrib.html\n"
		"\n"
		"@return @c true if this ASTNode or its children has units associated\n"
		"with it, @c false otherwise.\n"
		"\n"
		"@note The <code>sbml:units</code> attribute is only available in SBML\n"
		"Level&nbsp;3.  It may not be used in Levels 1&ndash;2 of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_setCharacter", _wrap_ASTNode_setCharacter, METH_VARARGS, (char *)"\n"
		"ASTNode_setCharacter(ASTNode self, char value) -> int\n"
		"\n"
		"Sets the value of this ASTNode to the given character.  If character\n"
		"is one of @c +, @c -, <code>*</code>, <code>/</code> or @c ^, the node\n"
		"type will be set accordingly.  For all other characters, the node type\n"
		"will be set to @link libsbml.AST_UNKNOWN AST_UNKNOWN@endlink.\n"
		"\n"
		"@param value the character value to which the node's value should be\n"
		"set.\n"
		"\n"
		"@return integer value indicating success/failure of the function.  The\n"
		"possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_setName", _wrap_ASTNode_setName, METH_VARARGS, (char *)"\n"
		"ASTNode_setName(ASTNode self, char name) -> int\n"
		"\n"
		"Sets the value of this ASTNode to the given name.\n"
		"\n"
		"As a side-effect, this ASTNode object's type will be reset to\n"
		"@link libsbml.AST_NAME AST_NAME@endlink if (and <em>only\n"
		"if</em>) the ASTNode was previously an operator (\n"
		"@if clike isOperator()@else ASTNode.isOperator()@endif\n"
		"<code>== true</code>), number (\n"
		"@if clike isNumber()@else ASTNode.isNumber()@endif\n"
		"<code>== true</code>), or unknown.\n"
		"This allows names to be set for @link libsbml.AST_FUNCTION\n"
		"AST_FUNCTION@endlink nodes and the like.\n"
		"\n"
		"@param name the string containing the name to which this node's value\n"
		"should be set\n"
		"\n"
		"@return integer value indicating success/failure of the function.  The\n"
		"possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_setValue", _wrap_ASTNode_setValue, METH_VARARGS, (char *)"\n"
		"setValue(long value) -> int\n"
		"setValue(long numerator, long denominator) -> int\n"
		"setValue(double value) -> int\n"
		"ASTNode_setValue(ASTNode self, double mantissa, long exponent) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setValue(int value)</pre>\n"
		"\n"
		"Sets the value of this ASTNode to the given integer and sets the node\n"
		"type to @link libsbml.AST_INTEGER AST_INTEGER@endlink.\n"
		"\n"
		"@param value the integer to which this node's value should be set\n"
		"\n"
		"@return integer value indicating success/failure of the function.  The\n"
		"possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setValue(long value)</pre>\n"
		"\n"
		"Sets the value of this ASTNode to the given (@c long) integer and sets\n"
		"the node type to @link libsbml.AST_INTEGER AST_INTEGER@endlink.\n"
		"\n"
		"@param value the integer to which this node's value should be set\n"
		"\n"
		"@return integer value indicating success/failure of the function.  The\n"
		"possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setValue(long numerator, long denominator)</pre>\n"
		"\n"
		"Sets the value of this ASTNode to the given rational in two parts: the\n"
		"numerator and denominator.  The node type is set to @link\n"
		"libsbml.AST_RATIONAL AST_RATIONAL@endlink.\n"
		"\n"
		"@param numerator the numerator value of the rational\n"
		"@param denominator the denominator value of the rational\n"
		"\n"
		"@return integer value indicating success/failure of the function.  The\n"
		"possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setValue(double value)</pre>\n"
		"\n"
		"Sets the value of this ASTNode to the given real (@c double) and sets\n"
		"the node type to @link libsbml.AST_REAL AST_REAL@endlink.\n"
		"\n"
		"This is functionally equivalent to:\n"
		"@code\n"
		"setValue(value, 0);\n"
		"@endcode\n"
		"\n"
		"@param value the @c double format number to which this node's value\n"
		"should be set\n"
		"\n"
		"@return integer value indicating success/failure of the function.  The\n"
		"possible values returned by this function are: @li @link\n"
		"libsbml.LIBSBML_OPERATION_SUCCESS\n"
		"LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>setValue(double mantissa, long exponent)</pre>\n"
		"\n"
		"Sets the value of this ASTNode to the given real (@c double) in two\n"
		"parts: the mantissa and the exponent.  The node type is set to\n"
		"@link libsbml.AST_REAL_E AST_REAL_E@endlink.\n"
		"\n"
		"@param mantissa the mantissa of this node's real-numbered value\n"
		"@param exponent the exponent of this node's real-numbered value\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_setType", _wrap_ASTNode_setType, METH_VARARGS, (char *)"\n"
		"ASTNode_setType(ASTNode self, ASTNodeType_t type) -> int\n"
		"\n"
		"Sets the type of this ASTNode to the given type code.  A side-effect\n"
		"of doing this is that any numerical values previously stored in this\n"
		"node are reset to zero.\n"
		"\n"
		"@param type the type to which this node should be set\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_setUnits", _wrap_ASTNode_setUnits, METH_VARARGS, (char *)"\n"
		"ASTNode_setUnits(ASTNode self, string units) -> int\n"
		"\n"
		"Sets the units of this ASTNode to units.\n"
		"\n"
		"The units will be set @em only if this ASTNode object represents a\n"
		"MathML <code>&lt;cn&gt;</code> element, i.e., represents a number.\n"
		"Callers may use\n"
		"@if clike isNumber()@else ASTNode.isNumber()@endif\n"
		"to inquire whether the node is of that type.\n"
		"\n"
		"@htmlinclude about-sbml-units-attrib.html\n"
		"\n"
		"@param units @c string representing the unit identifier.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"\n"
		"@note The <code>sbml:units</code> attribute is only available in SBML\n"
		"Level&nbsp;3.  It may not be used in Levels 1&ndash;2 of SBML.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_swapChildren", _wrap_ASTNode_swapChildren, METH_VARARGS, (char *)"\n"
		"ASTNode_swapChildren(ASTNode self, ASTNode that) -> int\n"
		"\n"
		"Swap the children of this ASTNode object with the children of the\n"
		"given ASTNode object.\n"
		"\n"
		"@param that the other node whose children should be used to replace\n"
		"<em>this</em> node's children\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_unsetUnits", _wrap_ASTNode_unsetUnits, METH_VARARGS, (char *)"\n"
		"ASTNode_unsetUnits(ASTNode self) -> int\n"
		"\n"
		"Unsets the units of this ASTNode.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_UNEXPECTED_ATTRIBUTE LIBSBML_UNEXPECTED_ATTRIBUTE @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getDefinitionURL", _wrap_ASTNode_getDefinitionURL, METH_VARARGS, (char *)"\n"
		"ASTNode_getDefinitionURL(ASTNode self) -> XMLAttributes\n"
		"\n"
		"Gets the MathML @c definitionURL attribute value.\n"
		"\n"
		"@return the value of the @c definitionURL attribute, in the form of\n"
		"a libSBML XMLAttributes object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_replaceArgument", _wrap_ASTNode_replaceArgument, METH_VARARGS, (char *)"\n"
		"ASTNode_replaceArgument(ASTNode self, string bvar, ASTNode arg)\n"
		"\n"
		"Replaces occurences of a given name within this ASTNode with the\n"
		"name/value/formula represented by @p arg.\n"
		"\n"
		"For example, if the formula in this ASTNode is <code>x + y</code>,\n"
		"then the <code>&lt;bvar&gt;</code> is @c x and @c arg is an ASTNode\n"
		"representing the real value @c 3.  This method substitutes @c 3 for @c\n"
		"x within this ASTNode object.\n"
		"\n"
		"@param bvar a string representing the variable name to be substituted\n"
		"@param arg an ASTNode representing the name/value/formula to substitute\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_getParentSBMLObject", _wrap_ASTNode_getParentSBMLObject, METH_VARARGS, (char *)"\n"
		"ASTNode_getParentSBMLObject(ASTNode self) -> SBase\n"
		"\n"
		"Returns the parent SBML object.\n"
		"\n"
		"@return the parent SBML object of this ASTNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_reduceToBinary", _wrap_ASTNode_reduceToBinary, METH_VARARGS, (char *)"\n"
		"ASTNode_reduceToBinary(ASTNode self)\n"
		"\n"
		"Reduces this ASTNode to a binary tree.\n"
		"\n"
		"Example: if this ASTNode is <code>and(x, y, z)</code>, then the \n"
		"formula of the reduced node is <code>and(and(x, y), z)</code>.  The\n"
		"operation replaces the formula stored in the current ASTNode object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_isWellFormedASTNode", _wrap_ASTNode_isWellFormedASTNode, METH_VARARGS, (char *)"\n"
		"ASTNode_isWellFormedASTNode(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ASTNode is well-formed.\n"
		"\n"
		"@note An ASTNode may be well-formed, with each node and its children\n"
		"having the appropriate number of children for the given type, but may\n"
		"still be invalid in the context of its use within an SBML model.\n"
		"\n"
		"@return @c true if this ASTNode is well-formed, @c false otherwise.\n"
		"\n"
		"@see hasCorrectNumberArguments()\n"
		" \n"
		"\n"
		""},
	 { (char *)"ASTNode_hasCorrectNumberArguments", _wrap_ASTNode_hasCorrectNumberArguments, METH_VARARGS, (char *)"\n"
		"ASTNode_hasCorrectNumberArguments(ASTNode self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ASTNode has the correct number of children for it's type.\n"
		"\n"
		"For example, an ASTNode with type @link libsbml.AST_PLUS\n"
		"AST_PLUS@endlink expects 2 child nodes.\n"
		"\n"
		"@note This function performs a check on the toplevel node only.\n"
		"Child nodes are not checked.\n"
		"\n"
		"@return @c true if this ASTNode is has appropriate number of children\n"
		"for it's type, @c false otherwise.\n"
		"\n"
		"@see isWellFormedASTNode()\n"
		" \n"
		"\n"
		""},
	 { (char *)"ASTNode_isBvar", _wrap_ASTNode_isBvar, METH_VARARGS, (char *)"\n"
		"ASTNode_isBvar(ASTNode self) -> bool\n"
		"\n"
		"@internal\n"
		"redicate returning @c true or @c false depending on whether this\n"
		"STNode has the correct number of children for it's type.\n"
		"\n"
		"or example, an ASTNode with type @link libsbml.AST_PLUS\n"
		"ST_PLUS@endlink expects 2 child nodes.\n"
		"\n"
		"note This function performs a check on the toplevel node only.\n"
		"hild nodes are not checked.\n"
		"\n"
		"return @c true if this ASTNode is has appropriate number of children\n"
		"or it's type, @c false otherwise.\n"
		"\n"
		"see isWellFormedASTNode()\n"
		"\n"
		"\n"
		""},
	 { (char *)"ASTNode_setBvar", _wrap_ASTNode_setBvar, METH_VARARGS, (char *)"\n"
		"ASTNode_setBvar(ASTNode self)\n"
		"\n"
		"@internal\n"
		"redicate returning @c true or @c false depending on whether this\n"
		"STNode has the correct number of children for it's type.\n"
		"\n"
		"or example, an ASTNode with type @link libsbml.AST_PLUS\n"
		"ST_PLUS@endlink expects 2 child nodes.\n"
		"\n"
		"note This function performs a check on the toplevel node only.\n"
		"hild nodes are not checked.\n"
		"\n"
		"return @c true if this ASTNode is has appropriate number of children\n"
		"or it's type, @c false otherwise.\n"
		"\n"
		"see isWellFormedASTNode()\n"
		"\n"
		"\n"
		""},
	 { (char *)"ASTNode_getListOfNodes", _wrap_ASTNode_getListOfNodes, METH_VARARGS, (char *)"\n"
		"ASTNode_getListOfNodes(ASTNode self) -> ASTNodeList\n"
		"\n"
		"Performs a depth-first search of the tree rooted at this ASTNode\n"
		"object, and returns a List of nodes where the given function\n"
		"<code>predicate(node)</code> returns @c true (non-zero).\n"
		"\n"
		"For portability between different programming languages, the predicate\n"
		"is passed in as a pointer to a function.  The function definition must\n"
		"have the type @link ASTNode.h::ASTNodePredicate ASTNodePredicate\n"
		"@endlink, which is defined as\n"
		"@code\n"
		"int (*ASTNodePredicate) (const ASTNode_t *node);\n"
		"@endcode\n"
		"where a return value of non-zero represents @c true and zero\n"
		"represents @c false.\n"
		"\n"
		"@param predicate the predicate to use\n"
		"\n"
		"@return the list of nodes for which the predicate returned @c true\n"
		"(non-zero).  The List returned is owned by the caller and should be\n"
		"deleted after the caller is done using it.  The ASTNode objects in the\n"
		"list; however, are not owned by the caller (as they still belong to\n"
		"the tree itself), and therefore should not be deleted.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ASTNode_swigregister", ASTNode_swigregister, METH_VARARGS, NULL},
	 { (char *)"parseFormula", _wrap_parseFormula, METH_VARARGS, (char *)"\n"
		"parseFormula(char formula) -> ASTNode_t\n"
		"\n"
		"Parses the given SBML formula and returns a representation of it as an\n"
		"Abstract Syntax Tree (AST).\n"
		"\n"
		"@if clike The text-string form of mathematical formulas produced by\n"
		"SBML_formulaToString() and read by SBML_parseFormula() are simple\n"
		"C-inspired infix notation taken from SBML Level&nbsp;1.  A formula in\n"
		"this text-string form therefore can be handed to a program that\n"
		"understands SBML Level&nbsp;1 mathematical expressions, or used as part\n"
		"of a formula translation system.  The syntax is described in detail in\n"
		"the documentation for ASTNode. @endif@if csharp The text-string form of\n"
		"mathematical formulas produced by SBML_formulaToString() and read by\n"
		"SBML_parseFormula() are simple C-inspired infix notation taken from SBML\n"
		"Level&nbsp;1.  A formula in this text-string form therefore can be\n"
		"handed to a program that understands SBML Level&nbsp;1 mathematical\n"
		"expressions, or used as part of a formula translation system.  The\n"
		"syntax is described in detail in the documentation for\n"
		"ASTNode. @else The text-string form of mathematical formulas produced by <code><a\n"
		"href='libsbml.html'>libsbml.formulaToString()</a></code> and read by\n"
		"<code><a href='libsbml.html'>libsbml.parseFormula()</a></code> are\n"
		"simple C-inspired infix notation taken from SBML Level&nbsp;1.  A\n"
		"formula in this text-string form therefore can be handed to a program\n"
		"that understands SBML Level&nbsp;1 mathematical expressions, or used as\n"
		"part of a formula translation system.  The syntax is described in detail\n"
		"in the documentation for ASTNode.  @endif\n"
		"\n"
		"This returns the root node of the AST corresponding to the formula.  If\n"
		"the formula contains a syntax error, @c None is returned instead.\n"
		"\n"
		"Note that this facility is provided as a convenience by libSBML&mdash;the\n"
		"MathML standard does not actually define a 'string-form' equivalent to\n"
		"MathML expression trees, so the choice of formula syntax is somewhat\n"
		"arbitrary.  The approach taken by libSBML is to use the syntax defined by\n"
		"SBML Level&nbsp;1 (which in fact used a text-string representation of\n"
		"formulas and not MathML).  This formula syntax is based mostly on C\n"
		"programming syntax, and may contain operators, function calls, symbols,\n"
		"and white space characters.  The following table provides the precedence\n"
		"rules for the different entities that may appear in formula strings.\n"
		"\n"
		"@htmlinclude math-precedence-table.html\n"
		"\n"
		"In the table above, @em operand implies the construct is an operand, @em\n"
		"prefix implies the operation is applied to the following arguments, @em\n"
		"unary implies there is one argument, and @em binary implies there are\n"
		"two arguments.  The values in the <b>Precedence</b> column show how the\n"
		"order of different types of operation are determined.  For example, the\n"
		"expression <code>a * b + c</code> is evaluated as <code>(a * b) +\n"
		"c</code> because the @c * operator has higher precedence.  The\n"
		"<b>Associates</b> column shows how the order of similar precedence\n"
		"operations is determined; for example, <code>a - b + c</code> is\n"
		"evaluated as <code>(a - b) + c</code> because the @c + and @c -\n"
		"operators are left-associative.\n"
		"\n"
		"The function call syntax consists of a function name, followed by optional\n"
		"white space, followed by an opening parenthesis token, followed by a\n"
		"sequence of zero or more arguments separated by commas (with each comma\n"
		"optionally preceded and/or followed by zero or more white space\n"
		"characters, followed by a closing parenthesis token.  The function name\n"
		"must be chosen from one of the pre-defined functions in SBML or a\n"
		"user-defined function in the model.  The following table lists the names\n"
		"of certain common mathematical functions; this table corresponds to\n"
		"Table&nbsp;6 in the <a target='_blank' href='http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2'>SBML Level&nbsp;1 Version&nbsp;2 specification</a>:\n"
		"\n"
		"@htmlinclude string-functions-table.html\n"
		"\n"
		"@warning There are differences between the symbols used to represent the\n"
		"common mathematical functions and the corresponding MathML token names.\n"
		"This is a potential source of incompatibilities.  Note in particular that\n"
		"in this text-string syntax, <code>log(x)</code> represents the natural\n"
		"logarithm, whereas in MathML, the natural logarithm is\n"
		"<code>&lt;ln/&gt;</code>.  Application writers are urged to be careful\n"
		"when translating between text forms and MathML forms, especially if they\n"
		"provide a direct text-string input facility to users of their software\n"
		"systems.<br><br>\n"
		"@htmlinclude L1-math-syntax-warning.html\n"
		"\n"
		"@param formula the text-string formula expression to be parsed\n"
		"\n"
		"@return the root node of the AST, or None if an error occurred in\n"
		"parsing the formula\n"
		"\n"
		"@if clike @see SBML_formulaToString()@endif\n"
		"@if csharp @see SBML_formulaToString()@endif\n"
		"@if java @see formulaToString()@endif\n"
		"\n"
		"\n"
		""},
	 { (char *)"formulaToString", _wrap_formulaToString, METH_VARARGS, (char *)"\n"
		"formulaToString(ASTNode_t tree) -> char\n"
		"\n"
		"Converts an AST to a string representation of a formula using a syntax\n"
		"basically derived from SBML Level&nbsp;1.\n"
		"\n"
		"@if clike The text-string form of mathematical formulas produced by\n"
		"SBML_formulaToString() and read by SBML_parseFormula() are simple\n"
		"C-inspired infix notation taken from SBML Level&nbsp;1.  A formula in\n"
		"this text-string form therefore can be handed to a program that\n"
		"understands SBML Level&nbsp;1 mathematical expressions, or used as part\n"
		"of a formula translation system.  The syntax is described in detail in\n"
		"the documentation for ASTNode. @endif@if csharp The text-string form of\n"
		"mathematical formulas produced by SBML_formulaToString() and read by\n"
		"SBML_parseFormula() are simple C-inspired infix notation taken from SBML\n"
		"Level&nbsp;1.  A formula in this text-string form therefore can be\n"
		"handed to a program that understands SBML Level&nbsp;1 mathematical\n"
		"expressions, or used as part of a formula translation system.  The\n"
		"syntax is described in detail in the documentation for\n"
		"ASTNode. @else The text-string form of mathematical formulas produced by <code><a\n"
		"href='libsbml.html#formulaToString(org.sbml.libsbml.ASTNode)'>\n"
		"libsbml.formulaToString()</a></code> and read by <code><a\n"
		"href='libsbml.html#parseFormula(java.lang.String)'>\n"
		"libsbml.parseFormula()</a></code> are simple C-inspired infix notation\n"
		"taken from SBML Level&nbsp;1.  A formula in this text-string form\n"
		"therefore can be handed to a program that understands SBML Level&nbsp;1\n"
		"mathematical expressions, or used as part of a formula translation\n"
		"system.  The syntax is described in detail in the documentation for\n"
		"ASTNode.  @endif\n"
		"\n"
		"Note that this facility is provided as a convenience by libSBML&mdash;the\n"
		"MathML standard does not actually define a 'string-form' equivalent to\n"
		"MathML expression trees, so the choice of formula syntax is somewhat\n"
		"arbitrary.  The approach taken by libSBML is to use the syntax defined by\n"
		"SBML Level&nbsp;1 (which in fact used a text-string representation of\n"
		"formulas and not MathML).  This formula syntax is based mostly on C\n"
		"programming syntax, and may contain operators, function calls, symbols,\n"
		"and white space characters.  The following table provides the precedence\n"
		"rules for the different entities that may appear in formula strings.\n"
		"\n"
		"@htmlinclude math-precedence-table.html\n"
		"\n"
		"In the table above, @em operand implies the construct is an operand, @em\n"
		"prefix implies the operation is applied to the following arguments, @em\n"
		"unary implies there is one argument, and @em binary implies there are\n"
		"two arguments.  The values in the <b>Precedence</b> column show how the\n"
		"order of different types of operation are determined.  For example, the\n"
		"expression <code>a * b + c</code> is evaluated as <code>(a * b) +\n"
		"c</code> because the @c * operator has higher precedence.  The\n"
		"<b>Associates</b> column shows how the order of similar precedence\n"
		"operations is determined; for example, <code>a - b + c</code> is\n"
		"evaluated as <code>(a - b) + c</code> because the @c + and @c -\n"
		"operators are left-associative.\n"
		"\n"
		"The function call syntax consists of a function name, followed by optional\n"
		"white space, followed by an opening parenthesis token, followed by a\n"
		"sequence of zero or more arguments separated by commas (with each comma\n"
		"optionally preceded and/or followed by zero or more white space\n"
		"characters, followed by a closing parenthesis token.  The function name\n"
		"must be chosen from one of the pre-defined functions in SBML or a\n"
		"user-defined function in the model.  The following table lists the names\n"
		"of certain common mathematical functions; this table corresponds to\n"
		"Table&nbsp;6 in the <a target='_blank' href='http://sbml.org/Documents/Specifications#SBML_Level_1_Version_2'>SBML Level&nbsp;1 Version&nbsp;2 specification</a>:\n"
		"\n"
		"@htmlinclude string-functions-table.html\n"
		"\n"
		"@warning There are differences between the symbols used to represent the\n"
		"common mathematical functions and the corresponding MathML token names.\n"
		"This is a potential source of incompatibilities.  Note in particular that\n"
		"in this text-string syntax, <code>log(x)</code> represents the natural\n"
		"logarithm, whereas in MathML, the natural logarithm is\n"
		"<code>&lt;ln/&gt;</code>.  Application writers are urged to be careful\n"
		"when translating between text forms and MathML forms, especially if they\n"
		"provide a direct text-string input facility to users of their software\n"
		"systems.<br><br>\n"
		"@htmlinclude L1-math-syntax-warning.html\n"
		"\n"
		"@param tree the AST to be converted.\n"
		"\n"
		"@return the formula from the given AST as an SBML Level 1 text-string\n"
		"mathematical formula.  The caller owns the returned string and is\n"
		"responsible for freeing it when it is no longer needed.\n"
		"\n"
		"@if clike @see SBML_parseFormula()@endif\n"
		"@if csharp @see SBML_parseFormula()@endif\n"
		"@if java @see parseFormula()@endif\n"
		"\n"
		"\n"
		""},
	 { (char *)"delete_XMLAttributes", _wrap_delete_XMLAttributes, METH_VARARGS, (char *)"delete_XMLAttributes(XMLAttributes self)"},
	 { (char *)"new_XMLAttributes", _wrap_new_XMLAttributes, METH_VARARGS, (char *)"\n"
		"XMLAttributes()\n"
		"new_XMLAttributes(XMLAttributes orig) -> XMLAttributes\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLAttributes()</pre>\n"
		"\n"
		"Creates a new empty XMLAttributes set.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLAttributes(XMLAttributes orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this XMLAttributes set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_clone", _wrap_XMLAttributes_clone, METH_VARARGS, (char *)"\n"
		"XMLAttributes_clone(XMLAttributes self) -> XMLAttributes\n"
		"\n"
		"Creates and returns a deep copy of this XMLAttributes set.\n"
		"\n"
		"@return a (deep) copy of this XMLAttributes set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_add", _wrap_XMLAttributes_add, METH_VARARGS, (char *)"\n"
		"add(string name, string value, string namespaceURI = \"\", \n"
		"    string prefix = \"\") -> int\n"
		"add(string name, string value, string namespaceURI = \"\") -> int\n"
		"add(string name, string value) -> int\n"
		"XMLAttributes_add(XMLAttributes self, XMLTriple triple, string value) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>add(  string name , string value , string namespaceURI = '' , string prefix = '')</pre>\n"
		"\n"
		"Adds an attribute (a name/value pair) to this XMLAttributes object,\n"
		"optionally with a prefix and URI defining a namespace.\n"
		"\n"
		"@param name a string, the local name of the attribute.\n"
		"@param value a string, the value of the attribute.\n"
		"@param namespaceURI a string, the namespace URI of the attribute.\n"
		"@param prefix a string, the prefix of the namespace\n"
		"\n"
		"@return an integer code indicating the success or failure of the\n"
		"function.  The possible values returned by this\n"
		"function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@note if local name with the same namespace URI already exists in this \n"
		"attribute set, its value and prefix will be replaced.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>add( XMLTriple triple, string value)</pre>\n"
		"\n"
		"Adds an attribute with the given XMLTriple/value pair to this XMLAttributes set.\n"
		"\n"
		"@note if local name with the same namespace URI already exists in this attribute set, \n"
		"its value and prefix will be replaced.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute.\n"
		"@param value a string, the value of the attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_removeResource", _wrap_XMLAttributes_removeResource, METH_VARARGS, (char *)"\n"
		"XMLAttributes_removeResource(XMLAttributes self, int n) -> int\n"
		"\n"
		"Removes an attribute with the given index from this XMLAttributes set.  \n"
		"\n"
		"@param n an integer the index of the resource to be deleted\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_remove", _wrap_XMLAttributes_remove, METH_VARARGS, (char *)"\n"
		"remove(int n) -> int\n"
		"remove(string name, string uri = \"\") -> int\n"
		"remove(string name) -> int\n"
		"XMLAttributes_remove(XMLAttributes self, XMLTriple triple) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(int n)</pre>\n"
		"\n"
		"Removes an attribute with the given index from this XMLAttributes set.  \n"
		"(This function is an alias of XMLAttributes.removeResource() ).\n"
		"\n"
		"@param n an integer the index of the resource to be deleted\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string name, string uri = '')</pre>\n"
		"\n"
		"Removes an attribute with the given local name and namespace URI from \n"
		"this XMLAttributes set.  \n"
		"\n"
		"@param name   a string, the local name of the attribute.\n"
		"@param uri    a string, the namespace URI of the attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(XMLTriple triple)</pre>\n"
		"\n"
		"Removes an attribute with the given XMLTriple from this XMLAttributes set.  \n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_clear", _wrap_XMLAttributes_clear, METH_VARARGS, (char *)"\n"
		"XMLAttributes_clear(XMLAttributes self) -> int\n"
		"\n"
		"Clears (deletes) all attributes in this XMLAttributes object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getIndex", _wrap_XMLAttributes_getIndex, METH_VARARGS, (char *)"\n"
		"getIndex(string name) -> int\n"
		"getIndex(string name, string uri) -> int\n"
		"XMLAttributes_getIndex(XMLAttributes self, XMLTriple triple) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getIndex(string name)</pre>\n"
		"\n"
		"Return the index of an attribute with the given name.\n"
		"\n"
		"@note A namespace bound to the name is not checked by this function.\n"
		"Thus, if there are multiple attributes with the given local name and\n"
		"different namespaces, the smallest index among those attributes will\n"
		"be returned.  XMLAttributes.getIndex() const or\n"
		"XMLAttributes.getIndex() const should be used to get an index of an\n"
		"attribute with the given local name and namespace.\n"
		"\n"
		"@param name a string, the local name of the attribute for which the \n"
		"index is required.\n"
		"\n"
		"@return the index of an attribute with the given local name, or -1 if not present.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getIndex(string name, string uri)</pre>\n"
		"\n"
		"Return the index of an attribute with the given local name and namespace URI.\n"
		"\n"
		"@param name a string, the local name of the attribute.\n"
		"@param uri  a string, the namespace URI of the attribute.\n"
		"\n"
		"@return the index of an attribute with the given local name and namespace URI, \n"
		"or -1 if not present.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getIndex(XMLTriple triple)</pre>\n"
		"\n"
		"Return the index of an attribute with the given XMLTriple.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute for which \n"
		"       the index is required.\n"
		"\n"
		"@return the index of an attribute with the given XMLTriple, or -1 if not present.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getLength", _wrap_XMLAttributes_getLength, METH_VARARGS, (char *)"\n"
		"XMLAttributes_getLength(XMLAttributes self) -> int\n"
		"\n"
		"Return the number of attributes in the set.\n"
		"\n"
		"@return the number of attributes in this XMLAttributes set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getName", _wrap_XMLAttributes_getName, METH_VARARGS, (char *)"\n"
		"XMLAttributes_getName(XMLAttributes self, int index) -> string\n"
		"\n"
		"Return the local name of an attribute in this XMLAttributes set (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose local name is \n"
		"required.\n"
		"\n"
		"@return the local name of an attribute in this list (by position).  \n"
		"\n"
		"@note If index is out of range, an empty string will be returned.  Use\n"
		"XMLAttributes.hasAttribute() const to test for the attribute\n"
		"existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getPrefix", _wrap_XMLAttributes_getPrefix, METH_VARARGS, (char *)"\n"
		"XMLAttributes_getPrefix(XMLAttributes self, int index) -> string\n"
		"\n"
		"Return the prefix of an attribute in this XMLAttributes set (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose prefix is \n"
		"required.\n"
		"\n"
		"@return the namespace prefix of an attribute in this list (by\n"
		"position).  \n"
		"\n"
		"@note If index is out of range, an empty string will be returned. Use\n"
		"XMLAttributes.hasAttribute() const to test for the attribute\n"
		"existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getPrefixedName", _wrap_XMLAttributes_getPrefixedName, METH_VARARGS, (char *)"\n"
		"XMLAttributes_getPrefixedName(XMLAttributes self, int index) -> string\n"
		"\n"
		"Return the prefixed name of an attribute in this XMLAttributes set (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose prefixed \n"
		"name is required.\n"
		"\n"
		"@return the prefixed name of an attribute in this list (by\n"
		"position).  \n"
		"\n"
		"@note If index is out of range, an empty string will be returned.  Use\n"
		"XMLAttributes.hasAttribute() const to test for attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getURI", _wrap_XMLAttributes_getURI, METH_VARARGS, (char *)"\n"
		"XMLAttributes_getURI(XMLAttributes self, int index) -> string\n"
		"\n"
		"Return the namespace URI of an attribute in this XMLAttributes set (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose namespace URI is \n"
		"required.\n"
		"\n"
		"@return the namespace URI of an attribute in this list (by position).\n"
		"\n"
		"@note If index is out of range, an empty string will be returned.  Use\n"
		"XMLAttributes.hasAttribute() const to test for attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_getValue", _wrap_XMLAttributes_getValue, METH_VARARGS, (char *)"\n"
		"getValue(int index) -> string\n"
		"getValue(string name) -> string\n"
		"getValue(string name, string uri) -> string\n"
		"XMLAttributes_getValue(XMLAttributes self, XMLTriple triple) -> string\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getValue(int index)</pre>\n"
		"\n"
		"Return the value of an attribute in this XMLAttributes set (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose value is \n"
		"required.\n"
		"\n"
		"@return the value of an attribute in the list (by position).  \n"
		"\n"
		"@note If index is out of range, an empty string will be returned.  Use\n"
		"XMLAttributes.hasAttribute() const to test for attribute existence.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getValue(string name)</pre>\n"
		"\n"
		"Return an attribute's value by name.\n"
		"\n"
		"@param name a string, the local name of the attribute whose value is required.\n"
		"\n"
		"@return The attribute value as a string.  \n"
		"\n"
		"@note If an attribute with the given local name does not exist, an\n"
		"empty string will be returned.  Use\n"
		"XMLAttributes.hasAttribute() const\n"
		"to test for attribute existence.  A namespace bound to the local name\n"
		"is not checked by this function.  Thus, if there are multiple\n"
		"attributes with the given local name and different namespaces, the\n"
		"value of an attribute with the smallest index among those attributes\n"
		"will be returned.  XMLAttributes.getValue() const or\n"
		"XMLAttributes.getValue() const should be used to get a value of an\n"
		"attribute with the given local name and namespace.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getValue(string name, string uri)</pre>\n"
		"\n"
		"Return a value of an attribute with the given local name and namespace URI.\n"
		"\n"
		"@param name a string, the local name of the attribute whose value is required.\n"
		"@param uri  a string, the namespace URI of the attribute.\n"
		"\n"
		"@return The attribute value as a string.  \n"
		"\n"
		"@note If an attribute with the given local name and namespace URI does\n"
		"not exist, an empty string will be returned.  Use\n"
		"XMLAttributes.hasAttribute() const\n"
		"to test for attribute existence.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getValue(XMLTriple triple)</pre>\n"
		"\n"
		"Return a value of an attribute with the given XMLTriple.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute whose \n"
		"       value is required.\n"
		"\n"
		"@return The attribute value as a string.  \n"
		"\n"
		"@note If an attribute with the given XMLTriple does not exist, an\n"
		"empty string will be returned.  Use\n"
		"XMLAttributes.hasAttribute() const to test for attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_hasAttribute", _wrap_XMLAttributes_hasAttribute, METH_VARARGS, (char *)"\n"
		"hasAttribute(int index) -> bool\n"
		"hasAttribute(string name, string uri = \"\") -> bool\n"
		"hasAttribute(string name) -> bool\n"
		"XMLAttributes_hasAttribute(XMLAttributes self, XMLTriple triple) -> bool\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>hasAttribute(int index)</pre>\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether\n"
		"an attribute with the given index exists in this XMLAttributes.\n"
		"\n"
		"@param index an integer, the position of the attribute.\n"
		"\n"
		"@return @c true if an attribute with the given index exists in this\n"
		"XMLAttributes, @c false otherwise.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>hasAttribute(string name, string uri='')</pre>\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether\n"
		"an attribute with the given local name and namespace URI exists in this \n"
		"XMLAttributes.\n"
		"\n"
		"@param name a string, the local name of the attribute.\n"
		"@param uri  a string, the namespace URI of the attribute.\n"
		"\n"
		"@return @c true if an attribute with the given local name and namespace \n"
		"URI exists in this XMLAttributes, @c false otherwise.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>hasAttribute(XMLTriple triple)</pre>\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether\n"
		"an attribute with the given XML triple exists in this XMLAttributes.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute \n"
		"\n"
		"@return @c true if an attribute with the given XML triple exists in this\n"
		"XMLAttributes, @c false otherwise.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_isEmpty", _wrap_XMLAttributes_isEmpty, METH_VARARGS, (char *)"\n"
		"XMLAttributes_isEmpty(XMLAttributes self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLAttributes set is empty.\n"
		"\n"
		"@return @c true if this XMLAttributes set is empty, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLAttributes_swigregister", XMLAttributes_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_XMLNamespaces", _wrap_delete_XMLNamespaces, METH_VARARGS, (char *)"delete_XMLNamespaces(XMLNamespaces self)"},
	 { (char *)"new_XMLNamespaces", _wrap_new_XMLNamespaces, METH_VARARGS, (char *)"\n"
		"XMLNamespaces()\n"
		"new_XMLNamespaces(XMLNamespaces orig) -> XMLNamespaces\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLNamespaces()</pre>\n"
		"\n"
		"Creates a new empty list of XML namespace declarations.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLNamespaces(XMLNamespaces orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this XMLNamespaces list.\n"
		"\n"
		"@param orig the XMLNamespaces object to copy\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_clone", _wrap_XMLNamespaces_clone, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_clone(XMLNamespaces self) -> XMLNamespaces\n"
		"\n"
		"Creates and returns a deep copy of this XMLNamespaces list.\n"
		"\n"
		"@return a (deep) copy of this XMLNamespaces list.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_add", _wrap_XMLNamespaces_add, METH_VARARGS, (char *)"\n"
		"add(string uri, string prefix = \"\") -> int\n"
		"XMLNamespaces_add(XMLNamespaces self, string uri) -> int\n"
		"\n"
		"Appends an XML namespace prefix and URI pair to this list of namespace\n"
		"declarations.\n"
		"\n"
		"An XMLNamespaces object stores a list of pairs of namespaces and their\n"
		"prefixes.  If there is an XML namespace with the given @p uri prefix\n"
		"in this list, then its corresponding URI will be overwritten by the\n"
		"new @p uri.  Calling programs could use one of the other XMLNamespaces\n"
		"methods, such as\n"
		"XMLNamespaces.hasPrefix() and \n"
		"XMLNamespaces.hasURI() to\n"
		"inquire whether a given prefix and/or URI\n"
		"is already present in this XMLNamespaces object.\n"
		"\n"
		"@param uri a string, the uri for the namespace\n"
		"@param prefix a string, the prefix for the namespace\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_remove", _wrap_XMLNamespaces_remove, METH_VARARGS, (char *)"\n"
		"remove(int index) -> int\n"
		"XMLNamespaces_remove(XMLNamespaces self, string prefix) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(int index)</pre>\n"
		"\n"
		"Removes an XML Namespace stored in the given position of this list.\n"
		"\n"
		"@param index an integer, position of the namespace to remove.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>remove(string prefix)</pre>\n"
		"\n"
		"Removes an XML Namespace with the given prefix.\n"
		"\n"
		"@param prefix a string, prefix of the required namespace.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"\n"
		"@see remove()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_clear", _wrap_XMLNamespaces_clear, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_clear(XMLNamespaces self) -> int\n"
		"\n"
		"Clears (deletes) all XML namespace declarations in this XMLNamespaces\n"
		"object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink\n"
		"\n"
		"@see remove()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_getIndex", _wrap_XMLNamespaces_getIndex, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_getIndex(XMLNamespaces self, string uri) -> int\n"
		"\n"
		"Look up the index of an XML namespace declaration by URI.\n"
		"\n"
		"An XMLNamespaces object stores a list of pairs of namespaces and their\n"
		"prefixes.  If this XMLNamespaces object contains a pair with the given\n"
		"URI @p uri, this method returns its index in the list.\n"
		"\n"
		"@param uri a string, the URI of the sought-after namespace.\n"
		"\n"
		"@return the index of the given declaration, or <code>-1</code> if not\n"
		"present.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_getIndexByPrefix", _wrap_XMLNamespaces_getIndexByPrefix, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_getIndexByPrefix(XMLNamespaces self, string prefix) -> int\n"
		"\n"
		"Look up the index of an XML namespace declaration by prefix.\n"
		"\n"
		"An XMLNamespaces object stores a list of pairs of namespaces and their\n"
		"prefixes.  If this XMLNamespaces object contains a pair with the given\n"
		"prefix @p prefix, this method returns its index in the list.\n"
		"\n"
		"@param prefix a string, the prefix string of the sought-after\n"
		"namespace\n"
		"\n"
		"@return the index of the given declaration, or <code>-1</code> if not\n"
		"present.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_getLength", _wrap_XMLNamespaces_getLength, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_getLength(XMLNamespaces self) -> int\n"
		"\n"
		"Returns the total number of URI-and-prefix pairs stored in this\n"
		"particular XMLNamespaces instance.\n"
		"\n"
		"@return the number of namespaces in this list.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_getPrefix", _wrap_XMLNamespaces_getPrefix, METH_VARARGS, (char *)"\n"
		"getPrefix(int index) -> string\n"
		"XMLNamespaces_getPrefix(XMLNamespaces self, string uri) -> string\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getPrefix(int index)</pre>\n"
		"\n"
		"Look up the prefix of an XML namespace declaration by its position.\n"
		"\n"
		"An XMLNamespaces object stores a list of pairs of namespaces and their\n"
		"prefixes.  This method returns the prefix of the <code>n</code>th\n"
		"element in that list (if it exists).  Callers should use\n"
		"XMLAttributes.getLength() first to find out how many namespaces are\n"
		"stored in the list.\n"
		"\n"
		"@param index an integer, position of the sought-after prefix\n"
		"\n"
		"@return the prefix of an XML namespace declaration in this list (by\n"
		"position), or an empty string if the @p index is out of range\n"
		"\n"
		"@see getLength()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getPrefix(string uri)</pre>\n"
		"\n"
		"Look up the prefix of an XML namespace declaration by its URI.\n"
		"\n"
		"An XMLNamespaces object stores a list of pairs of namespaces and their\n"
		"prefixes.  This method returns the prefix for a pair that has the\n"
		"given @p uri.\n"
		"\n"
		"@param uri a string, the URI of the prefix being sought\n"
		"\n"
		"@return the prefix of an XML namespace declaration given its URI, or\n"
		"an empty string if no such @p uri exists in this XMLNamespaces object\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_getURI", _wrap_XMLNamespaces_getURI, METH_VARARGS, (char *)"\n"
		"getURI(int index) -> string\n"
		"getURI(string prefix = \"\") -> string\n"
		"XMLNamespaces_getURI(XMLNamespaces self) -> string\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getURI(int index)</pre>\n"
		"\n"
		"Look up the URI of an XML namespace declaration by its position.\n"
		"\n"
		"An XMLNamespaces object stores a list of pairs of namespaces and their\n"
		"prefixes.  This method returns the URI of the <code>n</code>th element\n"
		"in that list (if it exists).  Callers should use\n"
		"XMLAttributes.getLength() first to find out how many namespaces are\n"
		"stored in the list.\n"
		"\n"
		"@param index an integer, position of the required URI.\n"
		"\n"
		"@return the URI of an XML namespace declaration in this list (by\n"
		"position), or an empty string if the @p index is out of range.\n"
		"\n"
		"@see getLength()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getURI(string prefix = '')</pre>\n"
		"\n"
		"Look up the URI of an XML namespace declaration by its prefix.\n"
		"\n"
		"An XMLNamespaces object stores a list of pairs of namespaces and their\n"
		"prefixes.  This method returns the namespace URI for a pair that has\n"
		"the given @p prefix.\n"
		"\n"
		"@param prefix a string, the prefix of the required URI\n"
		"\n"
		"@return the URI of an XML namespace declaration having the given @p\n"
		"prefix, or an empty string if no such prefix-and-URI pair exists\n"
		"in this XMLNamespaces object\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"\n"
		"@see getURI()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_isEmpty", _wrap_XMLNamespaces_isEmpty, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_isEmpty(XMLNamespaces self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"XMLNamespaces list is empty.\n"
		"\n"
		"@return @c true if this XMLNamespaces list is empty, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_hasURI", _wrap_XMLNamespaces_hasURI, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_hasURI(XMLNamespaces self, string uri) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether an XML\n"
		"Namespace with the given URI is contained in this XMLNamespaces list.\n"
		"\n"
		"@param uri a string, the uri for the namespace\n"
		"\n"
		"@return @c true if an XML Namespace with the given URI is contained in\n"
		"this XMLNamespaces list, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_hasPrefix", _wrap_XMLNamespaces_hasPrefix, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_hasPrefix(XMLNamespaces self, string prefix) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether an XML\n"
		"Namespace with the given prefix is contained in this XMLNamespaces\n"
		"list.\n"
		"\n"
		"@param prefix a string, the prefix for the namespace\n"
		"\n"
		"@return @c true if an XML Namespace with the given URI is contained in\n"
		"this XMLNamespaces list, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_hasNS", _wrap_XMLNamespaces_hasNS, METH_VARARGS, (char *)"\n"
		"XMLNamespaces_hasNS(XMLNamespaces self, string uri, string prefix) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether an XML\n"
		"Namespace with the given URI and prefix pair is contained in this\n"
		"XMLNamespaces list.\n"
		"\n"
		"@param uri a string, the URI for the namespace\n"
		"@param prefix a string, the prefix for the namespace\n"
		"\n"
		"@return @c true if an XML Namespace with the given uri/prefix pair is\n"
		"contained in this XMLNamespaces list, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNamespaces_swigregister", XMLNamespaces_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_XMLToken", _wrap_delete_XMLToken, METH_VARARGS, (char *)"delete_XMLToken(XMLToken self)"},
	 { (char *)"new_XMLToken", _wrap_new_XMLToken, METH_VARARGS, (char *)"\n"
		"XMLToken()\n"
		"XMLToken(XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, \n"
		"    unsigned int line = 0, unsigned int column = 0)\n"
		"XMLToken(XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, \n"
		"    unsigned int line = 0)\n"
		"XMLToken(XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces)\n"
		"XMLToken(XMLTriple triple, XMLAttributes attributes, unsigned int line = 0, \n"
		"    unsigned int column = 0)\n"
		"XMLToken(XMLTriple triple, XMLAttributes attributes, unsigned int line = 0)\n"
		"XMLToken(XMLTriple triple, XMLAttributes attributes)\n"
		"XMLToken(XMLTriple triple, unsigned int line = 0, unsigned int column = 0)\n"
		"XMLToken(XMLTriple triple, unsigned int line = 0)\n"
		"XMLToken(XMLTriple triple)\n"
		"XMLToken(string chars, unsigned int line = 0, unsigned int column = 0)\n"
		"XMLToken(string chars, unsigned int line = 0)\n"
		"XMLToken(string chars)\n"
		"new_XMLToken(XMLToken orig) -> XMLToken\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLToken()</pre>\n"
		"\n"
		"Creates a new empty XMLToken.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLToken(  XMLTriple      triple , XMLAttributes  attributes , XMLNamespaces  namespaces , const long    line   = 0 , const long    column = 0 )</pre>\n"
		"\n"
		"Creates a start element XMLToken with the given set of attributes and\n"
		"namespace declarations.\n"
		"\n"
		"@param triple XMLTriple.\n"
		"@param attributes XMLAttributes, the attributes to set.\n"
		"@param namespaces XMLNamespaces, the namespaces to set.\n"
		"@param line a long integer, the line number (default = 0).\n"
		"@param column a long integer, the column number (default = 0).\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLToken(  XMLTriple      triple , XMLAttributes  attributes , const long    line   = 0 , const long    column = 0 )</pre>\n"
		"\n"
		"Creates a start element XMLToken with the given set of attributes.\n"
		"\n"
		"@param triple XMLTriple.\n"
		"@param attributes XMLAttributes, the attributes to set.\n"
		"@param line a long integer, the line number (default = 0).\n"
		"@param column a long integer, the column number (default = 0).\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLToken(  XMLTriple    triple , const long  line   = 0 , const long  column = 0 )</pre>\n"
		"\n"
		"Creates an end element XMLToken.\n"
		"\n"
		"@param triple XMLTriple.\n"
		"@param line a long integer, the line number (default = 0).\n"
		"@param column a long integer, the column number (default = 0).\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLToken(  string  chars , const long  line   = 0 , const long  column = 0 )</pre>\n"
		"\n"
		"Creates a text XMLToken.\n"
		"\n"
		"@param chars a string, the text to be added to the XMLToken\n"
		"@param line a long integer, the line number (default = 0).\n"
		"@param column a long integer, the column number (default = 0).\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLToken(XMLToken orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this XMLToken.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_clone", _wrap_XMLToken_clone, METH_VARARGS, (char *)"\n"
		"XMLToken_clone(XMLToken self) -> XMLToken\n"
		"\n"
		"Creates and returns a deep copy of this XMLToken.\n"
		"\n"
		"@return a (deep) copy of this XMLToken set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttributes", _wrap_XMLToken_getAttributes, METH_VARARGS, (char *)"\n"
		"XMLToken_getAttributes(XMLToken self) -> XMLAttributes\n"
		"\n"
		"Returns the attributes of this element.\n"
		"\n"
		"@return the XMLAttributes of this XML element.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_setAttributes", _wrap_XMLToken_setAttributes, METH_VARARGS, (char *)"\n"
		"XMLToken_setAttributes(XMLToken self, XMLAttributes attributes) -> int\n"
		"\n"
		"Sets an XMLAttributes to this XMLToken.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param attributes XMLAttributes to be set to this XMLToken.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note This function replaces the existing XMLAttributes with the new one.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_addAttr", _wrap_XMLToken_addAttr, METH_VARARGS, (char *)"\n"
		"addAttr(string name, string value, string namespaceURI = \"\", \n"
		"    string prefix = \"\") -> int\n"
		"addAttr(string name, string value, string namespaceURI = \"\") -> int\n"
		"addAttr(string name, string value) -> int\n"
		"XMLToken_addAttr(XMLToken self, XMLTriple triple, string value) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>addAttr(  string name , string value , string namespaceURI = '' , string prefix = '')</pre>\n"
		"\n"
		"Adds an attribute to the attribute set in this XMLToken optionally \n"
		"with a prefix and URI defining a namespace.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param name a string, the local name of the attribute.\n"
		"@param value a string, the value of the attribute.\n"
		"@param namespaceURI a string, the namespace URI of the attribute.\n"
		"@param prefix a string, the prefix of the namespace\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"\n"
		"@note if local name with the same namespace URI already exists in the\n"
		"attribute set, its value and prefix will be replaced.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>addAttr( XMLTriple triple, string value)</pre>\n"
		"\n"
		"Adds an attribute with the given XMLTriple/value pair to the attribute set\n"
		"in this XMLToken.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@note if local name with the same namespace URI already exists in the \n"
		"attribute set, its value and prefix will be replaced.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute.\n"
		"@param value a string, the value of the attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_removeAttr", _wrap_XMLToken_removeAttr, METH_VARARGS, (char *)"\n"
		"removeAttr(int n) -> int\n"
		"removeAttr(string name, string uri = \"\") -> int\n"
		"removeAttr(string name) -> int\n"
		"XMLToken_removeAttr(XMLToken self, XMLTriple triple) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeAttr(int n)</pre>\n"
		"\n"
		"Removes an attribute with the given index from the attribute set in\n"
		"this XMLToken.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param n an integer the index of the resource to be deleted\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeAttr(string name, string uri = '')</pre>\n"
		"\n"
		"Removes an attribute with the given local name and namespace URI from \n"
		"the attribute set in this XMLToken.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param name   a string, the local name of the attribute.\n"
		"@param uri    a string, the namespace URI of the attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeAttr(XMLTriple triple)</pre>\n"
		"\n"
		"Removes an attribute with the given XMLTriple from the attribute set \n"
		"in this XMLToken.  \n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_clearAttributes", _wrap_XMLToken_clearAttributes, METH_VARARGS, (char *)"\n"
		"XMLToken_clearAttributes(XMLToken self) -> int\n"
		"\n"
		"Clears (deletes) all attributes in this XMLToken.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttrIndex", _wrap_XMLToken_getAttrIndex, METH_VARARGS, (char *)"\n"
		"getAttrIndex(string name, string uri = \"\") -> int\n"
		"getAttrIndex(string name) -> int\n"
		"XMLToken_getAttrIndex(XMLToken self, XMLTriple triple) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getAttrIndex(string name, string uri='')</pre>\n"
		"\n"
		"Return the index of an attribute with the given local name and namespace URI.\n"
		"\n"
		"@param name a string, the local name of the attribute.\n"
		"@param uri  a string, the namespace URI of the attribute.\n"
		"\n"
		"@return the index of an attribute with the given local name and namespace URI, \n"
		"or <code>-1</code> if not present.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getAttrIndex(XMLTriple triple)</pre>\n"
		"\n"
		"Return the index of an attribute with the given XMLTriple.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute for which \n"
		"       the index is required.\n"
		"\n"
		"@return the index of an attribute with the given XMLTriple, or <code>-1</code> if not present.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttributesLength", _wrap_XMLToken_getAttributesLength, METH_VARARGS, (char *)"\n"
		"XMLToken_getAttributesLength(XMLToken self) -> int\n"
		"\n"
		"Return the number of attributes in the attributes set.\n"
		"\n"
		"@return the number of attributes in the attributes set in this XMLToken.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttrName", _wrap_XMLToken_getAttrName, METH_VARARGS, (char *)"\n"
		"XMLToken_getAttrName(XMLToken self, int index) -> string\n"
		"\n"
		"Return the local name of an attribute in the attributes set in this \n"
		"XMLToken (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose local name \n"
		"is required.\n"
		"\n"
		"@return the local name of an attribute in this list (by position).  \n"
		"\n"
		"@note If index\n"
		"is out of range, an empty string will be returned.  Use\n"
		"XMLToken.hasAttr()\n"
		"to test for the attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttrPrefix", _wrap_XMLToken_getAttrPrefix, METH_VARARGS, (char *)"\n"
		"XMLToken_getAttrPrefix(XMLToken self, int index) -> string\n"
		"\n"
		"Return the prefix of an attribute in the attribute set in this \n"
		"XMLToken (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose prefix is \n"
		"required.\n"
		"\n"
		"@return the namespace prefix of an attribute in the attribute set\n"
		"(by position).  \n"
		"\n"
		"@note If index is out of range, an empty string will be returned. Use\n"
		"XMLToken.hasAttr() to test\n"
		"for the attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttrPrefixedName", _wrap_XMLToken_getAttrPrefixedName, METH_VARARGS, (char *)"\n"
		"XMLToken_getAttrPrefixedName(XMLToken self, int index) -> string\n"
		"\n"
		"Return the prefixed name of an attribute in the attribute set in this \n"
		"XMLToken (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose prefixed \n"
		"name is required.\n"
		"\n"
		"@return the prefixed name of an attribute in the attribute set \n"
		"(by position).  \n"
		"\n"
		"@note If index is out of range, an empty string will be returned.  Use\n"
		"XMLToken.hasAttr() to test\n"
		"for attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttrURI", _wrap_XMLToken_getAttrURI, METH_VARARGS, (char *)"\n"
		"XMLToken_getAttrURI(XMLToken self, int index) -> string\n"
		"\n"
		"Return the namespace URI of an attribute in the attribute set in this \n"
		"XMLToken (by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose namespace \n"
		"URI is required.\n"
		"\n"
		"@return the namespace URI of an attribute in the attribute set (by position).\n"
		"\n"
		"@note If index is out of range, an empty string will be returned.  Use\n"
		"XMLToken.hasAttr() to test\n"
		"for attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getAttrValue", _wrap_XMLToken_getAttrValue, METH_VARARGS, (char *)"\n"
		"getAttrValue(int index) -> string\n"
		"getAttrValue(string name, string uri = \"\") -> string\n"
		"getAttrValue(string name) -> string\n"
		"XMLToken_getAttrValue(XMLToken self, XMLTriple triple) -> string\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getAttrValue(int index)</pre>\n"
		"\n"
		"Return the value of an attribute in the attribute set in this XMLToken  \n"
		"(by position).\n"
		"\n"
		"@param index an integer, the position of the attribute whose value is \n"
		"required.\n"
		"\n"
		"@return the value of an attribute in the attribute set (by position).  \n"
		"\n"
		"@note If index is out of range, an empty string will be returned. Use\n"
		"XMLToken.hasAttr() to test\n"
		"for attribute existence.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getAttrValue(string name, string uri='')</pre>\n"
		"\n"
		"Return a value of an attribute with the given local name and namespace URI.\n"
		"\n"
		"@param name a string, the local name of the attribute whose value is required.\n"
		"@param uri  a string, the namespace URI of the attribute.\n"
		"\n"
		"@return The attribute value as a string.  \n"
		"\n"
		"@note If an attribute with the \n"
		"given local name and namespace URI does not exist, an empty string will be \n"
		"returned.  \n"
		"Use XMLToken.hasAttr()\n"
		"to test for attribute existence.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getAttrValue(XMLTriple triple)</pre>\n"
		"\n"
		"Return a value of an attribute with the given XMLTriple.\n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute whose \n"
		"       value is required.\n"
		"\n"
		"@return The attribute value as a string.  \n"
		"\n"
		"@note If an attribute with the\n"
		"given XMLTriple does not exist, an empty string will be returned.  \n"
		"Use XMLToken.hasAttr()\n"
		"to test for attribute existence.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_hasAttr", _wrap_XMLToken_hasAttr, METH_VARARGS, (char *)"\n"
		"hasAttr(int index) -> bool\n"
		"hasAttr(string name, string uri = \"\") -> bool\n"
		"hasAttr(string name) -> bool\n"
		"XMLToken_hasAttr(XMLToken self, XMLTriple triple) -> bool\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>hasAttr(int index)</pre>\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether\n"
		"an attribute with the given index exists in the attribute set in this \n"
		"XMLToken.\n"
		"\n"
		"@param index an integer, the position of the attribute.\n"
		"\n"
		"@return @c true if an attribute with the given index exists in the attribute \n"
		"set in this XMLToken, @c false otherwise.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>hasAttr(string name, string uri='')</pre>\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether\n"
		"an attribute with the given local name and namespace URI exists \n"
		"in the attribute set in this XMLToken.\n"
		"\n"
		"@param name a string, the local name of the attribute.\n"
		"@param uri  a string, the namespace URI of the attribute.\n"
		"\n"
		"@return @c true if an attribute with the given local name and namespace \n"
		"URI exists in the attribute set in this XMLToken, @c false otherwise.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>hasAttr(XMLTriple triple)</pre>\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether\n"
		"an attribute with the given XML triple exists in the attribute set in \n"
		"this XMLToken \n"
		"\n"
		"@param triple an XMLTriple, the XML triple of the attribute \n"
		"\n"
		"@return @c true if an attribute with the given XML triple exists\n"
		"in the attribute set in this XMLToken, @c false otherwise.\n"
		"\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isAttributesEmpty", _wrap_XMLToken_isAttributesEmpty, METH_VARARGS, (char *)"\n"
		"XMLToken_isAttributesEmpty(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"the attribute set in this XMLToken set is empty.\n"
		"\n"
		"@return @c true if the attribute set in this XMLToken is empty, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getNamespaces", _wrap_XMLToken_getNamespaces, METH_VARARGS, (char *)"\n"
		"XMLToken_getNamespaces(XMLToken self) -> XMLNamespaces\n"
		"\n"
		"Returns the XML namespace declarations for this XML element.\n"
		"\n"
		"@return the XML namespace declarations for this XML element.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_setNamespaces", _wrap_XMLToken_setNamespaces, METH_VARARGS, (char *)"\n"
		"XMLToken_setNamespaces(XMLToken self, XMLNamespaces namespaces) -> int\n"
		"\n"
		"Sets an XMLnamespaces to this XML element.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param namespaces XMLNamespaces to be set to this XMLToken.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"\n"
		"@note This function replaces the existing XMLNamespaces with the new one.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_addNamespace", _wrap_XMLToken_addNamespace, METH_VARARGS, (char *)"\n"
		"addNamespace(string uri, string prefix = \"\") -> int\n"
		"XMLToken_addNamespace(XMLToken self, string uri) -> int\n"
		"\n"
		"Appends an XML namespace prefix and URI pair to this XMLToken.\n"
		"If there is an XML namespace with the given prefix in this XMLToken, \n"
		"then the existing XML namespace will be overwritten by the new one.\n"
		"\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param uri a string, the uri for the namespace\n"
		"@param prefix a string, the prefix for the namespace\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_removeNamespace", _wrap_XMLToken_removeNamespace, METH_VARARGS, (char *)"\n"
		"removeNamespace(int index) -> int\n"
		"XMLToken_removeNamespace(XMLToken self, string prefix) -> int\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeNamespace(int index)</pre>\n"
		"\n"
		"Removes an XML Namespace stored in the given position of the XMLNamespaces\n"
		"of this XMLToken.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param index an integer, position of the removed namespace.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>removeNamespace(string prefix)</pre>\n"
		"\n"
		"Removes an XML Namespace with the given prefix.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@param prefix a string, prefix of the required namespace.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"@li @link libsbml.LIBSBML_INDEX_EXCEEDS_SIZE LIBSBML_INDEX_EXCEEDS_SIZE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_clearNamespaces", _wrap_XMLToken_clearNamespaces, METH_VARARGS, (char *)"\n"
		"XMLToken_clearNamespaces(XMLToken self) -> int\n"
		"\n"
		"Clears (deletes) all XML namespace declarations in the XMLNamespaces of\n"
		"this XMLToken.\n"
		"Nothing will be done if this XMLToken is not a start element.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getNamespaceIndex", _wrap_XMLToken_getNamespaceIndex, METH_VARARGS, (char *)"\n"
		"XMLToken_getNamespaceIndex(XMLToken self, string uri) -> int\n"
		"\n"
		"Look up the index of an XML namespace declaration by URI.\n"
		"\n"
		"@param uri a string, uri of the required namespace.\n"
		"\n"
		"@return the index of the given declaration, or <code>-1</code> if not present.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getNamespaceIndexByPrefix", _wrap_XMLToken_getNamespaceIndexByPrefix, METH_VARARGS, (char *)"\n"
		"XMLToken_getNamespaceIndexByPrefix(XMLToken self, string prefix) -> int\n"
		"\n"
		"Look up the index of an XML namespace declaration by prefix.\n"
		"\n"
		"@param prefix a string, prefix of the required namespace.\n"
		"\n"
		"@return the index of the given declaration, or <code>-1</code> if not present.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getNamespacesLength", _wrap_XMLToken_getNamespacesLength, METH_VARARGS, (char *)"\n"
		"XMLToken_getNamespacesLength(XMLToken self) -> int\n"
		"\n"
		"Returns the number of XML namespaces stored in the XMLNamespaces \n"
		"of this XMLToken.\n"
		"\n"
		"@return the number of namespaces in this list.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getNamespacePrefix", _wrap_XMLToken_getNamespacePrefix, METH_VARARGS, (char *)"\n"
		"getNamespacePrefix(int index) -> string\n"
		"XMLToken_getNamespacePrefix(XMLToken self, string uri) -> string\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getNamespacePrefix(int index)</pre>\n"
		"\n"
		"Look up the prefix of an XML namespace declaration by position.\n"
		"\n"
		"Callers should use getNamespacesLength() to find out how many \n"
		"namespaces are stored in the XMLNamespaces.\n"
		"\n"
		"@param index an integer, position of the required prefix.\n"
		"\n"
		"@return the prefix of an XML namespace declaration in the XMLNamespaces \n"
		"(by position).  \n"
		"\n"
		"@note If index is out of range, an empty string will be\n"
		"returned.\n"
		"\n"
		"@see getNamespacesLength()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getNamespacePrefix(string uri)</pre>\n"
		"\n"
		"Look up the prefix of an XML namespace declaration by its URI.\n"
		"\n"
		"@param uri a string, the URI of the prefix being sought\n"
		"\n"
		"@return the prefix of an XML namespace declaration given its URI.  \n"
		"\n"
		"@note If @p uri does not exist, an empty string will be returned.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getNamespaceURI", _wrap_XMLToken_getNamespaceURI, METH_VARARGS, (char *)"\n"
		"getNamespaceURI(int index) -> string\n"
		"getNamespaceURI(string prefix = \"\") -> string\n"
		"XMLToken_getNamespaceURI(XMLToken self) -> string\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getNamespaceURI(int index)</pre>\n"
		"\n"
		"Look up the URI of an XML namespace declaration by its position.\n"
		"\n"
		"@param index an integer, position of the required URI.\n"
		"\n"
		"@return the URI of an XML namespace declaration in the XMLNamespaces\n"
		"(by position).  \n"
		"\n"
		"@note If @p index is out of range, an empty string will be\n"
		"returned.\n"
		"\n"
		"@see getNamespacesLength()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getNamespaceURI(string prefix = '')</pre>\n"
		"\n"
		"Look up the URI of an XML namespace declaration by its prefix.\n"
		"\n"
		"@param prefix a string, the prefix of the required URI\n"
		"\n"
		"@return the URI of an XML namespace declaration given its prefix.  \n"
		"\n"
		"@note If @p prefix does not exist, an empty string will be returned.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isNamespacesEmpty", _wrap_XMLToken_isNamespacesEmpty, METH_VARARGS, (char *)"\n"
		"XMLToken_isNamespacesEmpty(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"the XMLNamespaces of this XMLToken is empty.\n"
		"\n"
		"@return @c true if the XMLNamespaces of this XMLToken is empty, \n"
		"@c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_hasNamespaceURI", _wrap_XMLToken_hasNamespaceURI, METH_VARARGS, (char *)"\n"
		"XMLToken_hasNamespaceURI(XMLToken self, string uri) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"an XML Namespace with the given URI is contained in the XMLNamespaces of\n"
		"this XMLToken.\n"
		"\n"
		"@param uri a string, the uri for the namespace\n"
		"\n"
		"@return @c true if an XML Namespace with the given URI is contained in the\n"
		"XMLNamespaces of this XMLToken,  @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_hasNamespacePrefix", _wrap_XMLToken_hasNamespacePrefix, METH_VARARGS, (char *)"\n"
		"XMLToken_hasNamespacePrefix(XMLToken self, string prefix) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"an XML Namespace with the given prefix is contained in the XMLNamespaces of\n"
		"this XMLToken.\n"
		"\n"
		"@param prefix a string, the prefix for the namespace\n"
		"\n"
		"@return @c true if an XML Namespace with the given URI is contained in the\n"
		"XMLNamespaces of this XMLToken, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_hasNamespaceNS", _wrap_XMLToken_hasNamespaceNS, METH_VARARGS, (char *)"\n"
		"XMLToken_hasNamespaceNS(XMLToken self, string uri, string prefix) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"an XML Namespace with the given uri/prefix pair is contained in the \n"
		"XMLNamespaces ofthis XMLToken.\n"
		"\n"
		"@param uri a string, the uri for the namespace\n"
		"@param prefix a string, the prefix for the namespace\n"
		"\n"
		"@return @c true if an XML Namespace with the given uri/prefix pair is \n"
		"contained in the XMLNamespaces of this XMLToken,  @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_setTriple", _wrap_XMLToken_setTriple, METH_VARARGS, (char *)"\n"
		"XMLToken_setTriple(XMLToken self, XMLTriple triple) -> int\n"
		"\n"
		"Sets the XMLTripe (name, uri and prefix) of this XML element.\n"
		"Nothing will be done if this XML element is a text node.\n"
		"\n"
		"@param triple XMLTriple to be added to this XML element.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getName", _wrap_XMLToken_getName, METH_VARARGS, (char *)"\n"
		"XMLToken_getName(XMLToken self) -> string\n"
		"\n"
		"Returns the (unqualified) name of this XML element.\n"
		"\n"
		"@return the (unqualified) name of this XML element.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getPrefix", _wrap_XMLToken_getPrefix, METH_VARARGS, (char *)"\n"
		"XMLToken_getPrefix(XMLToken self) -> string\n"
		"\n"
		"Returns the namespace prefix of this XML element.\n"
		"\n"
		"@return the namespace prefix of this XML element.  \n"
		"\n"
		"@note If no prefix\n"
		"exists, an empty string will be return.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getURI", _wrap_XMLToken_getURI, METH_VARARGS, (char *)"\n"
		"XMLToken_getURI(XMLToken self) -> string\n"
		"\n"
		"Returns the namespace URI of this XML element.\n"
		"\n"
		"@return the namespace URI of this XML element.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getCharacters", _wrap_XMLToken_getCharacters, METH_VARARGS, (char *)"\n"
		"XMLToken_getCharacters(XMLToken self) -> string\n"
		"\n"
		"Returns the text of this element.\n"
		"\n"
		"@return the characters of this XML text.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_append", _wrap_XMLToken_append, METH_VARARGS, (char *)"\n"
		"XMLToken_append(XMLToken self, string chars) -> int\n"
		"\n"
		"Appends characters to this XML text content.\n"
		"\n"
		"@param chars string, characters to append\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getColumn", _wrap_XMLToken_getColumn, METH_VARARGS, (char *)"\n"
		"XMLToken_getColumn(XMLToken self) -> unsigned int\n"
		"\n"
		"Returns the column at which this XMLToken occurred in the input\n"
		"document or data stream.\n"
		"\n"
		"@return the column at which this XMLToken occurred.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_getLine", _wrap_XMLToken_getLine, METH_VARARGS, (char *)"\n"
		"XMLToken_getLine(XMLToken self) -> unsigned int\n"
		"\n"
		"Returns the line at which this XMLToken occurred in the input document\n"
		"or data stream.\n"
		"\n"
		"@return the line at which this XMLToken occurred.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isElement", _wrap_XMLToken_isElement, METH_VARARGS, (char *)"\n"
		"XMLToken_isElement(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLToken is an XML element.\n"
		"\n"
		"@return @c true if this XMLToken is an XML element, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isEnd", _wrap_XMLToken_isEnd, METH_VARARGS, (char *)"\n"
		"XMLToken_isEnd(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLToken is an XML end element.\n"
		"\n"
		"@return @c true if this XMLToken is an XML end element, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isEndFor", _wrap_XMLToken_isEndFor, METH_VARARGS, (char *)"\n"
		"XMLToken_isEndFor(XMLToken self, XMLToken element) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLToken is an XML end element for the given start element.\n"
		"\n"
		"@param element XMLToken, element for which query is made.\n"
		"\n"
		"@return @c true if this XMLToken is an XML end element for the given\n"
		"XMLToken start element, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isEOF", _wrap_XMLToken_isEOF, METH_VARARGS, (char *)"\n"
		"XMLToken_isEOF(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLToken is an end of file marker.\n"
		"\n"
		"@return @c true if this XMLToken is an end of file (input) marker, @c false\n"
		"otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isStart", _wrap_XMLToken_isStart, METH_VARARGS, (char *)"\n"
		"XMLToken_isStart(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLToken is an XML start element.\n"
		"\n"
		"@return @c true if this XMLToken is an XML start element, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_isText", _wrap_XMLToken_isText, METH_VARARGS, (char *)"\n"
		"XMLToken_isText(XMLToken self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLToken is an XML text element.\n"
		"\n"
		"@return @c true if this XMLToken is an XML text element, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_setEnd", _wrap_XMLToken_setEnd, METH_VARARGS, (char *)"\n"
		"XMLToken_setEnd(XMLToken self) -> int\n"
		"\n"
		"Declares this XML start element is also an end element.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_setEOF", _wrap_XMLToken_setEOF, METH_VARARGS, (char *)"\n"
		"XMLToken_setEOF(XMLToken self) -> int\n"
		"\n"
		"Declares this XMLToken is an end-of-file (input) marker.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_unsetEnd", _wrap_XMLToken_unsetEnd, METH_VARARGS, (char *)"\n"
		"XMLToken_unsetEnd(XMLToken self) -> int\n"
		"\n"
		"Declares this XML start/end element is no longer an end element.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_toString", _wrap_XMLToken_toString, METH_VARARGS, (char *)"\n"
		"XMLToken_toString(XMLToken self) -> string\n"
		"\n"
		"Prints a string representation of the underlying token stream, for\n"
		"debugging purposes.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLToken_swigregister", XMLToken_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_XMLNode", _wrap_delete_XMLNode, METH_VARARGS, (char *)"delete_XMLNode(XMLNode self)"},
	 { (char *)"new_XMLNode", _wrap_new_XMLNode, METH_VARARGS, (char *)"\n"
		"XMLNode()\n"
		"XMLNode(XMLToken token)\n"
		"XMLNode(XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, \n"
		"    unsigned int line = 0, unsigned int column = 0)\n"
		"XMLNode(XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces, \n"
		"    unsigned int line = 0)\n"
		"XMLNode(XMLTriple triple, XMLAttributes attributes, XMLNamespaces namespaces)\n"
		"XMLNode(XMLTriple triple, XMLAttributes attributes, unsigned int line = 0, \n"
		"    unsigned int column = 0)\n"
		"XMLNode(XMLTriple triple, XMLAttributes attributes, unsigned int line = 0)\n"
		"XMLNode(XMLTriple triple, XMLAttributes attributes)\n"
		"XMLNode(XMLTriple triple, unsigned int line = 0, unsigned int column = 0)\n"
		"XMLNode(XMLTriple triple, unsigned int line = 0)\n"
		"XMLNode(XMLTriple triple)\n"
		"XMLNode(string chars, unsigned int line = 0, unsigned int column = 0)\n"
		"XMLNode(string chars, unsigned int line = 0)\n"
		"XMLNode(string chars)\n"
		"new_XMLNode(XMLNode orig) -> XMLNode\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLNode()</pre>\n"
		"\n"
		"Creates a new empty XMLNode with no children.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLNode(XMLToken token)</pre>\n"
		"\n"
		"Creates a new XMLNode by copying token.\n"
		"\n"
		"@param token XMLToken to be copied to XMLNode\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLNode(  XMLTriple     triple , XMLAttributes attributes , XMLNamespaces namespaces , const long   line   = 0 , const long   column = 0 )</pre>\n"
		"\n"
		"Creates a new start element XMLNode with the given set of attributes and\n"
		"namespace declarations.\n"
		"\n"
		"@param triple XMLTriple.\n"
		"@param attributes XMLAttributes, the attributes to set.\n"
		"@param namespaces XMLNamespaces, the namespaces to set.\n"
		"@param line a long integer, the line number (default = 0).\n"
		"@param column a long integer, the column number (default = 0).\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLNode(  XMLTriple      triple , XMLAttributes  attributes , const long    line   = 0 , const long    column = 0 )</pre>\n"
		"\n"
		"Creates a start element XMLNode with the given set of attributes.\n"
		"\n"
		"@param triple XMLTriple.\n"
		"@param attributes XMLAttributes, the attributes to set.\n"
		"@param line a long integer, the line number (default = 0).\n"
		"@param column a long integer, the column number (default = 0).\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		" \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLNode(  XMLTriple    triple , const long  line   = 0 , const long  column = 0 )</pre>\n"
		"\n"
		"Creates an end element XMLNode.\n"
		"\n"
		"@param triple XMLTriple.\n"
		"@param line a long integer, the line number (default = 0).\n"
		"@param column a long integer, the column number (default = 0).\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLNode(  string  chars , const long  line   = 0 , const long  column = 0 )</pre>\n"
		"\n"
		"Creates a text XMLNode.\n"
		"\n"
		"@param chars a string, the text to be added to the XMLToken\n"
		"@param line a long integer, the line number (default = 0).\n"
		"@param column a long integer, the column number (default = 0).\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLNode(XMLNode orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this XMLNode.\n"
		"\n"
		"@param orig the XMLNode instance to copy.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_clone", _wrap_XMLNode_clone, METH_VARARGS, (char *)"\n"
		"XMLNode_clone(XMLNode self) -> XMLNode\n"
		"\n"
		"Creates and returns a deep copy of this XMLNode.\n"
		"\n"
		"@return a (deep) copy of this XMLNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_addChild", _wrap_XMLNode_addChild, METH_VARARGS, (char *)"\n"
		"XMLNode_addChild(XMLNode self, XMLNode node) -> int\n"
		"\n"
		"Adds a copy of @p node as a child of this XMLNode.\n"
		"\n"
		"The given @p node is added at the end of the list of children.\n"
		"\n"
		"@param node the XMLNode to be added as child.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_XML_OPERATION LIBSBML_INVALID_XML_OPERATION @endlink\n"
		"\n"
		"@note The given node is added at the end of the children list.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_insertChild", _wrap_XMLNode_insertChild, METH_VARARGS, (char *)"\n"
		"XMLNode_insertChild(XMLNode self, unsigned int n, XMLNode node) -> XMLNode\n"
		"\n"
		"Inserts a copy of the given node as the <code>n</code>th child of this\n"
		"XMLNode.\n"
		"\n"
		"If the given index @p n is out of range for this XMLNode instance,\n"
		"the @p node is added at the end of the list of children.  Even in\n"
		"that situation, this method does not throw an error.\n"
		"\n"
		"@param n an integer, the index at which the given node is inserted\n"
		"@param node an XMLNode to be inserted as <code>n</code>th child.\n"
		"\n"
		"@return a reference to the newly-inserted child @p node\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_removeChild", _wrap_XMLNode_removeChild, METH_VARARGS, (char *)"\n"
		"XMLNode_removeChild(XMLNode self, unsigned int n) -> XMLNode\n"
		"\n"
		"Removes the <code>n</code>th child of this XMLNode and returns the\n"
		"removed node.\n"
		"\n"
		"It is important to keep in mind that a given XMLNode may have more\n"
		"than one child.  Calling this method erases all existing references to\n"
		"child nodes @em after the given position @p n.  If the index @p n is\n"
		"greater than the number of child nodes in this XMLNode, this method\n"
		"takes no action (and returns @c None).\n"
		"\n"
		"@param n an integer, the index of the node to be removed\n"
		"\n"
		"@return the removed child, or @c None if @p n is greater than the number\n"
		"of children in this node\n"
		"\n"
		"@note The caller owns the returned node and is responsible for deleting it.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_removeChildren", _wrap_XMLNode_removeChildren, METH_VARARGS, (char *)"\n"
		"XMLNode_removeChildren(XMLNode self) -> int\n"
		"\n"
		"Removes all children from this node.\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_getChild", _wrap_XMLNode_getChild, METH_VARARGS, (char *)"\n"
		"getChild(unsigned int n) -> XMLNode\n"
		"getChild(unsigned int n) -> XMLNode\n"
		"getChild(string name) -> XMLNode\n"
		"XMLNode_getChild(XMLNode self, string name) -> XMLNode\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getChild(long n)</pre>\n"
		"\n"
		"Returns the <code>n</code>th child of this XMLNode.\n"
		"\n"
		"If the index @p n is greater than the number of child nodes, or it is\n"
		"0 or less, this method returns an empty node.\n"
		"\n"
		"@param n the index of the node to return\n"
		"\n"
		"@return the  <code>n</code>th child of this XMLNode.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getChild(long n)</pre>\n"
		"\n"
		"Returns the  <code>n</code>th child of this XMLNode.\n"
		"\n"
		"If the index @p n is greater than the number of child nodes, or it is\n"
		"0 or less, this method returns an empty node.\n"
		"\n"
		"@param n an integer, the index of the node to return\n"
		"\n"
		"@return the  <code>n</code>th child of this XMLNode.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getChild(string  name)</pre>\n"
		"\n"
		"Returns the first child of this XMLNode with the corresponding name.\n"
		"\n"
		"If no child with corrsponding name can be found, \n"
		"this method returns an empty node.\n"
		"\n"
		"@param name the name of the node to return\n"
		"\n"
		"@return the first child of this XMLNode with given name.\n"
		" \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getChild(string  name)</pre>\n"
		"\n"
		"Returns the first child of this XMLNode with the corresponding name.\n"
		"\n"
		"If no child with corrsponding name can be found, \n"
		"this method returns an empty node.\n"
		"\n"
		"@param name the name of the node to return\n"
		"\n"
		"@return the first child of this XMLNode with given name.\n"
		" \n"
		"\n"
		""},
	 { (char *)"XMLNode_getIndex", _wrap_XMLNode_getIndex, METH_VARARGS, (char *)"\n"
		"XMLNode_getIndex(XMLNode self, string name) -> int\n"
		"\n"
		"Return the index of the first child of this XMLNode with the given name.\n"
		"\n"
		"\n"
		"@param name a string, the name of the child for which the \n"
		"index is required.\n"
		"\n"
		"@return the index of the first child of this XMLNode with the given name, or -1 if not present.\n"
		" \n"
		"\n"
		""},
	 { (char *)"XMLNode_hasChild", _wrap_XMLNode_hasChild, METH_VARARGS, (char *)"\n"
		"XMLNode_hasChild(XMLNode self, string name) -> bool\n"
		"\n"
		"Return a boolean indicating whether this XMLNode has a child with the given name.\n"
		"\n"
		"\n"
		"@param name a string, the name of the child to be checked.\n"
		"\n"
		"@return boolean indicating whether this XMLNode has a child with the given name.\n"
		" \n"
		"\n"
		""},
	 { (char *)"XMLNode_equals", _wrap_XMLNode_equals, METH_VARARGS, (char *)"\n"
		"XMLNode_equals(XMLNode self, XMLNode other) -> bool\n"
		"\n"
		"Compare this XMLNode against another XMLNode returning true if both nodes\n"
		"represent the same XML tree, or false otherwise.\n"
		"\n"
		"\n"
		"@param other another XMLNode to compare against\n"
		"\n"
		"@return boolean indicating whether this XMLNode represents the same XML tree as another.\n"
		" \n"
		"\n"
		""},
	 { (char *)"XMLNode_getNumChildren", _wrap_XMLNode_getNumChildren, METH_VARARGS, (char *)"\n"
		"XMLNode_getNumChildren(XMLNode self) -> unsigned int\n"
		"\n"
		"Returns the number of children for this XMLNode.\n"
		"\n"
		"@return the number of children for this XMLNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_toXMLString", _wrap_XMLNode_toXMLString, METH_VARARGS, (char *)"\n"
		"XMLNode_toXMLString(XMLNode self) -> string\n"
		"\n"
		"Returns a string representation of this XMLNode. \n"
		"\n"
		"@return a string derived from this XMLNode.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_convertXMLNodeToString", _wrap_XMLNode_convertXMLNodeToString, METH_VARARGS, (char *)"\n"
		"XMLNode_convertXMLNodeToString(XMLNode node) -> string\n"
		"\n"
		"Returns a string representation of a given XMLNode. \n"
		"\n"
		"@param node the XMLNode to be represented as a string\n"
		"\n"
		"@return a string-form representation of @p node\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_convertStringToXMLNode", _wrap_XMLNode_convertStringToXMLNode, METH_VARARGS, (char *)"\n"
		"convertStringToXMLNode(string xmlstr, XMLNamespaces xmlns = None) -> XMLNode\n"
		"XMLNode_convertStringToXMLNode(string xmlstr) -> XMLNode\n"
		"\n"
		"Returns an XMLNode which is derived from a string containing XML\n"
		"content.\n"
		"\n"
		"The XML namespace must be defined using argument @p xmlns if the\n"
		"corresponding XML namespace attribute is not part of the string of the\n"
		"first argument.\n"
		"\n"
		"@param xmlstr string to be converted to a XML node.\n"
		"@param xmlns XMLNamespaces the namespaces to set (default value is @c None).\n"
		"\n"
		"@note The caller owns the returned XMLNode and is reponsible for\n"
		"deleting it.  The returned XMLNode object is a dummy root (container)\n"
		"XMLNode if the top-level element in the given XML string is NOT\n"
		"<code>&lt;html&gt;</code>, <code>&lt;body&gt;</code>,\n"
		"<code>&lt;annotation&gt;</code>, or <code>&lt;notes&gt;</code>.  In\n"
		"the dummy root node, each top-level element in the given XML string is\n"
		"contained as a child XMLNode. XMLToken.isEOF() can be used to\n"
		"identify if the returned XMLNode object is a dummy node.\n"
		"\n"
		"@return a XMLNode which is converted from string @p xmlstr.  If the\n"
		"conversion failed, this method returns @c None.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLNode_swigregister", XMLNode_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_XMLTriple", _wrap_new_XMLTriple, METH_VARARGS, (char *)"\n"
		"XMLTriple()\n"
		"XMLTriple(string name, string uri, string prefix)\n"
		"XMLTriple(string triplet, char sepchar = ' ')\n"
		"XMLTriple(string triplet)\n"
		"new_XMLTriple(XMLTriple orig) -> XMLTriple\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLTriple()</pre>\n"
		"\n"
		"Creates a new, empty XMLTriple.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLTriple(  string  name , string  uri , string  prefix )</pre>\n"
		"\n"
		"Creates a new XMLTriple with the given @p name, @p uri and and @p\n"
		"prefix.\n"
		"\n"
		"@param name a string, name for the XMLTriple.\n"
		"@param uri a string, URI of the XMLTriple.\n"
		"@param prefix a string, prefix for the URI of the XMLTriple,\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLTriple(string triplet, const char sepchar = ' ')</pre>\n"
		"\n"
		"Creates a new XMLTriple by splitting the given @p triplet on the\n"
		"separator character @p sepchar.\n"
		"\n"
		"Triplet may be in one of the following formats:\n"
		"<ul>\n"
		"<li> name\n"
		"<li> uri sepchar name\n"
		"<li> uri sepchar name sepchar prefix\n"
		"</ul>\n"
		"@param triplet a string representing the triplet as above\n"
		"@param sepchar a character, the sepchar used in the triplet\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLTriple(XMLTriple orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this XMLTriple set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLTriple_clone", _wrap_XMLTriple_clone, METH_VARARGS, (char *)"\n"
		"XMLTriple_clone(XMLTriple self) -> XMLTriple\n"
		"\n"
		"Creates and returns a deep copy of this XMLTriple set.\n"
		"\n"
		"@return a (deep) copy of this XMLTriple set.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLTriple_getName", _wrap_XMLTriple_getName, METH_VARARGS, (char *)"\n"
		"XMLTriple_getName(XMLTriple self) -> string\n"
		"\n"
		"Returns the @em name portion of this XMLTriple.\n"
		"\n"
		"@return a string, the name from this XMLTriple.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLTriple_getPrefix", _wrap_XMLTriple_getPrefix, METH_VARARGS, (char *)"\n"
		"XMLTriple_getPrefix(XMLTriple self) -> string\n"
		"\n"
		"Returns the @em prefix portion of this XMLTriple.\n"
		"\n"
		"@return a string, the @em prefix portion of this XMLTriple.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLTriple_getURI", _wrap_XMLTriple_getURI, METH_VARARGS, (char *)"\n"
		"XMLTriple_getURI(XMLTriple self) -> string\n"
		"\n"
		"Returns the @em URI portion of this XMLTriple.\n"
		"\n"
		"@return URI a string, the @em prefix portion of this XMLTriple.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLTriple_getPrefixedName", _wrap_XMLTriple_getPrefixedName, METH_VARARGS, (char *)"\n"
		"XMLTriple_getPrefixedName(XMLTriple self) -> string\n"
		"\n"
		"Returns the prefixed name from this XMLTriple.\n"
		"\n"
		"@return a string, the prefixed name from this XMLTriple.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLTriple_isEmpty", _wrap_XMLTriple_isEmpty, METH_VARARGS, (char *)"\n"
		"XMLTriple_isEmpty(XMLTriple self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this XMLTriple is empty.\n"
		"\n"
		"@return @c true if this XMLTriple is empty, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_XMLTriple", _wrap_delete_XMLTriple, METH_VARARGS, (char *)"delete_XMLTriple(XMLTriple self)"},
	 { (char *)"XMLTriple_swigregister", XMLTriple_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_XMLOutputStream", _wrap_new_XMLOutputStream, METH_VARARGS, (char *)"\n"
		"XMLOutputStream(ostream stream, string encoding = \"UTF-8\", bool writeXMLDecl = True, \n"
		"    string programName = \"\", string programVersion = \"\")\n"
		"XMLOutputStream(ostream stream, string encoding = \"UTF-8\", bool writeXMLDecl = True, \n"
		"    string programName = \"\")\n"
		"XMLOutputStream(ostream stream, string encoding = \"UTF-8\", bool writeXMLDecl = True)\n"
		"XMLOutputStream(ostream stream, string encoding = \"UTF-8\")\n"
		"new_XMLOutputStream(ostream stream) -> XMLOutputStream\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLOutputStream(  std::ostream&       stream , string  encoding     = 'UTF-8' , bool                writeXMLDecl = true , string   programName  = '' , string  programVersion = '')</pre>\n"
		"\n"
		"Creates a new XMLOutputStream that wraps stream.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_endElement", _wrap_XMLOutputStream_endElement, METH_VARARGS, (char *)"\n"
		"endElement(string name)\n"
		"XMLOutputStream_endElement(XMLOutputStream self, XMLTriple triple)\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>endElement(string name)</pre>\n"
		"\n"
		"Writes the given XML end element name to this XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>endElement(XMLTriple triple)</pre>\n"
		"\n"
		"Writes the given XML end element 'prefix:name' to this\n"
		"XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_setAutoIndent", _wrap_XMLOutputStream_setAutoIndent, METH_VARARGS, (char *)"\n"
		"XMLOutputStream_setAutoIndent(XMLOutputStream self, bool indent)\n"
		"\n"
		"Turns automatic indentation on or off for this XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_startElement", _wrap_XMLOutputStream_startElement, METH_VARARGS, (char *)"\n"
		"startElement(string name)\n"
		"XMLOutputStream_startElement(XMLOutputStream self, XMLTriple triple)\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>startElement(string name)</pre>\n"
		"\n"
		"Writes the given XML start element name to this XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>startElement(XMLTriple triple)</pre>\n"
		"\n"
		"Writes the given XML start element 'prefix:name' to this\n"
		"XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_startEndElement", _wrap_XMLOutputStream_startEndElement, METH_VARARGS, (char *)"\n"
		"startEndElement(string name)\n"
		"XMLOutputStream_startEndElement(XMLOutputStream self, XMLTriple triple)\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>startEndElement(string name)</pre>\n"
		"\n"
		"Writes the given XML start and end element name to this XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>startEndElement(XMLTriple triple)</pre>\n"
		"\n"
		"Writes the given XML start and end element 'prefix:name' to this\n"
		"XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_writeAttribute", _wrap_XMLOutputStream_writeAttribute, METH_VARARGS, (char *)"\n"
		"writeAttribute(string name, string value)\n"
		"writeAttribute(XMLTriple triple, string value)\n"
		"writeAttribute(string name, bool value)\n"
		"writeAttribute(XMLTriple triple, bool value)\n"
		"writeAttribute(string name, double value)\n"
		"writeAttribute(XMLTriple triple, double value)\n"
		"writeAttribute(string name, long value)\n"
		"writeAttribute(XMLTriple triple, long value)\n"
		"writeAttribute(string name, int value)\n"
		"XMLOutputStream_writeAttribute(XMLOutputStream self, XMLTriple triple, int value)\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeAttribute(string name, string value)</pre>\n"
		"\n"
		"Writes the given attribute, name='value' to this XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeAttribute(XMLTriple triple, string value)</pre>\n"
		"\n"
		"Writes the given attribute, prefix:name='value' to this\n"
		"XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeAttribute(string name, const bool& value)</pre>\n"
		"\n"
		"Writes the given attribute, name='true' or name='false' to this\n"
		"XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeAttribute(XMLTriple triple, const bool& value)</pre>\n"
		"\n"
		"Writes the given attribute, prefix:name='true' or prefix:name='false'\n"
		"to this XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeAttribute(string name, const double& value)</pre>\n"
		"\n"
		"Writes the given attribute, name='value' to this XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeAttribute(XMLTriple triple, const double& value)</pre>\n"
		"\n"
		"Writes the given attribute, prefix:name='value' to this\n"
		"XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeAttribute(string name, const long& value)</pre>\n"
		"\n"
		"Writes the given attribute, name='value' to this XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeAttribute(XMLTriple triple, const long& value)</pre>\n"
		"\n"
		"Writes the given attribute, prefix:name='value' to this\n"
		"XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeAttribute(string name, const int& value)</pre>\n"
		"\n"
		"Writes the given attribute, name='value' to this XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeAttribute(XMLTriple triple, const int& value)</pre>\n"
		"\n"
		"Writes the given attribute, prefix:name='value' to this\n"
		"XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeAttribute(string name, const long& value)</pre>\n"
		"\n"
		"Writes the given attribute, name='value' to this XMLOutputStream.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>writeAttribute(XMLTriple triple, const long& value)</pre>\n"
		"\n"
		"Writes the given attribute, prefix:name='value' to this\n"
		"XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_writeXMLDecl", _wrap_XMLOutputStream_writeXMLDecl, METH_VARARGS, (char *)"\n"
		"XMLOutputStream_writeXMLDecl(XMLOutputStream self)\n"
		"\n"
		"Writes the XML declaration:\n"
		"<?xml version='1.0' encoding='...'?>\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_writeComment", _wrap_XMLOutputStream_writeComment, METH_VARARGS, (char *)"\n"
		"XMLOutputStream_writeComment(XMLOutputStream self, string programName, string programVersion)\n"
		"\n"
		"Writes an XML comment:\n"
		"<?xml version='1.0' encoding='...'?>\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_downIndent", _wrap_XMLOutputStream_downIndent, METH_VARARGS, (char *)"\n"
		"XMLOutputStream_downIndent(XMLOutputStream self)\n"
		"\n"
		"Decreases the indentation level for this XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_upIndent", _wrap_XMLOutputStream_upIndent, METH_VARARGS, (char *)"\n"
		"XMLOutputStream_upIndent(XMLOutputStream self)\n"
		"\n"
		"Increases the indentation level for this XMLOutputStream.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLOutputStream_writeAttributeBool", _wrap_XMLOutputStream_writeAttributeBool, METH_VARARGS, (char *)"\n"
		"writeAttributeBool(string name, bool value)\n"
		"XMLOutputStream_writeAttributeBool(XMLOutputStream self, XMLTriple name, bool value)\n"
		""},
	 { (char *)"delete_XMLOutputStream", _wrap_delete_XMLOutputStream, METH_VARARGS, (char *)"delete_XMLOutputStream(XMLOutputStream self)"},
	 { (char *)"XMLOutputStream_swigregister", XMLOutputStream_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_XMLError", _wrap_new_XMLError, METH_VARARGS, (char *)"\n"
		"XMLError(int errorId = 0, string details = \"\", unsigned int line = 0, \n"
		"    unsigned int column = 0, unsigned int severity = LIBSBML_SEV_FATAL, \n"
		"    unsigned int category = LIBSBML_CAT_INTERNAL)\n"
		"XMLError(int errorId = 0, string details = \"\", unsigned int line = 0, \n"
		"    unsigned int column = 0, unsigned int severity = LIBSBML_SEV_FATAL)\n"
		"XMLError(int errorId = 0, string details = \"\", unsigned int line = 0, \n"
		"    unsigned int column = 0)\n"
		"XMLError(int errorId = 0, string details = \"\", unsigned int line = 0)\n"
		"XMLError(int errorId = 0, string details = \"\")\n"
		"XMLError(int errorId = 0)\n"
		"XMLError()\n"
		"new_XMLError(XMLError orig) -> XMLError\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLError( const int errorId           = 0 , string details  = '' , const long line     = 0 , const long column   = 0 , const long severity = LIBSBML_SEV_FATAL , const long category = LIBSBML_CAT_INTERNAL )</pre>\n"
		"\n"
		"Creates a new XMLError to report that something occurred during XML\n"
		"processing.\n"
		"\n"
		"XMLError objects have identification numbers to indicate the nature of\n"
		"the exception.  @if clike These numbers are drawn from\n"
		"the enumeration <a class='el'\n"
		"href='#XMLErrorCode_t'>XMLErrorCode_t</a>.\n"
		"@else These numbers are defined as unsigned \n"
		"integer constants in the file\n"
		"'libsbmlConstants.java'.  See the <a class='el'\n"
		"href='#XMLErrorCode_t'>top of this documentation</a> for a table\n"
		"listing the possible values and their meanings. @endif The argument @p\n"
		"errorId to this constructor @em can be (but does not have to be) a\n"
		"value from this @if clike enumeration. If it is a value\n"
		"from <a class='el' href='#XMLErrorCode_t'>XMLErrorCode_t</a>, the\n"
		"XMLError class assumes the error is a low-level system or XML layer\n"
		"error and <em>prepends</em> a built-in, predefined error message to\n"
		"any string passed in the argument @p details to this constructor.  In\n"
		"addition, all <a class='el' href='#XMLErrorCode_t'>XMLErrorCode_t</a>\n"
		"errors have associated values for the @p severity and @p category\n"
		"codes, and these fields are filled-in as well from the enumerations <a\n"
		"class='el' href='#XMLErrorSeverity_t'>XMLErrorSeverity_t</a> and <a\n"
		"class='el' href='#XMLErrorCategory_t'>XMLErrorCategory_t</a>,\n"
		"respectively. @else set of constants.  If it is\n"
		"one of the predefined error identifiers, the XMLError class assumes\n"
		"the error is a low-level system or XML layer error and\n"
		"<em>prepends</em> a built-in, predefined error message to any string\n"
		"passed in the argument @p details to this constructor.  In addition,\n"
		"all the predefined error identifiers have associated values for the @p\n"
		"severity and @p category codes, and these fields are filled-in as\n"
		"well. @endif\n"
		"\n"
		"If the error identifier @p errorId is a number greater than 9999, this\n"
		"constructor assumes that the error was generated from another part of\n"
		"the software, and does not do additional filling in of values beyond\n"
		"the defaults in the constructor itself.  This allows XMLError to serve\n"
		"as a base class for other errors (and is used in this way elsewhere in\n"
		"libSBML).  Callers should fill in all the parameters with suitable\n"
		"values if generating errors with codes greater than 9999 to make\n"
		"maximum use of the XMLError facilities.\n"
		"\n"
		"@if clike As mentioned above, there are two other\n"
		"enumerations, <a class='el'\n"
		"href='#XMLErrorSeverity_t'>XMLErrorSeverity_t</a> and <a class='el'\n"
		"href='#XMLErrorCategory_t'>XMLErrorCategory_t</a>, used for indicating\n"
		"the severity and category of error for the predefined XMLError codes.\n"
		"The values passed in @p severity and @p category override the defaults\n"
		"assigned based on the error code.  If the value of @p errorId is a\n"
		"value from <a class='el' href='#XMLErrorCode_t'>XMLErrorCode_t</a>,\n"
		"callers do not need to fill in @p severity and @p category.\n"
		"Conversely, if @p errorId is not a value from <a class='el'\n"
		"href='#XMLErrorCode_t'>XMLErrorCode_t</a>, callers can use other\n"
		"values (not just those from <a class='el'\n"
		"href='#XMLErrorSeverity_t'>XMLErrorSeverity_t</a> and <a class='el'\n"
		"href='#XMLErrorCategory_t'>XMLErrorCategory_t</a>, but their own\n"
		"special values) for @p severity and @p\n"
		"category. @else As mentioned above, \n"
		"there are additional constants defined for <a class='el'\n"
		"href='#XMLErrorSeverity_t'>standard severity</a> and <a class='el'\n"
		"href='#XMLErrorCategory_t'>standard category</a> codes, and every predefined \n"
		"error in libSBML has an associated value for severity and category taken\n"
		"from these predefined sets.  These constants have symbol names\n"
		"prefixed with <code>LIBSBML_SEV_</code> and <code>LIBSBML_CAT_</code>,\n"
		"respectively.  If the value of @p errorId is one of the standard error\n"
		"codes, callers do not need to fill in @p severity and @p category in a\n"
		"call to this constructor.  Conversely, if @p errorId is not an existing\n"
		"XML-level error code, callers can use other values for @p severity and\n"
		"@p category. @endif\n"
		"\n"
		"@param errorId a long integer, the identification number of the error.\n"
		"\n"
		"@param details a string containing additional details about the error.\n"
		"If the error code in @p errorId is one that is recognized by XMLError,\n"
		"the given message is @em appended to a predefined message associated\n"
		"with the given code.  If the error code is not recognized, the message\n"
		"is stored as-is as the text of the error.\n"
		"\n"
		"@param line a long integer, the line number at which the error occured.\n"
		"\n"
		"@param column a long integer, the column number at which the error occured.\n"
		"\n"
		"@param severity an integer indicating severity of the error.\n"
		"\n"
		"@param category an integer indicating the category to which the error\n"
		"belongs.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>XMLError(XMLError orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this XMLError.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_XMLError", _wrap_delete_XMLError, METH_VARARGS, (char *)"delete_XMLError(XMLError self)"},
	 { (char *)"XMLError_getErrorId", _wrap_XMLError_getErrorId, METH_VARARGS, (char *)"\n"
		"XMLError_getErrorId(XMLError self) -> unsigned int\n"
		"\n"
		"Returns the identifier of this error.\n"
		"\n"
		"@return the error code for this error.\n"
		"\n"
		"@see getMessage()\n"
		"@see getShortMessage()\n"
		"@see getCategory()\n"
		"@see getSeverity()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getMessage", _wrap_XMLError_getMessage, METH_VARARGS, (char *)"\n"
		"XMLError_getMessage(XMLError self) -> string\n"
		"\n"
		"Returns the message text of this error.\n"
		"\n"
		"The message associated with an error object describes the nature of\n"
		"the problem.  The message returned by this method is generally longer\n"
		"and clearer than the message returned by XMLError.getShortMessage(),\n"
		"but not in all cases.\n"
		"\n"
		"Callers may use XMLError.getCategory() and XMLError.getSeverity() to\n"
		"obtain additional information about the nature and severity of the\n"
		"problem.\n"
		"\n"
		"@return the message text\n"
		"\n"
		"@see getErrorId()\n"
		"@see getShortMessage()\n"
		"@see getCategory()\n"
		"@see getSeverity()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getShortMessage", _wrap_XMLError_getShortMessage, METH_VARARGS, (char *)"\n"
		"XMLError_getShortMessage(XMLError self) -> string\n"
		"\n"
		"Returns a brief message for this error.\n"
		"\n"
		"This is an alternative error message that, in general, is as short as\n"
		"the authors could make it.  However, brevity is often inversely\n"
		"proportional to clarity, so this short message may not be sufficiently\n"
		"informative to understand the nature of the error.  Calling\n"
		"applications may wish to check XMLError.getMessage() in addition or\n"
		"instead.\n"
		"\n"
		"@return the short error message text\n"
		"\n"
		"@see getErrorId()\n"
		"@see getMessage()\n"
		"@see getCategory()\n"
		"@see getSeverity()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getLine", _wrap_XMLError_getLine, METH_VARARGS, (char *)"\n"
		"XMLError_getLine(XMLError self) -> unsigned int\n"
		"\n"
		"Returns the line number in the XML input near where the error, warning\n"
		"or other diagnostic occurred.\n"
		"\n"
		"We say 'near where the problem occurred', because many factors affect\n"
		"how accurate the line/column information ultimately is.  For example,\n"
		"different XML parsers have different conventions for which line and\n"
		"column number they report for a particular problem (which in turn\n"
		"makes a difference when a problem involves an opening XML tag on one\n"
		"line and a closing tag on another line).  In some situations, some\n"
		"parsers report invalid line and/or column numbers altogether.  If this\n"
		"occurs, the line and/or column number in the XMLError object will be\n"
		"set to the the value of the maximum unsigned long integer\n"
		"representable on the platform where libSBML is running.  (This is\n"
		"equal to the constant named <code>ULONG_MAX</code> in C and C++.)  The\n"
		"probability that a true line or column number in an SBML model would\n"
		"equal this value is vanishingly small; thus, if an application\n"
		"encounters these values in an XMLError object, it can assume no valid\n"
		"line/column number could be provided by libSBML in that situation.\n"
		"\n"
		"@return the line number\n"
		"\n"
		"@see getColumn()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getColumn", _wrap_XMLError_getColumn, METH_VARARGS, (char *)"\n"
		"XMLError_getColumn(XMLError self) -> unsigned int\n"
		"\n"
		"Returns the column number in the XML input near where the error,\n"
		"warning or other diagnostic occurred.\n"
		"\n"
		"We say 'near where the problem occurred', because many factors affect\n"
		"how accurate the line/column information ultimately is.  For example,\n"
		"different XML parsers have different conventions for which line and\n"
		"column number they report for a particular problem (which in turn\n"
		"makes a difference when a problem involves an opening XML tag on one\n"
		"line and a closing tag on another line).  In some situations, some\n"
		"parsers report invalid line and/or column numbers altogether.  If this\n"
		"occurs, the line and/or column number in the XMLError object will be\n"
		"set to the the value of the maximum unsigned long integer\n"
		"representable on the platform where libSBML is running.  (This is\n"
		"equal to the constant named <code>ULONG_MAX</code> in C and C++.)  The\n"
		"probability that a true line or column number in an SBML model would\n"
		"equal this value is vanishingly small; thus, if an application\n"
		"encounters these values in an XMLError object, it can assume no valid\n"
		"line/column number could be provided by libSBML in that situation.\n"
		"\n"
		"@return the column number\n"
		"\n"
		"@see getLine()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getSeverity", _wrap_XMLError_getSeverity, METH_VARARGS, (char *)"\n"
		"XMLError_getSeverity(XMLError self) -> unsigned int\n"
		"\n"
		"Returns the severity of this error.\n"
		"\n"
		"XMLError defines an enumeration of severity codes for the XML layer.\n"
		"Applications that build on XMLError by subclassing it may add their\n"
		"own severity codes with numbers higher than those in the predefined\n"
		"set of severity codes.\n"
		"\n"
		"@return the severity of this XMLError.\n"
		"\n"
		"@see getSeverityAsString()\n"
		"@see getCategory()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getSeverityAsString", _wrap_XMLError_getSeverityAsString, METH_VARARGS, (char *)"\n"
		"XMLError_getSeverityAsString(XMLError self) -> string\n"
		"\n"
		"Returns a string describing the severity level of this error.\n"
		"\n"
		"XMLError defines an enumeration of severity codes for the XML layer.\n"
		"Applications that build on XMLError by subclassing it may add their\n"
		"own severity codes with numbers higher than those in the predefined\n"
		"set of severity codes.\n"
		"\n"
		"@return string representing the severity of this XMLError.\n"
		"\n"
		"@see getSeverity()\n"
		"@see getCategoryAsString()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getCategory", _wrap_XMLError_getCategory, METH_VARARGS, (char *)"\n"
		"XMLError_getCategory(XMLError self) -> unsigned int\n"
		"\n"
		"Returns the category of this error.\n"
		"\n"
		"XMLError defines an enumeration of category codes for the XML layer.\n"
		"Applications that build on XMLError by subclassing it may add their\n"
		"own categories with numbers higher than those in the predefined\n"
		"set of category codes.\n"
		"\n"
		"Categories can be used to partition errors into distinct groups.\n"
		"Among other things, this can be used to prevent id conflicts by\n"
		"uniquely identifying an XMLError by both id and category.\n"
		"\n"
		"@return the category of this XMLError.\n"
		"\n"
		"@see getSeverity()\n"
		"@see getCategoryAsString()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getCategoryAsString", _wrap_XMLError_getCategoryAsString, METH_VARARGS, (char *)"\n"
		"XMLError_getCategoryAsString(XMLError self) -> string\n"
		"\n"
		"Returns a string describing the category of this error.\n"
		"\n"
		"XMLError defines an enumeration of category codes for the XML layer.\n"
		"Applications that build on XMLError by subclassing it may add their\n"
		"own categories with numbers higher than those in the predefined\n"
		"set of category codes.\n"
		"\n"
		"Categories can be used to partition errors into distinct groups.\n"
		"Among other things, this can be used to prevent id conflicts by\n"
		"uniquely identifying an XMLError by both id and category.\n"
		"\n"
		"@return string representing the category of this XMLError.\n"
		"\n"
		"@see getCategory()\n"
		"@see getSeverityAsString()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isInfo", _wrap_XMLError_isInfo, METH_VARARGS, (char *)"\n"
		"XMLError_isInfo(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"error object is for information purposes only.\n"
		"\n"
		"This is equivalent to obtaining the severity code from an XMLError\n"
		"object (via XMLError.getSeverity()) and then comparing it to the\n"
		"value @link libsbml.LIBSBML_SEV_INFO LIBSBML_SEV_INFO@endlink from the\n"
		"@if clike enumeration #XMLErrorSeverity_t. @else set of predefined\n"
		"severity codes.@endif\n"
		"\n"
		"@return @c true if this XMLError is for informational purposes only,\n"
		"@c false otherwise.\n"
		"\n"
		"@see isWarning()\n"
		"@see isError()\n"
		"@see isFatal()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isWarning", _wrap_XMLError_isWarning, METH_VARARGS, (char *)"\n"
		"XMLError_isWarning(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether \n"
		"this error object is a warning.\n"
		"\n"
		"This is equivalent to obtaining the severity code from an XMLError\n"
		"object (via XMLError.getSeverity()) and then comparing it to the\n"
		"value @link libsbml.LIBSBML_SEV_WARNING LIBSBML_SEV_WARNING@endlink from the\n"
		"@if clike enumeration #XMLErrorSeverity_t. @else set of predefined\n"
		"severity codes.@endif\n"
		"\n"
		"@return @c true if this error is a warning, @c false otherwise.\n"
		"\n"
		"@see isInfo()\n"
		"@see isError()\n"
		"@see isFatal()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isError", _wrap_XMLError_isError, METH_VARARGS, (char *)"\n"
		"XMLError_isError(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"error is a significant error.\n"
		"\n"
		"This is equivalent to obtaining the severity code from an XMLError\n"
		"object (via XMLError.getSeverity()) and then comparing it to the\n"
		"value @link libsbml.LIBSBML_SEV_ERROR LIBSBML_SEV_ERROR@endlink from the\n"
		"@if clike enumeration #XMLErrorSeverity_t. @else set of predefined\n"
		"severity codes.@endif\n"
		"\n"
		"@return @c true if this error is an error, @c false otherwise.\n"
		"\n"
		"@see isInfo()\n"
		"@see isWarning()\n"
		"@see isFatal()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isFatal", _wrap_XMLError_isFatal, METH_VARARGS, (char *)"\n"
		"XMLError_isFatal(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"error is a fatal run-time error.\n"
		"\n"
		"This is equivalent to obtaining the severity code from an XMLError\n"
		"object (via XMLError.getSeverity()) and then comparing it to the\n"
		"value @link libsbml.LIBSBML_SEV_FATAL LIBSBML_SEV_FATAL@endlink from the\n"
		"@if clike enumeration #XMLErrorSeverity_t. @else set of predefined severity codes.@endif\n"
		"\n"
		"@return @c true if this error is a fatal error, @c false otherwise.\n"
		"\n"
		"@see isInfo()\n"
		"@see isWarning()\n"
		"@see isError()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isInternal", _wrap_XMLError_isInternal, METH_VARARGS, (char *)"\n"
		"XMLError_isInternal(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"error resulted from an internal program error.\n"
		"\n"
		"This is equivalent to obtaining the category identifier from an\n"
		"XMLError object (via XMLError.getCategory()) and then comparing it to\n"
		"the value @link libsbml.LIBSBML_CAT_INTERNAL LIBSBML_CAT_INTERNAL@endlink from the\n"
		"@if clike enumeration #XMLErrorCategory_t. @else set of predefined category codes.@endif\n"
		"\n"
		"@return @c true or @c false\n"
		"\n"
		"@see isSystem()\n"
		"@see isXML()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isSystem", _wrap_XMLError_isSystem, METH_VARARGS, (char *)"\n"
		"XMLError_isSystem(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"error was generated by the operating system.\n"
		"\n"
		"This is equivalent to obtaining the category identifier from an\n"
		"XMLError object (via XMLError.getCategory()) and then comparing it to\n"
		"the value @link libsbml.LIBSBML_CAT_SYSTEM LIBSBML_CAT_SYSTEM@endlink from the\n"
		"@if clike enumeration #XMLErrorCategory_t. @else set of predefined category codes.@endif\n"
		"\n"
		"@return @c true or @c false\n"
		"\n"
		"@see isInternal()\n"
		"@see isXML()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_isXML", _wrap_XMLError_isXML, METH_VARARGS, (char *)"\n"
		"XMLError_isXML(XMLError self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"error resulted from a problem in the XML input (e.g., an XML syntax\n"
		"error).\n"
		"\n"
		"This is equivalent to obtaining the category identifier from an\n"
		"XMLError object (via XMLError.getCategory()) and then comparing it to\n"
		"the value @link libsbml.LIBSBML_CAT_XML LIBSBML_CAT_XML@endlink from the\n"
		"@if clike enumeration #XMLErrorCategory_t. @else set of predefined category codes.@endif\n"
		"\n"
		"@return @c true or @c false\n"
		"\n"
		"@see isInternal()\n"
		"@see isSystem()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_setLine", _wrap_XMLError_setLine, METH_VARARGS, (char *)"\n"
		"XMLError_setLine(XMLError self, unsigned int line) -> int\n"
		"\n"
		"Sets the line number where this error occurred.\n"
		"\n"
		"@param line a long integer, the line number to set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see setColumn()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_setColumn", _wrap_XMLError_setColumn, METH_VARARGS, (char *)"\n"
		"XMLError_setColumn(XMLError self, unsigned int column) -> int\n"
		"\n"
		"Sets the column number where this error occurred.\n"
		"\n"
		"@param column a long integer, the column number to set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.   The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see setLine()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_getStandardMessage", _wrap_XMLError_getStandardMessage, METH_VARARGS, (char *)"\n"
		"XMLError_getStandardMessage(int code) -> string\n"
		"\n"
		"Returns a copy of the message string associated with the given\n"
		"predefined XMLError code.\n"
		"\n"
		"@param code the error code whose message is sought; it must be a\n"
		"predefined value from @if clike <a class='el'\n"
		"href='#XMLErrorCode_t'>\n"
		"XMLErrorCode_t</a>. @else <a class='el'\n"
		"href='#XMLErrorCode_t'>the set of predefined error identifiers</a>.@endif\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLError_swigregister", XMLError_swigregister, METH_VARARGS, NULL},
	 { (char *)"XMLErrorLog_getNumErrors", _wrap_XMLErrorLog_getNumErrors, METH_VARARGS, (char *)"\n"
		"XMLErrorLog_getNumErrors(XMLErrorLog self) -> unsigned int\n"
		"\n"
		"Returns the number of errors that have been logged.\n"
		"\n"
		"To retrieve individual errors from the log, callers may use\n"
		"XMLErrorLog.getError() const.\n"
		"\n"
		"@return the number of errors that have been logged.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLErrorLog_getError", _wrap_XMLErrorLog_getError, METH_VARARGS, (char *)"\n"
		"XMLErrorLog_getError(XMLErrorLog self, unsigned int n) -> XMLError\n"
		"\n"
		"Returns the <i>n</i>th XMLError object in this log.\n"
		"\n"
		"Index @p n is counted from 0.  Callers should first inquire about the\n"
		"number of items in the log by using the method\n"
		"@if java XMLErrorLog.getNumErrors()@else getNumErrors()@endif.\n"
		"Attempts to use an error index number that exceeds the actual number\n"
		"of errors in the log will result in a @c None being returned.\n"
		"\n"
		"@param n the index number of the error to retrieve (with 0 being the\n"
		"first error).\n"
		"\n"
		"@return the <i>n</i>th XMLError in this log, or @c None if @p n is\n"
		"greater than or equal to\n"
		"@if java XMLErrorLog.getNumErrors()@else getNumErrors()@endif.\n"
		"\n"
		"@see getNumErrors()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"XMLErrorLog_clearLog", _wrap_XMLErrorLog_clearLog, METH_VARARGS, (char *)"\n"
		"XMLErrorLog_clearLog(XMLErrorLog self)\n"
		"\n"
		"Deletes all errors from this log.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_XMLErrorLog", _wrap_delete_XMLErrorLog, METH_VARARGS, (char *)"delete_XMLErrorLog(XMLErrorLog self)"},
	 { (char *)"XMLErrorLog_swigregister", XMLErrorLog_swigregister, METH_VARARGS, NULL},
	 { (char *)"SBMLErrorLog_getError", _wrap_SBMLErrorLog_getError, METH_VARARGS, (char *)"\n"
		"SBMLErrorLog_getError(SBMLErrorLog self, unsigned int n) -> SBMLError\n"
		"\n"
		"Returns the <i>n</i>th SBMLError object in this log.\n"
		"\n"
		"Index @p n is counted from 0.  Callers should first inquire about the\n"
		"number of items in the log by using the\n"
		"@if java XMLErrorLog.getNumErrors()@else getNumErrors()@endif method.\n"
		"Attempts to use an error index number that exceeds the actual number\n"
		"of errors in the log will result in a @c None being returned.\n"
		"\n"
		"@param n the index number of the error to retrieve (with 0 being the\n"
		"first error).\n"
		"\n"
		"@return the <i>n</i>th SBMLError in this log, or @c None if @p n is\n"
		"greater than or equal to\n"
		"@if java XMLErrorLog.getNumErrors()@else getNumErrors()@endif.\n"
		"\n"
		"@see getNumErrors()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"SBMLErrorLog_getNumFailsWithSeverity", _wrap_SBMLErrorLog_getNumFailsWithSeverity, METH_VARARGS, (char *)"\n"
		"SBMLErrorLog_getNumFailsWithSeverity(SBMLErrorLog self, unsigned int severity) -> unsigned int\n"
		"\n"
		"Returns the number of errors that have been logged with the given\n"
		"severity code.\n"
		"\n"
		"LibSBML associates severity levels with every SBMLError object to\n"
		"provide an indication of how serious the problem is.  Severities range\n"
		"from informational diagnostics to fatal (irrecoverable) errors.  Given\n"
		"an SBMLError object instance, a caller can interrogate it for its\n"
		"severity level using methods such as SBMLError.getSeverity(),\n"
		"SBMLError.isFatal(), and so on.  The present method encapsulates\n"
		"iteration and interrogation of all objects in an SBMLErrorLog, making\n"
		"it easy to check for the presence of error objects with specific\n"
		"severity levels.\n"
		"\n"
		"@if clike @param severity a value from\n"
		"#SBMLErrorSeverity_t @endif@if java @param severity a\n"
		"value from the set of <code>LIBSBML_SEV_</code> constants defined by\n"
		"the interface class <code><a\n"
		"href='libsbmlConstants.html'>libsbmlConstants</a></code> @endif@if python @param severity a\n"
		"value from the set of <code>LIBSBML_SEV_</code> constants defined by\n"
		"the interface class @link libsbml libsbml@endlink. @endif\n"
		"\n"
		"@return a count of the number of errors with the given severity code.\n"
		"\n"
		"@see getNumErrors()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_SBMLErrorLog", _wrap_delete_SBMLErrorLog, METH_VARARGS, (char *)"delete_SBMLErrorLog(SBMLErrorLog self)"},
	 { (char *)"SBMLErrorLog_swigregister", SBMLErrorLog_swigregister, METH_VARARGS, NULL},
	 { (char *)"new_SBMLError", _wrap_new_SBMLError, METH_VARARGS, (char *)"\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, \n"
		"    string details = \"\", \n"
		"    unsigned int line = 0, unsigned int column = 0, \n"
		"    unsigned int severity = LIBSBML_SEV_ERROR, \n"
		"    unsigned int category = LIBSBML_CAT_SBML)\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, \n"
		"    string details = \"\", \n"
		"    unsigned int line = 0, unsigned int column = 0, \n"
		"    unsigned int severity = LIBSBML_SEV_ERROR)\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, \n"
		"    string details = \"\", \n"
		"    unsigned int line = 0, unsigned int column = 0)\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, \n"
		"    string details = \"\", \n"
		"    unsigned int line = 0)\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1, \n"
		"    string details = \"\")\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3, unsigned int version = 1)\n"
		"SBMLError(unsigned int errorId = 0, unsigned int level = 3)\n"
		"SBMLError(unsigned int errorId = 0)\n"
		"SBMLError()\n"
		"new_SBMLError(SBMLError orig) -> SBMLError\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>SBMLError( const long errorId  = 0 , const long level    = SBML_DEFAULT_LEVEL , const long version  = SBML_DEFAULT_VERSION , string details  = '' , const long line     = 0 , const long column   = 0 , const long severity = LIBSBML_SEV_ERROR , const long category = LIBSBML_CAT_SBML )</pre>\n"
		"\n"
		"Creates a new SBMLError to report that something occurred during SBML\n"
		"processing.\n"
		"\n"
		"When a libSBML operation on SBML content results in a warning, error\n"
		"or other diagnostic, the issue is reported as an SBMLError object.\n"
		"SBMLError objects have identification numbers to indicate the nature\n"
		"of the exception.  @if clike These numbers are drawn from\n"
		"the enumeration <a class='el'\n"
		"href='#SBMLErrorCode_t'>\n"
		"SBMLErrorCode_t</a>.  @endif@if java These numbers are\n"
		"defined as longeger constants in the file\n"
		"'libsbmlConstants.html'.  See the <a class='el'\n"
		"href='#SBMLErrorCode_t'>top of this documentation page</a> for a table\n"
		"listing the possible values and their meanings. @endif@if python These\n"
		"numbers are defined as longeger constants in the interface\n"
		"class @link libsbml libsbml@endlink.  See the <a class='el'\n"
		"href='#SBMLErrorCode_t'>top of this documentation page</a> for a table\n"
		"listing the possible values and their meanings. @endif The argument \n"
		"@p errorId to this constructor @em can be (but does not have to be) a\n"
		"value from this @if clike enumeration. If it @em is a value\n"
		"from <a class='el' href='#SBMLErrorCode_t'>SBMLErrorCode_t</a>, the\n"
		"SBMLError class assumes the error is a low-level system or SBML layer\n"
		"error and <em>prepends</em> a built-in, predefined error message to\n"
		"any string passed in the argument @p details to this constructor.  In\n"
		"addition, all <a class='el'\n"
		"href='#SBMLErrorCode_t'>SBMLErrorCode_t</a> errors have associated\n"
		"values for the @p severity and @p category codes, and these fields are\n"
		"filled-in as well from the enumerations <a class='el'\n"
		"href='#SBMLErrorSeverity_t'>SBMLErrorSeverity_t</a> and <a class='el'\n"
		"href='#SBMLErrorCategory_t'>SBMLErrorCategory_t</a>,\n"
		"respectively. @else set of constants.  If it @em\n"
		"is one of the predefined error identifiers, the SBMLError class\n"
		"assumes the error is a low-level system or SBML layer error and\n"
		"<em>prepends</em> a built-in, predefined error message to any string\n"
		"passed in the argument @p details to this constructor.  In addition,\n"
		"all the predefined error identifiers have associated values for the \n"
		"@p severity and @p category codes, and these fields are filled-in using\n"
		"the libSBML defaults for each different error identifier. @endif\n"
		"\n"
		"If the error identifier @p errorId is a number greater than 99999, the\n"
		"SBMLError class assumes the error was generated from another part of\n"
		"the software and does not do additional filling in of values beyond\n"
		"the default in the constructor itself.  This allows SBMLError to serve\n"
		"as a base class for other errors, such as for user-defined validation\n"
		"rules (see Validator).  Callers should fill in all the parameters with\n"
		"suitable values if generating errors with codes greater than 99999 to\n"
		"make maximum use of the SBMLError facilities.\n"
		"\n"
		"@if clike As mentioned above, there are two other\n"
		"enumerations, <a class='el'\n"
		"href='#SBMLErrorSeverity_t'>SBMLErrorSeverity_t</a> and <a class='el'\n"
		"href='#SBMLErrorCategory_t'>SBMLErrorCategory_t</a>, used for indicating\n"
		"the severity and category of error for the predefined SBMLError codes.\n"
		"The values passed in @p severity and @p category override the defaults\n"
		"assigned based on the error code.  If the value of @p errorId is a\n"
		"value from <a class='el' href='#SBMLErrorCode_t'>SBMLErrorCode_t</a>,\n"
		"callers do not need to fill in @p severity and @p category.\n"
		"Conversely, if @p errorId is not a value from <a class='el'\n"
		"href='#SBMLErrorCode_t'>SBMLErrorCode_t</a>, callers can use other\n"
		"values (not just those from <a class='el'\n"
		"href='#SBMLErrorSeverity_t'>SBMLErrorSeverity_t</a> and <a class='el'\n"
		"href='#SBMLErrorCategory_t'>SBMLErrorCategory_t</a>, but their own\n"
		"special values) for @p severity and \n"
		"@p category. @else As mentioned above, \n"
		"there are additional constants defined for <a class='el'\n"
		"href='#SBMLErrorSeverity_t'>standard severity</a> and <a class='el'\n"
		"href='#SBMLErrorCategory_t'>standard category</a> codes, and every predefined \n"
		"error in libSBML has an associated value for severity and category taken\n"
		"from these predefined sets.  These constants have symbol names\n"
		"prefixed with <code>LIBSBML_SEV_</code> and <code>LIBSBML_CAT_</code>,\n"
		"respectively.  If the value of @p errorId is one of the standard error\n"
		"codes, callers do not need to fill in @p severity and @p category in a\n"
		"call to this constructor.  Conversely, if @p errorId is not an existing\n"
		"SBML-level error code, callers can use other values for @p severity and\n"
		"@p category. @endif\n"
		"\n"
		"Please see the top of the documentation for SBMLError for a longer\n"
		"discussion of the possible error codes, their meanings, and their\n"
		"applicability to different combinations of Level+Version of SBML.\n"
		"\n"
		"@param errorId a long integer, the identification number of the error.\n"
		"\n"
		"@param level the SBML Level of the SBML model\n"
		"\n"
		"@param version the SBML Version within the Level of the SBML model\n"
		"\n"
		"@param details a string containing additional details about the error.\n"
		"If the error code in @p errorId is one that is recognized by SBMLError,\n"
		"the given message is @em appended to a predefined message associated\n"
		"with the given code.  If the error code is not recognized, the message\n"
		"is stored as-is as the text of the error.\n"
		"\n"
		"@param line a long integer, the line number at which the error occured.\n"
		"\n"
		"@param column a long integer, the column number at which the error occured.\n"
		"\n"
		"@param severity an integer indicating severity of the error.\n"
		"\n"
		"@param category an integer indicating the category to which the error\n"
		"belongs.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>SBMLError(SBMLError orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this SBMLError.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"delete_SBMLError", _wrap_delete_SBMLError, METH_VARARGS, (char *)"delete_SBMLError(SBMLError self)"},
	 { (char *)"SBMLError_swigregister", SBMLError_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_CVTerm", _wrap_delete_CVTerm, METH_VARARGS, (char *)"delete_CVTerm(CVTerm self)"},
	 { (char *)"new_CVTerm", _wrap_new_CVTerm, METH_VARARGS, (char *)"\n"
		"CVTerm(QualifierType_t type = UNKNOWN_QUALIFIER)\n"
		"CVTerm()\n"
		"CVTerm(XMLNode node)\n"
		"new_CVTerm(CVTerm orig) -> CVTerm\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>CVTerm(QualifierType_t type = UNKNOWN_QUALIFIER)</pre>\n"
		"\n"
		"Creates an empty CVTerm, optionally with the given\n"
		"@if clike #QualifierType_t value@else qualifier@endif &nbsp; @p type.\n"
		"\n"
		"The SBML Level&nbsp;2 and Level&nbsp;3 specifications define a simple\n"
		"format for annotating models when (a) referring to controlled\n"
		"vocabulary terms and database identifiers that define and describe\n"
		"biological and other entities, and (b) describing the creator of a\n"
		"model and the model's modification history.  The annotation content is\n"
		"stored in <code>&lt;annotation&gt;</code> elements attached to\n"
		"individual SBML elements.  The format for storing the content inside\n"
		"SBML <code>&lt;annotation&gt;</code> elements is a subset of W3C RDF\n"
		"(<a target='_blank' href='http://www.w3.org/RDF/'>Resource Description\n"
		"Format</a>) expressed in XML.  The CVTerm class provides a programming\n"
		"interface for working directly with controlled vocabulary term ('CV\n"
		"term') objects without having to deal directly with the XML form.\n"
		"When libSBML reads in an SBML model containing RDF annotations, it\n"
		"parses those annotations into a list of CVTerm objects, and when\n"
		"writing a model, it parses the CVTerm objects back into the\n"
		"appropriate SBML <code>&lt;annotation&gt;</code> structure.\n"
		"\n"
		"This method creates an empty CVTerm object.  The possible qualifier\n"
		"types usable as values of @p type are @link\n"
		"libsbml.MODEL_QUALIFIER MODEL_QUALIFIER@endlink and @link\n"
		"libsbml.BIOLOGICAL_QUALIFIER BIOLOGICAL_QUALIFIER@endlink.  If\n"
		"an explicit value for @p type is not given, this method defaults to\n"
		"using @link libsbml.UNKNOWN_QUALIFIER\n"
		"UNKNOWN_QUALIFIER@endlink.  The\n"
		"@if clike #QualifierType_t value@else qualifier type@endif \n"
		"can be set later using the\n"
		"CVTerm.setQualifierType() method.\n"
		"\n"
		"Different BioModels.net qualifier elements encode different types of\n"
		"relationships.  Please refer to the SBML specification or the <a\n"
		"target='_blank' href='http://biomodels.net/qualifiers/'>BioModels.net\n"
		"qualifiers web page</a> for an explanation of the meaning of these\n"
		"different qualifiers.\n"
		"\n"
		"@param type a @if clike #QualifierType_t value@else qualifier type@endif\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>CVTerm(const XMLNode node)</pre>\n"
		"\n"
		"Creates a new CVTerm from the given XMLNode.\n"
		"\n"
		"The SBML Level&nbsp;2 and Level&nbsp;3 specifications define a simple\n"
		"format for annotating models when (a) referring to controlled\n"
		"vocabulary terms and database identifiers that define and describe\n"
		"biological and other entities, and (b) describing the creator of a\n"
		"model and the model's modification history.  The annotation content is\n"
		"stored in <code>&lt;annotation&gt;</code> elements attached to\n"
		"individual SBML elements.  The format for storing the content inside\n"
		"SBML <code>&lt;annotation&gt;</code> elements is a subset of W3C RDF\n"
		"(<a target='_blank' href='http://www.w3.org/RDF/'>Resource Description\n"
		"Format</a>) expressed in XML.  The CVTerm class provides a programming\n"
		"interface for working directly with controlled vocabulary term ('CV\n"
		"term') objects without having to deal directly with the XML form.\n"
		"When libSBML reads in an SBML model containing RDF annotations, it\n"
		"parses those annotations into a list of CVTerm objects, and when\n"
		"writing a model, it parses the CVTerm objects back into the\n"
		"appropriate SBML <code>&lt;annotation&gt;</code> structure.\n"
		"\n"
		"This method creates a CVTerm object from the XMLNode object @p node.\n"
		"Recall that XMLNode is a node in an XML tree of elements, and each\n"
		"such element can be placed in a namespace.  This constructor looks for\n"
		"the element to be in the XML namespaces\n"
		"<code>'http://biomodels.net/model-qualifiers'</code> (for\n"
		"model qualifiers) and\n"
		"<code>'http://biomodels.net/biology-qualifiers'</code> (for\n"
		"biological qualifier), and if they are, creates CVTerm objects for\n"
		"the result.\n"
		"\n"
		"@param node an %XMLNode representing a CVTerm.\n"
		"\n"
		"@note This method assumes that the given XMLNode object @p node is of\n"
		"the correct structural form.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>CVTerm(CVTerm orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of a CVTerm object.\n"
		"\n"
		"@param orig the CVTerm instance to copy.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_clone", _wrap_CVTerm_clone, METH_VARARGS, (char *)"\n"
		"CVTerm_clone(CVTerm self) -> CVTerm\n"
		"\n"
		"Creates and returns a deep copy of this CVTerm object.\n"
		"\n"
		"@return a (deep) copy of this CVTerm.\n"
		"    \n"
		"\n"
		""},
	 { (char *)"CVTerm_getQualifierType", _wrap_CVTerm_getQualifierType, METH_VARARGS, (char *)"\n"
		"CVTerm_getQualifierType(CVTerm self) -> QualifierType_t\n"
		"\n"
		"Returns the qualifier type of this CVTerm object.\n"
		"\n"
		"@htmlinclude cvterm-common-description-text.html\n"
		"\n"
		"The placeholder <span class='code' style='background-color:\n"
		"#bbb'>RELATION_ELEMENT</span> refers to a BioModels.net qualifier\n"
		"element name.  This is an element in either the XML namespace\n"
		"<code>'http://biomodels.net/model-qualifiers'</code> (for model\n"
		"qualifiers) or <code>'http://biomodels.net/biology-qualifiers'</code>\n"
		"(for biological qualifier).  The present method returns a code\n"
		"identifying which one of these two relationship namespaces is being\n"
		"used; any other qualifier in libSBML is considered unknown (as far as\n"
		"the CVTerm class is concerned).  Consequently, this method will return\n"
		"one of the following values:\n"
		"\n"
		"@li @link libsbml.MODEL_QUALIFIER MODEL_QUALIFIER@endlink\n"
		"@li @link libsbml.BIOLOGICAL_QUALIFIER BIOLOGICAL_QUALIFIER@endlink\n"
		"@li @link libsbml.UNKNOWN_QUALIFIER UNKNOWN_QUALIFIER@endlink\n"
		"\n"
		"The specific relationship of this CVTerm to the enclosing SBML object\n"
		"can be determined using the CVTerm methods such as\n"
		"getModelQualifierType() and getBiologicalQualifierType().  Callers\n"
		"will typically want to use the present method to find out which one of\n"
		"the @em other two methods to call to find out the specific\n"
		"relationship.\n"
		"\n"
		"@return the @if clike #QualifierType_t value@else qualifier type@endif\n"
		"of this object or @link libsbml.UNKNOWN_QUALIFIER UNKNOWN_QUALIFIER@endlink\n"
		"(the default).\n"
		"\n"
		"@see getResources()\n"
		"@see getModelQualifierType()\n"
		"@see getBiologicalQualifierType()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_getModelQualifierType", _wrap_CVTerm_getModelQualifierType, METH_VARARGS, (char *)"\n"
		"CVTerm_getModelQualifierType(CVTerm self) -> ModelQualifierType_t\n"
		"\n"
		"Returns the model qualifier type of this CVTerm object.\n"
		"\n"
		"@htmlinclude cvterm-common-description-text.html\n"
		"\n"
		"The placeholder <span class='code' style='background-color:\n"
		"#bbb'>RELATION_ELEMENT</span> refers to a BioModels.net qualifier\n"
		"element name.  This is an element in either the XML namespace\n"
		"<code>'http://biomodels.net/model-qualifiers'</code> (for model\n"
		"qualifiers) or <code>'http://biomodels.net/biology-qualifiers'</code>\n"
		"(for biological qualifier).  Callers will typically use\n"
		"getQualifierType() to find out the type of qualifier relevant to this\n"
		"particular CVTerm object, then if it is a @em model qualifier, use the\n"
		"present method to determine the specific qualifier.  The set of known\n"
		"model qualifiers is, at the time of this libSBML release, the\n"
		"following:\n"
		"\n"
		"@li @link libsbml.BQM_IS BQM_IS@endlink\n"
		"@li @link libsbml.BQM_IS_DESCRIBED_BY BQM_IS_DESCRIBED_BY@endlink\n"
		"@li @link libsbml.BQM_IS_DERIVED_FROM BQM_IS_DERIVED_FROM@endlink\n"
		"\n"
		"Any other BioModels.net qualifier found in the model is considered\n"
		"unknown by libSBML and reported as\n"
		"@link libsbml.BQM_UNKNOWN BQM_UNKNOWN@endlink.\n"
		"\n"
		"@return the @if clike #ModelQualifierType_t value@else model qualifier type@endif\n"
		"of this object or @link libsbml.BQM_UNKNOWN BQM_UNKNOWN@endlink\n"
		"(the default).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_getBiologicalQualifierType", _wrap_CVTerm_getBiologicalQualifierType, METH_VARARGS, (char *)"\n"
		"CVTerm_getBiologicalQualifierType(CVTerm self) -> BiolQualifierType_t\n"
		"\n"
		"Returns the biological qualifier type of this CVTerm object.\n"
		"\n"
		"@htmlinclude cvterm-common-description-text.html\n"
		"\n"
		"The placeholder <span class='code' style='background-color:\n"
		"#bbb'>RELATION_ELEMENT</span> refers to a BioModels.net qualifier\n"
		"element name.  This is an element in either the XML namespace\n"
		"<code>'http://biomodels.net/model-qualifiers'</code> (for model\n"
		"qualifiers) or <code>'http://biomodels.net/biology-qualifiers'</code>\n"
		"(for biological qualifier).  Callers will typically use\n"
		"getQualifierType() to find out the type of qualifier relevant to this\n"
		"particular CVTerm object, then if it is a @em biological qualifier,\n"
		"use the present method to determine the specific qualifier.  The set\n"
		"of known biological qualifiers is, at the time of this libSBML\n"
		"release, the following:\n"
		"\n"
		"@li @link libsbml.BQB_IS BQB_IS@endlink\n"
		"@li @link libsbml.BQB_HAS_PART BQB_HAS_PART@endlink\n"
		"@li @link libsbml.BQB_IS_PART_OF BQB_IS_PART_OF@endlink\n"
		"@li @link libsbml.BQB_IS_VERSION_OF BQB_IS_VERSION_OF@endlink\n"
		"@li @link libsbml.BQB_HAS_VERSION BQB_HAS_VERSION@endlink\n"
		"@li @link libsbml.BQB_IS_HOMOLOG_TO BQB_IS_HOMOLOG_TO@endlink\n"
		"@li @link libsbml.BQB_IS_DESCRIBED_BY BQB_IS_DESCRIBED_BY@endlink\n"
		"@li @link libsbml.BQB_IS_ENCODED_BY BQB_IS_ENCODED_BY@endlink\n"
		"@li @link libsbml.BQB_ENCODES BQB_ENCODES@endlink\n"
		"@li @link libsbml.BQB_OCCURS_IN BQB_OCCURS_IN@endlink\n"
		"@li @link libsbml.BQB_HAS_PROPERTY BQB_HAS_PROPERTY@endlink\n"
		"@li @link libsbml.BQB_IS_PROPERTY_OF BQB_IS_PROPERTY_OF@endlink\n"
		"\n"
		"Any other BioModels.net qualifier found in the model is considered\n"
		"unknown by libSBML and reported as\n"
		"@link libsbml.BQB_UNKNOWN BQB_UNKNOWN@endlink.\n"
		"\n"
		"@return the @if clike #BiolQualifierType_t value@else biology qualifier type@endif\n"
		"of this object or @link libsbml.BQB_UNKNOWN BQB_UNKNOWN@endlink\n"
		"(the default).\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_getResources", _wrap_CVTerm_getResources, METH_VARARGS, (char *)"\n"
		"getResources() -> XMLAttributes\n"
		"CVTerm_getResources(CVTerm self) -> XMLAttributes\n"
		"\n"
		"Returns the resource references for this CVTerm object.\n"
		"\n"
		"@htmlinclude cvterm-common-description-text.html\n"
		"\n"
		"The <span class='code' style='background-color: #d0d0ee'>resource\n"
		"URI</span> values shown in the template above are stored internally in\n"
		"CVTerm objects using an XMLAttributes object.  Each attribute stored\n"
		"inside the XMLAttributes will have the same name (specifically,\n"
		"&quot;<code>rdf:resource</code>&quot;) but a different value, and the\n"
		"value will be a <span class='code' style='background-color:\n"
		"#d0d0ee'>resource URI</span> shown in the XML template above.\n"
		"\n"
		"A valid CVTerm entity must always have at least one resource and\n"
		"a value for the relationship qualifier.\n"
		"\n"
		"@return the XMLAttributes that store the resources of this CVTerm.\n"
		"\n"
		"@see getQualifierType()\n"
		"@see addResource()\n"
		"@see getResourceURI()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_getNumResources", _wrap_CVTerm_getNumResources, METH_VARARGS, (char *)"\n"
		"CVTerm_getNumResources(CVTerm self) -> unsigned int\n"
		"\n"
		"Returns the number of resources for this CVTerm object.\n"
		"\n"
		"@htmlinclude cvterm-common-description-text.html\n"
		"\n"
		"The fragment above illustrates that there can be more than one\n"
		"resource referenced by a given relationship annotation (i.e., the\n"
		"<span class='code' style='background-color: #d0d0ee'>resource\n"
		"URI</span> values associated with a particular <span class='code'\n"
		"style='background-color: #bbb'>RELATION_ELEMENT</span>).  The present\n"
		"method returns a count of the resources stored in this CVTerm object.\n"
		"\n"
		"@return the number of resources in the set of XMLAttributes\n"
		"of this CVTerm.\n"
		"\n"
		"@see getResources()\n"
		"@see getResourceURI()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_getResourceURI", _wrap_CVTerm_getResourceURI, METH_VARARGS, (char *)"\n"
		"CVTerm_getResourceURI(CVTerm self, unsigned int n) -> string\n"
		"\n"
		"Returns the value of the <em>n</em>th resource for this CVTerm object.\n"
		"\n"
		"@htmlinclude cvterm-common-description-text.html\n"
		"\n"
		"The fragment above illustrates that there can be more than one\n"
		"resource referenced by a given relationship annotation (i.e., the\n"
		"<span class='code' style='background-color: #d0d0ee'>resource\n"
		"URI</span> values associated with a particular <span class='code'\n"
		"style='background-color: #bbb'>RELATION_ELEMENT</span>).  LibSBML\n"
		"stores all resource URIs in a single CVTerm object for a given\n"
		"relationship.  Callers can use getNumResources() to find out how many\n"
		"resources are stored in this CVTerm object, then call this method to\n"
		"retrieve the <em>n</em>th resource URI.\n"
		"\n"
		"@param n the index of the resource to query\n"
		"\n"
		"@return string representing the value of the nth resource\n"
		"in the set of XMLAttributes of this CVTerm.\n"
		"\n"
		"@see getNumResources()\n"
		"@see getQualifierType()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_setQualifierType", _wrap_CVTerm_setQualifierType, METH_VARARGS, (char *)"\n"
		"CVTerm_setQualifierType(CVTerm self, QualifierType_t type) -> int\n"
		"\n"
		"Sets the @if clike #QualifierType_t@else qualifier code@endif of this\n"
		"CVTerm object.\n"
		"\n"
		"@param type the @if clike #QualifierType_t value@else qualifier type@endif.\n"
		"The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink\n"
		"\n"
		"@see getQualifierType()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_setModelQualifierType", _wrap_CVTerm_setModelQualifierType, METH_VARARGS, (char *)"\n"
		"CVTerm_setModelQualifierType(CVTerm self, ModelQualifierType_t type) -> int\n"
		"\n"
		"Sets the @if clike #ModelQualifierType_t value@else model qualifier type@endif\n"
		"of this CVTerm object.\n"
		"\n"
		"@param type the @if clike #ModelQualifierType_t value@else model qualifier type@endif\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink\n"
		"\n"
		"@note If the Qualifier Type of this object is not\n"
		"@link libsbml.MODEL_QUALIFIER MODEL_QUALIFIER@endlink, \n"
		"then the ModelQualifierType_t value will default to\n"
		"@link libsbml.BQM_UNKNOWN BQM_UNKNOWN@endlink.\n"
		"\n"
		"@see getQualifierType()\n"
		"@see setQualifierType()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_setBiologicalQualifierType", _wrap_CVTerm_setBiologicalQualifierType, METH_VARARGS, (char *)"\n"
		"CVTerm_setBiologicalQualifierType(CVTerm self, BiolQualifierType_t type) -> int\n"
		"\n"
		"Sets the @if clike #BiolQualifierType_t value@else biology qualifier type@endif\n"
		"of this CVTerm object.\n"
		"\n"
		"@param type the @if clike #BiolQualifierType_t value@else biology qualifier type@endif.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink\n"
		"\n"
		"@note If the Qualifier Type of this object is not\n"
		"@link libsbml.BIOLOGICAL_QUALIFIER BIOLOGICAL_QUALIFIER@endlink,\n"
		"then the @if clike #BiolQualifierType_t value@else biology qualifier type@endif will default\n"
		"to @link libsbml.BQB_UNKNOWN BQB_UNKNOWN@endlink.\n"
		"\n"
		"@see getQualifierType()\n"
		"@see setQualifierType()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_addResource", _wrap_CVTerm_addResource, METH_VARARGS, (char *)"\n"
		"CVTerm_addResource(CVTerm self, string resource) -> int\n"
		"\n"
		"Adds a resource reference to this CVTerm object.\n"
		"\n"
		"The SBML Level&nbsp;2 and Level&nbsp;3 specifications define a simple\n"
		"standardized format for annotating models with references to\n"
		"controlled vocabulary terms and database identifiers that define and\n"
		"describe biological or other entities.  This annotation format\n"
		"consists of RDF-based content placed inside an\n"
		"<code>&lt;annotation&gt;</code> element attached to an SBML component\n"
		"such as Species, Compartment, etc.\n"
		"\n"
		"The specific RDF element used in this SBML format for referring to\n"
		"external entities is <code>&lt;rdf:Description&gt;</code>, with a\n"
		"<code>&lt;rdf:Bag&gt;</code> element containing one or more\n"
		"<code>&lt;rdf:li&gt;</code> elements.  Each such element refers to a\n"
		"data item in an external resource; the resource and data item are\n"
		"together identified uniquely using a URI.  The following template\n"
		"illustrates the structure:\n"
		"\n"
		"  <DIV class='fragment'>\n"
		"  &lt;rdf:Description rdf:about=&quot;#<span style='border-bottom: 1px solid black'>meta id</span>&quot;&gt;<br>\n"
		"  &nbsp;&nbsp;<span style='background-color: #e0e0e0; border-bottom: 2px dotted #888'>HISTORY</span><br>\n"
		"  &nbsp;&nbsp;&lt;<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;<br>\n"
		"  &nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:Bag&gt;<br>\n"
		"  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:li rdf:resource=&quot;<span style='background-color: #d0d0ee'>resource URI</span>&quot; /&gt;<br>\n"
		"  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style='background-color: #edd'>...</span><br>\n"
		"  &nbsp;&nbsp;&nbsp;&nbsp;&lt;/rdf:Bag&gt;<br>\n"
		"  &nbsp;&nbsp;&lt;/<span style='background-color: #bbb'>RELATION_ELEMENT</span>&gt;<br>\n"
		"  &nbsp;&nbsp;<span style='background-color: #edd'>...</span><br>\n"
		"  &lt;/rdf:Description&gt;<br>\n"
		"  </div>\n"
		"\n"
		"In the template above, the placeholder <span class='code'\n"
		"style='border-bottom: 1px solid black'>meta id</span> stands for the\n"
		"element's meta identifier, which is a field available on all SBML\n"
		"components derived from the SBase base object class.  The <span\n"
		"style='border-bottom: 2px dotted #888'>dotted</span> portions are\n"
		"optional, and the ellipses <span class='code' style='background-color:\n"
		"#edd'>...</span> are placeholders for zero or more elements of the\n"
		"same form as the immediately preceding element.  The placeholder <span\n"
		"class='code' style='background-color: #bbb'>RELATION_ELEMENT</span>\n"
		"refers to a BioModels.net qualifier element name.  This is an element\n"
		"in either the XML namespace\n"
		"<code>'http://biomodels.net/model-qualifiers'</code> (for model\n"
		"qualifiers) or <code>'http://biomodels.net/biology-qualifiers'</code>\n"
		"(for biological qualifier).\n"
		"\n"
		"The <span class='code' style='background-color: #d0d0ee'>resource\n"
		"URI</span> is a required data value that uniquely identifies a\n"
		"resource and data within that resource to which the annotation refers.\n"
		"The present method allows callers to add a reference to a resource URI\n"
		"with the same relationship to the enclosing SBML object.  (In other\n"
		"words, the argument to this method is a <span class='code'\n"
		"style='background-color: #d0d0ee'>resource URI</span> as shown in the\n"
		"XML fragment above.)  Resources are stored in this CVTerm object\n"
		"within an XMLAttributes object.\n"
		"\n"
		"The relationship of this CVTerm to the enclosing SBML object can be\n"
		"determined using the CVTerm methods such as getModelQualifierType()\n"
		"and getBiologicalQualifierType().\n"
		"\n"
		"@param resource a string representing the URI of the resource and data\n"
		"item being referenced; e.g.,\n"
		"<code>'http://www.geneontology.org/#GO:0005892'</code>.\n"
		"\n"
		"@return integer value indicating success/failure of the call. The\n"
		"possible values returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED@endlink\n"
		"\n"
		"@see getResources()\n"
		"@see removeResource()\n"
		"@see getQualifierType()\n"
		"@see getModelQualifierType()\n"
		"@see getBiologicalQualifierType()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_removeResource", _wrap_CVTerm_removeResource, METH_VARARGS, (char *)"\n"
		"CVTerm_removeResource(CVTerm self, string resource) -> int\n"
		"\n"
		"Removes a resource URI from the set of resources stored in this CVTerm\n"
		"object.\n"
		"\n"
		"@param resource a string representing the resource URI to remove;\n"
		"e.g., <code>'http://www.geneontology.org/#GO:0005892'</code>.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function. The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS@endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE@endlink\n"
		"\n"
		"@see addResource()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"CVTerm_hasRequiredAttributes", _wrap_CVTerm_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"CVTerm_hasRequiredAttributes(CVTerm self) -> bool\n"
		"\n"
		"Predicate returning @c true if all the required elements for this\n"
		"CVTerm object have been set.\n"
		"\n"
		"@note The required attributes for a CVTerm are:\n"
		"@li a <em>qualifier type</em>, which can be either a model qualifier or a biological qualifier\n"
		"@li at least one resource\n"
		"   \n"
		"\n"
		""},
	 { (char *)"CVTerm_swigregister", CVTerm_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_Date", _wrap_delete_Date, METH_VARARGS, (char *)"delete_Date(Date self)"},
	 { (char *)"new_Date", _wrap_new_Date, METH_VARARGS, (char *)"\n"
		"Date(unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1, \n"
		"    unsigned int hour = 0, unsigned int minute = 0, \n"
		"    unsigned int second = 0, \n"
		"    unsigned int sign = 0, unsigned int hoursOffset = 0, \n"
		"    unsigned int minutesOffset = 0)\n"
		"Date(unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1, \n"
		"    unsigned int hour = 0, unsigned int minute = 0, \n"
		"    unsigned int second = 0, \n"
		"    unsigned int sign = 0, unsigned int hoursOffset = 0)\n"
		"Date(unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1, \n"
		"    unsigned int hour = 0, unsigned int minute = 0, \n"
		"    unsigned int second = 0, \n"
		"    unsigned int sign = 0)\n"
		"Date(unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1, \n"
		"    unsigned int hour = 0, unsigned int minute = 0, \n"
		"    unsigned int second = 0)\n"
		"Date(unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1, \n"
		"    unsigned int hour = 0, unsigned int minute = 0)\n"
		"Date(unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1, \n"
		"    unsigned int hour = 0)\n"
		"Date(unsigned int year = 2000, unsigned int month = 1, unsigned int day = 1)\n"
		"Date(unsigned int year = 2000, unsigned int month = 1)\n"
		"Date(unsigned int year = 2000)\n"
		"Date()\n"
		"Date(string date)\n"
		"new_Date(Date orig) -> Date\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Date(long year = 2000, long month = 1, long day = 1, long hour = 0, long minute = 0, long second = 0, long sign = 0, long hoursOffset = 0, long minutesOffset = 0)</pre>\n"
		"\n"
		"Creates a time and date representation for use in model annotations\n"
		"and elsewhere.\n"
		"\n"
		"The following is the complete set of possible arguments to this\n"
		"constructor, with default values as indicated:\n"
		"\n"
		"@param year a long integereger representing the year.  This should be\n"
		"a four-digit number such as @c 2011.  (Default value used if this\n"
		"argument is not given: @c 2000.)\n"
		"\n"
		"@param month a long integereger representing the month, with a range\n"
		"of values of 1&ndash;12.  The value @c 1 represents January, and so\n"
		"on.  (Default value used if this argument is not given: @c 1.)\n"
		"\n"
		"@param day a long integereger representing the day of the month, with\n"
		"a range of values of 1&ndash;31.  (Default value used if this argument\n"
		"is not given: @c 1.)\n"
		"\n"
		"@param hour a long integereger representing the hour on a 24-hour\n"
		"clock, with a range of values of 0&ndash;23.  (Default value used if\n"
		"this argument is not given: @c 0.)\n"
		"\n"
		"@param minute a long integereger representing the minute, with a\n"
		"range of 0&ndash;59.  (Default value used if this argument is not\n"
		"given: @c 0.)\n"
		"\n"
		"@param second a long integereger representing the second, with a\n"
		"range of 0&ndash;59.  (Default value used if this argument is not\n"
		"given: @c 0.)\n"
		"\n"
		"@param sign a long integereger representing the sign of the offset\n"
		"(@c 0 signifying @c + and @c 1 signifying @c -).  See the paragraph\n"
		"below for further explanations.  (Default value used if this argument\n"
		"is not given: @c 0.)\n"
		"\n"
		"@param hoursOffset a long integereger representing the time zone's\n"
		"hour offset from GMT.  (Default value used if this argument is not\n"
		"given: @c 0.)\n"
		"\n"
		"@param minutesOffset a long integereger representing the time zone's\n"
		"minute offset from GMT.  (Default value used if this argument is not\n"
		"given: @c 0.)\n"
		"\n"
		"To illustrate the time zone offset, a value of <code>-05:00</code>\n"
		"would correspond to USA Eastern Standard Time.  In the Date object,\n"
		"this would require a value of @c 1 for the sign field, @c 5 for the\n"
		"hour offset and @c 0 for the minutes offset.\n"
		"\n"
		"@if notcpp @docnote @htmlinclude warn-default-args-in-docs.html @endif\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Date(string date)</pre>\n"
		"\n"
		"Creates a Date object from a string expressing a date and time value.\n"
		"\n"
		"This constructor expects its argument to be in the <a target='_blank'\n"
		"href='http://www.w3.org/TR/NOTE-datetime'>W3C date format with time\n"
		"zone offset</a>, used in RDF Dublin Core annotations within SBML.\n"
		"This format expresses a date and time value as a string of the form\n"
		"YYYY-MM-DDThh:mm:ssXHH:ZZ, where\n"
		"<ul>\n"
		"\n"
		"<li> @em YYYY is a four-digit integer representing the year.  This\n"
		"should be a four-digit number such as @c 2011.\n"
		"\n"
		"<li> @em MM is a two-digit integer representing the month, with a range\n"
		"of values of 01&ndash;12.  The value @c 1 represents January, and so\n"
		"on.\n"
		"\n"
		"<li> @em DD is a two-digit integer representing the day of the month,\n"
		"with a range of values of 01&ndash;31.\n"
		"\n"
		"<li> @em hh is a two-digit integer representing the hour on a 24-hour\n"
		"clock, with a range of values of 00&ndash;23.\n"
		"\n"
		"<li> @em mm is a two-digit integer representing the minute, with a\n"
		"range of 00&ndash;59.\n"
		"\n"
		"<li> @em ss is a two-digit integer representing the second, with a\n"
		"range of 0&ndash;59.\n"
		"\n"
		"<li> @em X is the the sign of the time zone offset, either @c + or\n"
		"<code>-</code>.\n"
		"\n"
		"<li> @em HH is a two-digit integer representing the hour of the time\n"
		"zone offset, with a range of 00&ndash;23.\n"
		"\n"
		"<li> @em ZZ is a two-digit integer representing the minutes of the time\n"
		"zone offset, with a range of 00&ndash;59.\n"
		"\n"
		"</ul>\n"
		"\n"
		"In the string format above, it is important not to forget the literal\n"
		"character @c T in the string.  Here is an example date/time string:\n"
		"<code>1997-07-16T19:20:30+01:00</code>, which would represent July 16,\n"
		"1997, at 19:20:30 in Central European Time (which is UTC +1:00).\n"
		"\n"
		"If this constructor is given a @c None argument or a string of length\n"
		"zero, it constructs a Date object with the value of January 1, 2000,\n"
		"at time 00:00 UTC.  Otherwise, the argument @em must be in the\n"
		"complete format described above, or unpredictable results will happen.\n"
		"\n"
		"@param date a string representing the date.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>Date(Date orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_clone", _wrap_Date_clone, METH_VARARGS, (char *)"\n"
		"Date_clone(Date self) -> Date\n"
		"\n"
		"Returns a copy of this Date.\n"
		"\n"
		"@return a (deep) copy of this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getYear", _wrap_Date_getYear, METH_VARARGS, (char *)"\n"
		"Date_getYear(Date self) -> unsigned int\n"
		"\n"
		"Returns the year from this Date.\n"
		"\n"
		"@return the year from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getMonth", _wrap_Date_getMonth, METH_VARARGS, (char *)"\n"
		"Date_getMonth(Date self) -> unsigned int\n"
		"\n"
		"Returns the month from this Date.\n"
		"\n"
		"@return the month from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getDay", _wrap_Date_getDay, METH_VARARGS, (char *)"\n"
		"Date_getDay(Date self) -> unsigned int\n"
		"\n"
		"Returns the day from this Date.\n"
		"\n"
		"@return the day from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getHour", _wrap_Date_getHour, METH_VARARGS, (char *)"\n"
		"Date_getHour(Date self) -> unsigned int\n"
		"\n"
		"Returns the hour from this Date.\n"
		"\n"
		"@return the hour from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getMinute", _wrap_Date_getMinute, METH_VARARGS, (char *)"\n"
		"Date_getMinute(Date self) -> unsigned int\n"
		"\n"
		"Returns the minute from this Date.\n"
		"\n"
		"@return the minute from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getSecond", _wrap_Date_getSecond, METH_VARARGS, (char *)"\n"
		"Date_getSecond(Date self) -> unsigned int\n"
		"\n"
		"Returns the seconds from this Date.\n"
		"\n"
		"@return the seconds from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getSignOffset", _wrap_Date_getSignOffset, METH_VARARGS, (char *)"\n"
		"Date_getSignOffset(Date self) -> unsigned int\n"
		"\n"
		"Returns the sign of the time zone offset from this Date.\n"
		"\n"
		"@return the sign of the offset from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getHoursOffset", _wrap_Date_getHoursOffset, METH_VARARGS, (char *)"\n"
		"Date_getHoursOffset(Date self) -> unsigned int\n"
		"\n"
		"Returns the hours of the time zone offset from this Date.\n"
		"\n"
		"@return the hours of the offset from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getMinutesOffset", _wrap_Date_getMinutesOffset, METH_VARARGS, (char *)"\n"
		"Date_getMinutesOffset(Date self) -> unsigned int\n"
		"\n"
		"Returns the minutes of the time zone offset from this Date.\n"
		"\n"
		"@return the minutes of the offset from this Date.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_getDateAsString", _wrap_Date_getDateAsString, METH_VARARGS, (char *)"\n"
		"Date_getDateAsString(Date self) -> string\n"
		"\n"
		"Returns the current Date value in text-string form.\n"
		"\n"
		"The string returned will be in the <a target='_blank'\n"
		"href='http://www.w3.org/TR/NOTE-datetime'>W3C date format with time\n"
		"zone offset</a>, used in RDF Dublin Core annotations within SBML.\n"
		"This format expresses a date and time value as a string of the form\n"
		"YYYY-MM-DDThh:mm:ssXHH:ZZ, where\n"
		"<ul>\n"
		"\n"
		"<li> @em YYYY is a four-digit integer representing the year.  This\n"
		"should be a four-digit number such as @c 2011.\n"
		"\n"
		"<li> @em MM is a two-digit integer representing the month, with a range\n"
		"of values of 01&ndash;12.  The value @c 1 represents January, and so\n"
		"on.\n"
		"\n"
		"<li> @em DD is a two-digit integer representing the day of the month,\n"
		"with a range of values of 01&ndash;31.\n"
		"\n"
		"<li> @em hh is a two-digit integer representing the hour on a 24-hour\n"
		"clock, with a range of values of 00&ndash;23.\n"
		"\n"
		"<li> @em mm is a two-digit integer representing the minute, with a\n"
		"range of 00&ndash;59.\n"
		"\n"
		"<li> @em ss is a two-digit integer representing the second, with a\n"
		"range of 0&ndash;59.\n"
		"\n"
		"<li> @em X is the the sign of the time zone offset, either @c + or\n"
		"<code>-</code>.\n"
		"\n"
		"<li> @em HH is a two-digit integer representing the hour of the time\n"
		"zone offset, with a range of 00&ndash;23.\n"
		"\n"
		"<li> @em ZZ is a two-digit integer representing the minutes of the time\n"
		"zone offset, with a range of 00&ndash;59.\n"
		"\n"
		"</ul>\n"
		"\n"
		"An example date/time string is <code>1997-07-16T19:20:30+01:00</code>,\n"
		"which represents July 16, 1997, at 19:20:30 in Central European Time\n"
		"(which is UTC +1:00).\n"
		"\n"
		"@return the date as a string.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setYear", _wrap_Date_setYear, METH_VARARGS, (char *)"\n"
		"Date_setYear(Date self, unsigned int year) -> int\n"
		"\n"
		"Sets the value of the year of this Date object.\n"
		"\n"
		"The value given as argument must be between 1000 and 9999 inclusive.\n"
		"(In the millennium during which this libSBML documentation is being\n"
		"written, a typical value is @c 2011, but we hope that SBML will\n"
		"continue to be used for a long time.)\n"
		" \n"
		"@param year a long integer representing the year.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setMonth", _wrap_Date_setMonth, METH_VARARGS, (char *)"\n"
		"Date_setMonth(Date self, unsigned int month) -> int\n"
		"\n"
		"Sets the value of the month of this Date object.\n"
		"\n"
		"@param month a long integer representing the month; it must be in the\n"
		"range 1&ndash;12 or an error will be signaled.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setDay", _wrap_Date_setDay, METH_VARARGS, (char *)"\n"
		"Date_setDay(Date self, unsigned int day) -> int\n"
		"\n"
		"Sets the value of the day of this Date object.\n"
		" \n"
		"@param day a long integer representing the day; it must be in the\n"
		"range 0&ndash;31 or an error will be signaled.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setHour", _wrap_Date_setHour, METH_VARARGS, (char *)"\n"
		"Date_setHour(Date self, unsigned int hour) -> int\n"
		"\n"
		"Sets the value of the hour of this Date object.\n"
		" \n"
		"@param hour a long integer representing the hour to set; it must be\n"
		"in the range 0&ndash;23 or an error will be signaled.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setMinute", _wrap_Date_setMinute, METH_VARARGS, (char *)"\n"
		"Date_setMinute(Date self, unsigned int minute) -> int\n"
		"\n"
		"Sets the value of the minute of this Date object.\n"
		" \n"
		"@param minute a long integer representing the minute to set; it must\n"
		"be in the range 0&ndash;59 or an error will be signaled.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setSecond", _wrap_Date_setSecond, METH_VARARGS, (char *)"\n"
		"Date_setSecond(Date self, unsigned int second) -> int\n"
		"\n"
		"Sets the value of the second of the Date object.\n"
		" \n"
		"@param second a long integer representing the seconds; it must\n"
		"be in the range 0&ndash;59 or an error will be signaled.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setSignOffset", _wrap_Date_setSignOffset, METH_VARARGS, (char *)"\n"
		"Date_setSignOffset(Date self, unsigned int sign) -> int\n"
		"\n"
		"Sets the value of the sign of the time zone offset of this Date object.\n"
		"\n"
		"The only permissible values are @c 0 and @c 1.\n"
		" \n"
		"@param sign a long integer representing the sign of the offset, with\n"
		"@c 0 signifying @c + and @c 1 signifying @c -.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setHoursOffset", _wrap_Date_setHoursOffset, METH_VARARGS, (char *)"\n"
		"Date_setHoursOffset(Date self, unsigned int hoursOffset) -> int\n"
		"\n"
		"Sets the value of this Date object's time zone hour offset.\n"
		" \n"
		"@param hoursOffset a long integer representing the hours of the\n"
		"offset; it must be in the range 0&ndash;23 or an error will be\n"
		"signaled.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setMinutesOffset", _wrap_Date_setMinutesOffset, METH_VARARGS, (char *)"\n"
		"Date_setMinutesOffset(Date self, unsigned int minutesOffset) -> int\n"
		"\n"
		"Sets the value of this Date object's time zone minutes offset.\n"
		" \n"
		"@param minutesOffset a long integer representing the minutes of the\n"
		"offset; it must be in the range 0&ndash;59 or an error will be\n"
		"signaled.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_setDateAsString", _wrap_Date_setDateAsString, METH_VARARGS, (char *)"\n"
		"Date_setDateAsString(Date self, string date) -> int\n"
		"\n"
		"Sets the value of this Date object using a date and time value\n"
		"expressed as a text string.\n"
		"\n"
		"This method expects its argument to be in the <a target='_blank'\n"
		"href='http://www.w3.org/TR/NOTE-datetime'>W3C date format with time\n"
		"zone offset</a>, used in RDF Dublin Core annotations within SBML.\n"
		"This format expresses a date and time value as a string of the form\n"
		"YYYY-MM-DDThh:mm:ssXHH:ZZ, where <ul>\n"
		"\n"
		"<li> @em YYYY is a four-digit integer representing the year.  This\n"
		"should be a four-digit number such as @c 2011.\n"
		"\n"
		"<li> @em MM is a two-digit integer representing the month, with a range\n"
		"of values of 01&ndash;12.  The value @c 1 represents January, and so\n"
		"on.\n"
		"\n"
		"<li> @em DD is a two-digit integer representing the day of the month,\n"
		"with a range of values of 01&ndash;31.\n"
		"\n"
		"<li> @em hh is a two-digit integer representing the hour on a 24-hour\n"
		"clock, with a range of values of 00&ndash;23.\n"
		"\n"
		"<li> @em mm is a two-digit integer representing the minute, with a\n"
		"range of 00&ndash;59.\n"
		"\n"
		"<li> @em ss is a two-digit integer representing the second, with a\n"
		"range of 0&ndash;59.\n"
		"\n"
		"<li> @em X is the the sign of the time zone offset, either @c + or\n"
		"<code>-</code>.\n"
		"\n"
		"<li> @em HH is a two-digit integer representing the hour of the time\n"
		"zone offset, with a range of 00&ndash;23.\n"
		"\n"
		"<li> @em ZZ is a two-digit integer representing the minutes of the time\n"
		"zone offset, with a range of 00&ndash;59.\n"
		"\n"
		"</ul>\n"
		"\n"
		"In the string format above, it is important not to forget the literal\n"
		"character @c T in the string.  Here is an example date/time string:\n"
		"<code>1997-07-16T19:20:30+01:00</code>, which would represent July 16,\n"
		"1997, at 19:20:30 in Central European Time (which is UTC +1:00).\n"
		"\n"
		"If this method is given a @c None argument or a string of length zero,\n"
		"it constructs a Date object with the value of January 1, 2000, at time\n"
		"00:00 UTC.  Otherwise, the argument @em must be in the complete format\n"
		"described above, or unpredictable results will happen.\n"
		"\n"
		"@param date a string representing the date.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_ATTRIBUTE_VALUE LIBSBML_INVALID_ATTRIBUTE_VALUE @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_representsValidDate", _wrap_Date_representsValidDate, METH_VARARGS, (char *)"\n"
		"Date_representsValidDate(Date self) -> bool\n"
		"\n"
		"Returns true or false depending on whether this date object represents\n"
		"a valid date and time value.\n"
		"\n"
		"This method verifies that the date/time value stored in this object is\n"
		"well-formed and represents plausible values.  A time and date value in\n"
		"the W3C format takes the form YYYY-MM-DDThh:mm:ssXHH:ZZ (e.g.,\n"
		"<code>1997-07-16T19:20:30+01:00</code>) where XHH:ZZ is the time zone\n"
		"offset.  This method checks such things as whether the value of the\n"
		"month number is less than or equal to 12, whether the value of the\n"
		"minutes number is less than or equal to 59, whether a time zone offset\n"
		"is set, etc.\n"
		"\n"
		"@return @c true if the date is valid, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"Date_swigregister", Date_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_ModelCreator", _wrap_delete_ModelCreator, METH_VARARGS, (char *)"delete_ModelCreator(ModelCreator self)"},
	 { (char *)"new_ModelCreator", _wrap_new_ModelCreator, METH_VARARGS, (char *)"\n"
		"ModelCreator()\n"
		"ModelCreator(XMLNode creator)\n"
		"new_ModelCreator(ModelCreator orig) -> ModelCreator\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>ModelCreator()</pre>\n"
		"\n"
		"Creates a new ModelCreator object.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>ModelCreator(const XMLNode creator)</pre>\n"
		"\n"
		"Creates a new ModelCreator from an XMLNode.\n"
		"\n"
		"@param creator the XMLNode from which to create the ModelCreator.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>ModelCreator(ModelCreator orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of the ModelCreator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_clone", _wrap_ModelCreator_clone, METH_VARARGS, (char *)"\n"
		"ModelCreator_clone(ModelCreator self) -> ModelCreator\n"
		"\n"
		"Creates and returns a copy of this ModelCreator.\n"
		"\n"
		"@return a (deep) copy of this ModelCreator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_getFamilyName", _wrap_ModelCreator_getFamilyName, METH_VARARGS, (char *)"\n"
		"ModelCreator_getFamilyName(ModelCreator self) -> string\n"
		"\n"
		"Returns the 'family name' stored in this ModelCreator object.\n"
		"\n"
		"@return the 'family name' portion of the ModelCreator object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_getGivenName", _wrap_ModelCreator_getGivenName, METH_VARARGS, (char *)"\n"
		"ModelCreator_getGivenName(ModelCreator self) -> string\n"
		"\n"
		"Returns the 'given name' stored in this ModelCreator object.\n"
		"\n"
		"@return the 'given name' portion of the ModelCreator object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_getEmail", _wrap_ModelCreator_getEmail, METH_VARARGS, (char *)"\n"
		"ModelCreator_getEmail(ModelCreator self) -> string\n"
		"\n"
		"Returns the 'email' stored in this ModelCreator object.\n"
		"\n"
		"@return email from the ModelCreator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_getOrganization", _wrap_ModelCreator_getOrganization, METH_VARARGS, (char *)"\n"
		"ModelCreator_getOrganization(ModelCreator self) -> string\n"
		"\n"
		"Returns the 'organization' stored in this ModelCreator object.\n"
		"\n"
		"@return organization from the ModelCreator.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_getOrganisation", _wrap_ModelCreator_getOrganisation, METH_VARARGS, (char *)"\n"
		"ModelCreator_getOrganisation(ModelCreator self) -> string\n"
		"\n"
		"(Alternate spelling) Returns the 'organization' stored in this\n"
		"ModelCreator object.\n"
		"\n"
		"@note This function is an alias of getOrganization().\n"
		"\n"
		"@return organization from the ModelCreator.\n"
		"\n"
		"@see getOrganization()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_isSetFamilyName", _wrap_ModelCreator_isSetFamilyName, METH_VARARGS, (char *)"\n"
		"ModelCreator_isSetFamilyName(ModelCreator self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ModelCreator's 'family name' part is set.\n"
		"\n"
		"@return @c true if the familyName of this ModelCreator is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_isSetGivenName", _wrap_ModelCreator_isSetGivenName, METH_VARARGS, (char *)"\n"
		"ModelCreator_isSetGivenName(ModelCreator self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ModelCreator's 'given name' part is set.\n"
		"\n"
		"@return @c true if the givenName of this ModelCreator is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_isSetEmail", _wrap_ModelCreator_isSetEmail, METH_VARARGS, (char *)"\n"
		"ModelCreator_isSetEmail(ModelCreator self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ModelCreator's 'email' part is set.\n"
		"\n"
		"@return @c true if the email of this ModelCreator is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_isSetOrganization", _wrap_ModelCreator_isSetOrganization, METH_VARARGS, (char *)"\n"
		"ModelCreator_isSetOrganization(ModelCreator self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ModelCreator's 'organization' part is set.\n"
		"\n"
		"@return @c true if the organization of this ModelCreator is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_isSetOrganisation", _wrap_ModelCreator_isSetOrganisation, METH_VARARGS, (char *)"\n"
		"ModelCreator_isSetOrganisation(ModelCreator self) -> bool\n"
		"\n"
		"(Alternate spelling) Predicate returning @c true or @c false depending\n"
		"on whether this ModelCreator's 'organization' part is set.\n"
		"\n"
		"@note This function is an alias of isSetOrganization().\n"
		"\n"
		"@return @c true if the organization of this ModelCreator is set, @c false otherwise.\n"
		"\n"
		"@see isSetOrganization()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_setFamilyName", _wrap_ModelCreator_setFamilyName, METH_VARARGS, (char *)"\n"
		"ModelCreator_setFamilyName(ModelCreator self, string familyName) -> int\n"
		"\n"
		"Sets the 'family name' portion of this ModelCreator object.\n"
		" \n"
		"@param familyName a string representing the familyName of the ModelCreator. \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_setGivenName", _wrap_ModelCreator_setGivenName, METH_VARARGS, (char *)"\n"
		"ModelCreator_setGivenName(ModelCreator self, string givenName) -> int\n"
		"\n"
		"Sets the 'given name' portion of this ModelCreator object.\n"
		" \n"
		"@param givenName a string representing the givenName of the ModelCreator. \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_setEmail", _wrap_ModelCreator_setEmail, METH_VARARGS, (char *)"\n"
		"ModelCreator_setEmail(ModelCreator self, string email) -> int\n"
		"\n"
		"Sets the 'email' portion of this ModelCreator object.\n"
		" \n"
		"@param email a string representing the email of the ModelCreator. \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_setOrganization", _wrap_ModelCreator_setOrganization, METH_VARARGS, (char *)"\n"
		"ModelCreator_setOrganization(ModelCreator self, string organization) -> int\n"
		"\n"
		"Sets the 'organization' portion of this ModelCreator object.\n"
		" \n"
		"@param organization a string representing the organization of the \n"
		"ModelCreator. \n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_setOrganisation", _wrap_ModelCreator_setOrganisation, METH_VARARGS, (char *)"\n"
		"ModelCreator_setOrganisation(ModelCreator self, string organization) -> int\n"
		"\n"
		"(Alternate spelling) Sets the 'organization' portion of this\n"
		"ModelCreator object.\n"
		"\n"
		"@param organization a string representing the organization of the\n"
		"ModelCreator.\n"
		"\n"
		"@note This function is an alias of setOrganization(string organization).\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"\n"
		"@see setOrganization()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_unsetFamilyName", _wrap_ModelCreator_unsetFamilyName, METH_VARARGS, (char *)"\n"
		"ModelCreator_unsetFamilyName(ModelCreator self) -> int\n"
		"\n"
		"Unsets the 'family name' portion of this ModelCreator object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_unsetGivenName", _wrap_ModelCreator_unsetGivenName, METH_VARARGS, (char *)"\n"
		"ModelCreator_unsetGivenName(ModelCreator self) -> int\n"
		"\n"
		"Unsets the 'given name' portion of this ModelCreator object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_unsetEmail", _wrap_ModelCreator_unsetEmail, METH_VARARGS, (char *)"\n"
		"ModelCreator_unsetEmail(ModelCreator self) -> int\n"
		"\n"
		"Unsets the 'email' portion of this ModelCreator object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_unsetOrganization", _wrap_ModelCreator_unsetOrganization, METH_VARARGS, (char *)"\n"
		"ModelCreator_unsetOrganization(ModelCreator self) -> int\n"
		"\n"
		"Unsets the 'organization' portion of this ModelCreator object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_unsetOrganisation", _wrap_ModelCreator_unsetOrganisation, METH_VARARGS, (char *)"\n"
		"ModelCreator_unsetOrganisation(ModelCreator self) -> int\n"
		"\n"
		"(Alternate spelling) Unsets the 'organization' portion of this ModelCreator object.\n"
		"\n"
		"@note This function is an alias of unsetOrganization().\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"\n"
		"@see unsetOrganization()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelCreator_hasRequiredAttributes", _wrap_ModelCreator_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"ModelCreator_hasRequiredAttributes(ModelCreator self) -> bool\n"
		"\n"
		"Predicate returning @c true if all the required elements for this\n"
		"ModelCreator object have been set.\n"
		"\n"
		"The only required elements for a ModelCreator object are the 'family\n"
		"name' and 'given name'.\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"   \n"
		"\n"
		""},
	 { (char *)"ModelCreator_swigregister", ModelCreator_swigregister, METH_VARARGS, NULL},
	 { (char *)"delete_ModelHistory", _wrap_delete_ModelHistory, METH_VARARGS, (char *)"delete_ModelHistory(ModelHistory self)"},
	 { (char *)"new_ModelHistory", _wrap_new_ModelHistory, METH_VARARGS, (char *)"\n"
		"ModelHistory()\n"
		"new_ModelHistory(ModelHistory orig) -> ModelHistory\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>ModelHistory()</pre>\n"
		"\n"
		"Creates a new ModelHistory object.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>ModelHistory(ModelHistory orig)</pre>\n"
		"\n"
		"Copy constructor; creates a copy of this ModelHistory object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_clone", _wrap_ModelHistory_clone, METH_VARARGS, (char *)"\n"
		"ModelHistory_clone(ModelHistory self) -> ModelHistory\n"
		"\n"
		"Creates and returns a copy of this ModelHistory object\n"
		"\n"
		"@return a (deep) copy of this ModelHistory object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getCreatedDate", _wrap_ModelHistory_getCreatedDate, METH_VARARGS, (char *)"\n"
		"ModelHistory_getCreatedDate(ModelHistory self) -> Date\n"
		"\n"
		"Returns the 'creation date' portion of this ModelHistory object.\n"
		"\n"
		"@return a Date object representing the creation date stored in\n"
		"this ModelHistory object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_isSetCreatedDate", _wrap_ModelHistory_isSetCreatedDate, METH_VARARGS, (char *)"\n"
		"ModelHistory_isSetCreatedDate(ModelHistory self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ModelHistory's 'creation date' is set.\n"
		"\n"
		"@return @c true if the creation date value of this ModelHistory is\n"
		"set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_isSetModifiedDate", _wrap_ModelHistory_isSetModifiedDate, METH_VARARGS, (char *)"\n"
		"ModelHistory_isSetModifiedDate(ModelHistory self) -> bool\n"
		"\n"
		"Predicate returning @c true or @c false depending on whether this\n"
		"ModelHistory's 'modified date' is set.\n"
		"\n"
		"@return @c true if the modification date value of this ModelHistory\n"
		"object is set, @c false otherwise.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_setCreatedDate", _wrap_ModelHistory_setCreatedDate, METH_VARARGS, (char *)"\n"
		"ModelHistory_setCreatedDate(ModelHistory self, Date date) -> int\n"
		"\n"
		"Sets the creation date of this ModelHistory object.\n"
		" \n"
		"@param date a Date object representing the date to which the 'created\n"
		"date' portion of this ModelHistory should be set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_setModifiedDate", _wrap_ModelHistory_setModifiedDate, METH_VARARGS, (char *)"\n"
		"ModelHistory_setModifiedDate(ModelHistory self, Date date) -> int\n"
		"\n"
		"Sets the modification date of this ModelHistory object.\n"
		" \n"
		"@param date a Date object representing the date to which the 'modified\n"
		"date' portion of this ModelHistory should be set.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_addModifiedDate", _wrap_ModelHistory_addModifiedDate, METH_VARARGS, (char *)"\n"
		"ModelHistory_addModifiedDate(ModelHistory self, Date date) -> int\n"
		"\n"
		"Adds a copy of a Date object to the list of 'modified date' values\n"
		"stored in this ModelHistory object.\n"
		"\n"
		"In the MIRIAM format for annotations, there can be multiple\n"
		"modification dates.  The libSBML ModelHistory class supports this by\n"
		"storing a list of 'modified date' values.\n"
		" \n"
		"@param date a Date object representing the 'modified date' that should\n"
		"be added to this ModelHistory object.\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getListModifiedDates", _wrap_ModelHistory_getListModifiedDates, METH_VARARGS, (char *)"\n"
		"ModelHistory_getListModifiedDates(ModelHistory self) -> List\n"
		"\n"
		"Returns the list of 'modified date' values (as Date objects) stored in\n"
		"this ModelHistory object.\n"
		"\n"
		"In the MIRIAM format for annotations, there can be multiple\n"
		"modification dates.  The libSBML ModelHistory class supports this by\n"
		"storing a list of 'modified date' values.\n"
		"\n"
		"@return the list of modification dates for this ModelHistory object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getModifiedDate", _wrap_ModelHistory_getModifiedDate, METH_VARARGS, (char *)"\n"
		"getModifiedDate() -> Date\n"
		"ModelHistory_getModifiedDate(ModelHistory self, unsigned int n) -> Date\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getModifiedDate()</pre>\n"
		"\n"
		"Returns the 'modified date' portion of this ModelHistory object.\n"
		"\n"
		"Note that in the MIRIAM format for annotations, there can be multiple\n"
		"modification dates.  The libSBML ModelHistory class supports this by\n"
		"storing a list of 'modified date' values.  If this ModelHistory object\n"
		"contains more than one 'modified date' value in the list, this method\n"
		"will return the first one in the list.\n"
		"\n"
		"@return a Date object representing the date of modification\n"
		"stored in this ModelHistory object.\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>getModifiedDate(long n)</pre>\n"
		"\n"
		"Get the nth Date object in the list of 'modified date' values stored\n"
		"in this ModelHistory object.\n"
		"\n"
		"In the MIRIAM format for annotations, there can be multiple\n"
		"modification dates.  The libSBML ModelHistory class supports this by\n"
		"storing a list of 'modified date' values.\n"
		"\n"
		"@return the nth Date in the list of ModifiedDates of this\n"
		"ModelHistory.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getNumModifiedDates", _wrap_ModelHistory_getNumModifiedDates, METH_VARARGS, (char *)"\n"
		"ModelHistory_getNumModifiedDates(ModelHistory self) -> unsigned int\n"
		"\n"
		"Get the number of Date objects in this ModelHistory object's list of\n"
		"'modified dates'.\n"
		"\n"
		"In the MIRIAM format for annotations, there can be multiple\n"
		"modification dates.  The libSBML ModelHistory class supports this by\n"
		"storing a list of 'modified date' values.\n"
		"\n"
		"@return the number of ModifiedDates in this ModelHistory.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_addCreator", _wrap_ModelHistory_addCreator, METH_VARARGS, (char *)"\n"
		"ModelHistory_addCreator(ModelHistory self, ModelCreator mc) -> int\n"
		"\n"
		"Adds a copy of a ModelCreator object to the list of 'model creator'\n"
		"values stored in this ModelHistory object.\n"
		"\n"
		"In the MIRIAM format for annotations, there can be multiple model\n"
		"creators.  The libSBML ModelHistory class supports this by storing a\n"
		"list of 'model creator' values.\n"
		"\n"
		"@param mc the ModelCreator to add\n"
		"\n"
		"@return integer value indicating success/failure of the\n"
		"function.  @if clike The value is drawn from the\n"
		"enumeration #OperationReturnValues_t. @endif The possible values\n"
		"returned by this function are:\n"
		"@li @link libsbml.LIBSBML_OPERATION_SUCCESS LIBSBML_OPERATION_SUCCESS @endlink\n"
		"@li @link libsbml.LIBSBML_INVALID_OBJECT LIBSBML_INVALID_OBJECT @endlink\n"
		"@li @link libsbml.LIBSBML_OPERATION_FAILED LIBSBML_OPERATION_FAILED @endlink\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getListCreators", _wrap_ModelHistory_getListCreators, METH_VARARGS, (char *)"\n"
		"ModelHistory_getListCreators(ModelHistory self) -> List\n"
		"\n"
		"Returns the list of ModelCreator objects stored in this ModelHistory\n"
		"object.\n"
		"\n"
		"In the MIRIAM format for annotations, there can be multiple model\n"
		"creators.  The libSBML ModelHistory class supports this by storing a\n"
		"list of 'model creator' values.\n"
		"\n"
		"@return the list of ModelCreator objects.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getCreator", _wrap_ModelHistory_getCreator, METH_VARARGS, (char *)"\n"
		"ModelHistory_getCreator(ModelHistory self, unsigned int n) -> ModelCreator\n"
		"\n"
		"Get the nth ModelCreator object stored in this ModelHistory object.\n"
		"\n"
		"In the MIRIAM format for annotations, there can be multiple model\n"
		"creators.  The libSBML ModelHistory class supports this by storing a\n"
		"list of 'model creator' values.\n"
		"\n"
		"@return the nth ModelCreator object.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_getNumCreators", _wrap_ModelHistory_getNumCreators, METH_VARARGS, (char *)"\n"
		"ModelHistory_getNumCreators(ModelHistory self) -> unsigned int\n"
		"\n"
		"Get the number of ModelCreator objects stored in this ModelHistory\n"
		"object.\n"
		"\n"
		"In the MIRIAM format for annotations, there can be multiple model\n"
		"creators.  The libSBML ModelHistory class supports this by storing a\n"
		"list of 'model creator' values.\n"
		"\n"
		"@return the number of ModelCreators objects.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"ModelHistory_hasRequiredAttributes", _wrap_ModelHistory_hasRequiredAttributes, METH_VARARGS, (char *)"\n"
		"ModelHistory_hasRequiredAttributes(ModelHistory self) -> bool\n"
		"\n"
		"Predicate returning @c true if all the required elements for this\n"
		"ModelHistory object have been set.\n"
		"\n"
		"The required elements for a ModelHistory object are 'created\n"
		"name', 'modified date', and at least one 'model creator'.\n"
		"\n"
		"@return a boolean value indicating whether all the required\n"
		"elements for this object have been defined.\n"
		"   \n"
		"\n"
		""},
	 { (char *)"ModelHistory_swigregister", ModelHistory_swigregister, METH_VARARGS, NULL},
	 { (char *)"RDFAnnotationParser_createAnnotation", _wrap_RDFAnnotationParser_createAnnotation, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_createAnnotation() -> XMLNode\n"
		"\n"
		"Creates a blank annotation and returns its root XMLNode object.\n"
		"\n"
		"This creates a completely empty SBML <code>&lt;annotation&gt;</code>\n"
		"element.  It is not attached to any SBML element.  An example of how\n"
		"this might be used is illustrated in the following code fragment.  In\n"
		"this example, suppose that @c content is an XMLNode object previously\n"
		"created, containing MIRIAM-style annotations, and that @c sbmlObject\n"
		"is an SBML object derived from SBase (e.g., a Model, or a Species, or\n"
		"a Compartment, etc.).  Then:@if clike\n"
		" @verbatim\n"
		" int success;                              // Status code variable, used below.\n"
		"\n"
		" XMLNodeRDF = createRDFAnnotation();     // Create RDF annotation XML structure.\n"
		" success = RDF->addChild(...content...);   // Put some content into it.\n"
		" ...                                       // Check 'success' return code value.\n"
		"\n"
		" XMLNodeann = createAnnotation();        // Create <annotation> container.\n"
		" success = ann->addChild(RDF);             // Put the RDF annotation into it.\n"
		" ...                                       // Check 'success' return code value.\n"
		"\n"
		" success = sbmlObject->setAnnotation(ann); // Set object's annotation to what we built.\n"
		" ...                                       // Check 'success' return code value.\n"
		" @endverbatim\n"
		"@endif@if java\n"
		" @verbatim\n"
		" int success;                                   // Status code variable, used below.\n"
		"\n"
		" XMLNode RDF = createRDFAnnotation();          // Create RDF annotation XML structure.\n"
		" success      = RDF.addChild(...content...);    // Put some content into it.\n"
		" ...                                            // Check 'success' return code value.\n"
		"\n"
		" XMLNode ann = createAnnotation();             // Create <annotation> container.\n"
		" success      = ann.addChild(RDF);              // Put the RDF annotation into it.\n"
		" ...                                            // Check 'success' return code value.\n"
		"\n"
		" success      = sbmlObject.setAnnotation(ann); // Set object's annotation to what we built.\n"
		" ...                                            // Check 'success' return code value.\n"
		" @endverbatim\n"
		"@endif@if python\n"
		" @verbatim\n"
		" RDF     = RDFAnnotationParser.createRDFAnnotation() # Create RDF annotation XML structure.\n"
		" success = RDF.addChild(...content...)               # Put some content into it.\n"
		" ...                                                 # Check 'success' return code value.\n"
		"\n"
		" annot   = RDFAnnotationParser.createAnnotation()    # Create <annotation> container.\n"
		" success = annot.addChild(RDF)                       # Put the RDF annotation into it.\n"
		" ...                                                 # Check 'success' return code value.\n"
		"\n"
		" success = sbmlObject.setAnnotation(annot)           # Set object's annotation to what we built.\n"
		" ...                                                 # Check 'success' return code value.\n"
		" @endverbatim\n"
		"@endif\n"
		"The SBML specification contains more information about the format of\n"
		"annotations.  We urge readers to consult Section&nbsp;6 of the SBML\n"
		"Level&nbsp;2 (Versions 2&ndash;4) and SBML Level&nbsp;3 specification\n"
		"documents.\n"
		"\n"
		"@return a pointer to an XMLNode for the annotation\n"
		"\n"
		"@see createRDFAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_createRDFAnnotation", _wrap_RDFAnnotationParser_createRDFAnnotation, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_createRDFAnnotation() -> XMLNode\n"
		"\n"
		"Creates a blank RDF element suitable for use in SBML annotations.\n"
		"\n"
		"The annotation created by this method has namespace declarations for\n"
		"all the relevant XML namespaces used in RDF annotations and also has\n"
		"an empty RDF element.  The result is the following XML:\n"
		" @verbatim\n"
		" <rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'\n"
		"          xmlns:dc='http://purl.org/dc/elements/1.1/'\n"
		"          xmlns:dcterms='http://purl.org/dc/terms/'\n"
		"          xmlns:vCard='http://www.w3.org/2001/vcard-rdf/3.0#'\n"
		"          xmlns:bqbiol='http://biomodels.net/biology-qualifiers/'\n"
		"          xmlns:bqmodel='http://biomodels.net/model-qualifiers/' >\n"
		"\n"
		" </rdf:RDF>\n"
		" @endverbatim\n"
		"\n"
		"Note that this does not create the containing SBML\n"
		"<code>&lt;annotation&gt;</code> element; the method\n"
		"@if clike createAnnotation()@else RDFAnnotationParser.createAnnotation()@endif\n"
		"is available for creating the container.\n"
		"\n"
		"@return a pointer to an XMLNode\n"
		"\n"
		"@see createAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_deleteRDFAnnotation", _wrap_RDFAnnotationParser_deleteRDFAnnotation, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_deleteRDFAnnotation(XMLNode annotation) -> XMLNode\n"
		"\n"
		"Deletes any RDF annotation found in the given XMLNode tree and returns\n"
		"any remaining annotation content.\n"
		"\n"
		"The name of the XMLNode given as parameter @p annotation must be\n"
		"'annotation', or else this method returns @c None.  The method will\n"
		"walk down the XML structure looking for elements that are in the\n"
		"RDF XML namespace, and remove them.\n"
		"\n"
		"@param annotation the XMLNode tree within which the RDF annotation is\n"
		"to be found and deleted\n"
		"\n"
		"@return the XMLNode structure that is left after RDF annotations are\n"
		"deleted.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_createRDFDescription", _wrap_RDFAnnotationParser_createRDFDescription, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_createRDFDescription(SBase obj) -> XMLNode\n"
		"\n"
		"Takes an SBML object and creates an empty XMLNode corresponding to an\n"
		"RDF 'Description' element.\n"
		"\n"
		"This method is a handy way of creating RDF description objects linked\n"
		"by the appropriate 'metaid' field to the given @p object, for\n"
		"insertion into RDF annotations in a model.  The method retrieves the\n"
		"'metaid' attribute from the @p object passed in as argument, then\n"
		"creates an empty element having the following form\n"
		"(where <span class='code' style='background-color: #eed0d0'>metaid</span> \n"
		"the value of the 'metaid' attribute of the argument):\n"
		"\n"
		"div class='fragment'>\n"
		"lt;rdf:Description rdf:about=&quot;#<span style='background-color: #eed0d0'>metaid</span>&quot; xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'&gt;<br>\n"
		"..<br>\n"
		"lt;/rdf:Description&gt;<br>\n"
		"/div>\n"
		"Note that this method does @em not create a complete annotation or\n"
		"even an RDF element; it only creates the 'Description' portion.  Callers\n"
		"will need to use other methods such as\n"
		"@if clike createRDFAnnotation()@else RDFAnnotationParser.createRDFAnnotation()@endif\n"
		"to create the rest of the structure for an annotation.\n"
		"\n"
		"@param obj the object to which the 'Description' refers\n"
		"\n"
		"@return a new XMLNode containing the 'rdf:Description' element with\n"
		"its 'about' attribute value set to the @p object meta identifier.\n"
		"\n"
		"@see createRDFAnnotation()\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_createCVTerms", _wrap_RDFAnnotationParser_createCVTerms, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_createCVTerms(SBase obj) -> XMLNode\n"
		"\n"
		"Takes a list of CVTerm objects and creates a the RDF 'Description'\n"
		"element.\n"
		"\n"
		"This essentially takes the given SBML object, reads out the CVTerm objects\n"
		"attached to it, calls\n"
		"@if clike createRDFDescription()@else RDFAnnotationParser.createRDFDescription()@endif\n"
		"to create an RDF 'Description' element to hold the terms and adds\n"
		"each term with appropriate qualifiers.\n"
		"\n"
		"@param obj the SBML object to start from\n"
		"\n"
		"@return the XMLNode tree corresponding to the Description element of\n"
		"an RDF annotation.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_parseCVTerms", _wrap_RDFAnnotationParser_parseCVTerms, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_parseCVTerms(SBase obj) -> XMLNode\n"
		"\n"
		"Takes a list of CVTerm objects and creates a complete SBML annotation\n"
		"around it.\n"
		"\n"
		"This essentially takes the given SBML object, calls\n"
		"@if clike RDFAnnotationParser.createCVTerms()@else RDFAnnotationParser.createCVTerms()@endif\n"
		"to read out the CVTerm objects\n"
		"attached to it, calls\n"
		"@if clike createRDFAnnotation()@else RDFAnnotationParser.createRDFAnnotation()@endif\n"
		"to create an RDF\n"
		"annotation to hold the terms, and finally calls\n"
		"@if clike createAnnotation()@else RDFAnnotationParser.createAnnotation()@endif\n"
		"to wrap the result as an SBML <code>&lt;annotation&gt;</code> element.\n"
		"\n"
		"@param obj the SBML object to start from\n"
		"\n"
		"@return the XMLNode tree corresponding to the annotation.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_parseModelHistory", _wrap_RDFAnnotationParser_parseModelHistory, METH_VARARGS, (char *)"\n"
		"RDFAnnotationParser_parseModelHistory(SBase obj) -> XMLNode\n"
		"\n"
		"Reads the model history stored in @p object and creates the\n"
		"XML structure for an SBML annotation representing that history.\n"
		"\n"
		"@param obj any SBase object\n"
		"\n"
		"@return the XMLNode corresponding to an annotation containing \n"
		"MIRIAM-compliant model history information in RDF format.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"RDFAnnotationParser_parseRDFAnnotation", _wrap_RDFAnnotationParser_parseRDFAnnotation, METH_VARARGS, (char *)"\n"
		"parseRDFAnnotation(XMLNode annotation) -> ModelHistory\n"
		"RDFAnnotationParser_parseRDFAnnotation(XMLNode annotation, CVTermList CVTerms)\n"
		"\n"
		"This method has multiple variants that differ in the arguments they accept.  Each is described separately below.\n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>parseRDFAnnotation(XMLNodeannotation, ListCVTerms)</pre>\n"
		"\n"
		"Parses an annotation (given as an XMLNode tree) into a list of\n"
		"CVTerm objects.\n"
		"\n"
		"This is used to take an annotation that has been read into an SBML\n"
		"model, identify the RDF elements within it, and create a list of\n"
		"corresponding CVTerm (controlled vocabulary term) objects.\n"
		"\n"
		"@param annotation XMLNode containing the annotation.\n"
		"\n"
		"@param CVTerms list of CVTerm objects to be created.\n"
		"\n"
		"@see parseRDFAnnotation()\n"
		"  \n"
		"\n"
		"<hr>\n"
		"Method variant with the following signature:\n"
		"<pre class='signature'>parseRDFAnnotation(XMLNodeannotation)</pre>\n"
		"\n"
		"Parses an annotation into a ModelHistory class instance.\n"
		"\n"
		"This is used to take an annotation that has been read into an SBML\n"
		"model, identify the RDF elements representing model history\n"
		"information, and create a list of corresponding CVTerm objects.\n"
		"\n"
		"@param annotation XMLNode containing the annotation.\n"
		"\n"
		"@return a pointer to the ModelHistory created.\n"
		"  \n"
		"\n"
		""},
	 { (char *)"new_RDFAnnotationParser", _wrap_new_RDFAnnotationParser, METH_VARARGS, (char *)"new_RDFAnnotationParser() -> RDFAnnotationParser"},
	 { (char *)"delete_RDFAnnotationParser", _wrap_delete_RDFAnnotationParser, METH_VARARGS, (char *)"delete_RDFAnnotationParser(RDFAnnotationParser self)"},
	 { (char *)"RDFAnnotationParser_swigregister", RDFAnnotationParser_swigregister, METH_VARARGS, NULL},
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_ConstraintTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Constraint *) x));
}
static void *_p_RateRuleTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (Rule *) ((RateRule *) x));
}
static void *_p_ListOfTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((ListOf *) x));
}
static void *_p_UnitTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Unit *) x));
}
static void *_p_ListOfFunctionDefinitionsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfFunctionDefinitions *) x));
}
static void *_p_ListOfUnitDefinitionsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfUnitDefinitions *) x));
}
static void *_p_SimpleSpeciesReferenceTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((SimpleSpeciesReference *) x));
}
static void *_p_SpeciesReferenceTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (SimpleSpeciesReference *) ((SpeciesReference *) x));
}
static void *_p_ModifierSpeciesReferenceTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (SimpleSpeciesReference *) ((ModifierSpeciesReference *) x));
}
static void *_p_InitialAssignmentTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((InitialAssignment *) x));
}
static void *_p_RuleTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Rule *) x));
}
static void *_p_ListOfLocalParametersTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *)(ListOfParameters *) ((ListOfLocalParameters *) x));
}
static void *_p_ListOfParametersTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfParameters *) x));
}
static void *_p_EventAssignmentTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((EventAssignment *) x));
}
static void *_p_AssignmentRuleTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (Rule *) ((AssignmentRule *) x));
}
static void *_p_SBMLDocumentTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((SBMLDocument *) x));
}
static void *_p_FunctionDefinitionTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((FunctionDefinition *) x));
}
static void *_p_UnitDefinitionTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((UnitDefinition *) x));
}
static void *_p_ListOfInitialAssignmentsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfInitialAssignments *) x));
}
static void *_p_AlgebraicRuleTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (Rule *) ((AlgebraicRule *) x));
}
static void *_p_ListOfEventAssignmentsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfEventAssignments *) x));
}
static void *_p_ListOfCompartmentTypesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfCompartmentTypes *) x));
}
static void *_p_EventTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Event *) x));
}
static void *_p_CompartmentTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Compartment *) x));
}
static void *_p_KineticLawTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((KineticLaw *) x));
}
static void *_p_ListOfEventsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfEvents *) x));
}
static void *_p_StoichiometryMathTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((StoichiometryMath *) x));
}
static void *_p_ModelTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Model *) x));
}
static void *_p_ListOfSpeciesTypesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfSpeciesTypes *) x));
}
static void *_p_ListOfRulesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfRules *) x));
}
static void *_p_ListOfSpeciesReferencesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfSpeciesReferences *) x));
}
static void *_p_ListOfConstraintsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfConstraints *) x));
}
static void *_p_DelayTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Delay *) x));
}
static void *_p_PriorityTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Priority *) x));
}
static void *_p_CompartmentTypeTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((CompartmentType *) x));
}
static void *_p_ListOfReactionsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfReactions *) x));
}
static void *_p_LocalParameterTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (Parameter *) ((LocalParameter *) x));
}
static void *_p_ParameterTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Parameter *) x));
}
static void *_p_ListOfSpeciesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfSpecies *) x));
}
static void *_p_SpeciesTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Species *) x));
}
static void *_p_TriggerTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Trigger *) x));
}
static void *_p_ListOfUnitsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfUnits *) x));
}
static void *_p_SpeciesTypeTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((SpeciesType *) x));
}
static void *_p_ReactionTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *)  ((Reaction *) x));
}
static void *_p_ListOfCompartmentsTo_p_SBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SBase *) (ListOf *) ((ListOfCompartments *) x));
}
static void *_p_AlgebraicRuleTo_p_Rule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Rule *)  ((AlgebraicRule *) x));
}
static void *_p_AssignmentRuleTo_p_Rule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Rule *)  ((AssignmentRule *) x));
}
static void *_p_RateRuleTo_p_Rule(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Rule *)  ((RateRule *) x));
}
static void *_p_SBMLConstructorExceptionTo_p_std__invalid_argument(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::invalid_argument *)  ((SBMLConstructorException *) x));
}
static void *_p_XMLConstructorExceptionTo_p_std__invalid_argument(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::invalid_argument *)  ((XMLConstructorException *) x));
}
static void *_p_XMLNodeTo_p_XMLToken(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLToken *)  ((XMLNode *) x));
}
static void *_p_SpeciesReferenceTo_p_SimpleSpeciesReference(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SimpleSpeciesReference *)  ((SpeciesReference *) x));
}
static void *_p_ModifierSpeciesReferenceTo_p_SimpleSpeciesReference(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SimpleSpeciesReference *)  ((ModifierSpeciesReference *) x));
}
static void *_p_std__basic_ostreamT_char_std__char_traitsT_char_t_tTo_p_std__basic_iosT_char_std__char_traitsT_char_t_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::basic_ios< char,std::char_traits< char > > *)  ((std::basic_ostream< char,std::char_traits< char > > *) x));
}
static void *_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_tTo_p_std__basic_iosT_char_std__char_traitsT_char_t_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::basic_ios< char,std::char_traits< char > > *) (std::basic_ostream< char > *) ((std::basic_ostringstream< char,std::char_traits< char >,std::allocator< char > > *) x));
}
static void *_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_tTo_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((std::basic_ostream< char,std::char_traits< char > > *)  ((std::basic_ostringstream< char,std::char_traits< char >,std::allocator< char > > *) x));
}
static void *_p_ListOfLocalParametersTo_p_ListOfParameters(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOfParameters *)  ((ListOfLocalParameters *) x));
}
static void *_p_SBMLErrorLogTo_p_XMLErrorLog(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLErrorLog *)  ((SBMLErrorLog *) x));
}
static void *_p_XMLOutputStringStreamTo_p_XMLOutputStream(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLOutputStream *)  ((XMLOutputStringStream *) x));
}
static void *_p_XMLOutputFileStreamTo_p_XMLOutputStream(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLOutputStream *)  ((XMLOutputFileStream *) x));
}
static void *_p_SBMLErrorTo_p_XMLError(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((XMLError *)  ((SBMLError *) x));
}
static void *_p_ListOfReactionsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfReactions *) x));
}
static void *_p_ListOfLocalParametersTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *) (ListOfParameters *) ((ListOfLocalParameters *) x));
}
static void *_p_ListOfParametersTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfParameters *) x));
}
static void *_p_ListOfRulesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfRules *) x));
}
static void *_p_ListOfEventsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfEvents *) x));
}
static void *_p_ListOfCompartmentsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfCompartments *) x));
}
static void *_p_ListOfCompartmentTypesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfCompartmentTypes *) x));
}
static void *_p_ListOfUnitDefinitionsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfUnitDefinitions *) x));
}
static void *_p_ListOfFunctionDefinitionsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfFunctionDefinitions *) x));
}
static void *_p_ListOfSpeciesTypesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfSpeciesTypes *) x));
}
static void *_p_ListOfSpeciesReferencesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfSpeciesReferences *) x));
}
static void *_p_ListOfInitialAssignmentsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfInitialAssignments *) x));
}
static void *_p_ListOfEventAssignmentsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfEventAssignments *) x));
}
static void *_p_ListOfConstraintsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfConstraints *) x));
}
static void *_p_ListOfUnitsTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfUnits *) x));
}
static void *_p_ListOfSpeciesTo_p_ListOf(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ListOf *)  ((ListOfSpecies *) x));
}
static void *_p_LocalParameterTo_p_Parameter(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((Parameter *)  ((LocalParameter *) x));
}
static swig_type_info _swigt__p_ASTNode = {"_p_ASTNode", "ASTNode *|ASTNode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ASTNodeType_t = {"_p_ASTNodeType_t", "enum ASTNodeType_t *|ASTNodeType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_AlgebraicRule = {"_p_AlgebraicRule", "AlgebraicRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_AssignmentRule = {"_p_AssignmentRule", "AssignmentRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_BiolQualifierType_t = {"_p_BiolQualifierType_t", "enum BiolQualifierType_t *|BiolQualifierType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CVTerm = {"_p_CVTerm", "CVTerm *|CVTerm_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Compartment = {"_p_Compartment", "Compartment_t *|Compartment *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CompartmentType = {"_p_CompartmentType", "CompartmentType *|CompartmentType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Constraint = {"_p_Constraint", "Constraint_t *|Constraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Date = {"_p_Date", "Date *|Date_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Delay = {"_p_Delay", "Delay *|Delay_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Event = {"_p_Event", "Event *|Event_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_EventAssignment = {"_p_EventAssignment", "EventAssignment_t *|EventAssignment *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FunctionDefinition = {"_p_FunctionDefinition", "FunctionDefinition_t *|FunctionDefinition *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_InitialAssignment = {"_p_InitialAssignment", "InitialAssignment_t *|InitialAssignment *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_KineticLaw = {"_p_KineticLaw", "KineticLaw *|KineticLaw_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_List = {"_p_List", "List *|List_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOf = {"_p_ListOf", "ListOf *|ListOf_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfCompartmentTypes = {"_p_ListOfCompartmentTypes", "ListOfCompartmentTypes *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfCompartments = {"_p_ListOfCompartments", "ListOfCompartments *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfConstraints = {"_p_ListOfConstraints", "ListOfConstraints *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfEventAssignments = {"_p_ListOfEventAssignments", "ListOfEventAssignments *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfEvents = {"_p_ListOfEvents", "ListOfEvents *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfFunctionDefinitions = {"_p_ListOfFunctionDefinitions", "ListOfFunctionDefinitions *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfInitialAssignments = {"_p_ListOfInitialAssignments", "ListOfInitialAssignments *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfLocalParameters = {"_p_ListOfLocalParameters", "ListOfLocalParameters *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfParameters = {"_p_ListOfParameters", "ListOfParameters *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfReactions = {"_p_ListOfReactions", "ListOfReactions *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfRules = {"_p_ListOfRules", "ListOfRules *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfSpecies = {"_p_ListOfSpecies", "ListOfSpecies *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfSpeciesReferences = {"_p_ListOfSpeciesReferences", "ListOfSpeciesReferences *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfSpeciesTypes = {"_p_ListOfSpeciesTypes", "ListOfSpeciesTypes *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfUnitDefinitions = {"_p_ListOfUnitDefinitions", "ListOfUnitDefinitions *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListOfUnits = {"_p_ListOfUnits", "ListOfUnits *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_ASTNode_t = {"_p_ListWrapperT_ASTNode_t", "ListWrapper< ASTNode > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_CVTerm_t = {"_p_ListWrapperT_CVTerm_t", "ListWrapper< CVTerm > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_Date_t = {"_p_ListWrapperT_Date_t", "ListWrapper< Date > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_ModelCreator_t = {"_p_ListWrapperT_ModelCreator_t", "ListWrapper< ModelCreator > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ListWrapperT_SBMLNamespaces_t = {"_p_ListWrapperT_SBMLNamespaces_t", "ListWrapper< SBMLNamespaces > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_LocalParameter = {"_p_LocalParameter", "LocalParameter *|LocalParameter_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Model = {"_p_Model", "Model *|Model_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ModelCreator = {"_p_ModelCreator", "ModelCreator *|ModelCreator_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ModelHistory = {"_p_ModelHistory", "ModelHistory *|ModelHistory_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ModelQualifierType_t = {"_p_ModelQualifierType_t", "enum ModelQualifierType_t *|ModelQualifierType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ModifierSpeciesReference = {"_p_ModifierSpeciesReference", "ModifierSpeciesReference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OperationReturnValues_t = {"_p_OperationReturnValues_t", "enum OperationReturnValues_t *|OperationReturnValues_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Parameter = {"_p_Parameter", "Parameter *|Parameter_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ParentMap__iterator = {"_p_ParentMap__iterator", "ParentIter *|ParentMap::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Priority = {"_p_Priority", "Priority *|Priority_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_QualifierType_t = {"_p_QualifierType_t", "enum QualifierType_t *|QualifierType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RDFAnnotationParser = {"_p_RDFAnnotationParser", "RDFAnnotationParser *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RateRule = {"_p_RateRule", "RateRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Reaction = {"_p_Reaction", "Reaction_t *|Reaction *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Rule = {"_p_Rule", "Rule_t *|Rule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RuleType_t = {"_p_RuleType_t", "enum RuleType_t *|RuleType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLDocument = {"_p_SBMLDocument", "SBMLDocument_t *|SBMLDocument *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLError = {"_p_SBMLError", "SBMLError *|SBMLError_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLErrorCategory_t = {"_p_SBMLErrorCategory_t", "enum SBMLErrorCategory_t *|SBMLErrorCategory_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLErrorCode_t = {"_p_SBMLErrorCode_t", "enum SBMLErrorCode_t *|SBMLErrorCode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLErrorLog = {"_p_SBMLErrorLog", "SBMLErrorLog *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLErrorSeverity_t = {"_p_SBMLErrorSeverity_t", "enum SBMLErrorSeverity_t *|SBMLErrorSeverity_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLNamespaces = {"_p_SBMLNamespaces", "SBMLNamespaces_t *|SBMLNamespaces *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLReader = {"_p_SBMLReader", "SBMLReader *|SBMLReader_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLTransforms = {"_p_SBMLTransforms", "SBMLTransforms *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLTypeCode_t = {"_p_SBMLTypeCode_t", "enum SBMLTypeCode_t *|SBMLTypeCode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLWriter = {"_p_SBMLWriter", "SBMLWriter *|SBMLWriter_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBO = {"_p_SBO", "SBO *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBase = {"_p_SBase", "SBase_t *|SBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SimpleSpeciesReference = {"_p_SimpleSpeciesReference", "SimpleSpeciesReference *|SpeciesReference_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Species = {"_p_Species", "Species_t *|Species *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SpeciesReference = {"_p_SpeciesReference", "SpeciesReference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SpeciesType = {"_p_SpeciesType", "SpeciesType *|SpeciesType_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_StoichiometryMath = {"_p_StoichiometryMath", "StoichiometryMath_t *|StoichiometryMath *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SyntaxChecker = {"_p_SyntaxChecker", "SyntaxChecker *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Trigger = {"_p_Trigger", "Trigger *|Trigger_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Unit = {"_p_Unit", "Unit_t *|Unit *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_UnitDefinition = {"_p_UnitDefinition", "UnitDefinition_t *|UnitDefinition *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_UnitKind_t = {"_p_UnitKind_t", "enum UnitKind_t *|UnitKind_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLAttributes = {"_p_XMLAttributes", "XMLAttributes *|XMLAttributes_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLError = {"_p_XMLError", "XMLError *|XMLError_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLErrorCategory_t = {"_p_XMLErrorCategory_t", "enum XMLErrorCategory_t *|XMLErrorCategory_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLErrorCode_t = {"_p_XMLErrorCode_t", "enum XMLErrorCode_t *|XMLErrorCode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLErrorLog = {"_p_XMLErrorLog", "XMLErrorLog *|XMLErrorLog_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLErrorSeverity_t = {"_p_XMLErrorSeverity_t", "enum XMLErrorSeverity_t *|XMLErrorSeverity_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLInputStream = {"_p_XMLInputStream", "XMLInputStream *|XMLInputStream_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLNamespaces = {"_p_XMLNamespaces", "XMLNamespaces_t *|XMLNamespaces *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLNode = {"_p_XMLNode", "XMLNode *|XMLNode_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLOutputStream = {"_p_XMLOutputStream", "XMLOutputStream *|XMLOutputStream_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLOutputStringStream = {"_p_XMLOutputStringStream", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_XMLOutputFileStream = {"_p_XMLOutputFileStream", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_XMLToken = {"_p_XMLToken", "XMLToken_t *|XMLToken *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_XMLTriple = {"_p_XMLTriple", "XMLTriple *|XMLTriple_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__CharT = {"_p__CharT", "_CharT *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char_type = {"_p_char_type", "char_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_reference = {"_p_const_reference", "const_reference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int_type = {"_p_int_type", "int_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_off_type = {"_p_off_type", "off_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_PyObject = {"_p_p_PyObject", "PyObject **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pos_type = {"_p_pos_type", "pos_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_reference = {"_p_reference", "reference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_state_type = {"_p_state_type", "state_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_iosT_char_std__char_traitsT_char_t_t = {"_p_std__basic_iosT_char_std__char_traitsT_char_t_t", "std::basic_ios< char > *|std::basic_ios< char,std::char_traits< char > > *|std::ios *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t = {"_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t", "std::basic_ostream< char > *|std::basic_ostream< char,std::char_traits< char > > *|std::ostream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t = {"_p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t", "std::basic_ostringstream< char > *|std::ostringstream *|std::basic_ostringstream< char,std::char_traits< char >,std::allocator< char > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_streambufT_char_std__char_traitsT_char_t_t = {"_p_std__basic_streambufT_char_std__char_traitsT_char_t_t", "std::basic_streambuf< char,std::char_traits< char > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t = {"_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t", "std::basic_string< char > *|std::basic_string< char,std::char_traits< char >,std::allocator< char > > *|std::string *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator = {"_p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator", "std::basic_string< char >::iterator *|std::basic_string< char,std::char_traits< char >,std::allocator< char > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__invalid_argument = {"_p_std__invalid_argument", "std::invalid_argument *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SBMLConstructorException = {"_p_SBMLConstructorException", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_XMLConstructorException = {"_p_XMLConstructorException", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_std__ios_base__openmode = {"_p_std__ios_base__openmode", "std::ios_base::openmode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__multimapT_int_int_t = {"_p_std__multimapT_int_int_t", "ParentMap *|std::multimap< int,int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t = {"_p_std__pairT_ParentMap__iterator_ParentMap__iterator_t", "ParentRange *|std::pair< ParentMap::iterator,ParentMap::iterator > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t = {"_p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t", "PackageReqd *|std::pair< std::basic_string< char,std::char_traits< char >,std::allocator< char > >,bool > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__SwigPyIterator = {"_p_swig__SwigPyIterator", "swig::SwigPyIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_ASTNode,
  &_swigt__p_ASTNodeType_t,
  &_swigt__p_AlgebraicRule,
  &_swigt__p_AssignmentRule,
  &_swigt__p_BiolQualifierType_t,
  &_swigt__p_CVTerm,
  &_swigt__p_Compartment,
  &_swigt__p_CompartmentType,
  &_swigt__p_Constraint,
  &_swigt__p_Date,
  &_swigt__p_Delay,
  &_swigt__p_Event,
  &_swigt__p_EventAssignment,
  &_swigt__p_FunctionDefinition,
  &_swigt__p_InitialAssignment,
  &_swigt__p_KineticLaw,
  &_swigt__p_List,
  &_swigt__p_ListOf,
  &_swigt__p_ListOfCompartmentTypes,
  &_swigt__p_ListOfCompartments,
  &_swigt__p_ListOfConstraints,
  &_swigt__p_ListOfEventAssignments,
  &_swigt__p_ListOfEvents,
  &_swigt__p_ListOfFunctionDefinitions,
  &_swigt__p_ListOfInitialAssignments,
  &_swigt__p_ListOfLocalParameters,
  &_swigt__p_ListOfParameters,
  &_swigt__p_ListOfReactions,
  &_swigt__p_ListOfRules,
  &_swigt__p_ListOfSpecies,
  &_swigt__p_ListOfSpeciesReferences,
  &_swigt__p_ListOfSpeciesTypes,
  &_swigt__p_ListOfUnitDefinitions,
  &_swigt__p_ListOfUnits,
  &_swigt__p_ListWrapperT_ASTNode_t,
  &_swigt__p_ListWrapperT_CVTerm_t,
  &_swigt__p_ListWrapperT_Date_t,
  &_swigt__p_ListWrapperT_ModelCreator_t,
  &_swigt__p_ListWrapperT_SBMLNamespaces_t,
  &_swigt__p_LocalParameter,
  &_swigt__p_Model,
  &_swigt__p_ModelCreator,
  &_swigt__p_ModelHistory,
  &_swigt__p_ModelQualifierType_t,
  &_swigt__p_ModifierSpeciesReference,
  &_swigt__p_OperationReturnValues_t,
  &_swigt__p_Parameter,
  &_swigt__p_ParentMap__iterator,
  &_swigt__p_Priority,
  &_swigt__p_QualifierType_t,
  &_swigt__p_RDFAnnotationParser,
  &_swigt__p_RateRule,
  &_swigt__p_Reaction,
  &_swigt__p_Rule,
  &_swigt__p_RuleType_t,
  &_swigt__p_SBMLConstructorException,
  &_swigt__p_SBMLDocument,
  &_swigt__p_SBMLError,
  &_swigt__p_SBMLErrorCategory_t,
  &_swigt__p_SBMLErrorCode_t,
  &_swigt__p_SBMLErrorLog,
  &_swigt__p_SBMLErrorSeverity_t,
  &_swigt__p_SBMLNamespaces,
  &_swigt__p_SBMLReader,
  &_swigt__p_SBMLTransforms,
  &_swigt__p_SBMLTypeCode_t,
  &_swigt__p_SBMLWriter,
  &_swigt__p_SBO,
  &_swigt__p_SBase,
  &_swigt__p_SimpleSpeciesReference,
  &_swigt__p_Species,
  &_swigt__p_SpeciesReference,
  &_swigt__p_SpeciesType,
  &_swigt__p_StoichiometryMath,
  &_swigt__p_SyntaxChecker,
  &_swigt__p_Trigger,
  &_swigt__p_Unit,
  &_swigt__p_UnitDefinition,
  &_swigt__p_UnitKind_t,
  &_swigt__p_XMLAttributes,
  &_swigt__p_XMLConstructorException,
  &_swigt__p_XMLError,
  &_swigt__p_XMLErrorCategory_t,
  &_swigt__p_XMLErrorCode_t,
  &_swigt__p_XMLErrorLog,
  &_swigt__p_XMLErrorSeverity_t,
  &_swigt__p_XMLInputStream,
  &_swigt__p_XMLNamespaces,
  &_swigt__p_XMLNode,
  &_swigt__p_XMLOutputFileStream,
  &_swigt__p_XMLOutputStream,
  &_swigt__p_XMLOutputStringStream,
  &_swigt__p_XMLToken,
  &_swigt__p_XMLTriple,
  &_swigt__p__CharT,
  &_swigt__p_allocator_type,
  &_swigt__p_char,
  &_swigt__p_char_type,
  &_swigt__p_const_reference,
  &_swigt__p_difference_type,
  &_swigt__p_int_type,
  &_swigt__p_off_type,
  &_swigt__p_p_PyObject,
  &_swigt__p_pos_type,
  &_swigt__p_reference,
  &_swigt__p_size_type,
  &_swigt__p_state_type,
  &_swigt__p_std__basic_iosT_char_std__char_traitsT_char_t_t,
  &_swigt__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,
  &_swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  &_swigt__p_std__basic_streambufT_char_std__char_traitsT_char_t_t,
  &_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  &_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,
  &_swigt__p_std__invalid_argument,
  &_swigt__p_std__ios_base__openmode,
  &_swigt__p_std__multimapT_int_int_t,
  &_swigt__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t,
  &_swigt__p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t,
  &_swigt__p_swig__SwigPyIterator,
  &_swigt__p_value_type,
};

static swig_cast_info _swigc__p_ASTNode[] = {  {&_swigt__p_ASTNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ASTNodeType_t[] = {  {&_swigt__p_ASTNodeType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AlgebraicRule[] = {  {&_swigt__p_AlgebraicRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AssignmentRule[] = {  {&_swigt__p_AssignmentRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BiolQualifierType_t[] = {  {&_swigt__p_BiolQualifierType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CVTerm[] = {  {&_swigt__p_CVTerm, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Compartment[] = {  {&_swigt__p_Compartment, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CompartmentType[] = {  {&_swigt__p_CompartmentType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Constraint[] = {  {&_swigt__p_Constraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Date[] = {  {&_swigt__p_Date, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Delay[] = {  {&_swigt__p_Delay, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Event[] = {  {&_swigt__p_Event, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EventAssignment[] = {  {&_swigt__p_EventAssignment, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FunctionDefinition[] = {  {&_swigt__p_FunctionDefinition, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InitialAssignment[] = {  {&_swigt__p_InitialAssignment, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_KineticLaw[] = {  {&_swigt__p_KineticLaw, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_List[] = {  {&_swigt__p_List, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOf[] = {  {&_swigt__p_ListOfReactions, _p_ListOfReactionsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfLocalParameters, _p_ListOfLocalParametersTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfParameters, _p_ListOfParametersTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfEvents, _p_ListOfEventsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfRules, _p_ListOfRulesTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfCompartments, _p_ListOfCompartmentsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfCompartmentTypes, _p_ListOfCompartmentTypesTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfUnitDefinitions, _p_ListOfUnitDefinitionsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfFunctionDefinitions, _p_ListOfFunctionDefinitionsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfSpeciesTypes, _p_ListOfSpeciesTypesTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfSpeciesReferences, _p_ListOfSpeciesReferencesTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfInitialAssignments, _p_ListOfInitialAssignmentsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfEventAssignments, _p_ListOfEventAssignmentsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfConstraints, _p_ListOfConstraintsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOfUnits, _p_ListOfUnitsTo_p_ListOf, 0, 0},  {&_swigt__p_ListOf, 0, 0, 0},  {&_swigt__p_ListOfSpecies, _p_ListOfSpeciesTo_p_ListOf, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfCompartmentTypes[] = {  {&_swigt__p_ListOfCompartmentTypes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfCompartments[] = {  {&_swigt__p_ListOfCompartments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfConstraints[] = {  {&_swigt__p_ListOfConstraints, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfEventAssignments[] = {  {&_swigt__p_ListOfEventAssignments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfEvents[] = {  {&_swigt__p_ListOfEvents, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfFunctionDefinitions[] = {  {&_swigt__p_ListOfFunctionDefinitions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfInitialAssignments[] = {  {&_swigt__p_ListOfInitialAssignments, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfLocalParameters[] = {  {&_swigt__p_ListOfLocalParameters, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfParameters[] = {  {&_swigt__p_ListOfParameters, 0, 0, 0},  {&_swigt__p_ListOfLocalParameters, _p_ListOfLocalParametersTo_p_ListOfParameters, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfReactions[] = {  {&_swigt__p_ListOfReactions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfRules[] = {  {&_swigt__p_ListOfRules, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfSpecies[] = {  {&_swigt__p_ListOfSpecies, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfSpeciesReferences[] = {  {&_swigt__p_ListOfSpeciesReferences, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfSpeciesTypes[] = {  {&_swigt__p_ListOfSpeciesTypes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfUnitDefinitions[] = {  {&_swigt__p_ListOfUnitDefinitions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListOfUnits[] = {  {&_swigt__p_ListOfUnits, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_ASTNode_t[] = {  {&_swigt__p_ListWrapperT_ASTNode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_CVTerm_t[] = {  {&_swigt__p_ListWrapperT_CVTerm_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_Date_t[] = {  {&_swigt__p_ListWrapperT_Date_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_ModelCreator_t[] = {  {&_swigt__p_ListWrapperT_ModelCreator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ListWrapperT_SBMLNamespaces_t[] = {  {&_swigt__p_ListWrapperT_SBMLNamespaces_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LocalParameter[] = {  {&_swigt__p_LocalParameter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Model[] = {  {&_swigt__p_Model, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ModelCreator[] = {  {&_swigt__p_ModelCreator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ModelHistory[] = {  {&_swigt__p_ModelHistory, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ModelQualifierType_t[] = {  {&_swigt__p_ModelQualifierType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ModifierSpeciesReference[] = {  {&_swigt__p_ModifierSpeciesReference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OperationReturnValues_t[] = {  {&_swigt__p_OperationReturnValues_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Parameter[] = {  {&_swigt__p_Parameter, 0, 0, 0},  {&_swigt__p_LocalParameter, _p_LocalParameterTo_p_Parameter, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ParentMap__iterator[] = {  {&_swigt__p_ParentMap__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Priority[] = {  {&_swigt__p_Priority, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_QualifierType_t[] = {  {&_swigt__p_QualifierType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RDFAnnotationParser[] = {  {&_swigt__p_RDFAnnotationParser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RateRule[] = {  {&_swigt__p_RateRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Reaction[] = {  {&_swigt__p_Reaction, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Rule[] = {  {&_swigt__p_Rule, 0, 0, 0},  {&_swigt__p_AlgebraicRule, _p_AlgebraicRuleTo_p_Rule, 0, 0},  {&_swigt__p_AssignmentRule, _p_AssignmentRuleTo_p_Rule, 0, 0},  {&_swigt__p_RateRule, _p_RateRuleTo_p_Rule, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RuleType_t[] = {  {&_swigt__p_RuleType_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLDocument[] = {  {&_swigt__p_SBMLDocument, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLError[] = {  {&_swigt__p_SBMLError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLErrorCategory_t[] = {  {&_swigt__p_SBMLErrorCategory_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLErrorCode_t[] = {  {&_swigt__p_SBMLErrorCode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLErrorLog[] = {  {&_swigt__p_SBMLErrorLog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLErrorSeverity_t[] = {  {&_swigt__p_SBMLErrorSeverity_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLNamespaces[] = {  {&_swigt__p_SBMLNamespaces, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLReader[] = {  {&_swigt__p_SBMLReader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLTransforms[] = {  {&_swigt__p_SBMLTransforms, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLTypeCode_t[] = {  {&_swigt__p_SBMLTypeCode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLWriter[] = {  {&_swigt__p_SBMLWriter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBO[] = {  {&_swigt__p_SBO, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBase[] = {  {&_swigt__p_Constraint, _p_ConstraintTo_p_SBase, 0, 0},  {&_swigt__p_RateRule, _p_RateRuleTo_p_SBase, 0, 0},  {&_swigt__p_ListOfFunctionDefinitions, _p_ListOfFunctionDefinitionsTo_p_SBase, 0, 0},  {&_swigt__p_ListOfUnitDefinitions, _p_ListOfUnitDefinitionsTo_p_SBase, 0, 0},  {&_swigt__p_SimpleSpeciesReference, _p_SimpleSpeciesReferenceTo_p_SBase, 0, 0},  {&_swigt__p_SpeciesReference, _p_SpeciesReferenceTo_p_SBase, 0, 0},  {&_swigt__p_ModifierSpeciesReference, _p_ModifierSpeciesReferenceTo_p_SBase, 0, 0},  {&_swigt__p_Event, _p_EventTo_p_SBase, 0, 0},  {&_swigt__p_EventAssignment, _p_EventAssignmentTo_p_SBase, 0, 0},  {&_swigt__p_InitialAssignment, _p_InitialAssignmentTo_p_SBase, 0, 0},  {&_swigt__p_ListOfLocalParameters, _p_ListOfLocalParametersTo_p_SBase, 0, 0},  {&_swigt__p_ListOfParameters, _p_ListOfParametersTo_p_SBase, 0, 0},  {&_swigt__p_AssignmentRule, _p_AssignmentRuleTo_p_SBase, 0, 0},  {&_swigt__p_SBMLDocument, _p_SBMLDocumentTo_p_SBase, 0, 0},  {&_swigt__p_FunctionDefinition, _p_FunctionDefinitionTo_p_SBase, 0, 0},  {&_swigt__p_UnitDefinition, _p_UnitDefinitionTo_p_SBase, 0, 0},  {&_swigt__p_Model, _p_ModelTo_p_SBase, 0, 0},  {&_swigt__p_ListOfInitialAssignments, _p_ListOfInitialAssignmentsTo_p_SBase, 0, 0},  {&_swigt__p_ListOfEventAssignments, _p_ListOfEventAssignmentsTo_p_SBase, 0, 0},  {&_swigt__p_AlgebraicRule, _p_AlgebraicRuleTo_p_SBase, 0, 0},  {&_swigt__p_Delay, _p_DelayTo_p_SBase, 0, 0},  {&_swigt__p_ListOf, _p_ListOfTo_p_SBase, 0, 0},  {&_swigt__p_ListOfCompartmentTypes, _p_ListOfCompartmentTypesTo_p_SBase, 0, 0},  {&_swigt__p_Compartment, _p_CompartmentTo_p_SBase, 0, 0},  {&_swigt__p_KineticLaw, _p_KineticLawTo_p_SBase, 0, 0},  {&_swigt__p_ListOfEvents, _p_ListOfEventsTo_p_SBase, 0, 0},  {&_swigt__p_StoichiometryMath, _p_StoichiometryMathTo_p_SBase, 0, 0},  {&_swigt__p_Unit, _p_UnitTo_p_SBase, 0, 0},  {&_swigt__p_SBase, 0, 0, 0},  {&_swigt__p_ListOfSpeciesReferences, _p_ListOfSpeciesReferencesTo_p_SBase, 0, 0},  {&_swigt__p_ListOfSpeciesTypes, _p_ListOfSpeciesTypesTo_p_SBase, 0, 0},  {&_swigt__p_ListOfRules, _p_ListOfRulesTo_p_SBase, 0, 0},  {&_swigt__p_Rule, _p_RuleTo_p_SBase, 0, 0},  {&_swigt__p_ListOfConstraints, _p_ListOfConstraintsTo_p_SBase, 0, 0},  {&_swigt__p_Priority, _p_PriorityTo_p_SBase, 0, 0},  {&_swigt__p_ListOfReactions, _p_ListOfReactionsTo_p_SBase, 0, 0},  {&_swigt__p_CompartmentType, _p_CompartmentTypeTo_p_SBase, 0, 0},  {&_swigt__p_LocalParameter, _p_LocalParameterTo_p_SBase, 0, 0},  {&_swigt__p_Parameter, _p_ParameterTo_p_SBase, 0, 0},  {&_swigt__p_ListOfSpecies, _p_ListOfSpeciesTo_p_SBase, 0, 0},  {&_swigt__p_Species, _p_SpeciesTo_p_SBase, 0, 0},  {&_swigt__p_Trigger, _p_TriggerTo_p_SBase, 0, 0},  {&_swigt__p_ListOfUnits, _p_ListOfUnitsTo_p_SBase, 0, 0},  {&_swigt__p_SpeciesType, _p_SpeciesTypeTo_p_SBase, 0, 0},  {&_swigt__p_ListOfCompartments, _p_ListOfCompartmentsTo_p_SBase, 0, 0},  {&_swigt__p_Reaction, _p_ReactionTo_p_SBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SimpleSpeciesReference[] = {  {&_swigt__p_SimpleSpeciesReference, 0, 0, 0},  {&_swigt__p_SpeciesReference, _p_SpeciesReferenceTo_p_SimpleSpeciesReference, 0, 0},  {&_swigt__p_ModifierSpeciesReference, _p_ModifierSpeciesReferenceTo_p_SimpleSpeciesReference, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Species[] = {  {&_swigt__p_Species, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SpeciesReference[] = {  {&_swigt__p_SpeciesReference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SpeciesType[] = {  {&_swigt__p_SpeciesType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_StoichiometryMath[] = {  {&_swigt__p_StoichiometryMath, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SyntaxChecker[] = {  {&_swigt__p_SyntaxChecker, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Trigger[] = {  {&_swigt__p_Trigger, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Unit[] = {  {&_swigt__p_Unit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UnitDefinition[] = {  {&_swigt__p_UnitDefinition, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_UnitKind_t[] = {  {&_swigt__p_UnitKind_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLAttributes[] = {  {&_swigt__p_XMLAttributes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLError[] = {  {&_swigt__p_XMLError, 0, 0, 0},  {&_swigt__p_SBMLError, _p_SBMLErrorTo_p_XMLError, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLErrorCategory_t[] = {  {&_swigt__p_XMLErrorCategory_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLErrorCode_t[] = {  {&_swigt__p_XMLErrorCode_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLErrorLog[] = {  {&_swigt__p_XMLErrorLog, 0, 0, 0},  {&_swigt__p_SBMLErrorLog, _p_SBMLErrorLogTo_p_XMLErrorLog, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLErrorSeverity_t[] = {  {&_swigt__p_XMLErrorSeverity_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLInputStream[] = {  {&_swigt__p_XMLInputStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLNamespaces[] = {  {&_swigt__p_XMLNamespaces, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLNode[] = {  {&_swigt__p_XMLNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLOutputStringStream[] = {{&_swigt__p_XMLOutputStringStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLOutputFileStream[] = {{&_swigt__p_XMLOutputFileStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLOutputStream[] = {  {&_swigt__p_XMLOutputStringStream, _p_XMLOutputStringStreamTo_p_XMLOutputStream, 0, 0},  {&_swigt__p_XMLOutputFileStream, _p_XMLOutputFileStreamTo_p_XMLOutputStream, 0, 0},  {&_swigt__p_XMLOutputStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLToken[] = {  {&_swigt__p_XMLToken, 0, 0, 0},  {&_swigt__p_XMLNode, _p_XMLNodeTo_p_XMLToken, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLTriple[] = {  {&_swigt__p_XMLTriple, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__CharT[] = {  {&_swigt__p__CharT, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char_type[] = {  {&_swigt__p_char_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_reference[] = {  {&_swigt__p_const_reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int_type[] = {  {&_swigt__p_int_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_off_type[] = {  {&_swigt__p_off_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_PyObject[] = {  {&_swigt__p_p_PyObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pos_type[] = {  {&_swigt__p_pos_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_reference[] = {  {&_swigt__p_reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_state_type[] = {  {&_swigt__p_state_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_iosT_char_std__char_traitsT_char_t_t[] = {  {&_swigt__p_std__basic_iosT_char_std__char_traitsT_char_t_t, 0, 0, 0},  {&_swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, _p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_tTo_p_std__basic_iosT_char_std__char_traitsT_char_t_t, 0, 0},  {&_swigt__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, _p_std__basic_ostreamT_char_std__char_traitsT_char_t_tTo_p_std__basic_iosT_char_std__char_traitsT_char_t_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t[] = {  {&_swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, _p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_tTo_p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0, 0},  {&_swigt__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t[] = {  {&_swigt__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_streambufT_char_std__char_traitsT_char_t_t[] = {  {&_swigt__p_std__basic_streambufT_char_std__char_traitsT_char_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t[] = {  {&_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator[] = {  {&_swigt__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SBMLConstructorException[] = {{&_swigt__p_SBMLConstructorException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_XMLConstructorException[] = {{&_swigt__p_XMLConstructorException, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__invalid_argument[] = {  {&_swigt__p_SBMLConstructorException, _p_SBMLConstructorExceptionTo_p_std__invalid_argument, 0, 0},  {&_swigt__p_XMLConstructorException, _p_XMLConstructorExceptionTo_p_std__invalid_argument, 0, 0},  {&_swigt__p_std__invalid_argument, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ios_base__openmode[] = {  {&_swigt__p_std__ios_base__openmode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__multimapT_int_int_t[] = {  {&_swigt__p_std__multimapT_int_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t[] = {  {&_swigt__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t[] = {  {&_swigt__p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__SwigPyIterator[] = {  {&_swigt__p_swig__SwigPyIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_ASTNode,
  _swigc__p_ASTNodeType_t,
  _swigc__p_AlgebraicRule,
  _swigc__p_AssignmentRule,
  _swigc__p_BiolQualifierType_t,
  _swigc__p_CVTerm,
  _swigc__p_Compartment,
  _swigc__p_CompartmentType,
  _swigc__p_Constraint,
  _swigc__p_Date,
  _swigc__p_Delay,
  _swigc__p_Event,
  _swigc__p_EventAssignment,
  _swigc__p_FunctionDefinition,
  _swigc__p_InitialAssignment,
  _swigc__p_KineticLaw,
  _swigc__p_List,
  _swigc__p_ListOf,
  _swigc__p_ListOfCompartmentTypes,
  _swigc__p_ListOfCompartments,
  _swigc__p_ListOfConstraints,
  _swigc__p_ListOfEventAssignments,
  _swigc__p_ListOfEvents,
  _swigc__p_ListOfFunctionDefinitions,
  _swigc__p_ListOfInitialAssignments,
  _swigc__p_ListOfLocalParameters,
  _swigc__p_ListOfParameters,
  _swigc__p_ListOfReactions,
  _swigc__p_ListOfRules,
  _swigc__p_ListOfSpecies,
  _swigc__p_ListOfSpeciesReferences,
  _swigc__p_ListOfSpeciesTypes,
  _swigc__p_ListOfUnitDefinitions,
  _swigc__p_ListOfUnits,
  _swigc__p_ListWrapperT_ASTNode_t,
  _swigc__p_ListWrapperT_CVTerm_t,
  _swigc__p_ListWrapperT_Date_t,
  _swigc__p_ListWrapperT_ModelCreator_t,
  _swigc__p_ListWrapperT_SBMLNamespaces_t,
  _swigc__p_LocalParameter,
  _swigc__p_Model,
  _swigc__p_ModelCreator,
  _swigc__p_ModelHistory,
  _swigc__p_ModelQualifierType_t,
  _swigc__p_ModifierSpeciesReference,
  _swigc__p_OperationReturnValues_t,
  _swigc__p_Parameter,
  _swigc__p_ParentMap__iterator,
  _swigc__p_Priority,
  _swigc__p_QualifierType_t,
  _swigc__p_RDFAnnotationParser,
  _swigc__p_RateRule,
  _swigc__p_Reaction,
  _swigc__p_Rule,
  _swigc__p_RuleType_t,
  _swigc__p_SBMLConstructorException,
  _swigc__p_SBMLDocument,
  _swigc__p_SBMLError,
  _swigc__p_SBMLErrorCategory_t,
  _swigc__p_SBMLErrorCode_t,
  _swigc__p_SBMLErrorLog,
  _swigc__p_SBMLErrorSeverity_t,
  _swigc__p_SBMLNamespaces,
  _swigc__p_SBMLReader,
  _swigc__p_SBMLTransforms,
  _swigc__p_SBMLTypeCode_t,
  _swigc__p_SBMLWriter,
  _swigc__p_SBO,
  _swigc__p_SBase,
  _swigc__p_SimpleSpeciesReference,
  _swigc__p_Species,
  _swigc__p_SpeciesReference,
  _swigc__p_SpeciesType,
  _swigc__p_StoichiometryMath,
  _swigc__p_SyntaxChecker,
  _swigc__p_Trigger,
  _swigc__p_Unit,
  _swigc__p_UnitDefinition,
  _swigc__p_UnitKind_t,
  _swigc__p_XMLAttributes,
  _swigc__p_XMLConstructorException,
  _swigc__p_XMLError,
  _swigc__p_XMLErrorCategory_t,
  _swigc__p_XMLErrorCode_t,
  _swigc__p_XMLErrorLog,
  _swigc__p_XMLErrorSeverity_t,
  _swigc__p_XMLInputStream,
  _swigc__p_XMLNamespaces,
  _swigc__p_XMLNode,
  _swigc__p_XMLOutputFileStream,
  _swigc__p_XMLOutputStream,
  _swigc__p_XMLOutputStringStream,
  _swigc__p_XMLToken,
  _swigc__p_XMLTriple,
  _swigc__p__CharT,
  _swigc__p_allocator_type,
  _swigc__p_char,
  _swigc__p_char_type,
  _swigc__p_const_reference,
  _swigc__p_difference_type,
  _swigc__p_int_type,
  _swigc__p_off_type,
  _swigc__p_p_PyObject,
  _swigc__p_pos_type,
  _swigc__p_reference,
  _swigc__p_size_type,
  _swigc__p_state_type,
  _swigc__p_std__basic_iosT_char_std__char_traitsT_char_t_t,
  _swigc__p_std__basic_ostreamT_char_std__char_traitsT_char_t_t,
  _swigc__p_std__basic_ostringstreamT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  _swigc__p_std__basic_streambufT_char_std__char_traitsT_char_t_t,
  _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t,
  _swigc__p_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t__iterator,
  _swigc__p_std__invalid_argument,
  _swigc__p_std__ios_base__openmode,
  _swigc__p_std__multimapT_int_int_t,
  _swigc__p_std__pairT_ParentMap__iterator_ParentMap__iterator_t,
  _swigc__p_std__pairT_std__basic_stringT_char_std__char_traitsT_char_t_std__allocatorT_char_t_t_bool_t,
  _swigc__p_swig__SwigPyIterator,
  _swigc__p_value_type,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;
  
  clientdata = clientdata;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpeters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject_HEAD
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  SWIGINTERN PyObject *
  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
    return PyUnicode_InternFromString("<Swig global variables>");
#else
    return PyString_FromString("<Swig global variables>");
#endif
  }
  
  SWIGINTERN PyObject *
  swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
#else
    PyObject *str = PyString_FromString("(");
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
    }
    PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
    return str;
  }
  
  SWIGINTERN int
  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
    char *tmp;
    PyObject *str = swig_varlink_str(v);
    fprintf(fp,"Swig global variables ");
    fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(str);
    return 0;
  }
  
  SWIGINTERN void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  SWIGINTERN PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = NULL;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == NULL && !PyErr_Occurred()) {
      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
    }
    return res;
  }
  
  SWIGINTERN int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_SetString(PyExc_NameError,"Unknown C global variable");
    }
    return res;
  }
  
  SWIGINTERN PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;  
    if (!type_init) {
      const PyTypeObject tmp
      = {
        /* PyObject header changed in Python 3 */
#if PY_VERSION_HEX >= 0x03000000
        PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else
        PyObject_HEAD_INIT(NULL)
        0,                                  /* Number of items in variable part (ob_size) */
#endif
        (char *)"swigvarlink",              /* Type name (tp_name) */
        sizeof(swig_varlinkobject),         /* Basic size (tp_basicsize) */
        0,                                  /* Itemsize (tp_itemsize) */
        (destructor) swig_varlink_dealloc,  /* Deallocator (tp_dealloc) */ 
        (printfunc) swig_varlink_print,     /* Print (tp_print) */
        (getattrfunc) swig_varlink_getattr, /* get attr (tp_getattr) */
        (setattrfunc) swig_varlink_setattr, /* Set attr (tp_setattr) */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
        0,                                  /* tp_del */
#endif
#ifdef COUNT_ALLOCS
        0,0,0,0                             /* tp_alloc -> tp_next */
#endif
      };
      varlink_type = tmp;
      /* for Python 3 we already assigned ob_type in PyVarObject_HEAD_INIT() */
#if PY_VERSION_HEX < 0x03000000
      varlink_type.ob_type = &PyType_Type;
#endif
      type_init = 1;
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  SWIGINTERN PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  SWIGINTERN void 
  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        strncpy(gv->name,name,size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  SWIGINTERN PyObject *
  SWIG_globals(void) {
    static PyObject *_SWIG_globals = 0; 
    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
    return _SWIG_globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (c && (c = strstr(c, "swig_ptr: "))) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
          if (ptr) {
            size_t shift = (ci->ptype) - types;
            swig_type_info *ty = types_initial[shift];
            size_t ldoc = (c - methods[i].ml_doc);
            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
            char *ndoc = (char*)malloc(ldoc + lptr + 10);
            if (ndoc) {
              char *buff = ndoc;
              strncpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              strncpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d;  
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
    PyModuleDef_HEAD_INIT,
    (char *) SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule((char *) SWIG_name, SwigMethods);
#endif
  d = PyModule_GetDict(m);
  
  SWIG_InitializeModule(0);
  SWIG_InstallConstants(d,swig_const_table);
  
  
  PyDict_SetItemString(d,(char*)"cvar", SWIG_globals());
  SWIG_addvarlink(SWIG_globals(),(char*)"string_npos",Swig_var_string_npos_get, Swig_var_string_npos_set);
  SWIG_addvarlink(SWIG_globals(),(char*)"cout",Swig_var_cout_get, Swig_var_cout_set);
  SWIG_addvarlink(SWIG_globals(),(char*)"cerr",Swig_var_cerr_get, Swig_var_cerr_set);
  SWIG_addvarlink(SWIG_globals(),(char*)"clog",Swig_var_clog_get, Swig_var_clog_set);
  SWIG_Python_SetConstant(d, "LIBSBML_DOTTED_VERSION",SWIG_FromCharPtr("4.3.0"));
  SWIG_Python_SetConstant(d, "LIBSBML_VERSION",SWIG_From_int(static_cast< int >(40300)));
  SWIG_Python_SetConstant(d, "LIBSBML_VERSION_STRING",SWIG_FromCharPtr("40300"));
  SWIG_Python_SetConstant(d, "LIBSBML_OPERATION_SUCCESS",SWIG_From_int(static_cast< int >(LIBSBML_OPERATION_SUCCESS)));
  SWIG_Python_SetConstant(d, "LIBSBML_INDEX_EXCEEDS_SIZE",SWIG_From_int(static_cast< int >(LIBSBML_INDEX_EXCEEDS_SIZE)));
  SWIG_Python_SetConstant(d, "LIBSBML_UNEXPECTED_ATTRIBUTE",SWIG_From_int(static_cast< int >(LIBSBML_UNEXPECTED_ATTRIBUTE)));
  SWIG_Python_SetConstant(d, "LIBSBML_OPERATION_FAILED",SWIG_From_int(static_cast< int >(LIBSBML_OPERATION_FAILED)));
  SWIG_Python_SetConstant(d, "LIBSBML_INVALID_ATTRIBUTE_VALUE",SWIG_From_int(static_cast< int >(LIBSBML_INVALID_ATTRIBUTE_VALUE)));
  SWIG_Python_SetConstant(d, "LIBSBML_INVALID_OBJECT",SWIG_From_int(static_cast< int >(LIBSBML_INVALID_OBJECT)));
  SWIG_Python_SetConstant(d, "LIBSBML_DUPLICATE_OBJECT_ID",SWIG_From_int(static_cast< int >(LIBSBML_DUPLICATE_OBJECT_ID)));
  SWIG_Python_SetConstant(d, "LIBSBML_LEVEL_MISMATCH",SWIG_From_int(static_cast< int >(LIBSBML_LEVEL_MISMATCH)));
  SWIG_Python_SetConstant(d, "LIBSBML_VERSION_MISMATCH",SWIG_From_int(static_cast< int >(LIBSBML_VERSION_MISMATCH)));
  SWIG_Python_SetConstant(d, "LIBSBML_INVALID_XML_OPERATION",SWIG_From_int(static_cast< int >(LIBSBML_INVALID_XML_OPERATION)));
  SWIG_Python_SetConstant(d, "SBML_UNKNOWN",SWIG_From_int(static_cast< int >(SBML_UNKNOWN)));
  SWIG_Python_SetConstant(d, "SBML_COMPARTMENT",SWIG_From_int(static_cast< int >(SBML_COMPARTMENT)));
  SWIG_Python_SetConstant(d, "SBML_COMPARTMENT_TYPE",SWIG_From_int(static_cast< int >(SBML_COMPARTMENT_TYPE)));
  SWIG_Python_SetConstant(d, "SBML_CONSTRAINT",SWIG_From_int(static_cast< int >(SBML_CONSTRAINT)));
  SWIG_Python_SetConstant(d, "SBML_DOCUMENT",SWIG_From_int(static_cast< int >(SBML_DOCUMENT)));
  SWIG_Python_SetConstant(d, "SBML_EVENT",SWIG_From_int(static_cast< int >(SBML_EVENT)));
  SWIG_Python_SetConstant(d, "SBML_EVENT_ASSIGNMENT",SWIG_From_int(static_cast< int >(SBML_EVENT_ASSIGNMENT)));
  SWIG_Python_SetConstant(d, "SBML_FUNCTION_DEFINITION",SWIG_From_int(static_cast< int >(SBML_FUNCTION_DEFINITION)));
  SWIG_Python_SetConstant(d, "SBML_INITIAL_ASSIGNMENT",SWIG_From_int(static_cast< int >(SBML_INITIAL_ASSIGNMENT)));
  SWIG_Python_SetConstant(d, "SBML_KINETIC_LAW",SWIG_From_int(static_cast< int >(SBML_KINETIC_LAW)));
  SWIG_Python_SetConstant(d, "SBML_LIST_OF",SWIG_From_int(static_cast< int >(SBML_LIST_OF)));
  SWIG_Python_SetConstant(d, "SBML_MODEL",SWIG_From_int(static_cast< int >(SBML_MODEL)));
  SWIG_Python_SetConstant(d, "SBML_PARAMETER",SWIG_From_int(static_cast< int >(SBML_PARAMETER)));
  SWIG_Python_SetConstant(d, "SBML_REACTION",SWIG_From_int(static_cast< int >(SBML_REACTION)));
  SWIG_Python_SetConstant(d, "SBML_RULE",SWIG_From_int(static_cast< int >(SBML_RULE)));
  SWIG_Python_SetConstant(d, "SBML_SPECIES",SWIG_From_int(static_cast< int >(SBML_SPECIES)));
  SWIG_Python_SetConstant(d, "SBML_SPECIES_REFERENCE",SWIG_From_int(static_cast< int >(SBML_SPECIES_REFERENCE)));
  SWIG_Python_SetConstant(d, "SBML_SPECIES_TYPE",SWIG_From_int(static_cast< int >(SBML_SPECIES_TYPE)));
  SWIG_Python_SetConstant(d, "SBML_MODIFIER_SPECIES_REFERENCE",SWIG_From_int(static_cast< int >(SBML_MODIFIER_SPECIES_REFERENCE)));
  SWIG_Python_SetConstant(d, "SBML_UNIT_DEFINITION",SWIG_From_int(static_cast< int >(SBML_UNIT_DEFINITION)));
  SWIG_Python_SetConstant(d, "SBML_UNIT",SWIG_From_int(static_cast< int >(SBML_UNIT)));
  SWIG_Python_SetConstant(d, "SBML_ALGEBRAIC_RULE",SWIG_From_int(static_cast< int >(SBML_ALGEBRAIC_RULE)));
  SWIG_Python_SetConstant(d, "SBML_ASSIGNMENT_RULE",SWIG_From_int(static_cast< int >(SBML_ASSIGNMENT_RULE)));
  SWIG_Python_SetConstant(d, "SBML_RATE_RULE",SWIG_From_int(static_cast< int >(SBML_RATE_RULE)));
  SWIG_Python_SetConstant(d, "SBML_SPECIES_CONCENTRATION_RULE",SWIG_From_int(static_cast< int >(SBML_SPECIES_CONCENTRATION_RULE)));
  SWIG_Python_SetConstant(d, "SBML_COMPARTMENT_VOLUME_RULE",SWIG_From_int(static_cast< int >(SBML_COMPARTMENT_VOLUME_RULE)));
  SWIG_Python_SetConstant(d, "SBML_PARAMETER_RULE",SWIG_From_int(static_cast< int >(SBML_PARAMETER_RULE)));
  SWIG_Python_SetConstant(d, "SBML_TRIGGER",SWIG_From_int(static_cast< int >(SBML_TRIGGER)));
  SWIG_Python_SetConstant(d, "SBML_DELAY",SWIG_From_int(static_cast< int >(SBML_DELAY)));
  SWIG_Python_SetConstant(d, "SBML_STOICHIOMETRY_MATH",SWIG_From_int(static_cast< int >(SBML_STOICHIOMETRY_MATH)));
  SWIG_Python_SetConstant(d, "SBML_LOCAL_PARAMETER",SWIG_From_int(static_cast< int >(SBML_LOCAL_PARAMETER)));
  SWIG_Python_SetConstant(d, "SBML_PRIORITY",SWIG_From_int(static_cast< int >(SBML_PRIORITY)));
  SWIG_Python_SetConstant(d, "SBML_FORMULA_UNITS_DATA",SWIG_From_int(static_cast< int >(SBML_FORMULA_UNITS_DATA)));
  SWIG_Python_SetConstant(d, "SBML_LIST_FORMULA_UNITS_DATA",SWIG_From_int(static_cast< int >(SBML_LIST_FORMULA_UNITS_DATA)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_COMPARTMENTS",SWIG_From_int(static_cast< int >(SBML_LISTOF_COMPARTMENTS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_COMPARTMENT_TYPES",SWIG_From_int(static_cast< int >(SBML_LISTOF_COMPARTMENT_TYPES)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_CONSTRAINTS",SWIG_From_int(static_cast< int >(SBML_LISTOF_CONSTRAINTS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_EVENTS",SWIG_From_int(static_cast< int >(SBML_LISTOF_EVENTS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_EVENT_ASSIGNMENTS",SWIG_From_int(static_cast< int >(SBML_LISTOF_EVENT_ASSIGNMENTS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_FUNCTION_DEFINITIONS",SWIG_From_int(static_cast< int >(SBML_LISTOF_FUNCTION_DEFINITIONS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_INITIAL_ASSIGNMENTS",SWIG_From_int(static_cast< int >(SBML_LISTOF_INITIAL_ASSIGNMENTS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_PARAMETERS",SWIG_From_int(static_cast< int >(SBML_LISTOF_PARAMETERS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_REACTIONS",SWIG_From_int(static_cast< int >(SBML_LISTOF_REACTIONS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_RULES",SWIG_From_int(static_cast< int >(SBML_LISTOF_RULES)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_SPECIES",SWIG_From_int(static_cast< int >(SBML_LISTOF_SPECIES)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_SPECIES_REFERENCES",SWIG_From_int(static_cast< int >(SBML_LISTOF_SPECIES_REFERENCES)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_SPECIES_TYPES",SWIG_From_int(static_cast< int >(SBML_LISTOF_SPECIES_TYPES)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_UNIT_DEFINITIONS",SWIG_From_int(static_cast< int >(SBML_LISTOF_UNIT_DEFINITIONS)));
  SWIG_Python_SetConstant(d, "SBML_LISTOF_UNITS",SWIG_From_int(static_cast< int >(SBML_LISTOF_UNITS)));
  SWIG_Python_SetConstant(d, "IdCheckON",SWIG_From_int(static_cast< int >(0x01)));
  SWIG_Python_SetConstant(d, "IdCheckOFF",SWIG_From_int(static_cast< int >(0xfe)));
  SWIG_Python_SetConstant(d, "SBMLCheckON",SWIG_From_int(static_cast< int >(0x02)));
  SWIG_Python_SetConstant(d, "SBMLCheckOFF",SWIG_From_int(static_cast< int >(0xfd)));
  SWIG_Python_SetConstant(d, "SBOCheckON",SWIG_From_int(static_cast< int >(0x04)));
  SWIG_Python_SetConstant(d, "SBOCheckOFF",SWIG_From_int(static_cast< int >(0xfb)));
  SWIG_Python_SetConstant(d, "MathCheckON",SWIG_From_int(static_cast< int >(0x08)));
  SWIG_Python_SetConstant(d, "MathCheckOFF",SWIG_From_int(static_cast< int >(0xf7)));
  SWIG_Python_SetConstant(d, "UnitsCheckON",SWIG_From_int(static_cast< int >(0x10)));
  SWIG_Python_SetConstant(d, "UnitsCheckOFF",SWIG_From_int(static_cast< int >(0xef)));
  SWIG_Python_SetConstant(d, "OverdeterCheckON",SWIG_From_int(static_cast< int >(0x20)));
  SWIG_Python_SetConstant(d, "OverdeterCheckOFF",SWIG_From_int(static_cast< int >(0xdf)));
  SWIG_Python_SetConstant(d, "PracticeCheckON",SWIG_From_int(static_cast< int >(0x40)));
  SWIG_Python_SetConstant(d, "PracticeCheckOFF",SWIG_From_int(static_cast< int >(0xbf)));
  SWIG_Python_SetConstant(d, "AllChecksON",SWIG_From_int(static_cast< int >(0x7f)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_AMPERE",SWIG_From_int(static_cast< int >(UNIT_KIND_AMPERE)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_AVOGADRO",SWIG_From_int(static_cast< int >(UNIT_KIND_AVOGADRO)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_BECQUEREL",SWIG_From_int(static_cast< int >(UNIT_KIND_BECQUEREL)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_CANDELA",SWIG_From_int(static_cast< int >(UNIT_KIND_CANDELA)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_CELSIUS",SWIG_From_int(static_cast< int >(UNIT_KIND_CELSIUS)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_COULOMB",SWIG_From_int(static_cast< int >(UNIT_KIND_COULOMB)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_DIMENSIONLESS",SWIG_From_int(static_cast< int >(UNIT_KIND_DIMENSIONLESS)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_FARAD",SWIG_From_int(static_cast< int >(UNIT_KIND_FARAD)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_GRAM",SWIG_From_int(static_cast< int >(UNIT_KIND_GRAM)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_GRAY",SWIG_From_int(static_cast< int >(UNIT_KIND_GRAY)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_HENRY",SWIG_From_int(static_cast< int >(UNIT_KIND_HENRY)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_HERTZ",SWIG_From_int(static_cast< int >(UNIT_KIND_HERTZ)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_ITEM",SWIG_From_int(static_cast< int >(UNIT_KIND_ITEM)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_JOULE",SWIG_From_int(static_cast< int >(UNIT_KIND_JOULE)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_KATAL",SWIG_From_int(static_cast< int >(UNIT_KIND_KATAL)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_KELVIN",SWIG_From_int(static_cast< int >(UNIT_KIND_KELVIN)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_KILOGRAM",SWIG_From_int(static_cast< int >(UNIT_KIND_KILOGRAM)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_LITER",SWIG_From_int(static_cast< int >(UNIT_KIND_LITER)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_LITRE",SWIG_From_int(static_cast< int >(UNIT_KIND_LITRE)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_LUMEN",SWIG_From_int(static_cast< int >(UNIT_KIND_LUMEN)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_LUX",SWIG_From_int(static_cast< int >(UNIT_KIND_LUX)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_METER",SWIG_From_int(static_cast< int >(UNIT_KIND_METER)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_METRE",SWIG_From_int(static_cast< int >(UNIT_KIND_METRE)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_MOLE",SWIG_From_int(static_cast< int >(UNIT_KIND_MOLE)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_NEWTON",SWIG_From_int(static_cast< int >(UNIT_KIND_NEWTON)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_OHM",SWIG_From_int(static_cast< int >(UNIT_KIND_OHM)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_PASCAL",SWIG_From_int(static_cast< int >(UNIT_KIND_PASCAL)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_RADIAN",SWIG_From_int(static_cast< int >(UNIT_KIND_RADIAN)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_SECOND",SWIG_From_int(static_cast< int >(UNIT_KIND_SECOND)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_SIEMENS",SWIG_From_int(static_cast< int >(UNIT_KIND_SIEMENS)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_SIEVERT",SWIG_From_int(static_cast< int >(UNIT_KIND_SIEVERT)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_STERADIAN",SWIG_From_int(static_cast< int >(UNIT_KIND_STERADIAN)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_TESLA",SWIG_From_int(static_cast< int >(UNIT_KIND_TESLA)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_VOLT",SWIG_From_int(static_cast< int >(UNIT_KIND_VOLT)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_WATT",SWIG_From_int(static_cast< int >(UNIT_KIND_WATT)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_WEBER",SWIG_From_int(static_cast< int >(UNIT_KIND_WEBER)));
  SWIG_Python_SetConstant(d, "UNIT_KIND_INVALID",SWIG_From_int(static_cast< int >(UNIT_KIND_INVALID)));
  SWIG_Python_SetConstant(d, "RULE_TYPE_RATE",SWIG_From_int(static_cast< int >(RULE_TYPE_RATE)));
  SWIG_Python_SetConstant(d, "RULE_TYPE_SCALAR",SWIG_From_int(static_cast< int >(RULE_TYPE_SCALAR)));
  SWIG_Python_SetConstant(d, "RULE_TYPE_INVALID",SWIG_From_int(static_cast< int >(RULE_TYPE_INVALID)));
  SWIG_Python_SetConstant(d, "SBML_DEFAULT_LEVEL",SWIG_From_int(static_cast< int >(3)));
  SWIG_Python_SetConstant(d, "SBML_DEFAULT_VERSION",SWIG_From_int(static_cast< int >(1)));
  SWIG_Python_SetConstant(d, "SBML_XMLNS_L1",SWIG_FromCharPtr("http://www.sbml.org/sbml/level1"));
  SWIG_Python_SetConstant(d, "SBML_XMLNS_L2V1",SWIG_FromCharPtr("http://www.sbml.org/sbml/level2"));
  SWIG_Python_SetConstant(d, "SBML_XMLNS_L2V2",SWIG_FromCharPtr("http://www.sbml.org/sbml/level2/version2"));
  SWIG_Python_SetConstant(d, "SBML_XMLNS_L2V3",SWIG_FromCharPtr("http://www.sbml.org/sbml/level2/version3"));
  SWIG_Python_SetConstant(d, "SBML_XMLNS_L2V4",SWIG_FromCharPtr("http://www.sbml.org/sbml/level2/version4"));
  SWIG_Python_SetConstant(d, "SBML_XMLNS_L3V1",SWIG_FromCharPtr("http://www.sbml.org/sbml/level3/version1/core"));
  SWIG_Python_SetConstant(d, "AST_PLUS",SWIG_From_int(static_cast< int >(AST_PLUS)));
  SWIG_Python_SetConstant(d, "AST_MINUS",SWIG_From_int(static_cast< int >(AST_MINUS)));
  SWIG_Python_SetConstant(d, "AST_TIMES",SWIG_From_int(static_cast< int >(AST_TIMES)));
  SWIG_Python_SetConstant(d, "AST_DIVIDE",SWIG_From_int(static_cast< int >(AST_DIVIDE)));
  SWIG_Python_SetConstant(d, "AST_POWER",SWIG_From_int(static_cast< int >(AST_POWER)));
  SWIG_Python_SetConstant(d, "AST_INTEGER",SWIG_From_int(static_cast< int >(AST_INTEGER)));
  SWIG_Python_SetConstant(d, "AST_REAL",SWIG_From_int(static_cast< int >(AST_REAL)));
  SWIG_Python_SetConstant(d, "AST_REAL_E",SWIG_From_int(static_cast< int >(AST_REAL_E)));
  SWIG_Python_SetConstant(d, "AST_RATIONAL",SWIG_From_int(static_cast< int >(AST_RATIONAL)));
  SWIG_Python_SetConstant(d, "AST_NAME",SWIG_From_int(static_cast< int >(AST_NAME)));
  SWIG_Python_SetConstant(d, "AST_NAME_AVOGADRO",SWIG_From_int(static_cast< int >(AST_NAME_AVOGADRO)));
  SWIG_Python_SetConstant(d, "AST_NAME_TIME",SWIG_From_int(static_cast< int >(AST_NAME_TIME)));
  SWIG_Python_SetConstant(d, "AST_CONSTANT_E",SWIG_From_int(static_cast< int >(AST_CONSTANT_E)));
  SWIG_Python_SetConstant(d, "AST_CONSTANT_FALSE",SWIG_From_int(static_cast< int >(AST_CONSTANT_FALSE)));
  SWIG_Python_SetConstant(d, "AST_CONSTANT_PI",SWIG_From_int(static_cast< int >(AST_CONSTANT_PI)));
  SWIG_Python_SetConstant(d, "AST_CONSTANT_TRUE",SWIG_From_int(static_cast< int >(AST_CONSTANT_TRUE)));
  SWIG_Python_SetConstant(d, "AST_LAMBDA",SWIG_From_int(static_cast< int >(AST_LAMBDA)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION",SWIG_From_int(static_cast< int >(AST_FUNCTION)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ABS",SWIG_From_int(static_cast< int >(AST_FUNCTION_ABS)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCCOS",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCOS)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCCOSH",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCOSH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCCOT",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCOT)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCCOTH",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCOTH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCCSC",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCSC)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCCSCH",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCCSCH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCSEC",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCSEC)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCSECH",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCSECH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCSIN",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCSIN)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCSINH",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCSINH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCTAN",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCTAN)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ARCTANH",SWIG_From_int(static_cast< int >(AST_FUNCTION_ARCTANH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_CEILING",SWIG_From_int(static_cast< int >(AST_FUNCTION_CEILING)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_COS",SWIG_From_int(static_cast< int >(AST_FUNCTION_COS)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_COSH",SWIG_From_int(static_cast< int >(AST_FUNCTION_COSH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_COT",SWIG_From_int(static_cast< int >(AST_FUNCTION_COT)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_COTH",SWIG_From_int(static_cast< int >(AST_FUNCTION_COTH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_CSC",SWIG_From_int(static_cast< int >(AST_FUNCTION_CSC)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_CSCH",SWIG_From_int(static_cast< int >(AST_FUNCTION_CSCH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_DELAY",SWIG_From_int(static_cast< int >(AST_FUNCTION_DELAY)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_EXP",SWIG_From_int(static_cast< int >(AST_FUNCTION_EXP)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_FACTORIAL",SWIG_From_int(static_cast< int >(AST_FUNCTION_FACTORIAL)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_FLOOR",SWIG_From_int(static_cast< int >(AST_FUNCTION_FLOOR)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_LN",SWIG_From_int(static_cast< int >(AST_FUNCTION_LN)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_LOG",SWIG_From_int(static_cast< int >(AST_FUNCTION_LOG)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_PIECEWISE",SWIG_From_int(static_cast< int >(AST_FUNCTION_PIECEWISE)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_POWER",SWIG_From_int(static_cast< int >(AST_FUNCTION_POWER)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_ROOT",SWIG_From_int(static_cast< int >(AST_FUNCTION_ROOT)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_SEC",SWIG_From_int(static_cast< int >(AST_FUNCTION_SEC)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_SECH",SWIG_From_int(static_cast< int >(AST_FUNCTION_SECH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_SIN",SWIG_From_int(static_cast< int >(AST_FUNCTION_SIN)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_SINH",SWIG_From_int(static_cast< int >(AST_FUNCTION_SINH)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_TAN",SWIG_From_int(static_cast< int >(AST_FUNCTION_TAN)));
  SWIG_Python_SetConstant(d, "AST_FUNCTION_TANH",SWIG_From_int(static_cast< int >(AST_FUNCTION_TANH)));
  SWIG_Python_SetConstant(d, "AST_LOGICAL_AND",SWIG_From_int(static_cast< int >(AST_LOGICAL_AND)));
  SWIG_Python_SetConstant(d, "AST_LOGICAL_NOT",SWIG_From_int(static_cast< int >(AST_LOGICAL_NOT)));
  SWIG_Python_SetConstant(d, "AST_LOGICAL_OR",SWIG_From_int(static_cast< int >(AST_LOGICAL_OR)));
  SWIG_Python_SetConstant(d, "AST_LOGICAL_XOR",SWIG_From_int(static_cast< int >(AST_LOGICAL_XOR)));
  SWIG_Python_SetConstant(d, "AST_RELATIONAL_EQ",SWIG_From_int(static_cast< int >(AST_RELATIONAL_EQ)));
  SWIG_Python_SetConstant(d, "AST_RELATIONAL_GEQ",SWIG_From_int(static_cast< int >(AST_RELATIONAL_GEQ)));
  SWIG_Python_SetConstant(d, "AST_RELATIONAL_GT",SWIG_From_int(static_cast< int >(AST_RELATIONAL_GT)));
  SWIG_Python_SetConstant(d, "AST_RELATIONAL_LEQ",SWIG_From_int(static_cast< int >(AST_RELATIONAL_LEQ)));
  SWIG_Python_SetConstant(d, "AST_RELATIONAL_LT",SWIG_From_int(static_cast< int >(AST_RELATIONAL_LT)));
  SWIG_Python_SetConstant(d, "AST_RELATIONAL_NEQ",SWIG_From_int(static_cast< int >(AST_RELATIONAL_NEQ)));
  SWIG_Python_SetConstant(d, "AST_UNKNOWN",SWIG_From_int(static_cast< int >(AST_UNKNOWN)));
  SWIG_Python_SetConstant(d, "XMLUnknownError",SWIG_From_int(static_cast< int >(XMLUnknownError)));
  SWIG_Python_SetConstant(d, "XMLOutOfMemory",SWIG_From_int(static_cast< int >(XMLOutOfMemory)));
  SWIG_Python_SetConstant(d, "XMLFileUnreadable",SWIG_From_int(static_cast< int >(XMLFileUnreadable)));
  SWIG_Python_SetConstant(d, "XMLFileUnwritable",SWIG_From_int(static_cast< int >(XMLFileUnwritable)));
  SWIG_Python_SetConstant(d, "XMLFileOperationError",SWIG_From_int(static_cast< int >(XMLFileOperationError)));
  SWIG_Python_SetConstant(d, "XMLNetworkAccessError",SWIG_From_int(static_cast< int >(XMLNetworkAccessError)));
  SWIG_Python_SetConstant(d, "InternalXMLParserError",SWIG_From_int(static_cast< int >(InternalXMLParserError)));
  SWIG_Python_SetConstant(d, "UnrecognizedXMLParserCode",SWIG_From_int(static_cast< int >(UnrecognizedXMLParserCode)));
  SWIG_Python_SetConstant(d, "XMLTranscoderError",SWIG_From_int(static_cast< int >(XMLTranscoderError)));
  SWIG_Python_SetConstant(d, "MissingXMLDecl",SWIG_From_int(static_cast< int >(MissingXMLDecl)));
  SWIG_Python_SetConstant(d, "MissingXMLEncoding",SWIG_From_int(static_cast< int >(MissingXMLEncoding)));
  SWIG_Python_SetConstant(d, "BadXMLDecl",SWIG_From_int(static_cast< int >(BadXMLDecl)));
  SWIG_Python_SetConstant(d, "BadXMLDOCTYPE",SWIG_From_int(static_cast< int >(BadXMLDOCTYPE)));
  SWIG_Python_SetConstant(d, "InvalidCharInXML",SWIG_From_int(static_cast< int >(InvalidCharInXML)));
  SWIG_Python_SetConstant(d, "BadlyFormedXML",SWIG_From_int(static_cast< int >(BadlyFormedXML)));
  SWIG_Python_SetConstant(d, "UnclosedXMLToken",SWIG_From_int(static_cast< int >(UnclosedXMLToken)));
  SWIG_Python_SetConstant(d, "InvalidXMLConstruct",SWIG_From_int(static_cast< int >(InvalidXMLConstruct)));
  SWIG_Python_SetConstant(d, "XMLTagMismatch",SWIG_From_int(static_cast< int >(XMLTagMismatch)));
  SWIG_Python_SetConstant(d, "DuplicateXMLAttribute",SWIG_From_int(static_cast< int >(DuplicateXMLAttribute)));
  SWIG_Python_SetConstant(d, "UndefinedXMLEntity",SWIG_From_int(static_cast< int >(UndefinedXMLEntity)));
  SWIG_Python_SetConstant(d, "BadProcessingInstruction",SWIG_From_int(static_cast< int >(BadProcessingInstruction)));
  SWIG_Python_SetConstant(d, "BadXMLPrefix",SWIG_From_int(static_cast< int >(BadXMLPrefix)));
  SWIG_Python_SetConstant(d, "BadXMLPrefixValue",SWIG_From_int(static_cast< int >(BadXMLPrefixValue)));
  SWIG_Python_SetConstant(d, "MissingXMLRequiredAttribute",SWIG_From_int(static_cast< int >(MissingXMLRequiredAttribute)));
  SWIG_Python_SetConstant(d, "XMLAttributeTypeMismatch",SWIG_From_int(static_cast< int >(XMLAttributeTypeMismatch)));
  SWIG_Python_SetConstant(d, "XMLBadUTF8Content",SWIG_From_int(static_cast< int >(XMLBadUTF8Content)));
  SWIG_Python_SetConstant(d, "MissingXMLAttributeValue",SWIG_From_int(static_cast< int >(MissingXMLAttributeValue)));
  SWIG_Python_SetConstant(d, "BadXMLAttributeValue",SWIG_From_int(static_cast< int >(BadXMLAttributeValue)));
  SWIG_Python_SetConstant(d, "BadXMLAttribute",SWIG_From_int(static_cast< int >(BadXMLAttribute)));
  SWIG_Python_SetConstant(d, "UnrecognizedXMLElement",SWIG_From_int(static_cast< int >(UnrecognizedXMLElement)));
  SWIG_Python_SetConstant(d, "BadXMLComment",SWIG_From_int(static_cast< int >(BadXMLComment)));
  SWIG_Python_SetConstant(d, "BadXMLDeclLocation",SWIG_From_int(static_cast< int >(BadXMLDeclLocation)));
  SWIG_Python_SetConstant(d, "XMLUnexpectedEOF",SWIG_From_int(static_cast< int >(XMLUnexpectedEOF)));
  SWIG_Python_SetConstant(d, "BadXMLIDValue",SWIG_From_int(static_cast< int >(BadXMLIDValue)));
  SWIG_Python_SetConstant(d, "BadXMLIDRef",SWIG_From_int(static_cast< int >(BadXMLIDRef)));
  SWIG_Python_SetConstant(d, "UninterpretableXMLContent",SWIG_From_int(static_cast< int >(UninterpretableXMLContent)));
  SWIG_Python_SetConstant(d, "BadXMLDocumentStructure",SWIG_From_int(static_cast< int >(BadXMLDocumentStructure)));
  SWIG_Python_SetConstant(d, "InvalidAfterXMLContent",SWIG_From_int(static_cast< int >(InvalidAfterXMLContent)));
  SWIG_Python_SetConstant(d, "XMLExpectedQuotedString",SWIG_From_int(static_cast< int >(XMLExpectedQuotedString)));
  SWIG_Python_SetConstant(d, "XMLEmptyValueNotPermitted",SWIG_From_int(static_cast< int >(XMLEmptyValueNotPermitted)));
  SWIG_Python_SetConstant(d, "XMLBadNumber",SWIG_From_int(static_cast< int >(XMLBadNumber)));
  SWIG_Python_SetConstant(d, "XMLBadColon",SWIG_From_int(static_cast< int >(XMLBadColon)));
  SWIG_Python_SetConstant(d, "MissingXMLElements",SWIG_From_int(static_cast< int >(MissingXMLElements)));
  SWIG_Python_SetConstant(d, "XMLContentEmpty",SWIG_From_int(static_cast< int >(XMLContentEmpty)));
  SWIG_Python_SetConstant(d, "XMLErrorCodesUpperBound",SWIG_From_int(static_cast< int >(XMLErrorCodesUpperBound)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_INTERNAL",SWIG_From_int(static_cast< int >(LIBSBML_CAT_INTERNAL)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SYSTEM",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SYSTEM)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_XML",SWIG_From_int(static_cast< int >(LIBSBML_CAT_XML)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_INFO",SWIG_From_int(static_cast< int >(LIBSBML_SEV_INFO)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_WARNING",SWIG_From_int(static_cast< int >(LIBSBML_SEV_WARNING)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_ERROR",SWIG_From_int(static_cast< int >(LIBSBML_SEV_ERROR)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_FATAL",SWIG_From_int(static_cast< int >(LIBSBML_SEV_FATAL)));
  SWIG_Python_SetConstant(d, "UnknownError",SWIG_From_int(static_cast< int >(UnknownError)));
  SWIG_Python_SetConstant(d, "NotUTF8",SWIG_From_int(static_cast< int >(NotUTF8)));
  SWIG_Python_SetConstant(d, "UnrecognizedElement",SWIG_From_int(static_cast< int >(UnrecognizedElement)));
  SWIG_Python_SetConstant(d, "NotSchemaConformant",SWIG_From_int(static_cast< int >(NotSchemaConformant)));
  SWIG_Python_SetConstant(d, "L3NotSchemaConformant",SWIG_From_int(static_cast< int >(L3NotSchemaConformant)));
  SWIG_Python_SetConstant(d, "InvalidMathElement",SWIG_From_int(static_cast< int >(InvalidMathElement)));
  SWIG_Python_SetConstant(d, "DisallowedMathMLSymbol",SWIG_From_int(static_cast< int >(DisallowedMathMLSymbol)));
  SWIG_Python_SetConstant(d, "DisallowedMathMLEncodingUse",SWIG_From_int(static_cast< int >(DisallowedMathMLEncodingUse)));
  SWIG_Python_SetConstant(d, "DisallowedDefinitionURLUse",SWIG_From_int(static_cast< int >(DisallowedDefinitionURLUse)));
  SWIG_Python_SetConstant(d, "BadCsymbolDefinitionURLValue",SWIG_From_int(static_cast< int >(BadCsymbolDefinitionURLValue)));
  SWIG_Python_SetConstant(d, "DisallowedMathTypeAttributeUse",SWIG_From_int(static_cast< int >(DisallowedMathTypeAttributeUse)));
  SWIG_Python_SetConstant(d, "DisallowedMathTypeAttributeValue",SWIG_From_int(static_cast< int >(DisallowedMathTypeAttributeValue)));
  SWIG_Python_SetConstant(d, "LambdaOnlyAllowedInFunctionDef",SWIG_From_int(static_cast< int >(LambdaOnlyAllowedInFunctionDef)));
  SWIG_Python_SetConstant(d, "BooleanOpsNeedBooleanArgs",SWIG_From_int(static_cast< int >(BooleanOpsNeedBooleanArgs)));
  SWIG_Python_SetConstant(d, "NumericOpsNeedNumericArgs",SWIG_From_int(static_cast< int >(NumericOpsNeedNumericArgs)));
  SWIG_Python_SetConstant(d, "ArgsToEqNeedSameType",SWIG_From_int(static_cast< int >(ArgsToEqNeedSameType)));
  SWIG_Python_SetConstant(d, "PiecewiseNeedsConsistentTypes",SWIG_From_int(static_cast< int >(PiecewiseNeedsConsistentTypes)));
  SWIG_Python_SetConstant(d, "PieceNeedsBoolean",SWIG_From_int(static_cast< int >(PieceNeedsBoolean)));
  SWIG_Python_SetConstant(d, "ApplyCiMustBeUserFunction",SWIG_From_int(static_cast< int >(ApplyCiMustBeUserFunction)));
  SWIG_Python_SetConstant(d, "ApplyCiMustBeModelComponent",SWIG_From_int(static_cast< int >(ApplyCiMustBeModelComponent)));
  SWIG_Python_SetConstant(d, "KineticLawParametersAreLocalOnly",SWIG_From_int(static_cast< int >(KineticLawParametersAreLocalOnly)));
  SWIG_Python_SetConstant(d, "MathResultMustBeNumeric",SWIG_From_int(static_cast< int >(MathResultMustBeNumeric)));
  SWIG_Python_SetConstant(d, "OpsNeedCorrectNumberOfArgs",SWIG_From_int(static_cast< int >(OpsNeedCorrectNumberOfArgs)));
  SWIG_Python_SetConstant(d, "InvalidNoArgsPassedToFunctionDef",SWIG_From_int(static_cast< int >(InvalidNoArgsPassedToFunctionDef)));
  SWIG_Python_SetConstant(d, "DisallowedMathUnitsUse",SWIG_From_int(static_cast< int >(DisallowedMathUnitsUse)));
  SWIG_Python_SetConstant(d, "InvalidUnitsValue",SWIG_From_int(static_cast< int >(InvalidUnitsValue)));
  SWIG_Python_SetConstant(d, "DuplicateComponentId",SWIG_From_int(static_cast< int >(DuplicateComponentId)));
  SWIG_Python_SetConstant(d, "DuplicateUnitDefinitionId",SWIG_From_int(static_cast< int >(DuplicateUnitDefinitionId)));
  SWIG_Python_SetConstant(d, "DuplicateLocalParameterId",SWIG_From_int(static_cast< int >(DuplicateLocalParameterId)));
  SWIG_Python_SetConstant(d, "MultipleAssignmentOrRateRules",SWIG_From_int(static_cast< int >(MultipleAssignmentOrRateRules)));
  SWIG_Python_SetConstant(d, "MultipleEventAssignmentsForId",SWIG_From_int(static_cast< int >(MultipleEventAssignmentsForId)));
  SWIG_Python_SetConstant(d, "EventAndAssignmentRuleForId",SWIG_From_int(static_cast< int >(EventAndAssignmentRuleForId)));
  SWIG_Python_SetConstant(d, "DuplicateMetaId",SWIG_From_int(static_cast< int >(DuplicateMetaId)));
  SWIG_Python_SetConstant(d, "InvalidSBOTermSyntax",SWIG_From_int(static_cast< int >(InvalidSBOTermSyntax)));
  SWIG_Python_SetConstant(d, "InvalidMetaidSyntax",SWIG_From_int(static_cast< int >(InvalidMetaidSyntax)));
  SWIG_Python_SetConstant(d, "InvalidIdSyntax",SWIG_From_int(static_cast< int >(InvalidIdSyntax)));
  SWIG_Python_SetConstant(d, "InvalidUnitIdSyntax",SWIG_From_int(static_cast< int >(InvalidUnitIdSyntax)));
  SWIG_Python_SetConstant(d, "InvalidNameSyntax",SWIG_From_int(static_cast< int >(InvalidNameSyntax)));
  SWIG_Python_SetConstant(d, "MissingAnnotationNamespace",SWIG_From_int(static_cast< int >(MissingAnnotationNamespace)));
  SWIG_Python_SetConstant(d, "DuplicateAnnotationNamespaces",SWIG_From_int(static_cast< int >(DuplicateAnnotationNamespaces)));
  SWIG_Python_SetConstant(d, "SBMLNamespaceInAnnotation",SWIG_From_int(static_cast< int >(SBMLNamespaceInAnnotation)));
  SWIG_Python_SetConstant(d, "MultipleAnnotations",SWIG_From_int(static_cast< int >(MultipleAnnotations)));
  SWIG_Python_SetConstant(d, "InconsistentArgUnits",SWIG_From_int(static_cast< int >(InconsistentArgUnits)));
  SWIG_Python_SetConstant(d, "InconsistentKineticLawUnitsL3",SWIG_From_int(static_cast< int >(InconsistentKineticLawUnitsL3)));
  SWIG_Python_SetConstant(d, "AssignRuleCompartmentMismatch",SWIG_From_int(static_cast< int >(AssignRuleCompartmentMismatch)));
  SWIG_Python_SetConstant(d, "AssignRuleSpeciesMismatch",SWIG_From_int(static_cast< int >(AssignRuleSpeciesMismatch)));
  SWIG_Python_SetConstant(d, "AssignRuleParameterMismatch",SWIG_From_int(static_cast< int >(AssignRuleParameterMismatch)));
  SWIG_Python_SetConstant(d, "AssignRuleStoichiometryMismatch",SWIG_From_int(static_cast< int >(AssignRuleStoichiometryMismatch)));
  SWIG_Python_SetConstant(d, "InitAssignCompartmenMismatch",SWIG_From_int(static_cast< int >(InitAssignCompartmenMismatch)));
  SWIG_Python_SetConstant(d, "InitAssignSpeciesMismatch",SWIG_From_int(static_cast< int >(InitAssignSpeciesMismatch)));
  SWIG_Python_SetConstant(d, "InitAssignParameterMismatch",SWIG_From_int(static_cast< int >(InitAssignParameterMismatch)));
  SWIG_Python_SetConstant(d, "InitAssignStoichiometryMismatch",SWIG_From_int(static_cast< int >(InitAssignStoichiometryMismatch)));
  SWIG_Python_SetConstant(d, "RateRuleCompartmentMismatch",SWIG_From_int(static_cast< int >(RateRuleCompartmentMismatch)));
  SWIG_Python_SetConstant(d, "RateRuleSpeciesMismatch",SWIG_From_int(static_cast< int >(RateRuleSpeciesMismatch)));
  SWIG_Python_SetConstant(d, "RateRuleParameterMismatch",SWIG_From_int(static_cast< int >(RateRuleParameterMismatch)));
  SWIG_Python_SetConstant(d, "RateRuleStoichiometryMismatch",SWIG_From_int(static_cast< int >(RateRuleStoichiometryMismatch)));
  SWIG_Python_SetConstant(d, "KineticLawNotSubstancePerTime",SWIG_From_int(static_cast< int >(KineticLawNotSubstancePerTime)));
  SWIG_Python_SetConstant(d, "SpeciesInvalidExtentUnits",SWIG_From_int(static_cast< int >(SpeciesInvalidExtentUnits)));
  SWIG_Python_SetConstant(d, "DelayUnitsNotTime",SWIG_From_int(static_cast< int >(DelayUnitsNotTime)));
  SWIG_Python_SetConstant(d, "EventAssignCompartmentMismatch",SWIG_From_int(static_cast< int >(EventAssignCompartmentMismatch)));
  SWIG_Python_SetConstant(d, "EventAssignSpeciesMismatch",SWIG_From_int(static_cast< int >(EventAssignSpeciesMismatch)));
  SWIG_Python_SetConstant(d, "EventAssignParameterMismatch",SWIG_From_int(static_cast< int >(EventAssignParameterMismatch)));
  SWIG_Python_SetConstant(d, "EventAssignStoichiometryMismatch",SWIG_From_int(static_cast< int >(EventAssignStoichiometryMismatch)));
  SWIG_Python_SetConstant(d, "PriorityUnitsNotDimensionless",SWIG_From_int(static_cast< int >(PriorityUnitsNotDimensionless)));
  SWIG_Python_SetConstant(d, "OverdeterminedSystem",SWIG_From_int(static_cast< int >(OverdeterminedSystem)));
  SWIG_Python_SetConstant(d, "InvalidModelSBOTerm",SWIG_From_int(static_cast< int >(InvalidModelSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidFunctionDefSBOTerm",SWIG_From_int(static_cast< int >(InvalidFunctionDefSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidParameterSBOTerm",SWIG_From_int(static_cast< int >(InvalidParameterSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidInitAssignSBOTerm",SWIG_From_int(static_cast< int >(InvalidInitAssignSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidRuleSBOTerm",SWIG_From_int(static_cast< int >(InvalidRuleSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidConstraintSBOTerm",SWIG_From_int(static_cast< int >(InvalidConstraintSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidReactionSBOTerm",SWIG_From_int(static_cast< int >(InvalidReactionSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesReferenceSBOTerm",SWIG_From_int(static_cast< int >(InvalidSpeciesReferenceSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidKineticLawSBOTerm",SWIG_From_int(static_cast< int >(InvalidKineticLawSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidEventSBOTerm",SWIG_From_int(static_cast< int >(InvalidEventSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidEventAssignmentSBOTerm",SWIG_From_int(static_cast< int >(InvalidEventAssignmentSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidCompartmentSBOTerm",SWIG_From_int(static_cast< int >(InvalidCompartmentSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesSBOTerm",SWIG_From_int(static_cast< int >(InvalidSpeciesSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidCompartmentTypeSBOTerm",SWIG_From_int(static_cast< int >(InvalidCompartmentTypeSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesTypeSBOTerm",SWIG_From_int(static_cast< int >(InvalidSpeciesTypeSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidTriggerSBOTerm",SWIG_From_int(static_cast< int >(InvalidTriggerSBOTerm)));
  SWIG_Python_SetConstant(d, "InvalidDelaySBOTerm",SWIG_From_int(static_cast< int >(InvalidDelaySBOTerm)));
  SWIG_Python_SetConstant(d, "NotesNotInXHTMLNamespace",SWIG_From_int(static_cast< int >(NotesNotInXHTMLNamespace)));
  SWIG_Python_SetConstant(d, "NotesContainsXMLDecl",SWIG_From_int(static_cast< int >(NotesContainsXMLDecl)));
  SWIG_Python_SetConstant(d, "NotesContainsDOCTYPE",SWIG_From_int(static_cast< int >(NotesContainsDOCTYPE)));
  SWIG_Python_SetConstant(d, "InvalidNotesContent",SWIG_From_int(static_cast< int >(InvalidNotesContent)));
  SWIG_Python_SetConstant(d, "OnlyOneNotesElementAllowed",SWIG_From_int(static_cast< int >(OnlyOneNotesElementAllowed)));
  SWIG_Python_SetConstant(d, "InvalidNamespaceOnSBML",SWIG_From_int(static_cast< int >(InvalidNamespaceOnSBML)));
  SWIG_Python_SetConstant(d, "MissingOrInconsistentLevel",SWIG_From_int(static_cast< int >(MissingOrInconsistentLevel)));
  SWIG_Python_SetConstant(d, "MissingOrInconsistentVersion",SWIG_From_int(static_cast< int >(MissingOrInconsistentVersion)));
  SWIG_Python_SetConstant(d, "PackageNSMustMatch",SWIG_From_int(static_cast< int >(PackageNSMustMatch)));
  SWIG_Python_SetConstant(d, "LevelPositiveInteger",SWIG_From_int(static_cast< int >(LevelPositiveInteger)));
  SWIG_Python_SetConstant(d, "VersionPositiveInteger",SWIG_From_int(static_cast< int >(VersionPositiveInteger)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnSBML",SWIG_From_int(static_cast< int >(AllowedAttributesOnSBML)));
  SWIG_Python_SetConstant(d, "MissingModel",SWIG_From_int(static_cast< int >(MissingModel)));
  SWIG_Python_SetConstant(d, "IncorrectOrderInModel",SWIG_From_int(static_cast< int >(IncorrectOrderInModel)));
  SWIG_Python_SetConstant(d, "EmptyListElement",SWIG_From_int(static_cast< int >(EmptyListElement)));
  SWIG_Python_SetConstant(d, "NeedCompartmentIfHaveSpecies",SWIG_From_int(static_cast< int >(NeedCompartmentIfHaveSpecies)));
  SWIG_Python_SetConstant(d, "OneOfEachListOf",SWIG_From_int(static_cast< int >(OneOfEachListOf)));
  SWIG_Python_SetConstant(d, "OnlyFuncDefsInListOfFuncDefs",SWIG_From_int(static_cast< int >(OnlyFuncDefsInListOfFuncDefs)));
  SWIG_Python_SetConstant(d, "OnlyUnitDefsInListOfUnitDefs",SWIG_From_int(static_cast< int >(OnlyUnitDefsInListOfUnitDefs)));
  SWIG_Python_SetConstant(d, "OnlyCompartmentsInListOfCompartments",SWIG_From_int(static_cast< int >(OnlyCompartmentsInListOfCompartments)));
  SWIG_Python_SetConstant(d, "OnlySpeciesInListOfSpecies",SWIG_From_int(static_cast< int >(OnlySpeciesInListOfSpecies)));
  SWIG_Python_SetConstant(d, "OnlyParametersInListOfParameters",SWIG_From_int(static_cast< int >(OnlyParametersInListOfParameters)));
  SWIG_Python_SetConstant(d, "OnlyInitAssignsInListOfInitAssigns",SWIG_From_int(static_cast< int >(OnlyInitAssignsInListOfInitAssigns)));
  SWIG_Python_SetConstant(d, "OnlyRulesInListOfRules",SWIG_From_int(static_cast< int >(OnlyRulesInListOfRules)));
  SWIG_Python_SetConstant(d, "OnlyConstraintsInListOfConstraints",SWIG_From_int(static_cast< int >(OnlyConstraintsInListOfConstraints)));
  SWIG_Python_SetConstant(d, "OnlyReactionsInListOfReactions",SWIG_From_int(static_cast< int >(OnlyReactionsInListOfReactions)));
  SWIG_Python_SetConstant(d, "OnlyEventsInListOfEvents",SWIG_From_int(static_cast< int >(OnlyEventsInListOfEvents)));
  SWIG_Python_SetConstant(d, "L3ConversionFactorOnModel",SWIG_From_int(static_cast< int >(L3ConversionFactorOnModel)));
  SWIG_Python_SetConstant(d, "L3TimeUnitsOnModel",SWIG_From_int(static_cast< int >(L3TimeUnitsOnModel)));
  SWIG_Python_SetConstant(d, "L3VolumeUnitsOnModel",SWIG_From_int(static_cast< int >(L3VolumeUnitsOnModel)));
  SWIG_Python_SetConstant(d, "L3AreaUnitsOnModel",SWIG_From_int(static_cast< int >(L3AreaUnitsOnModel)));
  SWIG_Python_SetConstant(d, "L3LengthUnitsOnModel",SWIG_From_int(static_cast< int >(L3LengthUnitsOnModel)));
  SWIG_Python_SetConstant(d, "L3ExtentUnitsOnModel",SWIG_From_int(static_cast< int >(L3ExtentUnitsOnModel)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnModel",SWIG_From_int(static_cast< int >(AllowedAttributesOnModel)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfFuncs",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfFuncs)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfUnitDefs",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfUnitDefs)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfComps",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfComps)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfSpecies",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfSpecies)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfParams",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfParams)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfInitAssign",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfInitAssign)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfRules",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfRules)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfConstraints",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfConstraints)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfReactions",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfReactions)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfEvents",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfEvents)));
  SWIG_Python_SetConstant(d, "FunctionDefMathNotLambda",SWIG_From_int(static_cast< int >(FunctionDefMathNotLambda)));
  SWIG_Python_SetConstant(d, "InvalidApplyCiInLambda",SWIG_From_int(static_cast< int >(InvalidApplyCiInLambda)));
  SWIG_Python_SetConstant(d, "RecursiveFunctionDefinition",SWIG_From_int(static_cast< int >(RecursiveFunctionDefinition)));
  SWIG_Python_SetConstant(d, "InvalidCiInLambda",SWIG_From_int(static_cast< int >(InvalidCiInLambda)));
  SWIG_Python_SetConstant(d, "InvalidFunctionDefReturnType",SWIG_From_int(static_cast< int >(InvalidFunctionDefReturnType)));
  SWIG_Python_SetConstant(d, "OneMathElementPerFunc",SWIG_From_int(static_cast< int >(OneMathElementPerFunc)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnFunc",SWIG_From_int(static_cast< int >(AllowedAttributesOnFunc)));
  SWIG_Python_SetConstant(d, "InvalidUnitDefId",SWIG_From_int(static_cast< int >(InvalidUnitDefId)));
  SWIG_Python_SetConstant(d, "InvalidSubstanceRedefinition",SWIG_From_int(static_cast< int >(InvalidSubstanceRedefinition)));
  SWIG_Python_SetConstant(d, "InvalidLengthRedefinition",SWIG_From_int(static_cast< int >(InvalidLengthRedefinition)));
  SWIG_Python_SetConstant(d, "InvalidAreaRedefinition",SWIG_From_int(static_cast< int >(InvalidAreaRedefinition)));
  SWIG_Python_SetConstant(d, "InvalidTimeRedefinition",SWIG_From_int(static_cast< int >(InvalidTimeRedefinition)));
  SWIG_Python_SetConstant(d, "InvalidVolumeRedefinition",SWIG_From_int(static_cast< int >(InvalidVolumeRedefinition)));
  SWIG_Python_SetConstant(d, "VolumeLitreDefExponentNotOne",SWIG_From_int(static_cast< int >(VolumeLitreDefExponentNotOne)));
  SWIG_Python_SetConstant(d, "VolumeMetreDefExponentNot3",SWIG_From_int(static_cast< int >(VolumeMetreDefExponentNot3)));
  SWIG_Python_SetConstant(d, "EmptyListOfUnits",SWIG_From_int(static_cast< int >(EmptyListOfUnits)));
  SWIG_Python_SetConstant(d, "InvalidUnitKind",SWIG_From_int(static_cast< int >(InvalidUnitKind)));
  SWIG_Python_SetConstant(d, "OffsetNoLongerValid",SWIG_From_int(static_cast< int >(OffsetNoLongerValid)));
  SWIG_Python_SetConstant(d, "CelsiusNoLongerValid",SWIG_From_int(static_cast< int >(CelsiusNoLongerValid)));
  SWIG_Python_SetConstant(d, "EmptyUnitListElement",SWIG_From_int(static_cast< int >(EmptyUnitListElement)));
  SWIG_Python_SetConstant(d, "OneListOfUnitsPerUnitDef",SWIG_From_int(static_cast< int >(OneListOfUnitsPerUnitDef)));
  SWIG_Python_SetConstant(d, "OnlyUnitsInListOfUnits",SWIG_From_int(static_cast< int >(OnlyUnitsInListOfUnits)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnUnitDefinition",SWIG_From_int(static_cast< int >(AllowedAttributesOnUnitDefinition)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfUnits",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfUnits)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnUnit",SWIG_From_int(static_cast< int >(AllowedAttributesOnUnit)));
  SWIG_Python_SetConstant(d, "ZeroDimensionalCompartmentSize",SWIG_From_int(static_cast< int >(ZeroDimensionalCompartmentSize)));
  SWIG_Python_SetConstant(d, "ZeroDimensionalCompartmentUnits",SWIG_From_int(static_cast< int >(ZeroDimensionalCompartmentUnits)));
  SWIG_Python_SetConstant(d, "ZeroDimensionalCompartmentConst",SWIG_From_int(static_cast< int >(ZeroDimensionalCompartmentConst)));
  SWIG_Python_SetConstant(d, "UndefinedOutsideCompartment",SWIG_From_int(static_cast< int >(UndefinedOutsideCompartment)));
  SWIG_Python_SetConstant(d, "RecursiveCompartmentContainment",SWIG_From_int(static_cast< int >(RecursiveCompartmentContainment)));
  SWIG_Python_SetConstant(d, "ZeroDCompartmentContainment",SWIG_From_int(static_cast< int >(ZeroDCompartmentContainment)));
  SWIG_Python_SetConstant(d, "Invalid1DCompartmentUnits",SWIG_From_int(static_cast< int >(Invalid1DCompartmentUnits)));
  SWIG_Python_SetConstant(d, "Invalid2DCompartmentUnits",SWIG_From_int(static_cast< int >(Invalid2DCompartmentUnits)));
  SWIG_Python_SetConstant(d, "Invalid3DCompartmentUnits",SWIG_From_int(static_cast< int >(Invalid3DCompartmentUnits)));
  SWIG_Python_SetConstant(d, "InvalidCompartmentTypeRef",SWIG_From_int(static_cast< int >(InvalidCompartmentTypeRef)));
  SWIG_Python_SetConstant(d, "OneDimensionalCompartmentUnits",SWIG_From_int(static_cast< int >(OneDimensionalCompartmentUnits)));
  SWIG_Python_SetConstant(d, "TwoDimensionalCompartmentUnits",SWIG_From_int(static_cast< int >(TwoDimensionalCompartmentUnits)));
  SWIG_Python_SetConstant(d, "ThreeDimensionalCompartmentUnits",SWIG_From_int(static_cast< int >(ThreeDimensionalCompartmentUnits)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnCompartment",SWIG_From_int(static_cast< int >(AllowedAttributesOnCompartment)));
  SWIG_Python_SetConstant(d, "NoUnitsOnCompartment",SWIG_From_int(static_cast< int >(NoUnitsOnCompartment)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesCompartmentRef",SWIG_From_int(static_cast< int >(InvalidSpeciesCompartmentRef)));
  SWIG_Python_SetConstant(d, "HasOnlySubsNoSpatialUnits",SWIG_From_int(static_cast< int >(HasOnlySubsNoSpatialUnits)));
  SWIG_Python_SetConstant(d, "NoSpatialUnitsInZeroD",SWIG_From_int(static_cast< int >(NoSpatialUnitsInZeroD)));
  SWIG_Python_SetConstant(d, "NoConcentrationInZeroD",SWIG_From_int(static_cast< int >(NoConcentrationInZeroD)));
  SWIG_Python_SetConstant(d, "SpatialUnitsInOneD",SWIG_From_int(static_cast< int >(SpatialUnitsInOneD)));
  SWIG_Python_SetConstant(d, "SpatialUnitsInTwoD",SWIG_From_int(static_cast< int >(SpatialUnitsInTwoD)));
  SWIG_Python_SetConstant(d, "SpatialUnitsInThreeD",SWIG_From_int(static_cast< int >(SpatialUnitsInThreeD)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesSusbstanceUnits",SWIG_From_int(static_cast< int >(InvalidSpeciesSusbstanceUnits)));
  SWIG_Python_SetConstant(d, "BothAmountAndConcentrationSet",SWIG_From_int(static_cast< int >(BothAmountAndConcentrationSet)));
  SWIG_Python_SetConstant(d, "NonBoundarySpeciesAssignedAndUsed",SWIG_From_int(static_cast< int >(NonBoundarySpeciesAssignedAndUsed)));
  SWIG_Python_SetConstant(d, "NonConstantSpeciesUsed",SWIG_From_int(static_cast< int >(NonConstantSpeciesUsed)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesTypeRef",SWIG_From_int(static_cast< int >(InvalidSpeciesTypeRef)));
  SWIG_Python_SetConstant(d, "MultSpeciesSameTypeInCompartment",SWIG_From_int(static_cast< int >(MultSpeciesSameTypeInCompartment)));
  SWIG_Python_SetConstant(d, "MissingSpeciesCompartment",SWIG_From_int(static_cast< int >(MissingSpeciesCompartment)));
  SWIG_Python_SetConstant(d, "SpatialSizeUnitsRemoved",SWIG_From_int(static_cast< int >(SpatialSizeUnitsRemoved)));
  SWIG_Python_SetConstant(d, "SubstanceUnitsOnSpecies",SWIG_From_int(static_cast< int >(SubstanceUnitsOnSpecies)));
  SWIG_Python_SetConstant(d, "ConversionFactorOnSpecies",SWIG_From_int(static_cast< int >(ConversionFactorOnSpecies)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnSpecies",SWIG_From_int(static_cast< int >(AllowedAttributesOnSpecies)));
  SWIG_Python_SetConstant(d, "InvalidParameterUnits",SWIG_From_int(static_cast< int >(InvalidParameterUnits)));
  SWIG_Python_SetConstant(d, "ParameterUnits",SWIG_From_int(static_cast< int >(ParameterUnits)));
  SWIG_Python_SetConstant(d, "ConversionFactorMustConstant",SWIG_From_int(static_cast< int >(ConversionFactorMustConstant)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnParameter",SWIG_From_int(static_cast< int >(AllowedAttributesOnParameter)));
  SWIG_Python_SetConstant(d, "InvalidInitAssignSymbol",SWIG_From_int(static_cast< int >(InvalidInitAssignSymbol)));
  SWIG_Python_SetConstant(d, "MultipleInitAssignments",SWIG_From_int(static_cast< int >(MultipleInitAssignments)));
  SWIG_Python_SetConstant(d, "InitAssignmentAndRuleForSameId",SWIG_From_int(static_cast< int >(InitAssignmentAndRuleForSameId)));
  SWIG_Python_SetConstant(d, "OneMathElementPerInitialAssign",SWIG_From_int(static_cast< int >(OneMathElementPerInitialAssign)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnInitialAssign",SWIG_From_int(static_cast< int >(AllowedAttributesOnInitialAssign)));
  SWIG_Python_SetConstant(d, "InvalidAssignRuleVariable",SWIG_From_int(static_cast< int >(InvalidAssignRuleVariable)));
  SWIG_Python_SetConstant(d, "InvalidRateRuleVariable",SWIG_From_int(static_cast< int >(InvalidRateRuleVariable)));
  SWIG_Python_SetConstant(d, "AssignmentToConstantEntity",SWIG_From_int(static_cast< int >(AssignmentToConstantEntity)));
  SWIG_Python_SetConstant(d, "RateRuleForConstantEntity",SWIG_From_int(static_cast< int >(RateRuleForConstantEntity)));
  SWIG_Python_SetConstant(d, "RepeatedRule10304",SWIG_From_int(static_cast< int >(RepeatedRule10304)));
  SWIG_Python_SetConstant(d, "CircularRuleDependency",SWIG_From_int(static_cast< int >(CircularRuleDependency)));
  SWIG_Python_SetConstant(d, "OneMathElementPerRule",SWIG_From_int(static_cast< int >(OneMathElementPerRule)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnAssignRule",SWIG_From_int(static_cast< int >(AllowedAttributesOnAssignRule)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnRateRule",SWIG_From_int(static_cast< int >(AllowedAttributesOnRateRule)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnAlgRule",SWIG_From_int(static_cast< int >(AllowedAttributesOnAlgRule)));
  SWIG_Python_SetConstant(d, "ConstraintMathNotBoolean",SWIG_From_int(static_cast< int >(ConstraintMathNotBoolean)));
  SWIG_Python_SetConstant(d, "IncorrectOrderInConstraint",SWIG_From_int(static_cast< int >(IncorrectOrderInConstraint)));
  SWIG_Python_SetConstant(d, "ConstraintNotInXHTMLNamespace",SWIG_From_int(static_cast< int >(ConstraintNotInXHTMLNamespace)));
  SWIG_Python_SetConstant(d, "ConstraintContainsXMLDecl",SWIG_From_int(static_cast< int >(ConstraintContainsXMLDecl)));
  SWIG_Python_SetConstant(d, "ConstraintContainsDOCTYPE",SWIG_From_int(static_cast< int >(ConstraintContainsDOCTYPE)));
  SWIG_Python_SetConstant(d, "InvalidConstraintContent",SWIG_From_int(static_cast< int >(InvalidConstraintContent)));
  SWIG_Python_SetConstant(d, "OneMathElementPerConstraint",SWIG_From_int(static_cast< int >(OneMathElementPerConstraint)));
  SWIG_Python_SetConstant(d, "OneMessageElementPerConstraint",SWIG_From_int(static_cast< int >(OneMessageElementPerConstraint)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnConstraint",SWIG_From_int(static_cast< int >(AllowedAttributesOnConstraint)));
  SWIG_Python_SetConstant(d, "NoReactantsOrProducts",SWIG_From_int(static_cast< int >(NoReactantsOrProducts)));
  SWIG_Python_SetConstant(d, "IncorrectOrderInReaction",SWIG_From_int(static_cast< int >(IncorrectOrderInReaction)));
  SWIG_Python_SetConstant(d, "EmptyListInReaction",SWIG_From_int(static_cast< int >(EmptyListInReaction)));
  SWIG_Python_SetConstant(d, "InvalidReactantsProductsList",SWIG_From_int(static_cast< int >(InvalidReactantsProductsList)));
  SWIG_Python_SetConstant(d, "InvalidModifiersList",SWIG_From_int(static_cast< int >(InvalidModifiersList)));
  SWIG_Python_SetConstant(d, "OneSubElementPerReaction",SWIG_From_int(static_cast< int >(OneSubElementPerReaction)));
  SWIG_Python_SetConstant(d, "CompartmentOnReaction",SWIG_From_int(static_cast< int >(CompartmentOnReaction)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnReaction",SWIG_From_int(static_cast< int >(AllowedAttributesOnReaction)));
  SWIG_Python_SetConstant(d, "InvalidSpeciesReference",SWIG_From_int(static_cast< int >(InvalidSpeciesReference)));
  SWIG_Python_SetConstant(d, "RepeatedRule20611",SWIG_From_int(static_cast< int >(RepeatedRule20611)));
  SWIG_Python_SetConstant(d, "BothStoichiometryAndMath",SWIG_From_int(static_cast< int >(BothStoichiometryAndMath)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnSpeciesReference",SWIG_From_int(static_cast< int >(AllowedAttributesOnSpeciesReference)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnModifier",SWIG_From_int(static_cast< int >(AllowedAttributesOnModifier)));
  SWIG_Python_SetConstant(d, "UndeclaredSpeciesRef",SWIG_From_int(static_cast< int >(UndeclaredSpeciesRef)));
  SWIG_Python_SetConstant(d, "IncorrectOrderInKineticLaw",SWIG_From_int(static_cast< int >(IncorrectOrderInKineticLaw)));
  SWIG_Python_SetConstant(d, "EmptyListInKineticLaw",SWIG_From_int(static_cast< int >(EmptyListInKineticLaw)));
  SWIG_Python_SetConstant(d, "NonConstantLocalParameter",SWIG_From_int(static_cast< int >(NonConstantLocalParameter)));
  SWIG_Python_SetConstant(d, "SubsUnitsNoLongerValid",SWIG_From_int(static_cast< int >(SubsUnitsNoLongerValid)));
  SWIG_Python_SetConstant(d, "TimeUnitsNoLongerValid",SWIG_From_int(static_cast< int >(TimeUnitsNoLongerValid)));
  SWIG_Python_SetConstant(d, "OneListOfPerKineticLaw",SWIG_From_int(static_cast< int >(OneListOfPerKineticLaw)));
  SWIG_Python_SetConstant(d, "OnlyLocalParamsInListOfLocalParams",SWIG_From_int(static_cast< int >(OnlyLocalParamsInListOfLocalParams)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfLocalParam",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfLocalParam)));
  SWIG_Python_SetConstant(d, "OneMathPerKineticLaw",SWIG_From_int(static_cast< int >(OneMathPerKineticLaw)));
  SWIG_Python_SetConstant(d, "UndeclaredSpeciesInStoichMath",SWIG_From_int(static_cast< int >(UndeclaredSpeciesInStoichMath)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnKineticLaw",SWIG_From_int(static_cast< int >(AllowedAttributesOnKineticLaw)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfSpeciesRef",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfSpeciesRef)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfMods",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfMods)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnLocalParameter",SWIG_From_int(static_cast< int >(AllowedAttributesOnLocalParameter)));
  SWIG_Python_SetConstant(d, "MissingTriggerInEvent",SWIG_From_int(static_cast< int >(MissingTriggerInEvent)));
  SWIG_Python_SetConstant(d, "TriggerMathNotBoolean",SWIG_From_int(static_cast< int >(TriggerMathNotBoolean)));
  SWIG_Python_SetConstant(d, "MissingEventAssignment",SWIG_From_int(static_cast< int >(MissingEventAssignment)));
  SWIG_Python_SetConstant(d, "TimeUnitsEvent",SWIG_From_int(static_cast< int >(TimeUnitsEvent)));
  SWIG_Python_SetConstant(d, "IncorrectOrderInEvent",SWIG_From_int(static_cast< int >(IncorrectOrderInEvent)));
  SWIG_Python_SetConstant(d, "ValuesFromTriggerTimeNeedDelay",SWIG_From_int(static_cast< int >(ValuesFromTriggerTimeNeedDelay)));
  SWIG_Python_SetConstant(d, "DelayNeedsValuesFromTriggerTime",SWIG_From_int(static_cast< int >(DelayNeedsValuesFromTriggerTime)));
  SWIG_Python_SetConstant(d, "OneMathPerTrigger",SWIG_From_int(static_cast< int >(OneMathPerTrigger)));
  SWIG_Python_SetConstant(d, "OneMathPerDelay",SWIG_From_int(static_cast< int >(OneMathPerDelay)));
  SWIG_Python_SetConstant(d, "InvalidEventAssignmentVariable",SWIG_From_int(static_cast< int >(InvalidEventAssignmentVariable)));
  SWIG_Python_SetConstant(d, "EventAssignmentForConstantEntity",SWIG_From_int(static_cast< int >(EventAssignmentForConstantEntity)));
  SWIG_Python_SetConstant(d, "OneMathPerEventAssignment",SWIG_From_int(static_cast< int >(OneMathPerEventAssignment)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnEventAssignment",SWIG_From_int(static_cast< int >(AllowedAttributesOnEventAssignment)));
  SWIG_Python_SetConstant(d, "OnlyOneDelayPerEvent",SWIG_From_int(static_cast< int >(OnlyOneDelayPerEvent)));
  SWIG_Python_SetConstant(d, "OneListOfEventAssignmentsPerEvent",SWIG_From_int(static_cast< int >(OneListOfEventAssignmentsPerEvent)));
  SWIG_Python_SetConstant(d, "OnlyEventAssignInListOfEventAssign",SWIG_From_int(static_cast< int >(OnlyEventAssignInListOfEventAssign)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnListOfEventAssign",SWIG_From_int(static_cast< int >(AllowedAttributesOnListOfEventAssign)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnEvent",SWIG_From_int(static_cast< int >(AllowedAttributesOnEvent)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnTrigger",SWIG_From_int(static_cast< int >(AllowedAttributesOnTrigger)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnDelay",SWIG_From_int(static_cast< int >(AllowedAttributesOnDelay)));
  SWIG_Python_SetConstant(d, "PersistentNotBoolean",SWIG_From_int(static_cast< int >(PersistentNotBoolean)));
  SWIG_Python_SetConstant(d, "InitialValueNotBoolean",SWIG_From_int(static_cast< int >(InitialValueNotBoolean)));
  SWIG_Python_SetConstant(d, "OnlyOnePriorityPerEvent",SWIG_From_int(static_cast< int >(OnlyOnePriorityPerEvent)));
  SWIG_Python_SetConstant(d, "OneMathPerPriority",SWIG_From_int(static_cast< int >(OneMathPerPriority)));
  SWIG_Python_SetConstant(d, "AllowedAttributesOnPriority",SWIG_From_int(static_cast< int >(AllowedAttributesOnPriority)));
  SWIG_Python_SetConstant(d, "GeneralWarningNotSpecified",SWIG_From_int(static_cast< int >(GeneralWarningNotSpecified)));
  SWIG_Python_SetConstant(d, "CompartmentShouldHaveSize",SWIG_From_int(static_cast< int >(CompartmentShouldHaveSize)));
  SWIG_Python_SetConstant(d, "ParameterShouldHaveUnits",SWIG_From_int(static_cast< int >(ParameterShouldHaveUnits)));
  SWIG_Python_SetConstant(d, "LocalParameterShadowsId",SWIG_From_int(static_cast< int >(LocalParameterShadowsId)));
  SWIG_Python_SetConstant(d, "LibSBMLAdditionalCodesLowerBound",SWIG_From_int(static_cast< int >(LibSBMLAdditionalCodesLowerBound)));
  SWIG_Python_SetConstant(d, "CannotConvertToL1V1",SWIG_From_int(static_cast< int >(CannotConvertToL1V1)));
  SWIG_Python_SetConstant(d, "NoEventsInL1",SWIG_From_int(static_cast< int >(NoEventsInL1)));
  SWIG_Python_SetConstant(d, "NoFunctionDefinitionsInL1",SWIG_From_int(static_cast< int >(NoFunctionDefinitionsInL1)));
  SWIG_Python_SetConstant(d, "NoConstraintsInL1",SWIG_From_int(static_cast< int >(NoConstraintsInL1)));
  SWIG_Python_SetConstant(d, "NoInitialAssignmentsInL1",SWIG_From_int(static_cast< int >(NoInitialAssignmentsInL1)));
  SWIG_Python_SetConstant(d, "NoSpeciesTypesInL1",SWIG_From_int(static_cast< int >(NoSpeciesTypesInL1)));
  SWIG_Python_SetConstant(d, "NoCompartmentTypeInL1",SWIG_From_int(static_cast< int >(NoCompartmentTypeInL1)));
  SWIG_Python_SetConstant(d, "NoNon3DComparmentsInL1",SWIG_From_int(static_cast< int >(NoNon3DComparmentsInL1)));
  SWIG_Python_SetConstant(d, "NoFancyStoichiometryMathInL1",SWIG_From_int(static_cast< int >(NoFancyStoichiometryMathInL1)));
  SWIG_Python_SetConstant(d, "NoNonIntegerStoichiometryInL1",SWIG_From_int(static_cast< int >(NoNonIntegerStoichiometryInL1)));
  SWIG_Python_SetConstant(d, "NoUnitMultipliersOrOffsetsInL1",SWIG_From_int(static_cast< int >(NoUnitMultipliersOrOffsetsInL1)));
  SWIG_Python_SetConstant(d, "SpeciesCompartmentRequiredInL1",SWIG_From_int(static_cast< int >(SpeciesCompartmentRequiredInL1)));
  SWIG_Python_SetConstant(d, "NoSpeciesSpatialSizeUnitsInL1",SWIG_From_int(static_cast< int >(NoSpeciesSpatialSizeUnitsInL1)));
  SWIG_Python_SetConstant(d, "NoSBOTermsInL1",SWIG_From_int(static_cast< int >(NoSBOTermsInL1)));
  SWIG_Python_SetConstant(d, "StrictUnitsRequiredInL1",SWIG_From_int(static_cast< int >(StrictUnitsRequiredInL1)));
  SWIG_Python_SetConstant(d, "ConversionFactorNotInL1",SWIG_From_int(static_cast< int >(ConversionFactorNotInL1)));
  SWIG_Python_SetConstant(d, "CompartmentNotOnL1Reaction",SWIG_From_int(static_cast< int >(CompartmentNotOnL1Reaction)));
  SWIG_Python_SetConstant(d, "ExtentUnitsNotSubstance",SWIG_From_int(static_cast< int >(ExtentUnitsNotSubstance)));
  SWIG_Python_SetConstant(d, "NoConstraintsInL2v1",SWIG_From_int(static_cast< int >(NoConstraintsInL2v1)));
  SWIG_Python_SetConstant(d, "NoInitialAssignmentsInL2v1",SWIG_From_int(static_cast< int >(NoInitialAssignmentsInL2v1)));
  SWIG_Python_SetConstant(d, "NoSpeciesTypeInL2v1",SWIG_From_int(static_cast< int >(NoSpeciesTypeInL2v1)));
  SWIG_Python_SetConstant(d, "NoCompartmentTypeInL2v1",SWIG_From_int(static_cast< int >(NoCompartmentTypeInL2v1)));
  SWIG_Python_SetConstant(d, "NoSBOTermsInL2v1",SWIG_From_int(static_cast< int >(NoSBOTermsInL2v1)));
  SWIG_Python_SetConstant(d, "NoIdOnSpeciesReferenceInL2v1",SWIG_From_int(static_cast< int >(NoIdOnSpeciesReferenceInL2v1)));
  SWIG_Python_SetConstant(d, "NoDelayedEventAssignmentInL2v1",SWIG_From_int(static_cast< int >(NoDelayedEventAssignmentInL2v1)));
  SWIG_Python_SetConstant(d, "StrictUnitsRequiredInL2v1",SWIG_From_int(static_cast< int >(StrictUnitsRequiredInL2v1)));
  SWIG_Python_SetConstant(d, "IntegerSpatialDimensions",SWIG_From_int(static_cast< int >(IntegerSpatialDimensions)));
  SWIG_Python_SetConstant(d, "StoichiometryMathNotYetSupported",SWIG_From_int(static_cast< int >(StoichiometryMathNotYetSupported)));
  SWIG_Python_SetConstant(d, "PrioirtyLostFromL3",SWIG_From_int(static_cast< int >(PrioirtyLostFromL3)));
  SWIG_Python_SetConstant(d, "NonPersistentNotSupported",SWIG_From_int(static_cast< int >(NonPersistentNotSupported)));
  SWIG_Python_SetConstant(d, "InitialValueFalseEventNotSupported",SWIG_From_int(static_cast< int >(InitialValueFalseEventNotSupported)));
  SWIG_Python_SetConstant(d, "SBOTermNotUniversalInL2v2",SWIG_From_int(static_cast< int >(SBOTermNotUniversalInL2v2)));
  SWIG_Python_SetConstant(d, "NoUnitOffsetInL2v2",SWIG_From_int(static_cast< int >(NoUnitOffsetInL2v2)));
  SWIG_Python_SetConstant(d, "NoKineticLawTimeUnitsInL2v2",SWIG_From_int(static_cast< int >(NoKineticLawTimeUnitsInL2v2)));
  SWIG_Python_SetConstant(d, "NoKineticLawSubstanceUnitsInL2v2",SWIG_From_int(static_cast< int >(NoKineticLawSubstanceUnitsInL2v2)));
  SWIG_Python_SetConstant(d, "NoDelayedEventAssignmentInL2v2",SWIG_From_int(static_cast< int >(NoDelayedEventAssignmentInL2v2)));
  SWIG_Python_SetConstant(d, "ModelSBOBranchChangedBeyondL2v2",SWIG_From_int(static_cast< int >(ModelSBOBranchChangedBeyondL2v2)));
  SWIG_Python_SetConstant(d, "StrictUnitsRequiredInL2v2",SWIG_From_int(static_cast< int >(StrictUnitsRequiredInL2v2)));
  SWIG_Python_SetConstant(d, "StrictSBORequiredInL2v2",SWIG_From_int(static_cast< int >(StrictSBORequiredInL2v2)));
  SWIG_Python_SetConstant(d, "DuplicateAnnotationInvalidInL2v2",SWIG_From_int(static_cast< int >(DuplicateAnnotationInvalidInL2v2)));
  SWIG_Python_SetConstant(d, "NoUnitOffsetInL2v3",SWIG_From_int(static_cast< int >(NoUnitOffsetInL2v3)));
  SWIG_Python_SetConstant(d, "NoKineticLawTimeUnitsInL2v3",SWIG_From_int(static_cast< int >(NoKineticLawTimeUnitsInL2v3)));
  SWIG_Python_SetConstant(d, "NoKineticLawSubstanceUnitsInL2v3",SWIG_From_int(static_cast< int >(NoKineticLawSubstanceUnitsInL2v3)));
  SWIG_Python_SetConstant(d, "NoSpeciesSpatialSizeUnitsInL2v3",SWIG_From_int(static_cast< int >(NoSpeciesSpatialSizeUnitsInL2v3)));
  SWIG_Python_SetConstant(d, "NoEventTimeUnitsInL2v3",SWIG_From_int(static_cast< int >(NoEventTimeUnitsInL2v3)));
  SWIG_Python_SetConstant(d, "NoDelayedEventAssignmentInL2v3",SWIG_From_int(static_cast< int >(NoDelayedEventAssignmentInL2v3)));
  SWIG_Python_SetConstant(d, "ModelSBOBranchChangedBeyondL2v3",SWIG_From_int(static_cast< int >(ModelSBOBranchChangedBeyondL2v3)));
  SWIG_Python_SetConstant(d, "StrictUnitsRequiredInL2v3",SWIG_From_int(static_cast< int >(StrictUnitsRequiredInL2v3)));
  SWIG_Python_SetConstant(d, "StrictSBORequiredInL2v3",SWIG_From_int(static_cast< int >(StrictSBORequiredInL2v3)));
  SWIG_Python_SetConstant(d, "DuplicateAnnotationInvalidInL2v3",SWIG_From_int(static_cast< int >(DuplicateAnnotationInvalidInL2v3)));
  SWIG_Python_SetConstant(d, "NoUnitOffsetInL2v4",SWIG_From_int(static_cast< int >(NoUnitOffsetInL2v4)));
  SWIG_Python_SetConstant(d, "NoKineticLawTimeUnitsInL2v4",SWIG_From_int(static_cast< int >(NoKineticLawTimeUnitsInL2v4)));
  SWIG_Python_SetConstant(d, "NoKineticLawSubstanceUnitsInL2v4",SWIG_From_int(static_cast< int >(NoKineticLawSubstanceUnitsInL2v4)));
  SWIG_Python_SetConstant(d, "NoSpeciesSpatialSizeUnitsInL2v4",SWIG_From_int(static_cast< int >(NoSpeciesSpatialSizeUnitsInL2v4)));
  SWIG_Python_SetConstant(d, "NoEventTimeUnitsInL2v4",SWIG_From_int(static_cast< int >(NoEventTimeUnitsInL2v4)));
  SWIG_Python_SetConstant(d, "ModelSBOBranchChangedInL2v4",SWIG_From_int(static_cast< int >(ModelSBOBranchChangedInL2v4)));
  SWIG_Python_SetConstant(d, "DuplicateAnnotationInvalidInL2v4",SWIG_From_int(static_cast< int >(DuplicateAnnotationInvalidInL2v4)));
  SWIG_Python_SetConstant(d, "NoSpeciesTypeInL3v1",SWIG_From_int(static_cast< int >(NoSpeciesTypeInL3v1)));
  SWIG_Python_SetConstant(d, "NoCompartmentTypeInL3v1",SWIG_From_int(static_cast< int >(NoCompartmentTypeInL3v1)));
  SWIG_Python_SetConstant(d, "NoUnitOffsetInL3v1",SWIG_From_int(static_cast< int >(NoUnitOffsetInL3v1)));
  SWIG_Python_SetConstant(d, "NoKineticLawTimeUnitsInL3v1",SWIG_From_int(static_cast< int >(NoKineticLawTimeUnitsInL3v1)));
  SWIG_Python_SetConstant(d, "NoKineticLawSubstanceUnitsInL3v1",SWIG_From_int(static_cast< int >(NoKineticLawSubstanceUnitsInL3v1)));
  SWIG_Python_SetConstant(d, "NoSpeciesSpatialSizeUnitsInL3v1",SWIG_From_int(static_cast< int >(NoSpeciesSpatialSizeUnitsInL3v1)));
  SWIG_Python_SetConstant(d, "NoEventTimeUnitsInL3v1",SWIG_From_int(static_cast< int >(NoEventTimeUnitsInL3v1)));
  SWIG_Python_SetConstant(d, "ModelSBOBranchChangedInL3v1",SWIG_From_int(static_cast< int >(ModelSBOBranchChangedInL3v1)));
  SWIG_Python_SetConstant(d, "DuplicateAnnotationInvalidInL3v1",SWIG_From_int(static_cast< int >(DuplicateAnnotationInvalidInL3v1)));
  SWIG_Python_SetConstant(d, "NoCompartmentOutsideInL3v1",SWIG_From_int(static_cast< int >(NoCompartmentOutsideInL3v1)));
  SWIG_Python_SetConstant(d, "NoStoichiometryMathInL3v1",SWIG_From_int(static_cast< int >(NoStoichiometryMathInL3v1)));
  SWIG_Python_SetConstant(d, "InvalidSBMLLevelVersion",SWIG_From_int(static_cast< int >(InvalidSBMLLevelVersion)));
  SWIG_Python_SetConstant(d, "AnnotationNotesNotAllowedLevel1",SWIG_From_int(static_cast< int >(AnnotationNotesNotAllowedLevel1)));
  SWIG_Python_SetConstant(d, "InvalidRuleOrdering",SWIG_From_int(static_cast< int >(InvalidRuleOrdering)));
  SWIG_Python_SetConstant(d, "RequiredPackagePresent",SWIG_From_int(static_cast< int >(RequiredPackagePresent)));
  SWIG_Python_SetConstant(d, "UnrequiredPackagePresent",SWIG_From_int(static_cast< int >(UnrequiredPackagePresent)));
  SWIG_Python_SetConstant(d, "SubsUnitsAllowedInKL",SWIG_From_int(static_cast< int >(SubsUnitsAllowedInKL)));
  SWIG_Python_SetConstant(d, "TimeUnitsAllowedInKL",SWIG_From_int(static_cast< int >(TimeUnitsAllowedInKL)));
  SWIG_Python_SetConstant(d, "FormulaInLevel1KL",SWIG_From_int(static_cast< int >(FormulaInLevel1KL)));
  SWIG_Python_SetConstant(d, "TimeUnitsRemoved",SWIG_From_int(static_cast< int >(TimeUnitsRemoved)));
  SWIG_Python_SetConstant(d, "BadMathML",SWIG_From_int(static_cast< int >(BadMathML)));
  SWIG_Python_SetConstant(d, "FailedMathMLReadOfDouble",SWIG_From_int(static_cast< int >(FailedMathMLReadOfDouble)));
  SWIG_Python_SetConstant(d, "FailedMathMLReadOfInteger",SWIG_From_int(static_cast< int >(FailedMathMLReadOfInteger)));
  SWIG_Python_SetConstant(d, "FailedMathMLReadOfExponential",SWIG_From_int(static_cast< int >(FailedMathMLReadOfExponential)));
  SWIG_Python_SetConstant(d, "FailedMathMLReadOfRational",SWIG_From_int(static_cast< int >(FailedMathMLReadOfRational)));
  SWIG_Python_SetConstant(d, "BadMathMLNodeType",SWIG_From_int(static_cast< int >(BadMathMLNodeType)));
  SWIG_Python_SetConstant(d, "NoTimeSymbolInFunctionDef",SWIG_From_int(static_cast< int >(NoTimeSymbolInFunctionDef)));
  SWIG_Python_SetConstant(d, "NoBodyInFunctionDef",SWIG_From_int(static_cast< int >(NoBodyInFunctionDef)));
  SWIG_Python_SetConstant(d, "InconsistentArgUnitsWarnings",SWIG_From_int(static_cast< int >(InconsistentArgUnitsWarnings)));
  SWIG_Python_SetConstant(d, "InconsistentPowerUnitsWarnings",SWIG_From_int(static_cast< int >(InconsistentPowerUnitsWarnings)));
  SWIG_Python_SetConstant(d, "InconsistentExponUnitsWarnings",SWIG_From_int(static_cast< int >(InconsistentExponUnitsWarnings)));
  SWIG_Python_SetConstant(d, "UndeclaredUnits",SWIG_From_int(static_cast< int >(UndeclaredUnits)));
  SWIG_Python_SetConstant(d, "UnrecognisedSBOTerm",SWIG_From_int(static_cast< int >(UnrecognisedSBOTerm)));
  SWIG_Python_SetConstant(d, "ObseleteSBOTerm",SWIG_From_int(static_cast< int >(ObseleteSBOTerm)));
  SWIG_Python_SetConstant(d, "IncorrectCompartmentSpatialDimensions",SWIG_From_int(static_cast< int >(IncorrectCompartmentSpatialDimensions)));
  SWIG_Python_SetConstant(d, "CompartmentTypeNotValidAttribute",SWIG_From_int(static_cast< int >(CompartmentTypeNotValidAttribute)));
  SWIG_Python_SetConstant(d, "ConstantNotValidAttribute",SWIG_From_int(static_cast< int >(ConstantNotValidAttribute)));
  SWIG_Python_SetConstant(d, "MetaIdNotValidAttribute",SWIG_From_int(static_cast< int >(MetaIdNotValidAttribute)));
  SWIG_Python_SetConstant(d, "SBOTermNotValidAttributeBeforeL2V3",SWIG_From_int(static_cast< int >(SBOTermNotValidAttributeBeforeL2V3)));
  SWIG_Python_SetConstant(d, "InvalidL1CompartmentUnits",SWIG_From_int(static_cast< int >(InvalidL1CompartmentUnits)));
  SWIG_Python_SetConstant(d, "L1V1CompartmentVolumeReqd",SWIG_From_int(static_cast< int >(L1V1CompartmentVolumeReqd)));
  SWIG_Python_SetConstant(d, "CompartmentTypeNotValidComponent",SWIG_From_int(static_cast< int >(CompartmentTypeNotValidComponent)));
  SWIG_Python_SetConstant(d, "ConstraintNotValidComponent",SWIG_From_int(static_cast< int >(ConstraintNotValidComponent)));
  SWIG_Python_SetConstant(d, "EventNotValidComponent",SWIG_From_int(static_cast< int >(EventNotValidComponent)));
  SWIG_Python_SetConstant(d, "SBOTermNotValidAttributeBeforeL2V2",SWIG_From_int(static_cast< int >(SBOTermNotValidAttributeBeforeL2V2)));
  SWIG_Python_SetConstant(d, "FuncDefNotValidComponent",SWIG_From_int(static_cast< int >(FuncDefNotValidComponent)));
  SWIG_Python_SetConstant(d, "InitialAssignNotValidComponent",SWIG_From_int(static_cast< int >(InitialAssignNotValidComponent)));
  SWIG_Python_SetConstant(d, "VariableNotValidAttribute",SWIG_From_int(static_cast< int >(VariableNotValidAttribute)));
  SWIG_Python_SetConstant(d, "UnitsNotValidAttribute",SWIG_From_int(static_cast< int >(UnitsNotValidAttribute)));
  SWIG_Python_SetConstant(d, "ConstantSpeciesNotValidAttribute",SWIG_From_int(static_cast< int >(ConstantSpeciesNotValidAttribute)));
  SWIG_Python_SetConstant(d, "SpatialSizeUnitsNotValidAttribute",SWIG_From_int(static_cast< int >(SpatialSizeUnitsNotValidAttribute)));
  SWIG_Python_SetConstant(d, "SpeciesTypeNotValidAttribute",SWIG_From_int(static_cast< int >(SpeciesTypeNotValidAttribute)));
  SWIG_Python_SetConstant(d, "HasOnlySubsUnitsNotValidAttribute",SWIG_From_int(static_cast< int >(HasOnlySubsUnitsNotValidAttribute)));
  SWIG_Python_SetConstant(d, "IdNotValidAttribute",SWIG_From_int(static_cast< int >(IdNotValidAttribute)));
  SWIG_Python_SetConstant(d, "NameNotValidAttribute",SWIG_From_int(static_cast< int >(NameNotValidAttribute)));
  SWIG_Python_SetConstant(d, "SpeciesTypeNotValidComponent",SWIG_From_int(static_cast< int >(SpeciesTypeNotValidComponent)));
  SWIG_Python_SetConstant(d, "StoichiometryMathNotValidComponent",SWIG_From_int(static_cast< int >(StoichiometryMathNotValidComponent)));
  SWIG_Python_SetConstant(d, "MultiplierNotValidAttribute",SWIG_From_int(static_cast< int >(MultiplierNotValidAttribute)));
  SWIG_Python_SetConstant(d, "OffsetNotValidAttribute",SWIG_From_int(static_cast< int >(OffsetNotValidAttribute)));
  SWIG_Python_SetConstant(d, "InvalidTargetLevelVersion",SWIG_From_int(static_cast< int >(InvalidTargetLevelVersion)));
  SWIG_Python_SetConstant(d, "L3NotSupported",SWIG_From_int(static_cast< int >(L3NotSupported)));
  SWIG_Python_SetConstant(d, "SBMLCodesUpperBound",SWIG_From_int(static_cast< int >(SBMLCodesUpperBound)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML_L1_COMPAT",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L1_COMPAT)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML_L2V1_COMPAT",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L2V1_COMPAT)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML_L2V2_COMPAT",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L2V2_COMPAT)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_GENERAL_CONSISTENCY",SWIG_From_int(static_cast< int >(LIBSBML_CAT_GENERAL_CONSISTENCY)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_IDENTIFIER_CONSISTENCY",SWIG_From_int(static_cast< int >(LIBSBML_CAT_IDENTIFIER_CONSISTENCY)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_UNITS_CONSISTENCY",SWIG_From_int(static_cast< int >(LIBSBML_CAT_UNITS_CONSISTENCY)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_MATHML_CONSISTENCY",SWIG_From_int(static_cast< int >(LIBSBML_CAT_MATHML_CONSISTENCY)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBO_CONSISTENCY",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBO_CONSISTENCY)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_OVERDETERMINED_MODEL",SWIG_From_int(static_cast< int >(LIBSBML_CAT_OVERDETERMINED_MODEL)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML_L2V3_COMPAT",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L2V3_COMPAT)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_MODELING_PRACTICE",SWIG_From_int(static_cast< int >(LIBSBML_CAT_MODELING_PRACTICE)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_INTERNAL_CONSISTENCY",SWIG_From_int(static_cast< int >(LIBSBML_CAT_INTERNAL_CONSISTENCY)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML_L2V4_COMPAT",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L2V4_COMPAT)));
  SWIG_Python_SetConstant(d, "LIBSBML_CAT_SBML_L3V1_COMPAT",SWIG_From_int(static_cast< int >(LIBSBML_CAT_SBML_L3V1_COMPAT)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_SCHEMA_ERROR",SWIG_From_int(static_cast< int >(LIBSBML_SEV_SCHEMA_ERROR)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_GENERAL_WARNING",SWIG_From_int(static_cast< int >(LIBSBML_SEV_GENERAL_WARNING)));
  SWIG_Python_SetConstant(d, "LIBSBML_SEV_NOT_APPLICABLE",SWIG_From_int(static_cast< int >(LIBSBML_SEV_NOT_APPLICABLE)));
  SWIG_Python_SetConstant(d, "MODEL_QUALIFIER",SWIG_From_int(static_cast< int >(MODEL_QUALIFIER)));
  SWIG_Python_SetConstant(d, "BIOLOGICAL_QUALIFIER",SWIG_From_int(static_cast< int >(BIOLOGICAL_QUALIFIER)));
  SWIG_Python_SetConstant(d, "UNKNOWN_QUALIFIER",SWIG_From_int(static_cast< int >(UNKNOWN_QUALIFIER)));
  SWIG_Python_SetConstant(d, "BQM_IS",SWIG_From_int(static_cast< int >(BQM_IS)));
  SWIG_Python_SetConstant(d, "BQM_IS_DESCRIBED_BY",SWIG_From_int(static_cast< int >(BQM_IS_DESCRIBED_BY)));
  SWIG_Python_SetConstant(d, "BQM_IS_DERIVED_FROM",SWIG_From_int(static_cast< int >(BQM_IS_DERIVED_FROM)));
  SWIG_Python_SetConstant(d, "BQM_UNKNOWN",SWIG_From_int(static_cast< int >(BQM_UNKNOWN)));
  SWIG_Python_SetConstant(d, "BQB_IS",SWIG_From_int(static_cast< int >(BQB_IS)));
  SWIG_Python_SetConstant(d, "BQB_HAS_PART",SWIG_From_int(static_cast< int >(BQB_HAS_PART)));
  SWIG_Python_SetConstant(d, "BQB_IS_PART_OF",SWIG_From_int(static_cast< int >(BQB_IS_PART_OF)));
  SWIG_Python_SetConstant(d, "BQB_IS_VERSION_OF",SWIG_From_int(static_cast< int >(BQB_IS_VERSION_OF)));
  SWIG_Python_SetConstant(d, "BQB_HAS_VERSION",SWIG_From_int(static_cast< int >(BQB_HAS_VERSION)));
  SWIG_Python_SetConstant(d, "BQB_IS_HOMOLOG_TO",SWIG_From_int(static_cast< int >(BQB_IS_HOMOLOG_TO)));
  SWIG_Python_SetConstant(d, "BQB_IS_DESCRIBED_BY",SWIG_From_int(static_cast< int >(BQB_IS_DESCRIBED_BY)));
  SWIG_Python_SetConstant(d, "BQB_IS_ENCODED_BY",SWIG_From_int(static_cast< int >(BQB_IS_ENCODED_BY)));
  SWIG_Python_SetConstant(d, "BQB_ENCODES",SWIG_From_int(static_cast< int >(BQB_ENCODES)));
  SWIG_Python_SetConstant(d, "BQB_OCCURS_IN",SWIG_From_int(static_cast< int >(BQB_OCCURS_IN)));
  SWIG_Python_SetConstant(d, "BQB_HAS_PROPERTY",SWIG_From_int(static_cast< int >(BQB_HAS_PROPERTY)));
  SWIG_Python_SetConstant(d, "BQB_IS_PROPERTY_OF",SWIG_From_int(static_cast< int >(BQB_IS_PROPERTY_OF)));
  SWIG_Python_SetConstant(d, "BQB_UNKNOWN",SWIG_From_int(static_cast< int >(BQB_UNKNOWN)));
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}

